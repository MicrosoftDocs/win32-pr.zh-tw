---
description: 每個服務都有控制項處理常式，也就是處理函式，會在服務進程從服務控制程式接收控制項要求時由控制項發送器叫用。
ms.assetid: 437334ed-05fa-4ab6-aab3-dc2739113e19
title: 服務控制處理函式
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1303bff45421ee7206d02be9ee30066324648823
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106972619"
---
# <a name="service-control-handler-function"></a><span data-ttu-id="88788-103">服務控制處理函式</span><span class="sxs-lookup"><span data-stu-id="88788-103">Service Control Handler Function</span></span>

<span data-ttu-id="88788-104">每個服務都有控制項處理常式，也就是 [**處理**](/windows/desktop/api/Winsvc/nc-winsvc-lphandler_function) 函式，會在服務進程從服務控制程式接收控制項要求時由控制項發送器叫用。</span><span class="sxs-lookup"><span data-stu-id="88788-104">Each service has a control handler, the [**Handler**](/windows/desktop/api/Winsvc/nc-winsvc-lphandler_function) function, that is invoked by the control dispatcher when the service process receives a control request from a service control program.</span></span> <span data-ttu-id="88788-105">因此，此函式會在控制項發送器的內容中執行。</span><span class="sxs-lookup"><span data-stu-id="88788-105">Therefore, this function executes in the context of the control dispatcher.</span></span> <span data-ttu-id="88788-106">如需範例，請參閱 [撰寫控制項處理常式函數](writing-a-control-handler-function.md)。</span><span class="sxs-lookup"><span data-stu-id="88788-106">For an example, see [Writing a Control Handler Function](writing-a-control-handler-function.md).</span></span>

<span data-ttu-id="88788-107">服務會呼叫 [**RegisterServiceCtrlHandler**](/windows/desktop/api/Winsvc/nf-winsvc-registerservicectrlhandlera) 或 [**RegisterServiceCtrlHandlerEx**](/windows/desktop/api/Winsvc/nf-winsvc-registerservicectrlhandlerexa) 函式來註冊其服務控制處理常式函式。</span><span class="sxs-lookup"><span data-stu-id="88788-107">A service calls the [**RegisterServiceCtrlHandler**](/windows/desktop/api/Winsvc/nf-winsvc-registerservicectrlhandlera) or [**RegisterServiceCtrlHandlerEx**](/windows/desktop/api/Winsvc/nf-winsvc-registerservicectrlhandlerexa) function to register its service control handler function.</span></span>

<span data-ttu-id="88788-108">當叫用服務控制處理常式時，服務必須呼叫 [**>setservicestatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) 函式，只有在處理控制項程式碼導致服務狀態變更時，才會將其狀態報表給 SCM。</span><span class="sxs-lookup"><span data-stu-id="88788-108">When the service control handler is invoked, the service must call the [**SetServiceStatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) function to report its status to the SCM only if handling the control code causes the service status to change.</span></span> <span data-ttu-id="88788-109">如果處理控制項程式碼不會導致服務狀態變更，則不需要呼叫 **>setservicestatus**。</span><span class="sxs-lookup"><span data-stu-id="88788-109">If handling the control code does not cause the service status to change, it is not necessary to call **SetServiceStatus**.</span></span>

<span data-ttu-id="88788-110">服務控制程式可以使用 [**ControlService**](/windows/desktop/api/Winsvc/nf-winsvc-controlservice) 函式來傳送控制要求。</span><span class="sxs-lookup"><span data-stu-id="88788-110">A service control program can send control requests using the [**ControlService**](/windows/desktop/api/Winsvc/nf-winsvc-controlservice) function.</span></span> <span data-ttu-id="88788-111">所有服務都必須接受並處理 **服務 \_ 控制 \_** 的查閱控制項程式碼。</span><span class="sxs-lookup"><span data-stu-id="88788-111">All services must accept and process the **SERVICE\_CONTROL\_INTERROGATE** control code.</span></span> <span data-ttu-id="88788-112">您可以藉由呼叫 [**>setservicestatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus)來啟用或停用其他控制項代碼的接受。</span><span class="sxs-lookup"><span data-stu-id="88788-112">You can enable or disable acceptance of the other control codes by calling [**SetServiceStatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus).</span></span> <span data-ttu-id="88788-113">若要接收 **服務 \_ 控制 \_ DEVICEEVENT** 控制項程式碼，您必須呼叫 [**RegisterDeviceNotification**](/windows/desktop/api/winuser/nf-winuser-registerdevicenotificationa) 函數。</span><span class="sxs-lookup"><span data-stu-id="88788-113">To receive the **SERVICE\_CONTROL\_DEVICEEVENT** control code, you must call the [**RegisterDeviceNotification**](/windows/desktop/api/winuser/nf-winuser-registerdevicenotificationa) function.</span></span> <span data-ttu-id="88788-114">服務也可以處理其他使用者定義的控制項碼。</span><span class="sxs-lookup"><span data-stu-id="88788-114">Services can also handle additional user-defined control codes.</span></span>

<span data-ttu-id="88788-115">如果服務接受 **服務 \_ 控制 \_ 停止** 控制程式代碼，它必須在收到時停止，並進入 **服務 \_ 停止 \_ 暫** 止或 **服務 \_ 已停止** 狀態。</span><span class="sxs-lookup"><span data-stu-id="88788-115">If a service accepts the **SERVICE\_CONTROL\_STOP** control code, it must stop upon receipt, going to either the **SERVICE\_STOP\_PENDING** or **SERVICE\_STOPPED** state.</span></span> <span data-ttu-id="88788-116">SCM 傳送此控制項程式碼之後，就不會傳送其他控制碼。</span><span class="sxs-lookup"><span data-stu-id="88788-116">After the SCM sends this control code, it will not send other control codes.</span></span>

<span data-ttu-id="88788-117">**WINDOWS XP：** 如果服務未傳回 **\_ 錯誤** 並繼續執行，它會繼續接收控制碼。</span><span class="sxs-lookup"><span data-stu-id="88788-117">**Windows XP:** If the service returns **NO\_ERROR** and continues to run, it continues to receive control codes.</span></span> <span data-ttu-id="88788-118">此行為自 Windows Server 2003 和 Windows XP Service Pack 2 (SP2) 起變更。</span><span class="sxs-lookup"><span data-stu-id="88788-118">This behavior changed starting with Windows Server 2003 and Windows XP with Service Pack 2 (SP2).</span></span>

<span data-ttu-id="88788-119">控制處理常式必須在30秒內傳回，否則 SCM 會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="88788-119">The control handler must return within 30 seconds, or the SCM returns an error.</span></span> <span data-ttu-id="88788-120">如果服務在執行控制處理常式時必須執行冗長的處理，它應該會建立次要執行緒來執行冗長的處理，然後從控制項處理常式返回。</span><span class="sxs-lookup"><span data-stu-id="88788-120">If a service must do lengthy processing when the service is executing the control handler, it should create a secondary thread to perform the lengthy processing, and then return from the control handler.</span></span> <span data-ttu-id="88788-121">這可防止服務與控制項發送器系結。</span><span class="sxs-lookup"><span data-stu-id="88788-121">This prevents the service from tying up the control dispatcher.</span></span> <span data-ttu-id="88788-122">例如，處理需要很長時間之服務的停止要求時，請建立另一個執行緒來處理停止進程。</span><span class="sxs-lookup"><span data-stu-id="88788-122">For example, when handling the stop request for a service that takes a long time, create another thread to handle the stop process.</span></span> <span data-ttu-id="88788-123">控制項處理常式應該只呼叫具有 **服務 \_ 停止 \_ 暫** 止訊息的 [**>setservicestatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) ，然後再返回。</span><span class="sxs-lookup"><span data-stu-id="88788-123">The control handler should simply call [**SetServiceStatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) with the **SERVICE\_STOP\_PENDING** message and return.</span></span>

<span data-ttu-id="88788-124">當使用者關閉系統時，所有已呼叫 [**>setservicestatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) 與服務的控制項處理常式都會 **\_ 接受 \_ PRESHUTDOWN** 控制項程式碼，以接收 **服務 \_ 控制項 \_ PRESHUTDOWN** 控制項程式碼。</span><span class="sxs-lookup"><span data-stu-id="88788-124">When the user shuts down the system, all control handlers that have called [**SetServiceStatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) with the **SERVICE\_ACCEPT\_PRESHUTDOWN** control code receive the **SERVICE\_CONTROL\_PRESHUTDOWN** control code.</span></span> <span data-ttu-id="88788-125">服務控制管理員會等到服務停止或指定的 preshutdown 超時值過期 (此值可以使用 [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a) 函數) 來設定。</span><span class="sxs-lookup"><span data-stu-id="88788-125">The service control manager waits until the service stops or the specified preshutdown time-out value expires (this value can be set with the [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a) function).</span></span> <span data-ttu-id="88788-126">只有在特殊情況下，才應該使用這個控制項程式碼，因為處理此通知的服務會封鎖系統關閉，直到服務停止或 preshutdown 逾時間隔到期為止。</span><span class="sxs-lookup"><span data-stu-id="88788-126">This control code should be used only in special circumstances, because a service that handles this notification blocks system shutdown until the service stops or the preshutdown time-out interval expires.</span></span>

<span data-ttu-id="88788-127">Preshutdown 通知完成之後，所有已呼叫 [**>setservicestatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) 與 **服務 \_ 接受 \_ 關機** 控制程式代碼的控制項處理常式都會收到 **服務 \_ 控制 \_ 關閉** 控制程式代碼。</span><span class="sxs-lookup"><span data-stu-id="88788-127">After the preshutdown notifications have been completed, all control handlers that have called [**SetServiceStatus**](/windows/desktop/api/Winsvc/nf-winsvc-setservicestatus) with the **SERVICE\_ACCEPT\_SHUTDOWN** control code receive the **SERVICE\_CONTROL\_SHUTDOWN** control code.</span></span> <span data-ttu-id="88788-128">系統會以它們出現在已安裝服務的資料庫中的順序來通知。</span><span class="sxs-lookup"><span data-stu-id="88788-128">They are notified in the order that they appear in the database of installed services.</span></span> <span data-ttu-id="88788-129">根據預設，服務大約需要20秒的時間，才能在系統關機之前執行清除工作。</span><span class="sxs-lookup"><span data-stu-id="88788-129">By default, a service has approximately 20 seconds to perform cleanup tasks before the system shuts down.</span></span> <span data-ttu-id="88788-130">在這段時間到期後，不論服務關機是否已完成，系統關機都會繼續進行。</span><span class="sxs-lookup"><span data-stu-id="88788-130">After this time expires, system shutdown proceeds regardless of whether service shutdown is complete.</span></span> <span data-ttu-id="88788-131">請注意，如果系統處於關機狀態 (未重新開機或關閉) ，則服務會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="88788-131">Note that if the system is left in the shutdown state (not restarted or powered down), the service continues to run.</span></span>

<span data-ttu-id="88788-132">如果服務需要更多時間來清除，它會傳送 **停止 \_ 擱置** 狀態訊息，以及等待提示，因此服務控制器知道在向系統回報服務關機完成之前，要等待多久的時間。</span><span class="sxs-lookup"><span data-stu-id="88788-132">If the service requires more time to cleanup, it sends **STOP\_PENDING** status messages, along with a wait hint, so the service controller knows how long to wait before reporting to the system that service shutdown is complete.</span></span> <span data-ttu-id="88788-133">不過，為了避免服務停止關機，服務控制器等候的時間會有所限制。</span><span class="sxs-lookup"><span data-stu-id="88788-133">However, to prevent a service from stopping shutdown, there is a limit to how long the service controller waits.</span></span> <span data-ttu-id="88788-134">如果要透過服務嵌入式管理單元關閉服務，限制為125秒或125000毫秒。</span><span class="sxs-lookup"><span data-stu-id="88788-134">If the service is being shut down through the Services snap-in, the limit is 125 seconds, or 125,000 milliseconds.</span></span> <span data-ttu-id="88788-135">如果作業系統正在重新開機，則會在 **WaitToKillServiceTimeout** 值中指定時間限制， (以毫秒為單位) 下列登錄機碼：</span><span class="sxs-lookup"><span data-stu-id="88788-135">If the operating system is rebooting, the time limit is specified in the **WaitToKillServiceTimeout** value (in milliseconds) of the following registry key:</span></span>

<span data-ttu-id="88788-136">**HKEY \_ 本機 \_ 電腦 \\ 系統 \\ CurrentControlSet \\ 控制項**</span><span class="sxs-lookup"><span data-stu-id="88788-136">**HKEY\_LOCAL\_MACHINE\\SYSTEM\\CurrentControlSet\\Control**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="88788-137">服務不應嘗試藉由修改此值來增加時間限制。</span><span class="sxs-lookup"><span data-stu-id="88788-137">A service should not attempt to increase the time limit by modifying this value.</span></span> <span data-ttu-id="88788-138">如果您需要手動設定 **WaitToKillServiceTimeout** ，此值應以毫秒為單位。</span><span class="sxs-lookup"><span data-stu-id="88788-138">If you do need to set **WaitToKillServiceTimeout** by hand, the value should be in milliseconds.</span></span>

<span data-ttu-id="88788-139">客戶需要快速關閉作業系統。</span><span class="sxs-lookup"><span data-stu-id="88788-139">Customers require fast shutdown of the operating system.</span></span> <span data-ttu-id="88788-140">例如，如果在 ups 電源上執行的電腦無法在 UPS 耗盡電源之前完成關機，資料可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="88788-140">For example, if a computer running on UPS power cannot complete shutdown before the UPS runs out of power, data can be lost.</span></span> <span data-ttu-id="88788-141">因此，服務應該儘快完成其清除工作。</span><span class="sxs-lookup"><span data-stu-id="88788-141">Therefore, services should complete their cleanup tasks as quickly as possible.</span></span> <span data-ttu-id="88788-142">藉由定期儲存資料、追蹤儲存至磁片的資料，並只在關機時儲存未儲存的資料，是很好的做法。</span><span class="sxs-lookup"><span data-stu-id="88788-142">It is a good practice to minimize unsaved data by saving data on a regular basis, keeping track of the data that is saved to disk, and only saving your unsaved data on shutdown.</span></span> <span data-ttu-id="88788-143">由於電腦正在關機，因此請勿花時間釋出已配置的記憶體或其他系統資源。</span><span class="sxs-lookup"><span data-stu-id="88788-143">Because the computer is being shut down, do not spend time releasing allocated memory or other system resources.</span></span> <span data-ttu-id="88788-144">如果您需要通知伺服器正在結束，請將等待回復所花費的時間降到最低，因為網路問題可能會延遲服務的關機。</span><span class="sxs-lookup"><span data-stu-id="88788-144">If you need to notify a server that you are exiting, minimize the time spent waiting for a reply, because network problems could delay the shutdown of your service.</span></span>

<span data-ttu-id="88788-145">請注意，在服務關閉期間，SCM 預設不會考慮相依性。</span><span class="sxs-lookup"><span data-stu-id="88788-145">Note that during service shutdown, by default, the SCM does not take dependencies into consideration.</span></span> <span data-ttu-id="88788-146">SCM 會列舉正在執行的服務清單，並傳送 **服務 \_ 控制 \_ 關閉** 命令。</span><span class="sxs-lookup"><span data-stu-id="88788-146">The SCM enumerates the list of running services and sends the **SERVICE\_CONTROL\_SHUTDOWN** command.</span></span> <span data-ttu-id="88788-147">因此，服務可能會失敗，因為它所依存的另一個服務已停止。</span><span class="sxs-lookup"><span data-stu-id="88788-147">Therefore, a service may fail because another service it depends on has already stopped.</span></span>

<span data-ttu-id="88788-148">若要手動設定服務的關機順序，請建立 multistring 登錄值，其中包含服務名稱（依應關閉的順序），並將其指派給控制項索引鍵的 **PreshutdownOrder** 值，如下所示：</span><span class="sxs-lookup"><span data-stu-id="88788-148">To set the shutdown order of services manually, create a multistring registry value that contains the service names in the order in which they should be shut down and assign it to the Control key's **PreshutdownOrder** value, as follows:</span></span>

<span data-ttu-id="88788-149">**HKEY \_ LOCAL \_ MACHINE \\ SYSTEM \\ CurrentControlSet \\ Control \\ PreshutdownOrder = "Shutdown Order"**</span><span class="sxs-lookup"><span data-stu-id="88788-149">**HKEY\_LOCAL\_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\PreshutdownOrder="Shutdown Order"**</span></span>

<span data-ttu-id="88788-150">若要從您的應用程式設定相依服務的關機順序，請使用 [**SetProcessShutdownParameters**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters) 函數。</span><span class="sxs-lookup"><span data-stu-id="88788-150">To set the shutdown order of dependent services from your application, use the [**SetProcessShutdownParameters**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setprocessshutdownparameters) function.</span></span> <span data-ttu-id="88788-151">SCM 會使用此函式來提供其處理常式0x1E0 優先權。</span><span class="sxs-lookup"><span data-stu-id="88788-151">The SCM uses this function to give its handler 0x1E0 priority.</span></span> <span data-ttu-id="88788-152">SCM 會在呼叫其控制處理常式時傳送 **服務 \_ 控制 \_ 關閉** 通知，並等候服務結束，然後再從其控制處理常式傳回。</span><span class="sxs-lookup"><span data-stu-id="88788-152">The SCM sends **SERVICE\_CONTROL\_SHUTDOWN** notifications when its control handler is called and waits for the services to exit before returning from its control handler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="88788-153">相關主題</span><span class="sxs-lookup"><span data-stu-id="88788-153">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="88788-154">撰寫控制項處理常式函數</span><span class="sxs-lookup"><span data-stu-id="88788-154">Writing a Control Handler Function</span></span>](writing-a-control-handler-function.md)
</dt> </dl>

 

 
