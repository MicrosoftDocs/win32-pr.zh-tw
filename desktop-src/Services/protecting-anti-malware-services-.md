---
description: 瞭解如何 () 使用者模式服務保護反惡意程式碼，以及如何選擇在反惡意程式碼服務中包含這項功能。
ms.assetid: 88875a0d-9027-43f2-8411-34f9ff428fe5
title: 保護反惡意程式碼服務
ms.topic: article
ms.date: 08/02/2018
ms.openlocfilehash: 5e7783eb307381d368900332b5e761ad62785913
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104027439"
---
# <a name="protecting-anti-malware-services"></a>保護反惡意程式碼服務

Windows 8.1 引進了受保護服務的新概念來保護反惡意程式碼服務，這是惡意軟體攻擊的頻繁目標。

瞭解如何 () 使用者模式服務保護反惡意程式碼，以及如何選擇在反惡意程式碼服務中包含這項功能。

這項資訊適用于下列作業系統和其後續動作：

-   Windows 8.1
-   Windows Server 2012 R2

此處所討論的參考和資源列于本主題的結尾。

## <a name="introduction"></a>簡介

大部分反惡意程式碼解決方案都包含使用者模式服務，此服務會執行特定的作業來偵測和移除系統中的惡意程式碼。 此使用者模式服務也經常負責下載最新的病毒定義和簽章。 此使用者模式服務會成為惡意程式碼的頻繁目標，因為這是停用系統保護的單一失敗點。 為了防禦使用者模式服務的攻擊，反惡意程式碼廠商必須在其軟體中加入許多功能和啟發學習法。 不過，這類技術並不完全可靠，而且容易出錯，因為它們必須識別 Windows 在其服務上執行的功能，並選擇性地啟用該功能。

在 Windows 8.1 中，引進了受保護服務的新概念，可讓反惡意程式碼使用者模式服務以受保護的服務的形式啟動。 將服務啟動為受保護之後，Windows 會使用程式碼完整性，只允許受信任的程式碼載入受保護的服務。 Windows 也會保護這些進程免于程式碼插入和其他來自管理進程的攻擊。

本檔說明使用早期啟動反惡意程式碼 (ELAM) 驅動程式的反惡意程式碼廠商如何加入宣告這項功能，並將其反惡意程式碼服務啟動為受保護的服務。

## <a name="system-protected-process"></a>系統保護的進程

從 Windows 8.1 開始，已在核心中放置新的安全性模型，以更妥善防禦系統關鍵元件的惡意攻擊。 這項新的安全性模型可將受保護的程式基礎結構舊版 Windows （例如，播放 DRM 內容）延伸至一般用途的模型，以供協力廠商反惡意程式碼廠商使用。 受保護的進程基礎結構只允許已受信任、簽署的程式碼載入，並內建防禦程式碼插入式攻擊。

如需受保護進程的詳細資訊，請參閱 [Windows Vista 中受保護的進程](https://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/process_vista.doc) 。

新的安全性模型會使用與系統保護進程不同的保護程式基礎結構變異，因為這會讓 DRM 內容保持獨立，因此更適合這項功能。 每個受系統保護的進程都有相關聯的層級或屬性，表示允許在進程內載入之已簽署程式碼的簽章原則。 反惡意程式碼服務選擇進入受保護的服務模式之後，就可以在該程式中載入只允許以反惡意程式碼廠商的憑證簽署的 Windows 簽署程式碼或程式碼。 同樣地，其他受保護的進程層級具有 Windows 強制執行的不同程式碼原則。

## <a name="requirements"></a>規格需求

若要讓反惡意程式碼使用者模式服務以受保護的服務執行，反惡意程式碼廠商必須在 Windows 電腦上安裝 ELAM 驅動程式。 除了現有的 ELAM 驅動程式認證需求之外，驅動程式還必須有一個內嵌的資源區段，其中包含用來簽署使用者模式服務二進位檔的憑證資訊。

> [!IMPORTANT]
> 在 Windows 8.1 中，憑證連結必須是由驅動程式驗證所決定的已知根，或是必須包含根憑證。

 

在開機過程中，此資源區段將會從 ELAM 驅動程式解壓縮，以驗證憑證資訊並註冊反惡意程式碼服務。 反惡意程式碼服務也可以在反惡意程式碼軟體安裝過程中，藉由呼叫特殊 API 來註冊，如本檔稍後所述。

從 ELAM 驅動程式成功解壓縮資源區段並註冊使用者模式服務之後，就可以將服務啟動為受保護的服務。 當服務啟動為受保護之後，系統上其他未受保護的進程將無法插入執行緒，而且它們不會被允許寫入受保護進程的虛擬記憶體。

此外，任何載入受保護進程的非 Windows Dll 都必須使用適當的憑證進行簽署。

如需 ELAM 驅動程式的詳細資訊，請參閱 [早期啟動反惡意](/windows/desktop/w8cookbook/secured-boot) 代碼。

### <a name="anti-malware-service-signing-requirements"></a>反惡意程式碼服務簽署需求

需要啟動為受保護的使用者模式服務，必須使用有效的憑證進行簽署。 服務 EXE 必須已簽署頁面雜湊，而任何載入服務的非 Windows Dll 也必須使用相同的憑證進行簽署。 您必須將這些憑證的雜湊新增至資源檔，以連結至 ELAM 驅動程式。

> [!Note]  
> 您必須使用 SHA256 檔案/頁面雜湊，但憑證可能會繼續為 SHA1。

 

### <a name="primary-signature-recommended"></a> (建議) 的主要簽章

我們建議反惡意程式碼廠商使用其現有的 Authenticode 憑證來簽署反惡意程式碼服務二進位檔，並將此 Authenticode 憑證的雜湊包含在資源區段中，以指出用來簽署服務二進位檔的憑證。 如果您更新此憑證，則必須使用更新的憑證雜湊來發行較新版本的 ELAM 驅動程式。

### <a name="secondary-signature-optional"></a>次要簽章 (選用) 

反惡意程式碼廠商可選擇設定私人 CA，並使用來自此 CA 的憑證來將反惡意程式碼服務二進位檔簽署為次要簽章。 使用私人 CA 的主要優點是，它可讓廠商建立具有特製化 EKU 屬性的憑證，以用來區別相同廠商的多個產品。 由於私人 CA 憑證通常會有較長的到期日，因此它也可減少因為憑證到期而更新 ELAM 驅動程式的需求。

請注意，如果服務二進位檔是以私用 CA 憑證簽署，則二進位檔也必須以現有的 Authenticode 憑證雙重簽署。 如果二進位檔未由知名的受信任 CA 簽署 (例如 VeriSign) ，則電腦的使用者不會因為它們無法信任私用 CA 而在二進位檔中沒有任何信心。 使用現有的 Authenticode 憑證雙重簽署二進位檔，也可讓二進位檔在舊版作業系統上執行。

如需如何設定及安裝憑證授權單位單位的詳細資訊，請參閱 [設定證書](/previous-versions/windows/desktop/ms755466(v=vs.85)) 頒發機構單位和 [安裝憑證授權單位](/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj125375(v=ws.11))單位。

> [!Note]  
> 若要與 Windows Vista 或 Windows XP (或沒有 SHA2 修補程式) 的 Windows 7 相容，您可以在使用 SHA256 檔案/頁面雜湊的 [SignTool.exe](/windows/desktop/SecCrypto/signtool) 簽署二進位檔時，使用 "/as" 參數。 這會將簽章新增為檔案的次要簽章。 SHA1 會先簽署檔案，因為 Windows XP、Windows Vista 和 Windows 7 只會看到第一個簽章。

 

### <a name="dll-signing-requirements"></a>DLL 簽署需求

如先前所述，任何載入受保護服務的非 Windows Dll 都必須使用簽署反惡意程式碼服務所用的相同憑證來簽署。

### <a name="catalog-signing"></a>目錄簽署

反惡意程式碼廠商可以包含其他公司所開發的封裝，而不需要更新二進位簽章。 若要達成此目的，您可以依照下列步驟，在目錄中包含以其 Authenticode 憑證簽署的二進位檔：

1. 使用[MakeCat](/windows/desktop/SecCrypto/makecat)產生目錄
2. 將沒有適當簽章的所有二進位檔新增至目錄
3. 使用 Authenticode 憑證簽署類別目錄，就像任何其他二進位檔一樣
4. 使用 [ [新增類別目錄](/windows/desktop/api/Mscat/nf-mscat-cryptcatadminaddcatalog) ] 功能，將目錄包含在應用程式中。

當程式碼完整性在沒有適當簽章的套件之間進行時，它會搜尋具有核准簽章的目錄。 只要遵循這些步驟並隨應用程式一起安裝，它就會找到這個目錄。


## <a name="resource-file-info"></a>資源檔資訊

您必須建立資源檔，並將其連結至 ELAM 驅動程式。 您必須在資源檔中新增憑證的雜湊以及其他憑證資訊。

資源區段必須是下列配置，系統才能成功將二進位影像中的資源解壓縮，並驗證內嵌的憑證資訊。

``` syntax
MicrosoftElamCertificateInfo  MSElamCertInfoID
{
      3, // count of entries
      L”CertHash1\0”,
      Algorithm,
      L”EKU1\0”,
      L”CertHash2\0”,
      Algorithm,
      L”\0”, //No EKU for cert hash 2
      L”CertHash3\0”,
      Algorithm,
      L”EKU3a;EKU3b;EKU3c\0”,  //multiple EKU entries supported (max: 3)
}
```

如需使用者定義資源檔的詳細資訊，請參閱 [使用者定義的資源](/windows/desktop/menurc/user-defined-resource)。

### <a name="certhash"></a>CertHash

用來簽署反惡意程式碼服務之憑證的雜湊。 CertMgr.exe 工具（隨附于 Windows SDK）可以用來取得雜湊。

``` syntax
certmgr.exe –v <path to the signed file>
```

例如：

![反惡意程式碼保護的服務憑證雜湊 (certhash) ](images/cert-hash-example.png)

### <a name="algorithm"></a>演算法

演算法值代表憑證的演算法。 支援這些演算法值：

<dl> 0x8004 – SHA1  
0x800c – SHA256  
0X800d – SHA384  
0x800e – SHA512  
</dl>

請記得包含演算法 (的值（如上所示）) 而不是演算法的實際名稱。 例如，如果 cert 以 SHA256 演算法為基礎，請在資源區段中包含0x800c。

### <a name="eku"></a>EKU

EKU 物件代表憑證 (EKU) 屬性的單一擴充金鑰使用方式。 這是選擇性的， \\ 如果沒有任何 eku 與憑證相關聯，則應指定 "0"。在同一個系統上執行的單一反惡意程式碼廠商有多項產品和服務的情況下，反惡意程式碼廠商可使用私人 CA 憑證的 EKU 屬性來區分不同的服務。 例如，如果系統上有兩個服務從相同的反惡意程式碼廠商執行，而且是由相同的 CA 所簽署，則需要啟動為受保護的服務可以使用包含特殊 EKU 的 CA 所發行的憑證進行簽署。 必須將此 EKU 新增至資源區段。 然後，系統會註冊 EKU，並與憑證雜湊配對，以驗證並啟動受保護的服務。

請注意，憑證鏈必須包含程式碼簽署 EKU (1.3.6.1.5.5.7.3.3) ，但此 EKU 不得包含在 ELAM 驅動程式的資源區段中。

> [!Note]  
> 如果 ELAM 驅動程式的憑證資訊中包含 EKU 資訊，則簽署二進位檔時必須使用相同的 EKU。

 

### <a name="count"></a>Count

如果反惡意程式碼服務二進位檔是使用 Authenticode 憑證和私人 CA 憑證來簽署，則只有私人 CA 憑證資訊才能新增至資源區段。

## <a name="launching-anti-malware-services-as-protected"></a>以受保護的方式啟動反惡意程式碼服務

### <a name="registering-the-service"></a>註冊服務

必須先向系統註冊反惡意程式碼服務，才能將它啟動為受保護。 在安裝反惡意程式碼軟體期間，安裝程式可以安裝 ELAM 驅動程式，並重新啟動系統以自動註冊服務。 系統會在開機時註冊服務，方法是將上述資源檔中連結的憑證資訊解壓縮至 ELAM 驅動程式。

在安裝階段，強烈建議您重新開機系統，讓 ELAM 驅動程式能夠載入並驗證系統的狀態。 不過，在必須避免重新開機的情況下，Windows 也會公開一種機制，讓反惡意程式碼安裝程式使用 API 將服務註冊為受保護。

### <a name="registering-the-service-without-rebooting-the-system"></a>註冊服務而不重新開機系統

在安裝期間，反惡意程式碼軟體安裝程式可以呼叫 [**InstallELAMCertificateInfo**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo) API，並提供 ELAM 驅動程式檔案的控制碼。 系統會開啟 ELAM 驅動程式，並呼叫內部常式以確定 ELAM 驅動程式是否已正確簽署，然後從與 ELAM 驅動程式相關聯的資源區段中解壓縮憑證資訊。 如需函數語法，請參閱 [**InstallELAMCertificateInfo**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo)。

程式碼範例：


```C++
HANDLE FileHandle = NULL;

FileHandle = CreateFile(<Insert Elam driver file name>,
                        FILE_READ_DATA,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

if (InstallElamCertificateInfo(FileHandle) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}
```



### <a name="starting-the-service-as-protected"></a>以受保護的方式啟動服務

安裝程式可以依照下列步驟，建立、設定及啟動受保護的服務：

1.  呼叫 [**CreateService**](/windows/desktop/api/Winsvc/nf-winsvc-createservicea) API，以建立服務物件，並將它加入至服務控制管理員 (SCM) 資料庫。
2.  呼叫 [**SetServiceObjectSecurity**](/windows/desktop/api/winsvc/nf-winsvc-setserviceobjectsecurity) API，以設定在步驟1中建立之服務物件的安全描述項。
3.  呼叫 [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a) API，將服務標示為受保護，並指定新的 **服務設定 \_ \_ 啟動 \_ 受保護** 的列舉值，這個值已新增至 Windows 8.1) 的 (。

    程式碼範例：

    ```C++
    SERVICE_LAUNCH_PROTECTED_INFO Info;
    SC_HANDLE hService;

    Info.dwLaunchProtected = SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT;

    hService = CreateService (/* ... */);

    if (ChangeServiceConfig2(hService,
                             SERVICE_CONFIG_LAUNCH_PROTECTED,
                             &Info) == FALSE)
    {
        Result = GetLastError();
    }
    ```

    

4.  呼叫 [**StartService**](/windows/desktop/api/Winsvc/nf-winsvc-startservicea) API 以啟動服務。 以受保護的方式啟動服務時，SCM 會檢查程式碼完整性 (CI) 子系統來驗證憑證資訊。 在 CI 驗證憑證資訊之後，SCM 會將服務啟動為受保護。
    1.  請注意，如果您未藉由呼叫 [**InstallELAMCertificateInfo**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo) API 來註冊服務，則此步驟會失敗。
    2.  如果已將服務設定為在系統啟動階段期間自動啟動，您可以避免這個步驟，並只需重新開機系統。 在重新開機期間，系統會自動註冊服務 (如果 ELAM 驅動程式已順利啟動) 並以受保護模式啟動服務。

### <a name="launching-a-child-process-as-protected"></a>以受保護的方式啟動子進程

新的安全性模型也可讓反惡意程式碼保護的服務以受保護的方式啟動子進程。 這些子進程會在與父服務相同的保護層級上執行，而且必須使用透過 ELAM 資源區段註冊的相同憑證來簽署其二進位檔。

為了讓反惡意程式碼保護的服務能夠以受保護的方式啟動子進程，已公開新的擴充屬性索引鍵（ **PROC \_ 執行緒 \_ 屬性 \_ 保護 \_ 層級**），而且必須與 [**UpdateProcThreadAttribute**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute) API 搭配使用。 **保護 \_ 層級 \_** 的屬性值指標必須傳遞至 **UpdateProcThreadAttribute** API。

注意：

-   若要使用這個新屬性，服務也必須在 [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)呼叫的進程建立旗標參數中，指定 **建立 \_ 受保護的 \_ 進程**。
-   您必須使用/ac 參數來簽署您的服務二進位檔，以包含要將它連結到已知 CA 的交叉憑證。 未適當連結至已知根 CA 的自我簽署憑證將無法運作。

程式碼範例：


```C++
DWORD ProtectionLevel = PROTECTION_LEVEL_SAME;
SIZE_T AttributeListSize;

STARTUPINFOEXW StartupInfoEx = { 0 };

StartupInfoEx.StartupInfo.cb = sizeof(StartupInfoEx);

if (InitializeProcThreadAttributeList(NULL,
                                      1,
                                      0,
                                      &AttributeListSize) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

StartupInfoEx.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST) HeapAlloc(
    GetProcessHeap(),
    0,
    AttributeListSize
    );

if (InitializeProcThreadAttributeList(StartupInfoEx.lpAttributeList,
                                      1,
                                      0,
                                      &AttributeListSize) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

if (UpdateProcThreadAttribute(StartupInfoEx.lpAttributeList,
                              0,
                              PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL,
                              &ProtectionLevel,
                              sizeof(ProtectionLevel),
                              NULL,
                              NULL) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

PROCESS_INFORMATION ProcessInformation = { 0 };

if (CreateProcessW(ApplicationName,
                   CommandLine,
                   ProcessAttributes,
                   ThreadAttributes,
                   InheritHandles,
                   EXTENDED_STARTUPINFO_PRESENT | CREATE_PROTECTED_PROCESS,
                   Environment,
                   CurrentDirectory,
                   (LPSTARTUPINFOW)&StartupInfoEx,
                   &ProcessInformation) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}
```



## <a name="updates-and-servicing"></a>更新與服務

反惡意程式碼服務啟動為受保護之後，其他未受保護的進程 (，甚至是系統管理員) 無法停止服務。 如果是服務二進位檔的更新，反惡意程式碼服務就必須接收來自安裝程式的回呼，以自行停止，使其可供服務。 在服務停止之後，反惡意程式碼安裝程式就可以執行升級，然後依照上述的步驟在 [註冊服務](https://www.bing.com/search?q=Registering+the+service) 和 [啟動服務作為受保護](#starting-the-service-as-protected) 的區段來註冊憑證，並將服務啟動為受保護。

請注意，服務應該確保只有受信任的呼叫端可以停止服務。 允許不受信任的呼叫端這麼做，就無法保護服務的目的。

### <a name="unregistering-the-service"></a>取消註冊服務

當您卸載受保護的服務時，服務必須呼叫 [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a) API 將本身標記為未受保護。 請注意，因為系統不允許任何未受保護的進程改變受保護服務的設定，所以 [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a) 的呼叫必須由受保護的服務本身進行。 當服務重新設定為以未受保護的方式執行時，卸載程式可以直接採取適當的步驟，從系統移除反惡意程式碼軟體。

## <a name="debugging-an-anti-malware-protected-service"></a>調試反惡意程式碼保護的服務

在受保護的進程安全性模型中，其他未受保護的進程無法插入執行緒或寫入受保護進程的虛擬記憶體。 不過，您可以使用 (KD) 的核心偵錯工具，來偵測任何反惡意程式碼保護的進程。 KD 也可以用來檢查反惡意程式碼服務是否以受保護的狀態執行：

``` syntax
dt –r1 nt!_EPROCESS <Process Address>
+0x67a Protection       : _PS_PROTECTION
      +0x000 Level            : 0x31 '1'
      +0x000 Type             : 0y0001
      +0x000 Signer           : 0y0011
```

如果 *類型* 成員的值是0y0001，則服務會以受保護的方式執行。

此外，反惡意程式碼保護的服務上只允許下列 SC 命令：

-   `sc config start=Auto`
-   `sc qc`
-   `sc start`
-   `sc interrogate`
-   `sc sdshow`

如果已附加偵錯工具，請使用登錄中的下列旗標，在未簽署的 (或不當簽署的) 二進位檔載入至反惡意程式碼保護的服務時，于偵錯工具中中斷。

``` syntax
Key:   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CI
Value: DebugFlags      REG_DWORD
```

當簽章驗證失敗時，將值設定為 **00000400** ，以在偵錯工具中中斷。

> [!Note]  
> 受保護的進程限制：
>
> 1.  具有 UI 或 GUI 的進程無法受到保護，因為核心會在記憶體中鎖定進程，而不允許寫入它。
> 2.  在 Windows 10 之前，1703版 (建立者更新) ，受保護的進程無法使用 TLS 或 SSL 通訊協定，因為本地安全機構 (LSA) 和受保護的進程之間共用憑證的限制。

 

## <a name="resources"></a>資源

如需詳細資訊，請參閱：

-   [早期啟動反惡意程式碼](/windows/desktop/w8cookbook/secured-boot)
-   [Windows Vista 中受保護的進程](/previous-versions/windows/hardware/download/dn550976(v=vs.85))
-   [設定憑證授權單位單位](/previous-versions/windows/desktop/ms755466(v=vs.85))
-   [安裝憑證授權單位](/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj125375(v=ws.11))
-   [使用者定義的資源](/windows/desktop/menurc/user-defined-resource)

本文參考這些 Windows API 函數：

-   [**ChangeServiceConfig2**](/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfig2a)
-   [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)
-   [**CreateService**](/windows/desktop/api/Winsvc/nf-winsvc-createservicea)
-   [**InitializeProcThreadAttributeList**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist)
-   [**InstallELAMCertificateInfo**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo)
-   [**SetServiceObjectSecurity**](/windows/desktop/api/winsvc/nf-winsvc-setserviceobjectsecurity)
-   [**StartService**](/windows/desktop/api/Winsvc/nf-winsvc-startservicea)
-   [**UpdateProcThreadAttribute**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute)

 

 
