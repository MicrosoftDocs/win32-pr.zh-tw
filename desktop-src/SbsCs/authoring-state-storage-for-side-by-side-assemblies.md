---
description: 建立您自己的並存元件時，請遵循建立並存元件的指導方針，並根據撰寫並存元件 DLL 的指導方針，編寫要包含在元件中的任何 DLL。
ms.assetid: 0e98bbcd-7e23-4a33-b0fa-1f936d0ef96b
title: 撰寫並存元件的狀態儲存體
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: eee388cf680ee3a186a225ca7e3bde8b6eae625d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103693515"
---
# <a name="authoring-state-storage-for-side-by-side-assemblies"></a><span data-ttu-id="60be1-103">撰寫並存元件的狀態儲存體</span><span class="sxs-lookup"><span data-stu-id="60be1-103">Authoring State Storage for Side-by-side Assemblies</span></span>

<span data-ttu-id="60be1-104">建立您自己的並存元件時，請遵循 [建立並存元件的指導方針](guidelines-for-creating-side-by-side-assemblies.md) ，並根據 [撰寫並存元件 dll](authoring-a-dll-for-a-side-by-side-assembly.md)的指導方針，編寫要包含在元件中的任何 DLL。</span><span class="sxs-lookup"><span data-stu-id="60be1-104">When creating your own side-by-side assemblies, follow the [Guidelines for Creating Side-by-side Assemblies](guidelines-for-creating-side-by-side-assemblies.md) and author any DLL to be included in the assembly according to the guidelines in [Authoring a DLL for a Side-by-Side Assembly](authoring-a-dll-for-a-side-by-side-assembly.md).</span></span>

<span data-ttu-id="60be1-105">遵循下列的狀態儲存指導方針：</span><span class="sxs-lookup"><span data-stu-id="60be1-105">Adhere to the following guidelines for the storage of the state:</span></span>

-   <span data-ttu-id="60be1-106">將狀態儲存體設計為向前及向後相容。</span><span class="sxs-lookup"><span data-stu-id="60be1-106">Design state storage to be forward and backward compatible.</span></span> <span data-ttu-id="60be1-107">預期版本會以任何順序使用：例如，v1、v3 和 v2。</span><span class="sxs-lookup"><span data-stu-id="60be1-107">Expect the versions to be used in any order: for example, v1, then v3, then v2.</span></span>
-   <span data-ttu-id="60be1-108">初始化和設定元件程式碼中元件的預設設定。</span><span class="sxs-lookup"><span data-stu-id="60be1-108">Initialize and set the default settings for the assembly in the assembly code.</span></span> <span data-ttu-id="60be1-109">請勿將預設設定儲存在登錄中。</span><span class="sxs-lookup"><span data-stu-id="60be1-109">Do not save the defaults settings in the registry.</span></span>
-   <span data-ttu-id="60be1-110">登錄設定必須以個別版本撰寫，以隔離可同時執行的多個元件版本。</span><span class="sxs-lookup"><span data-stu-id="60be1-110">Registry settings must be written on an individual-version basis to isolate multiple assembly versions that may be run at the same time.</span></span> <span data-ttu-id="60be1-111">設計並存元件，以便在並存共用案例期間，正確地儲存和處理元件的狀態。</span><span class="sxs-lookup"><span data-stu-id="60be1-111">Design your side-by-side assembly to correctly store and handle the state of the assembly during side-by-side sharing scenarios.</span></span>
-   <span data-ttu-id="60be1-112">元件通常會將狀態資訊儲存在登錄機碼中。</span><span class="sxs-lookup"><span data-stu-id="60be1-112">Assemblies commonly store state information in registry keys.</span></span> <span data-ttu-id="60be1-113">撰寫一組標頭檔和 helper 函式，以提供簡單的方式來將包含元件狀態的登錄機碼設定為版本。</span><span class="sxs-lookup"><span data-stu-id="60be1-113">Author a set of header files and helper functions to provide an easy way to version registry keys containing the assembly state.</span></span>
-   <span data-ttu-id="60be1-114">儲存在登錄中的任何元件狀態資訊都必須與元件的其他版本隔離。</span><span class="sxs-lookup"><span data-stu-id="60be1-114">Any assembly state information saved in the registry must be isolated from other versions of the assembly.</span></span> <span data-ttu-id="60be1-115">儲存在登錄中的狀態設定必須儲存在登錄的個別版本區段中。</span><span class="sxs-lookup"><span data-stu-id="60be1-115">State settings stored in the registry must be saved in individual version sections of the registry.</span></span> <span data-ttu-id="60be1-116">登錄的 HKLM 和 HKCU 部分都需要這項功能。</span><span class="sxs-lookup"><span data-stu-id="60be1-116">This is required in both the HKLM and HKCU parts of the registry.</span></span> <span data-ttu-id="60be1-117">例如，在下列登錄機碼下儲存元件版本 XXXX 的 HKCU 狀態設定：</span><span class="sxs-lookup"><span data-stu-id="60be1-117">For example, store HKCU state settings for assembly version XXXX under the following registry key:</span></span>

    <span data-ttu-id="60be1-118">**HKCU** \\**MyCompany** \\**MyComponent** \\**VersionXXXX**</span><span class="sxs-lookup"><span data-stu-id="60be1-118">**HKCU**\\**MyCompany**\\**MyComponent**\\**VersionXXXX**</span></span>

-   <span data-ttu-id="60be1-119">共用元件儲存在登錄中的任何狀態資訊都必須儲存在登錄的個別版本區段中。</span><span class="sxs-lookup"><span data-stu-id="60be1-119">Any state information stored in the registry by shared assemblies must be saved in individual version sections of the registry.</span></span> <span data-ttu-id="60be1-120">例如，稱為 EnableSuperCoolFeature 的狀態設定可能會有 **TRUE** 或 **FALSE** 的值。</span><span class="sxs-lookup"><span data-stu-id="60be1-120">For example, a state setting called EnableSuperCoolFeature might have a value of **TRUE** or **FALSE**.</span></span> <span data-ttu-id="60be1-121">儲存 [*共用並存元件*](s-sbscs-gly.md) 的值，如下所示：</span><span class="sxs-lookup"><span data-stu-id="60be1-121">Store the value for a [*shared side-by-side assembly*](s-sbscs-gly.md) as follows:</span></span>

    <span data-ttu-id="60be1-122">**HKEY \_CurrentUser** \\ **Software** \\ **MyCompany** \\ **MyComponent** \\ **version 01.01** \\ **EnableSuperCoolFeature = TRUE**</span><span class="sxs-lookup"><span data-stu-id="60be1-122">**HKEY\_CurrentUser**\\**Software**\\**MyCompany**\\**MyComponent**\\**Version01.01**\\**EnableSuperCoolFeature = TRUE**</span></span>

-   <span data-ttu-id="60be1-123">私用元件儲存在登錄中的任何狀態資訊都必須儲存在登錄的個別應用程式區段中。</span><span class="sxs-lookup"><span data-stu-id="60be1-123">Any state information stored in the registry by private assemblies must be saved in individual application sections of the registry.</span></span> <span data-ttu-id="60be1-124">這會將元件的狀態設定與應用程式隔離。</span><span class="sxs-lookup"><span data-stu-id="60be1-124">This isolates the assembly's state settings to the application.</span></span> <span data-ttu-id="60be1-125">您可以使用 [**GetModuleFileName**](/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) 函數來設定虛擬根目錄。</span><span class="sxs-lookup"><span data-stu-id="60be1-125">You can use the [**GetModuleFileName**](/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) function to set up a virtual root.</span></span> <span data-ttu-id="60be1-126">例如，如果元件版本 XXYY 是 "SomeApplication" 的私用元件，則對 **GetModuleFileName** 的呼叫會傳回 "SomeApplication"，且元件的任何私用狀態設定都應該使用下列機碼來寫入：</span><span class="sxs-lookup"><span data-stu-id="60be1-126">For example, if assembly version XXYY is a private assembly of "SomeApplication," a call to **GetModuleFileName** returns "SomeApplication" and any private state settings for the assembly should be written under the following key:</span></span>

    <span data-ttu-id="60be1-127">**HKCU** \\**MyCompany** \\**MyComponent** \\**VersionXXYY** \\**SomeApplication**</span><span class="sxs-lookup"><span data-stu-id="60be1-127">**HKCU**\\**MyCompany**\\**MyComponent**\\**VersionXXYY**\\**SomeApplication**</span></span>

-   <span data-ttu-id="60be1-128">讓儲存在登錄中的共用狀態設定，私用至執行的元件內容。</span><span class="sxs-lookup"><span data-stu-id="60be1-128">Make shared state settings stored in the registry private to the assembly context that runs.</span></span> <span data-ttu-id="60be1-129">您可以使用 [**GetModuleFileName**](/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) 函數來設定虛擬根目錄。</span><span class="sxs-lookup"><span data-stu-id="60be1-129">You can use the [**GetModuleFileName**](/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) function to set up a virtual root.</span></span> <span data-ttu-id="60be1-130">這應針對 HKLM 和 HKCU 分支進行。</span><span class="sxs-lookup"><span data-stu-id="60be1-130">This should be done for HKLM and HKCU branches.</span></span>
-   <span data-ttu-id="60be1-131">在理想的情況下，您應該採用持續性模型，讓應用程式維持狀態，而且不會改變登錄。</span><span class="sxs-lookup"><span data-stu-id="60be1-131">Ideally, you should adopt a persistence model in which the application persists the state and does not alter the registry.</span></span> <span data-ttu-id="60be1-132">應用程式應該不需要直接接觸元件的登錄專案。</span><span class="sxs-lookup"><span data-stu-id="60be1-132">An application should not need to directly touch the component's registry entries.</span></span> <span data-ttu-id="60be1-133">相反地，元件應該提供可儲存或還原並存相容之設定的 API 函數。</span><span class="sxs-lookup"><span data-stu-id="60be1-133">Instead, the assembly should offer API functions that save or restore settings that are side-by-side compatible.</span></span>
-   <span data-ttu-id="60be1-134">元件可能會將狀態設定儲存在登錄外的存放區，讓元件能夠與全域狀態互動。</span><span class="sxs-lookup"><span data-stu-id="60be1-134">Assemblies may save state settings in stores outside the registry to enable the assembly to interact with the global state.</span></span> <span data-ttu-id="60be1-135">並存元件可能會使用下列並存相容存放區：</span><span class="sxs-lookup"><span data-stu-id="60be1-135">Side-by-side assemblies may use the following side-by-side compatible stores:</span></span>
    -   <span data-ttu-id="60be1-136">受保護的存放區 (*pstore*) </span><span class="sxs-lookup"><span data-stu-id="60be1-136">A protected store (*pstore*)</span></span>
    -   <span data-ttu-id="60be1-137">WinInet 快取</span><span class="sxs-lookup"><span data-stu-id="60be1-137">A WinInet cache</span></span>
    -   <span data-ttu-id="60be1-138">Microsoft SQL Server</span><span class="sxs-lookup"><span data-stu-id="60be1-138">A Microsoft SQL Server</span></span>

 

 
