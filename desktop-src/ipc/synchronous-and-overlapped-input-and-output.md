---
description: 同步管道 i/o 和非同步管道 i/o。 ReadFile、WriteFile、TransactNamedPipe 和 ConnectNamedPipe 函數可以同步或非同步方式，在管道上執行輸入和輸出作業。
ms.assetid: 5ab9bb7f-1f99-4041-bba8-2863f34dbcaf
title: 同步和重迭的管道 i/o
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3becfb19dfe5fa49d4121246a576fb3200226b1a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106988435"
---
# <a name="synchronous-and-overlapped-pipe-io"></a><span data-ttu-id="c9566-104">同步和重迭的管道 i/o</span><span class="sxs-lookup"><span data-stu-id="c9566-104">Synchronous and Overlapped Pipe I/O</span></span>

<span data-ttu-id="c9566-105">[**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile)、 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile)、 [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)和 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)函數可以同步或非同步方式，在管道上執行輸入和輸出作業。</span><span class="sxs-lookup"><span data-stu-id="c9566-105">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can perform input and output operations on a pipe either synchronously or asynchronously.</span></span> <span data-ttu-id="c9566-106">當函式以同步方式執行時，它會等到執行的作業完成後才會傳回。</span><span class="sxs-lookup"><span data-stu-id="c9566-106">When a function runs synchronously, it does not return until the operation it is performing is completed.</span></span> <span data-ttu-id="c9566-107">這表示，呼叫執行緒的執行可能會在等候需要花費很多時間的作業完成時，封鎖無限期。</span><span class="sxs-lookup"><span data-stu-id="c9566-107">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to be completed.</span></span> <span data-ttu-id="c9566-108">當函式以非同步方式執行時，它會立即傳回，即使操作尚未完成。</span><span class="sxs-lookup"><span data-stu-id="c9566-108">When a function runs asynchronously, it returns immediately, even if the operation has not been completed.</span></span> <span data-ttu-id="c9566-109">這可讓您在背景執行耗時的作業，而呼叫執行緒可以自由執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="c9566-109">This enables a time-consuming operation to be executed in the background while the calling thread is free to perform other tasks.</span></span>

<span data-ttu-id="c9566-110">使用非同步 i/o 可讓管道伺服器使用迴圈來執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="c9566-110">Using asynchronous I/O enables a pipe server to use a loop that performs the following steps:</span></span>

1.  <span data-ttu-id="c9566-111">在等候函式的呼叫中指定多個事件物件，並等候其中一個物件設定為已發出信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="c9566-111">Specify multiple event objects in a call to the wait function, and wait for one of the objects to be set to the signaled state.</span></span>
2.  <span data-ttu-id="c9566-112">使用 wait 函式的傳回值來判斷已完成的重迭運算。</span><span class="sxs-lookup"><span data-stu-id="c9566-112">Use the wait function's return value to determine which overlapped operation has finished.</span></span>
3.  <span data-ttu-id="c9566-113">執行清除已完成的作業所需的工作，並起始該管道控制碼的下一次操作。</span><span class="sxs-lookup"><span data-stu-id="c9566-113">Perform the tasks necessary to clean up the completed operation and initiate the next operation for that pipe handle.</span></span> <span data-ttu-id="c9566-114">這可能牽涉到針對相同的管道控制碼啟動另一個重迭的作業。</span><span class="sxs-lookup"><span data-stu-id="c9566-114">This can involve starting another overlapped operation for the same pipe handle.</span></span>

<span data-ttu-id="c9566-115">重迭的作業可讓一個管道同時讀取和寫入資料，以及針對單一線程，在多個管道控制碼上執行同時的 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="c9566-115">Overlapped operations make it possible for one pipe to read and write data simultaneously and for a single thread to perform simultaneous I/O operations on multiple pipe handles.</span></span> <span data-ttu-id="c9566-116">這可讓單一執行緒的管道伺服器有效率地處理與多個管道用戶端之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="c9566-116">This enables a single-threaded pipe server to handle communications with multiple pipe clients efficiently.</span></span> <span data-ttu-id="c9566-117">如需範例，請參閱使用重迭 [i/o 的具名管道伺服器](named-pipe-server-using-overlapped-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="c9566-117">For an example, see [Named Pipe Server Using Overlapped I/O](named-pipe-server-using-overlapped-i-o.md).</span></span>

<span data-ttu-id="c9566-118">若要讓管道伺服器使用同步作業來與多個用戶端通訊，它必須為每個管道用戶端建立個別的執行緒，讓一個或多個執行緒可以在其他執行緒等候時執行。</span><span class="sxs-lookup"><span data-stu-id="c9566-118">For a pipe server to use synchronous operations to communicate with more than one client, it must create a separate thread for each pipe client so that one or more threads can run while other threads are waiting.</span></span> <span data-ttu-id="c9566-119">如需使用同步作業之多執行緒管道伺服器的範例，請參閱 [多執行緒管道伺服器](multithreaded-pipe-server.md)。</span><span class="sxs-lookup"><span data-stu-id="c9566-119">For an example of a multithreaded pipe server that uses synchronous operations, see [Multithreaded Pipe Server](multithreaded-pipe-server.md).</span></span>

## <a name="enabling-asynchronous-operation"></a><span data-ttu-id="c9566-120">啟用非同步作業</span><span class="sxs-lookup"><span data-stu-id="c9566-120">Enabling Asynchronous Operation</span></span>

<span data-ttu-id="c9566-121">[**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile)、 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile)、 [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)和 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)函式只有在您針對指定的管道控制碼啟用重迭模式，並 [**指定對重迭結構的**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped)有效指標時，才能以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="c9566-121">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can be performed asynchronously only if you enable overlapped mode for the specified pipe handle and specify a valid pointer to an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="c9566-122">如果重 **迭指標** 為 **Null**，則函式傳回值可能會不正確地表示作業已完成。</span><span class="sxs-lookup"><span data-stu-id="c9566-122">If the **OVERLAPPED** pointer is **NULL**, the function return value can incorrectly indicate that the operation has been completed.</span></span> <span data-ttu-id="c9566-123">因此，強烈建議您如果建立的控制碼的檔案旗標 \_ \_ 重迭，而且想要使用非同步行為，您應該一律指定有效的重迭結構。</span><span class="sxs-lookup"><span data-stu-id="c9566-123">Therefore, it is strongly recommended that if you create a handle with FILE\_FLAG\_OVERLAPPED and want asynchronous behavior, you should always specify a valid **OVERLAPPED** structure.</span></span>

<span data-ttu-id="c9566-124">[**指定之**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped)重迭結構的 **hEvent** 成員必須包含手動重設事件物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="c9566-124">The **hEvent** member of the specified [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must contain a handle to a manual-reset event object.</span></span> <span data-ttu-id="c9566-125">這是 [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) 函數所建立的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="c9566-125">This is a synchronization object created by the [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) function.</span></span> <span data-ttu-id="c9566-126">起始重迭作業的執行緒會使用事件物件來判斷作業何時完成。</span><span class="sxs-lookup"><span data-stu-id="c9566-126">The thread that initiates the overlapped operation uses the event object to determine when the operation has finished.</span></span> <span data-ttu-id="c9566-127">當您在相同的控制碼上執行並行作業時，不應該使用管道控制碼進行同步處理，因為沒有辦法知道哪一項作業的完成會導致管道控制碼收到信號。</span><span class="sxs-lookup"><span data-stu-id="c9566-127">You should not use the pipe handle for synchronization when performing simultaneous operations on the same handle because there is no way of knowing which operation's completion caused the pipe handle to be signaled.</span></span> <span data-ttu-id="c9566-128">在相同管道控制碼上執行同時作業的唯一可靠方法，是針對每個作業 **使用個別的** 重迭結構及其本身的事件物件。</span><span class="sxs-lookup"><span data-stu-id="c9566-128">The only reliable technique for performing simultaneous operations on the same pipe handle is to use a separate **OVERLAPPED** structure with its own event object for each operation.</span></span> <span data-ttu-id="c9566-129">如需事件物件的詳細資訊，請參閱 [同步](/windows/desktop/Sync/synchronization)處理。</span><span class="sxs-lookup"><span data-stu-id="c9566-129">For more information about event objects, see [Synchronization](/windows/desktop/Sync/synchronization).</span></span>

<span data-ttu-id="c9566-130">此外，當重迭的作業完成時，您也可以使用 [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) 或 [**GetQueuedCompletionStatusEx**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) 函數來通知您。</span><span class="sxs-lookup"><span data-stu-id="c9566-130">Also, you can be notified when an overlapped operation completes by using the [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) or [**GetQueuedCompletionStatusEx**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) functions.</span></span> <span data-ttu-id="c9566-131">在此情況下，您不 [**需要在重迭的結構中**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 指派手動重設事件，並且會以非同步讀取或寫入作業的相同方式，對管道控制碼執行完成。</span><span class="sxs-lookup"><span data-stu-id="c9566-131">In this case, you do not need to assign the manual-reset event in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, and the completion happens against the pipe handle in the same way as an asynchronous read or write operation.</span></span> <span data-ttu-id="c9566-132">如需詳細資訊，請參閱 [I/o 完成埠](/windows/desktop/FileIO/i-o-completion-ports)。</span><span class="sxs-lookup"><span data-stu-id="c9566-132">For more information, see [I/O Completion Ports](/windows/desktop/FileIO/i-o-completion-ports).</span></span>

<span data-ttu-id="c9566-133">當 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile)、 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile)、 [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)和 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) 作業以非同步方式執行時，會發生下列其中一種情況：</span><span class="sxs-lookup"><span data-stu-id="c9566-133">When [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) operations are performed asynchronously, one of the following occurs:</span></span>

-   <span data-ttu-id="c9566-134">如果函式傳回時作業已完成，則傳回值會指出作業成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="c9566-134">If the operation is complete when the function returns, the return value indicates the success or failure of the operation.</span></span> <span data-ttu-id="c9566-135">如果發生錯誤，則傳回值為零，而且 [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) 函式會傳回錯誤 IO 擱置以外的值 \_ \_ 。</span><span class="sxs-lookup"><span data-stu-id="c9566-135">If an error occurs, the return value is zero and the [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns something other than ERROR\_IO\_PENDING.</span></span>
-   <span data-ttu-id="c9566-136">如果函式傳回時作業未完成，則傳回值為零，而 [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) 會傳回錯誤 \_ IO \_ 暫止。</span><span class="sxs-lookup"><span data-stu-id="c9566-136">If the operation has not finished when the function returns, the return value is zero and [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns ERROR\_IO\_PENDING.</span></span> <span data-ttu-id="c9566-137">在此情況下，呼叫執行緒必須等候作業完成。</span><span class="sxs-lookup"><span data-stu-id="c9566-137">In this case, the calling thread must wait until the operation has finished.</span></span> <span data-ttu-id="c9566-138">接著，呼叫的執行緒必須呼叫 [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) 函數來判斷結果。</span><span class="sxs-lookup"><span data-stu-id="c9566-138">The calling thread must then call the [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) function to determine the results.</span></span>

## <a name="using-completion-routines"></a><span data-ttu-id="c9566-139">使用完成常式</span><span class="sxs-lookup"><span data-stu-id="c9566-139">Using Completion Routines</span></span>

<span data-ttu-id="c9566-140">[**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex)和 [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex)函數提供另一種形式的重迭 i/o。</span><span class="sxs-lookup"><span data-stu-id="c9566-140">The [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions provide another form of overlapped I/O.</span></span> <span data-ttu-id="c9566-141">不同于重迭的 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) 和 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) 函式（使用事件物件來表示完成），擴充函數會指定 *完成常式*。</span><span class="sxs-lookup"><span data-stu-id="c9566-141">Unlike the overlapped [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) functions, which use an event object to signal completion, the extended functions specify a *completion routine*.</span></span> <span data-ttu-id="c9566-142">完成常式是在讀取或寫入作業完成時，已排入佇列以便執行的函式。</span><span class="sxs-lookup"><span data-stu-id="c9566-142">A completion routine is a function that is queued for execution when the read or write operation is finished.</span></span> <span data-ttu-id="c9566-143">在呼叫 **ReadFileEx** 和 **WriteFileEx** 的執行緒啟動 *可提供警示等候* 作業之前，不會執行完成常式，方法是呼叫其中一個 [可提供警示 wait 函數](/windows/desktop/Sync/wait-functions) ，並將 *fAlertable* 參數設定為 **TRUE**。</span><span class="sxs-lookup"><span data-stu-id="c9566-143">The completion routine is not executed until the thread that called **ReadFileEx** and **WriteFileEx** starts an *alertable wait operation* by calling one of the [alertable wait functions](/windows/desktop/Sync/wait-functions) with the *fAlertable* parameter set to **TRUE**.</span></span> <span data-ttu-id="c9566-144">在可提供警示等候作業中，函式也會在 **ReadFileEx** 或 **WriteFileEx** 完成常式排入佇列以供執行時傳回。</span><span class="sxs-lookup"><span data-stu-id="c9566-144">In an alertable wait operation, the functions also return when a **ReadFileEx** or **WriteFileEx** completion routine is queued for execution.</span></span> <span data-ttu-id="c9566-145">管道伺服器可以使用擴充的函式，對每個連接到它的用戶端執行一系列的讀取和寫入作業。</span><span class="sxs-lookup"><span data-stu-id="c9566-145">A pipe server can use the extended functions to perform a sequence of read and write operations for each client that connects to it.</span></span> <span data-ttu-id="c9566-146">順序中的每個讀取或寫入作業都會指定一個完成常式，而每個完成常式都會起始順序中的下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="c9566-146">Each read or write operation in the sequence specifies a completion routine, and each completion routine initiates the next step in the sequence.</span></span> <span data-ttu-id="c9566-147">如需範例，請參閱 [使用完成常式的具名管道伺服器](named-pipe-server-using-completion-routines.md)。</span><span class="sxs-lookup"><span data-stu-id="c9566-147">For an example, see [Named Pipe Server Using Completion Routines](named-pipe-server-using-completion-routines.md).</span></span>

 

 
