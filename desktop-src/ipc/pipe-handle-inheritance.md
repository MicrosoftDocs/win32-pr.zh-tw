---
description: 管道伺服器控制是否可透過下列方式繼承其控制碼。
ms.assetid: 72302f8b-f3a2-4efc-aab1-e596b8323984
title: 管道控制碼繼承
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 21cf91d4393b43011a2df632806f96da1e713b96
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103689512"
---
# <a name="pipe-handle-inheritance"></a><span data-ttu-id="0eac6-103">管道控制碼繼承</span><span class="sxs-lookup"><span data-stu-id="0eac6-103">Pipe Handle Inheritance</span></span>

<span data-ttu-id="0eac6-104">管道伺服器控制是否可透過下列方式繼承其控制碼：</span><span class="sxs-lookup"><span data-stu-id="0eac6-104">The pipe server controls whether its handles can be inherited in the following ways:</span></span>

-   <span data-ttu-id="0eac6-105">[**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe)函式會接收 [**安全性 \_ 屬性**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85))結構。</span><span class="sxs-lookup"><span data-stu-id="0eac6-105">The [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) function receives a [**SECURITY\_ATTRIBUTES**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure.</span></span> <span data-ttu-id="0eac6-106">如果管道伺服器將此結構的 **bInheritHandle** 成員設為 **TRUE**，則可以繼承 **CreatePipe** 所建立的控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-106">If the pipe server sets the **bInheritHandle** member of this structure to **TRUE**, the handles created by **CreatePipe** can be inherited.</span></span>
-   <span data-ttu-id="0eac6-107">管道伺服器可以使用 [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) 函數來變更管道控制碼的繼承。</span><span class="sxs-lookup"><span data-stu-id="0eac6-107">The pipe server can use the [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) function to change the inheritance of a pipe handle.</span></span> <span data-ttu-id="0eac6-108">管道伺服器可以建立可繼承管道控制碼的基類重複，或可繼承的基類管道控制碼重複。</span><span class="sxs-lookup"><span data-stu-id="0eac6-108">The pipe server can create a noninheritable duplicate of an inheritable pipe handle or an inheritable duplicate of a noninheritable pipe handle.</span></span>
-   <span data-ttu-id="0eac6-109">[**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)函數可讓管道伺服器指定子進程是否全部繼承或全部都不繼承它的可繼承控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-109">The [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) function enables the pipe server to specify whether a child process inherits all or none of its inheritable handles.</span></span>

<span data-ttu-id="0eac6-110">當子進程繼承管道控制碼時，系統會讓進程存取管道。</span><span class="sxs-lookup"><span data-stu-id="0eac6-110">When a child process inherits a pipe handle, the system enables the process to access the pipe.</span></span> <span data-ttu-id="0eac6-111">不過，父進程必須將控制碼值傳達給子進程。</span><span class="sxs-lookup"><span data-stu-id="0eac6-111">However, the parent process must communicate the handle value to the child process.</span></span> <span data-ttu-id="0eac6-112">父進程通常會將標準輸出控制碼重新導向至子進程，如下列步驟所示：</span><span class="sxs-lookup"><span data-stu-id="0eac6-112">The parent process typically does this by redirecting the standard output handle to the child process, as shown in the following steps:</span></span>

1.  <span data-ttu-id="0eac6-113">呼叫 [**GetStdHandle**](/windows/console/getstdhandle) 函數，以取得目前的標準輸出控制碼;儲存此控制碼，讓您可以在建立子進程之後還原原始的標準輸出控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-113">Call the [**GetStdHandle**](/windows/console/getstdhandle) function to get the current standard output handle; save this handle so you can restore the original standard output handle after the child process has been created.</span></span>
2.  <span data-ttu-id="0eac6-114">呼叫 [**SetStdHandle**](/windows/console/setstdhandle) 函數，將標準輸出控制碼設定為管道的寫入控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-114">Call the [**SetStdHandle**](/windows/console/setstdhandle) function to set the standard output handle to the write handle to the pipe.</span></span> <span data-ttu-id="0eac6-115">現在父進程可以建立子進程。</span><span class="sxs-lookup"><span data-stu-id="0eac6-115">Now the parent process can create the child process.</span></span>
3.  <span data-ttu-id="0eac6-116">呼叫 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 函數，以關閉管道的寫入控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-116">Call the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function to close the write handle to the pipe.</span></span> <span data-ttu-id="0eac6-117">在子進程繼承寫入控制碼之後，父進程就不再需要它的複本。</span><span class="sxs-lookup"><span data-stu-id="0eac6-117">After the child process inherits the write handle, the parent process no longer needs its copy.</span></span>
4.  <span data-ttu-id="0eac6-118">呼叫 [**SetStdHandle**](/windows/console/setstdhandle) 來還原原始標準輸出控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-118">Call [**SetStdHandle**](/windows/console/setstdhandle) to restore the original standard output handle.</span></span>

<span data-ttu-id="0eac6-119">子進程會使用 [**GetStdHandle**](/windows/console/getstdhandle) 函式來取得其標準輸出控制碼，現在是管道的寫入結束控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-119">The child process uses the [**GetStdHandle**](/windows/console/getstdhandle) function to get its standard output handle, which is now a handle to the write end of a pipe.</span></span> <span data-ttu-id="0eac6-120">子進程接著會使用 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) 函式，將其輸出傳送至管道。</span><span class="sxs-lookup"><span data-stu-id="0eac6-120">The child process then uses the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) function to send its output to the pipe.</span></span> <span data-ttu-id="0eac6-121">當子系使用管道完成時，它應該藉由呼叫 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 或終止來關閉管道控制碼，這會自動關閉控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-121">When the child has finished with the pipe, it should close the pipe handle by calling [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) or by terminating, which automatically closes the handle.</span></span>

<span data-ttu-id="0eac6-122">父進程會使用 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) 函式來接收來自管道的輸入。</span><span class="sxs-lookup"><span data-stu-id="0eac6-122">The parent process uses the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) function to receive input from the pipe.</span></span> <span data-ttu-id="0eac6-123">資料會以位元組資料流程的形式寫入至匿名管道。</span><span class="sxs-lookup"><span data-stu-id="0eac6-123">Data is written to an anonymous pipe as a stream of bytes.</span></span> <span data-ttu-id="0eac6-124">這表示，從管道讀取的父進程無法區分以個別寫入作業撰寫的位元組，除非父進程和子進程都使用通訊協定來指出寫入作業結束的位置。</span><span class="sxs-lookup"><span data-stu-id="0eac6-124">This means that the parent process reading from a pipe cannot distinguish between the bytes written in separate write operations, unless both the parent and child processes use a protocol to indicate where the write operation ends.</span></span> <span data-ttu-id="0eac6-125">當管道的所有寫入控制碼都關閉時， **ReadFile** 函數會傳回零。</span><span class="sxs-lookup"><span data-stu-id="0eac6-125">When all write handles to the pipe are closed, the **ReadFile** function returns zero.</span></span> <span data-ttu-id="0eac6-126">在呼叫 **ReadFile** 之前，父進程必須關閉管道寫入端的控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-126">It is important for the parent process to close its handle to the write end of the pipe before calling **ReadFile**.</span></span> <span data-ttu-id="0eac6-127">如果沒有這樣做， **ReadFile** 作業就無法傳回零，因為父進程具有管道寫入結尾的開啟控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-127">If this is not done, the **ReadFile** operation cannot return zero because the parent process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="0eac6-128">重新導向標準輸入控制碼的程式，與重新導向標準輸出控制碼的程式類似，不同之處在于管道的讀取控制碼是用來做為子系的標準輸入控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-128">The procedure for redirecting the standard input handle is similar to that for redirecting the standard output handle, except that the pipe's read handle is used as the child's standard input handle.</span></span> <span data-ttu-id="0eac6-129">在此情況下，父進程必須確保子進程不會繼承管道的寫入控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-129">In this case, the parent process must ensure that the child process does not inherit the pipe's write handle.</span></span> <span data-ttu-id="0eac6-130">如果沒有這麼做，子進程所執行的 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) 作業就無法傳回零，因為子進程具有管道寫入結束的控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eac6-130">If this is not done, the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) operation performed by the child process cannot return zero because the child process has an open handle to the write end of the pipe.</span></span>

<span data-ttu-id="0eac6-131">如需使用匿名管道來重新導向子進程之標準控制碼的範例程式，請參閱 [使用重新導向的輸入和輸出建立子進程](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output)。</span><span class="sxs-lookup"><span data-stu-id="0eac6-131">For an example program that uses anonymous pipes to redirect the standard handles of a child process, see [Creating a Child Process with Redirected Input and Output](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).</span></span>

 

 
