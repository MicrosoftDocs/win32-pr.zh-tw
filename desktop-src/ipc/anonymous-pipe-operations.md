---
description: 匿名管道作業，包括管道建立、寫入管道、管道控制碼。
ms.assetid: df81471c-1072-4456-a877-304e76ade4bd
title: 匿名管道作業
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 963d7127c51859b05e570d00291470a49be5ba66
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106975040"
---
# <a name="anonymous-pipe-operations"></a><span data-ttu-id="1290f-103">匿名管道作業</span><span class="sxs-lookup"><span data-stu-id="1290f-103">Anonymous Pipe Operations</span></span>

<span data-ttu-id="1290f-104">[**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe)函式會建立匿名管道，並傳回兩個控制碼：管道的讀取控制碼和管道的寫入控制碼。</span><span class="sxs-lookup"><span data-stu-id="1290f-104">The [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) function creates an anonymous pipe and returns two handles: a read handle to the pipe and a write handle to the pipe.</span></span> <span data-ttu-id="1290f-105">讀取控制碼具有管道的唯讀存取權，且寫入控制碼具有管道的僅限寫入存取權。</span><span class="sxs-lookup"><span data-stu-id="1290f-105">The read handle has read-only access to the pipe, and the write handle has write-only access to the pipe.</span></span> <span data-ttu-id="1290f-106">若要使用管道進行通訊，管道伺服器必須將管道控制碼傳遞至另一個進程。</span><span class="sxs-lookup"><span data-stu-id="1290f-106">To communicate using the pipe, the pipe server must pass a pipe handle to another process.</span></span> <span data-ttu-id="1290f-107">這通常是透過繼承來完成;也就是說，進程允許子進程繼承控制碼。</span><span class="sxs-lookup"><span data-stu-id="1290f-107">Usually, this is done through inheritance; that is, the process allows the handle to be inherited by a child process.</span></span> <span data-ttu-id="1290f-108">此程式也可以使用 [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) 函式來複製管道控制碼，並使用某種形式的處理序間通訊（例如 DDE 或共用記憶體）將它傳送至不相關的進程。</span><span class="sxs-lookup"><span data-stu-id="1290f-108">The process can also duplicate a pipe handle using the [**DuplicateHandle**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) function and send it to an unrelated process using some form of interprocess communication, such as DDE or shared memory.</span></span>

<span data-ttu-id="1290f-109">管道伺服器可以將讀取控制碼或寫入控制碼傳送到管道用戶端，視用戶端是否應該使用匿名管道來傳送資訊或接收資訊而定。</span><span class="sxs-lookup"><span data-stu-id="1290f-109">A pipe server can send either the read handle or the write handle to the pipe client, depending on whether the client should use the anonymous pipe to send information or receive information.</span></span> <span data-ttu-id="1290f-110">若要從管道讀取，請在 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) 函式的呼叫中使用管道的讀取控制碼。</span><span class="sxs-lookup"><span data-stu-id="1290f-110">To read from the pipe, use the pipe's read handle in a call to the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) function.</span></span> <span data-ttu-id="1290f-111">當另一個進程寫入管道時， **ReadFile** 呼叫會傳回。</span><span class="sxs-lookup"><span data-stu-id="1290f-111">The **ReadFile** call returns when another process has written to the pipe.</span></span> <span data-ttu-id="1290f-112">如果已關閉管道的所有寫入控制碼，或在完成讀取作業之前發生錯誤，則 **ReadFile** 呼叫也會傳回。</span><span class="sxs-lookup"><span data-stu-id="1290f-112">The **ReadFile** call can also return if all write handles to the pipe have been closed or if an error occurs before the read operation has been completed.</span></span>

<span data-ttu-id="1290f-113">若要寫入管道，請在 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) 函式的呼叫中使用管道的寫入控制碼。</span><span class="sxs-lookup"><span data-stu-id="1290f-113">To write to the pipe, use the pipe's write handle in a call to the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) function.</span></span> <span data-ttu-id="1290f-114">**WriteFile** 呼叫必須等到將指定的位元組數目寫入管道或發生錯誤之後，才會傳回。</span><span class="sxs-lookup"><span data-stu-id="1290f-114">The **WriteFile** call does not return until it has written the specified number of bytes to the pipe or an error occurs.</span></span> <span data-ttu-id="1290f-115">如果管道緩衝區已滿，且要寫入的位元組數較多，則在另一個進程從管道讀取時， **WriteFile** 不會傳回，因此可提供更多的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="1290f-115">If the pipe buffer is full and there are more bytes to be written, **WriteFile** does not return until another process reads from the pipe, making more buffer space available.</span></span> <span data-ttu-id="1290f-116">當管道伺服器呼叫 [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe)時，會指定該管道的緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="1290f-116">The pipe server specifies the buffer size for the pipe when it calls [**CreatePipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe).</span></span>

<span data-ttu-id="1290f-117">匿名管道不支援非同步 (重迭) 讀取和寫入作業。</span><span class="sxs-lookup"><span data-stu-id="1290f-117">Asynchronous (overlapped) read and write operations are not supported by anonymous pipes.</span></span> <span data-ttu-id="1290f-118">這表示您不能使用 [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) 和 [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) 函數搭配匿名管道。</span><span class="sxs-lookup"><span data-stu-id="1290f-118">This means that you cannot use the [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions with anonymous pipes.</span></span> <span data-ttu-id="1290f-119">此外，當搭配匿名管道使用這些函式時，會忽略 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile)和 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile)的 *lpOverlapped* 參數。</span><span class="sxs-lookup"><span data-stu-id="1290f-119">In addition, the *lpOverlapped* parameter of [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) is ignored when these functions are used with anonymous pipes.</span></span>

<span data-ttu-id="1290f-120">匿名管道會一直存在，直到所有管道控制碼（讀取和寫入）都已關閉為止。</span><span class="sxs-lookup"><span data-stu-id="1290f-120">An anonymous pipe exists until all pipe handles, both read and write, have been closed.</span></span> <span data-ttu-id="1290f-121">進程可以使用 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 函式來關閉其管道控制碼。</span><span class="sxs-lookup"><span data-stu-id="1290f-121">A process can close its pipe handles by using the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span> <span data-ttu-id="1290f-122">進程終止時，所有管道控制碼也會關閉。</span><span class="sxs-lookup"><span data-stu-id="1290f-122">All pipe handles are also closed when the process terminates.</span></span>

<span data-ttu-id="1290f-123">匿名管道會使用具有唯一名稱的具名管道來執行。</span><span class="sxs-lookup"><span data-stu-id="1290f-123">Anonymous pipes are implemented using a named pipe with a unique name.</span></span> <span data-ttu-id="1290f-124">因此，您通常可以將控制碼傳遞至需要具名管道控制碼的函式。</span><span class="sxs-lookup"><span data-stu-id="1290f-124">Therefore, you can often pass a handle to an anonymous pipe to a function that requires a handle to a named pipe.</span></span>

 

 
