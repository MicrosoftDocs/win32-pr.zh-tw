---
description: 管道作業（包括管道用戶端和伺服器）可以呼叫數個函式的其中一個（除了 CallNamedPipe），以讀取和寫入具名管道。
ms.assetid: ae06455e-33bc-433d-be8f-aeb8eeb99b1d
title: 具名管道作業
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 703189a129fc44b956ab65c2f70bbf88bfd22700
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104112024"
---
# <a name="named-pipe-operations"></a><span data-ttu-id="018f8-103">具名管道作業</span><span class="sxs-lookup"><span data-stu-id="018f8-103">Named Pipe Operations</span></span>

<span data-ttu-id="018f8-104">當管道伺服器第一次呼叫 [**CreateNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-createnamedpipea) 函式時，它會使用 *nMaxInstances* 參數來指定可同時存在之管道的實例數目上限。</span><span class="sxs-lookup"><span data-stu-id="018f8-104">The first time the pipe server calls the [**CreateNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-createnamedpipea) function, it uses the *nMaxInstances* parameter to specify the maximum number of instances of the pipe that can exist simultaneously.</span></span> <span data-ttu-id="018f8-105">只要不超過實例的數目上限，伺服器就可以重複呼叫 **CreateNamedPipe** 來建立管道的其他實例。</span><span class="sxs-lookup"><span data-stu-id="018f8-105">The server can call **CreateNamedPipe** repeatedly to create additional instances of the pipe, as long as it does not exceed the maximum number of instances.</span></span> <span data-ttu-id="018f8-106">如果函式成功，每個呼叫都會將控制碼傳回給具名管道實例的伺服器端。</span><span class="sxs-lookup"><span data-stu-id="018f8-106">If the function succeeds, each call returns a handle to the server end of a named pipe instance.</span></span>

<span data-ttu-id="018f8-107">當管道伺服器建立管道實例時，管道用戶端就可以藉由呼叫 [**CreateFile**](/windows/desktop/api/fileapi/nf-fileapi-createfilea) 或 [**CallNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) 函式來與其連接。</span><span class="sxs-lookup"><span data-stu-id="018f8-107">As soon as the pipe server creates a pipe instance, a pipe client can connect to it by calling the [**CreateFile**](/windows/desktop/api/fileapi/nf-fileapi-createfilea) or [**CallNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) function.</span></span> <span data-ttu-id="018f8-108">如果有可用的管道實例， **CreateFile** 會將控制碼傳回給管道實例的用戶端。</span><span class="sxs-lookup"><span data-stu-id="018f8-108">If a pipe instance is available, **CreateFile** returns a handle to the client end of the pipe instance.</span></span> <span data-ttu-id="018f8-109">如果沒有可用的管道實例，管道用戶端可以使用 [**WaitNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-waitnamedpipea) 函式來等待管道變成可用。</span><span class="sxs-lookup"><span data-stu-id="018f8-109">If no instances of the pipe are available, a pipe client can use the [**WaitNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-waitnamedpipea) function to wait until a pipe becomes available.</span></span>

<span data-ttu-id="018f8-110">管道伺服器可以藉由呼叫 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) 函式來判斷管道用戶端連接到管道實例的時間。</span><span class="sxs-lookup"><span data-stu-id="018f8-110">A pipe server can determine when a pipe client is connected to a pipe instance by calling the [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) function.</span></span> <span data-ttu-id="018f8-111">如果管道控制碼處於封鎖等候模式，則在用戶端連接之前， **ConnectNamedPipe** 不會傳回。</span><span class="sxs-lookup"><span data-stu-id="018f8-111">If the pipe handle is in blocking-wait mode, **ConnectNamedPipe** does not return until a client is connected.</span></span>

<span data-ttu-id="018f8-112">管道用戶端和伺服器可以呼叫數個函式的其中一個（除了 [**CallNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) ），以讀取和寫入具名管道。</span><span class="sxs-lookup"><span data-stu-id="018f8-112">Pipe clients and servers can call one of several functions — in addition to [**CallNamedPipe**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) — to read from and write to a named pipe.</span></span> <span data-ttu-id="018f8-113">這些函式的行為取決於管線的型別，以及指定管道控制碼的作用中模式，如下所示：</span><span class="sxs-lookup"><span data-stu-id="018f8-113">The behavior of these functions depends on the type of pipe and the modes in effect for the specified pipe handle, as follows:</span></span>

-   <span data-ttu-id="018f8-114">[**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile)和 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile)函數可以搭配 byte 類型或訊息類型的管道使用。</span><span class="sxs-lookup"><span data-stu-id="018f8-114">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) functions can be used with either byte-type or message-type pipes.</span></span>
-   <span data-ttu-id="018f8-115">如果已針對重迭的作業開啟管道控制碼， [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) 和 [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) 函數可以搭配 byte 類型或訊息類型管道使用。</span><span class="sxs-lookup"><span data-stu-id="018f8-115">The [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions can be used with either byte-type or message-type pipes if the pipe handle was opened for overlapped operations.</span></span>
-   <span data-ttu-id="018f8-116">[**PeekNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe)函式可以用來讀取，而不需移除位元組類型管道或訊息類型管道的內容。</span><span class="sxs-lookup"><span data-stu-id="018f8-116">The [**PeekNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe) function can be used to read without removing the contents of either a byte-type pipe or a message-type pipe.</span></span> <span data-ttu-id="018f8-117">**PeekNamedPipe** 也可以傳回管道實例的其他相關資訊。</span><span class="sxs-lookup"><span data-stu-id="018f8-117">**PeekNamedPipe** can also return additional information about the pipe instance.</span></span>
-   <span data-ttu-id="018f8-118">如果呼叫進程的管道控制碼設定為訊息讀取模式，則 [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) 函數可以搭配 message 類型的雙工管道使用。</span><span class="sxs-lookup"><span data-stu-id="018f8-118">The [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) function can be used with message-type duplex pipes if the pipe handle to the calling process is set to message-read mode.</span></span> <span data-ttu-id="018f8-119">此函式會寫入要求訊息，並在單一作業中讀取回復訊息，從而增強網路效能。</span><span class="sxs-lookup"><span data-stu-id="018f8-119">The function writes a request message and reads a reply message in a single operation, enhancing network performance.</span></span>

<span data-ttu-id="018f8-120">管道伺服器在管道用戶端啟動之前，不應執行封鎖讀取操作。</span><span class="sxs-lookup"><span data-stu-id="018f8-120">The pipe server should not perform a blocking read operation until the pipe client has started.</span></span> <span data-ttu-id="018f8-121">否則，可能會發生競爭情況。</span><span class="sxs-lookup"><span data-stu-id="018f8-121">Otherwise, a race condition can occur.</span></span> <span data-ttu-id="018f8-122">這通常發生在初始化程式碼（例如 C 執行時間程式庫的程式碼）需要鎖定和檢查繼承的控制碼時。</span><span class="sxs-lookup"><span data-stu-id="018f8-122">This typically occurs when initialization code, such as that of the C run-time library, needs to lock and examine inherited handles.</span></span>

<span data-ttu-id="018f8-123">當用戶端和伺服器使用管道實例完成時，伺服器應該先呼叫 [**FlushFileBuffers**](/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers) 函式，以確保用戶端會讀取寫入管道的所有位元組或訊息。</span><span class="sxs-lookup"><span data-stu-id="018f8-123">When a client and server finish using a pipe instance, the server should first call the [**FlushFileBuffers**](/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers) function, to ensure that all bytes or messages written to the pipe are read by the client.</span></span> <span data-ttu-id="018f8-124">在用戶端從管道讀取所有資料之前， **FlushFileBuffers** 不會傳回。</span><span class="sxs-lookup"><span data-stu-id="018f8-124">**FlushFileBuffers** does not return until the client has read all data from the pipe.</span></span> <span data-ttu-id="018f8-125">然後伺服器會呼叫 [**DisconnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-disconnectnamedpipe) 函式來關閉管道用戶端的連接。</span><span class="sxs-lookup"><span data-stu-id="018f8-125">The server then calls the [**DisconnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-disconnectnamedpipe) function to close the connection to the pipe client.</span></span> <span data-ttu-id="018f8-126">此函式會讓用戶端的控制碼無效（如果尚未關閉）。</span><span class="sxs-lookup"><span data-stu-id="018f8-126">This function makes the client's handle invalid, if it has not already been closed.</span></span> <span data-ttu-id="018f8-127">管線中任何未讀取的資料都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="018f8-127">Any unread data in the pipe is discarded.</span></span> <span data-ttu-id="018f8-128">用戶端中斷連線之後，伺服器會呼叫 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 函式來關閉其對管道實例的控制碼。</span><span class="sxs-lookup"><span data-stu-id="018f8-128">After the client is disconnected, the server calls the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function to close its handle to the pipe instance.</span></span> <span data-ttu-id="018f8-129">或者，伺服器可以使用 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) ，讓新的用戶端連接到此管道的實例。</span><span class="sxs-lookup"><span data-stu-id="018f8-129">Alternatively, the server can use [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) to enable a new client to connect to this instance of the pipe.</span></span>

<span data-ttu-id="018f8-130">進程可以藉由呼叫 [**GetNamedPipeInfo**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-getnamedpipeinfo) 函式來取得具名管道的相關資訊，此函式會傳回管道的類型、輸入和輸出緩衝區的大小，以及可建立的管道實例數目上限。</span><span class="sxs-lookup"><span data-stu-id="018f8-130">A process can retrieve information about a named pipe by calling the [**GetNamedPipeInfo**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-getnamedpipeinfo) function, which returns the type of the pipe, the size of the input and output buffers, and the maximum number of pipe instances that can be created.</span></span> <span data-ttu-id="018f8-131">[**GetNamedPipeHandleState**](/windows/desktop/api/Winbase/nf-winbase-getnamedpipehandlestatea)函式會報告管道控制碼的讀取和等候模式、目前的管道實例數目，以及透過網路通訊之管道的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="018f8-131">The [**GetNamedPipeHandleState**](/windows/desktop/api/Winbase/nf-winbase-getnamedpipehandlestatea) function reports on the read and wait modes of a pipe handle, the current number of pipe instances, and additional information for pipes that communicate over a network.</span></span> <span data-ttu-id="018f8-132">[**SetNamedPipeHandleState**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate)函式會設定管道控制碼的讀取模式和等候模式。</span><span class="sxs-lookup"><span data-stu-id="018f8-132">The [**SetNamedPipeHandleState**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate) function sets the read mode and wait modes of a pipe handle.</span></span> <span data-ttu-id="018f8-133">針對與遠端伺服器通訊的管道用戶端，此函式也會控制要收集的最大位元組數目，或在傳送訊息之前等候的最長時間， (假設用戶端的控制碼未開啟且已啟用寫入模式的) 。</span><span class="sxs-lookup"><span data-stu-id="018f8-133">For pipe clients communicating with a remote server, the function also controls the maximum number of bytes to collect or the maximum time to wait before transmitting a message (assuming the client's handle was not opened with write-through mode enabled).</span></span>

 

 
