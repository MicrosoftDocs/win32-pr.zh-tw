---
title: 尋找端點
description: 伺服器程式會接聽用戶端要求的端點。 端點字串的語法取決於您所使用的通訊協定順序。 例如，TCP/IP 的端點是埠號碼，具名管道的端點語法是有效的管道名稱。
ms.assetid: 330bbe9f-b7e9-4a5b-86d8-824edec960d2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bb0a97df3408a4d3c24dff9de28553f9e4b2210d
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104315367"
---
# <a name="finding-endpoints"></a><span data-ttu-id="e4abe-105">尋找端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-105">Finding Endpoints</span></span>

<span data-ttu-id="e4abe-106">伺服器程式會接聽用戶端要求的端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-106">Server programs listen to endpoints for client requests.</span></span> <span data-ttu-id="e4abe-107">端點字串的語法取決於您所使用的通訊協定順序。</span><span class="sxs-lookup"><span data-stu-id="e4abe-107">The syntax of the endpoint string depends on the protocol sequence you use.</span></span> <span data-ttu-id="e4abe-108">例如，TCP/IP 的端點是埠號碼，具名管道的端點語法是有效的管道名稱。</span><span class="sxs-lookup"><span data-stu-id="e4abe-108">For example, the endpoint for TCP/IP is a port number, and the endpoint syntax for named pipes is a valid pipe name.</span></span>

<span data-ttu-id="e4abe-109">端點有兩種類型：知名和動態。</span><span class="sxs-lookup"><span data-stu-id="e4abe-109">There are two types of endpoints: well-known and dynamic.</span></span> <span data-ttu-id="e4abe-110">您選擇的程式所使用的端點類型，會決定分散式應用程式或執行時間程式庫是否指定端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-110">Your choice of which type of endpoint your program uses determines whether the distributed application or the run-time library specifies the endpoint.</span></span>

<span data-ttu-id="e4abe-111">本節將討論端點，並提供如何尋找它們的資訊。</span><span class="sxs-lookup"><span data-stu-id="e4abe-111">This section discusses endpoints and presents information on how to find them.</span></span> <span data-ttu-id="e4abe-112">它會組織成下列主題：</span><span class="sxs-lookup"><span data-stu-id="e4abe-112">It is organized into the following topics:</span></span>

-   [<span data-ttu-id="e4abe-113">使用 Well-Known 端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-113">Using Well-Known Endpoints</span></span>](#using-well-known-endpoints)
-   [<span data-ttu-id="e4abe-114">使用動態端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-114">Using Dynamic Endpoints</span></span>](#using-dynamic-endpoints)
-   [<span data-ttu-id="e4abe-115">將 Well-Known 端點匯出至端點對應資料庫</span><span class="sxs-lookup"><span data-stu-id="e4abe-115">Exporting Well-Known Endpoints Into the Endpoint Map Database</span></span>](#exporting-well-known-endpoints-into-the-endpoint-map-database)

> [!Note]  
> <span data-ttu-id="e4abe-116">*靜態端點* 和 *已知端點* 的條款是相等的，並且可交換使用。</span><span class="sxs-lookup"><span data-stu-id="e4abe-116">The terms *static endpoints* and *well-known endpoints* are equivalent, and used interchangeably.</span></span>

 

<span data-ttu-id="e4abe-117">您的用戶端應用程式可能會使用端點對應來判斷伺服器程式目前是否正在執行。</span><span class="sxs-lookup"><span data-stu-id="e4abe-117">It is possible for your client application to use the endpoint map to determine whether or not a server program is currently running.</span></span> <span data-ttu-id="e4abe-118">您的用戶端可以呼叫 [**RpcMgmtInqIfIds**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids)、 [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin)和 [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) ，以查看伺服器是否已在端點對應中註冊所需的特定介面。</span><span class="sxs-lookup"><span data-stu-id="e4abe-118">Your client can call [**RpcMgmtInqIfIds**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) to see if the server has registered the particular interface it requires in the endpoint map.</span></span>

## <a name="using-well-known-endpoints"></a><span data-ttu-id="e4abe-119">使用知名端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-119">Using Well-known Endpoints</span></span>

<span data-ttu-id="e4abe-120">已知的端點是伺服器程式每次執行時所使用的預先指派端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-120">Well-known endpoints are pre-assigned endpoints that the server program uses every time it runs.</span></span> <span data-ttu-id="e4abe-121">由於伺服器一律會接聽該特定端點，因此用戶端一律會嘗試連接到該端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-121">Because the server always listens to that particular endpoint, the client always attempts to connect to it.</span></span> <span data-ttu-id="e4abe-122">知名的端點通常是由負責傳輸通訊協定的授權單位所指派。</span><span class="sxs-lookup"><span data-stu-id="e4abe-122">Well-known endpoints are usually assigned by the authority responsible for the transport protocol.</span></span> <span data-ttu-id="e4abe-123">因為伺服器主機電腦具有有限數量的可用端點，所以不建議應用程式開發人員使用已知的端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-123">Because server host computers have a finite number of available endpoints, application developers are strongly discouraged from using well-known endpoints.</span></span> <span data-ttu-id="e4abe-124">動態端點的另一個優點是它們可簡化系統的長期管理和維護。</span><span class="sxs-lookup"><span data-stu-id="e4abe-124">Another advantage of dynamic endpoints is that they simplify long-term management and maintenance of the system.</span></span>

<span data-ttu-id="e4abe-125">分散式應用程式可以在字串中指定知名的端點，並將該字串作為參數傳遞至函式 [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep)。</span><span class="sxs-lookup"><span data-stu-id="e4abe-125">A distributed application can specify a well-known endpoint in a string and pass that string as a parameter to the function [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep).</span></span> <span data-ttu-id="e4abe-126">或者，端點字串也可以出現在 IDL 檔案介面標頭中，作為 \[ [端點](/windows/desktop/Midl/endpoint) \] 介面屬性的一部分。</span><span class="sxs-lookup"><span data-stu-id="e4abe-126">Alternatively, the endpoint string can appear in the IDL file interface header as part of the \[ [endpoint](/windows/desktop/Midl/endpoint)\] interface attribute.</span></span>

<span data-ttu-id="e4abe-127">您可以使用兩種方法來執行已知的端點：</span><span class="sxs-lookup"><span data-stu-id="e4abe-127">You can use two approaches to implement the well-known endpoint:</span></span>

-   <span data-ttu-id="e4abe-128">在字串系結中指定所有資訊</span><span class="sxs-lookup"><span data-stu-id="e4abe-128">Specify all information in a string binding</span></span>
-   <span data-ttu-id="e4abe-129">在名稱服務資料庫中儲存已知的端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-129">Store the well-known endpoint in the name service database</span></span>

<span data-ttu-id="e4abe-130">開發應用程式時，您可以撰寫建立系結至分散式應用程式所需的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="e4abe-130">You can write all of the information needed to establish a binding into a distributed application when you develop it.</span></span> <span data-ttu-id="e4abe-131">用戶端可以直接在字串中指定已知的端點，呼叫 [**RpcStringBindingCompose**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) 來建立包含所有系結資訊的字串，並將此字串提供給函數 [**RpcBindingFromStringBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) ，以取得控制碼。</span><span class="sxs-lookup"><span data-stu-id="e4abe-131">The client can specify the well-known endpoint directly in a string, call [**RpcStringBindingCompose**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) to create a string that contains all the binding information, and supply this string to the function [**RpcBindingFromStringBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) to obtain a handle.</span></span> <span data-ttu-id="e4abe-132">用戶端和伺服器可以硬式編碼，以使用已知的端點，或寫入，讓端點資訊來自命令列、資料檔、設定檔案或 IDL 檔案。</span><span class="sxs-lookup"><span data-stu-id="e4abe-132">The client and server can be hard-coded to use a well-known endpoint, or written so that the endpoint information comes from the command line, a data file, a configuration file, or the IDL file.</span></span>

<span data-ttu-id="e4abe-133">您的用戶端應用程式也可以查詢名稱服務資料庫，以取得已知的端點資訊。</span><span class="sxs-lookup"><span data-stu-id="e4abe-133">Your client application can also query a name service database for well-known endpoint information.</span></span>

## <a name="using-dynamic-endpoints"></a><span data-ttu-id="e4abe-134">使用動態端點</span><span class="sxs-lookup"><span data-stu-id="e4abe-134">Using Dynamic Endpoints</span></span>

<span data-ttu-id="e4abe-135">特定伺服器的端點數目和特定的通訊協定順序通常會受到限制。</span><span class="sxs-lookup"><span data-stu-id="e4abe-135">The number of endpoints for a particular server and a particular protocol sequence are usually limited.</span></span> <span data-ttu-id="e4abe-136">例如，當您使用 [ncacn \_ ip \_ tcp](/windows/desktop/Midl/ncacn-ip-tcp) 通訊協定序列（指出 RPC 網路通訊使用 tcp/ip 進行通訊）時，只有有限的埠可用 (大部分的系統都只會開啟範圍1025到5000的) 。</span><span class="sxs-lookup"><span data-stu-id="e4abe-136">For example, when you use the [ncacn\_ip\_tcp](/windows/desktop/Midl/ncacn-ip-tcp) protocol sequence, indicating that RPC network communication occurs using TCP/IP, only a limited number of ports are available (most systems have only the range 1025 through 5000 opened).</span></span> <span data-ttu-id="e4abe-137">RPC 執行時間程式庫可讓您視需要動態指派端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-137">The RPC run-time libraries allow you to assign endpoints dynamically, as needed.</span></span> <span data-ttu-id="e4abe-138">由於可能的介面 Uuid 數目幾乎沒有限制，因此使用介面 UUID 來指示呼叫會提供更多的空間來擴充和提供更大的彈性。</span><span class="sxs-lookup"><span data-stu-id="e4abe-138">Since the number of possible interface UUIDs is practically unlimited, using the interface UUID to direct the call offers more room for expansion and more flexibility.</span></span>

<span data-ttu-id="e4abe-139">根據預設，當 RPC 執行時間程式庫函數查詢名稱服務資料庫時，會搜尋端點資訊。</span><span class="sxs-lookup"><span data-stu-id="e4abe-139">By default, the RPC run-time library functions search for endpoint information when they query a name service database.</span></span> <span data-ttu-id="e4abe-140">如果端點是動態的，則名稱服務資料庫將不會包含端點資訊。</span><span class="sxs-lookup"><span data-stu-id="e4abe-140">If the endpoint is dynamic, the name service database will not contain endpoint information.</span></span> <span data-ttu-id="e4abe-141">不過，查詢會將伺服器的名稱提供給您的用戶端程式。</span><span class="sxs-lookup"><span data-stu-id="e4abe-141">However, the query will give your client program the name of a server.</span></span> <span data-ttu-id="e4abe-142">然後，它可以搜尋伺服器的端點對應。</span><span class="sxs-lookup"><span data-stu-id="e4abe-142">It can then search the server's endpoint map.</span></span>

<span data-ttu-id="e4abe-143">如果用戶端需要使用動態端點進行遠端程序呼叫，則慣用的方法是在部分綁定的系結控制碼上進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="e4abe-143">If the client needs to make a remote procedure call using a dynamic endpoint, the preferred method is to make the call on a partially bound binding handle.</span></span> <span data-ttu-id="e4abe-144">RPC 執行時間會以透明的方式解析端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-144">The RPC run time resolves the endpoint transparently.</span></span> <span data-ttu-id="e4abe-145">這個方法優於使用 [**RpcEpResolveBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) 函式，因為它允許在 RPC 執行時間中使用 advanced 快取機制。</span><span class="sxs-lookup"><span data-stu-id="e4abe-145">This method is superior to using the [**RpcEpResolveBinding**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) function, as it allows advanced caching mechanisms in the RPC run time.</span></span>

<span data-ttu-id="e4abe-146">如果需要更明確地控制端點選取，用戶端可以呼叫 [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin)、 [**RpcMgmtEpEltInqNext**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext)和 [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) 函式，一次搜尋一個專案的端點對應。</span><span class="sxs-lookup"><span data-stu-id="e4abe-146">If more specific control over endpoint selection is required, clients can search the endpoint map one entry at a time by calling the [**RpcMgmtEpEltInqBegin**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**RpcMgmtEpEltInqNext**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext), and [**RpcMgmtEpEltInqDone**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) functions.</span></span>

## <a name="exporting-well-known-endpoints-into-the-endpoint-map-database"></a><span data-ttu-id="e4abe-147">將知名端點匯出至端點對應資料庫</span><span class="sxs-lookup"><span data-stu-id="e4abe-147">Exporting Well-known Endpoints into the Endpoint Map Database</span></span>

<span data-ttu-id="e4abe-148">您可以混用兩種方法來尋找端點，尤其是當分散式系統從已知的端點模型轉換為動態端點模型時。</span><span class="sxs-lookup"><span data-stu-id="e4abe-148">It is possible to mix the two approaches to finding endpoints, especially when a distributed system is transitioning from a well-known endpoint model to a dynamic endpoint model.</span></span> <span data-ttu-id="e4abe-149">在這類轉換中，伺服器的中繼版本將使用已知的端點，但它也會向端點對應資料庫註冊已知的端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-149">In such transitions, an intermediate version of the server will use a well-known endpoint, but it will also register the well-known endpoint with the endpoint map database.</span></span> <span data-ttu-id="e4abe-150">這種方法可讓使用已知端點的用戶端和使用動態端點的用戶端進行連接。</span><span class="sxs-lookup"><span data-stu-id="e4abe-150">This approach allows clients that use well known endpoint and clients that use a dynamic endpoint to connect.</span></span> <span data-ttu-id="e4abe-151">所有伺服器都升級之後，就可以部署只能使用動態端點的新用戶端版本。</span><span class="sxs-lookup"><span data-stu-id="e4abe-151">Once all servers are upgraded, a new client version can be deployed that uses dynamic endpoints only.</span></span> <span data-ttu-id="e4abe-152">所有用戶端都升級之後，最終的伺服器版本就可以停止使用已知的端點，而且只會開始使用動態端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-152">Once all clients are upgraded, a final server version can stop using well-known endpoints and begin using dynamic endpoints only.</span></span>

<span data-ttu-id="e4abe-153">這種方法可讓已開始使用已知端點的應用程式轉換路徑，但不需要同時更新所有伺服器和用戶端，即可遷移至動態端點。</span><span class="sxs-lookup"><span data-stu-id="e4abe-153">This approach allows a transition path for applications that have started with a well-known endpoint but want to migrate to a dynamic endpoint without requiring a simultaneous update of all servers and clients.</span></span>

 

 