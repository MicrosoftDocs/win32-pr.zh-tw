---
title: 防止用戶端停止回應
description: 有兩種方式可讓您的用戶端停止網路連線，可能會導致伺服器要求遺失，或者伺服器本身可能會損毀。 使用預設選項時，RPC 永遠不會結束呼叫，而您的用戶端執行緒會永遠等候回應。
ms.assetid: 2c201e29-9d9c-48e6-b0b5-68e4b25c3fb7
keywords:
- 遠端程序呼叫 RPC、最佳作法，防止用戶端停止回應
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 18d4b5fc92ca18b575d081cd7b5abf90929e7df5
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103682479"
---
# <a name="preventing-client-side-hangs"></a><span data-ttu-id="44cac-105">防止用戶端停止回應</span><span class="sxs-lookup"><span data-stu-id="44cac-105">Preventing Client-side Hangs</span></span>

<span data-ttu-id="44cac-106">有兩種方式可讓您的用戶端停止回應：網路連線可能會導致伺服器要求遺失，或者伺服器本身可能會損毀。</span><span class="sxs-lookup"><span data-stu-id="44cac-106">There are two ways your client can hang: network connectivity can cause server requests to become lost, or the server itself can crash.</span></span> <span data-ttu-id="44cac-107">使用預設選項時，RPC 永遠不會結束呼叫，而您的用戶端執行緒會永遠等候回應。</span><span class="sxs-lookup"><span data-stu-id="44cac-107">With default options, RPC will never time out a call, and your client thread will wait forever for a response.</span></span>

<span data-ttu-id="44cac-108">有兩種方法可以防止這種情況：保持連接和超時。</span><span class="sxs-lookup"><span data-stu-id="44cac-108">There are two methods to prevent this: keep alives and time outs.</span></span>

## <a name="tcp-keep-alives"></a><span data-ttu-id="44cac-109">TCP 保持連接</span><span class="sxs-lookup"><span data-stu-id="44cac-109">TCP Keep Alives</span></span>

<span data-ttu-id="44cac-110">用戶端可以設定為定期偵測伺服器，以確保伺服器正在運作且正在執行。</span><span class="sxs-lookup"><span data-stu-id="44cac-110">The client can be set up to periodically ping the server to ensure the server is alive and running.</span></span> <span data-ttu-id="44cac-111">Ping 是 [**ncacn \_ ip \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp) 和 [**ncacn \_ HTTP**](/windows/desktop/Midl/ncacn-http) 通訊協定序列的 tcp 持續，因此它們在 CPU 使用率和網路頻寬中的效率很高。</span><span class="sxs-lookup"><span data-stu-id="44cac-111">The pings are TCP keep-alives for the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences, and as such, they are efficient in CPU utilization and network bandwidth.</span></span> <span data-ttu-id="44cac-112">若要讓指定的遠端程序呼叫保持連接，請在呼叫起始之前，先使用 [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) 函數。</span><span class="sxs-lookup"><span data-stu-id="44cac-112">To enable keep alives on a given remote procedure call, use the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function before the call is initiated.</span></span> <span data-ttu-id="44cac-113">此函式會接受系結控制碼，並將時間當作引數。</span><span class="sxs-lookup"><span data-stu-id="44cac-113">This function takes a binding handle and a time out as arguments.</span></span> <span data-ttu-id="44cac-114">在 **RpcMgmtSetComTimeout** 之後，在這個系結控制碼上的每個遠端程序呼叫都會使用提供的超時時間。</span><span class="sxs-lookup"><span data-stu-id="44cac-114">Every remote procedure call on this binding handle after **RpcMgmtSetComTimeout** uses the supplied time out.</span></span>

<span data-ttu-id="44cac-115">[**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout)函式的 Timeout 參數會指定 RPC 執行時間在開啟保持連接之前的等候時間長度。</span><span class="sxs-lookup"><span data-stu-id="44cac-115">The Timeout parameter for the [**RpcMgmtSetComTimeout**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout) function specifies how long the RPC run time waits before it turns on keep alives.</span></span> <span data-ttu-id="44cac-116">超時值是介於0和10之間的值，其中0是最短的時間，而10則是無限期的 (沒有時間) 。</span><span class="sxs-lookup"><span data-stu-id="44cac-116">The time out is a value between 0 and 10, where 0 is the minimal time out, and 10 is infinite time out (no time out).</span></span> <span data-ttu-id="44cac-117">時間本身不是以秒為單位;從提供給 **RpcMgmtSetComTimeout** 函式的超時時間值到秒的轉譯是由 RPC 執行時間所完成，而且是執行特定的。</span><span class="sxs-lookup"><span data-stu-id="44cac-117">The time out itself is not in seconds; the translation from the time-out value supplied to the **RpcMgmtSetComTimeout** function to seconds is done by the RPC run time, and is implementation specific.</span></span>

<span data-ttu-id="44cac-118">下表提供 Windows 2000 和 Windows XP 的轉譯為秒數。</span><span class="sxs-lookup"><span data-stu-id="44cac-118">The following table provides the translation to seconds for Windows 2000 and Windows XP.</span></span> <span data-ttu-id="44cac-119">未來的 Windows 版本可能會變更 Timeout 參數和超時值（以秒為單位）之間的對應：</span><span class="sxs-lookup"><span data-stu-id="44cac-119">Future versions of Windows may change the mapping between the Timeout parameter and the time-out value in seconds:</span></span>

| <span data-ttu-id="44cac-120">Timeout 參數</span><span class="sxs-lookup"><span data-stu-id="44cac-120">Timeout parameter</span></span>                       | <span data-ttu-id="44cac-121">實際時間（秒）</span><span class="sxs-lookup"><span data-stu-id="44cac-121">Actual time out in seconds</span></span> |
|-----------------------------------------|----------------------------|
| <span data-ttu-id="44cac-122">0 (RPC \_ C 系結 \_ \_ 最小 \_ 超時) </span><span class="sxs-lookup"><span data-stu-id="44cac-122">0 (RPC\_C\_BINDING\_MIN\_TIMEOUT)</span></span>       | <span data-ttu-id="44cac-123">120</span><span class="sxs-lookup"><span data-stu-id="44cac-123">120</span></span>                        |
| <span data-ttu-id="44cac-124">1</span><span class="sxs-lookup"><span data-stu-id="44cac-124">1</span></span>                                       | <span data-ttu-id="44cac-125">240</span><span class="sxs-lookup"><span data-stu-id="44cac-125">240</span></span>                        |
| <span data-ttu-id="44cac-126">2</span><span class="sxs-lookup"><span data-stu-id="44cac-126">2</span></span>                                       | <span data-ttu-id="44cac-127">360</span><span class="sxs-lookup"><span data-stu-id="44cac-127">360</span></span>                        |
| <span data-ttu-id="44cac-128">3</span><span class="sxs-lookup"><span data-stu-id="44cac-128">3</span></span>                                       | <span data-ttu-id="44cac-129">480</span><span class="sxs-lookup"><span data-stu-id="44cac-129">480</span></span>                        |
| <span data-ttu-id="44cac-130">4</span><span class="sxs-lookup"><span data-stu-id="44cac-130">4</span></span>                                       | <span data-ttu-id="44cac-131">600</span><span class="sxs-lookup"><span data-stu-id="44cac-131">600</span></span>                        |
| <span data-ttu-id="44cac-132">5 (RPC \_ C 系結 \_ \_ 預設 \_ 超時) </span><span class="sxs-lookup"><span data-stu-id="44cac-132">5 (RPC\_C\_BINDING\_DEFAULT\_TIMEOUT)</span></span>   | <span data-ttu-id="44cac-133">720</span><span class="sxs-lookup"><span data-stu-id="44cac-133">720</span></span>                        |
| <span data-ttu-id="44cac-134">6</span><span class="sxs-lookup"><span data-stu-id="44cac-134">6</span></span>                                       | <span data-ttu-id="44cac-135">840</span><span class="sxs-lookup"><span data-stu-id="44cac-135">840</span></span>                        |
| <span data-ttu-id="44cac-136">7</span><span class="sxs-lookup"><span data-stu-id="44cac-136">7</span></span>                                       | <span data-ttu-id="44cac-137">960</span><span class="sxs-lookup"><span data-stu-id="44cac-137">960</span></span>                        |
| <span data-ttu-id="44cac-138">8</span><span class="sxs-lookup"><span data-stu-id="44cac-138">8</span></span>                                       | <span data-ttu-id="44cac-139">1080</span><span class="sxs-lookup"><span data-stu-id="44cac-139">1080</span></span>                       |
| <span data-ttu-id="44cac-140">9 (RPC C 系結的 \_ \_ \_ 最大 \_ 超時) </span><span class="sxs-lookup"><span data-stu-id="44cac-140">9 (RPC\_C\_BINDING\_MAX\_TIMEOUT)</span></span>       | <span data-ttu-id="44cac-141">1200</span><span class="sxs-lookup"><span data-stu-id="44cac-141">1200</span></span>                       |
| <span data-ttu-id="44cac-142">10 (RPC \_ C 系結 \_ \_ 無限 \_ 超時) </span><span class="sxs-lookup"><span data-stu-id="44cac-142">10 (RPC\_C\_BINDING\_INFINITE\_TIMEOUT)</span></span> | <span data-ttu-id="44cac-143">無限的時間</span><span class="sxs-lookup"><span data-stu-id="44cac-143">Infinite time out</span></span>          |



 

<span data-ttu-id="44cac-144">一旦開啟 [保持連線]，用戶端就會每秒傳送一個保持運作封包。</span><span class="sxs-lookup"><span data-stu-id="44cac-144">Once the keep alives are turned on, the client sends one keep alive packet every second.</span></span> <span data-ttu-id="44cac-145">如果有三個或更多的伺服器沒有通知，用戶端會宣告連接沒有作用，且遠端程序呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="44cac-145">If there is no acknowledgment from the server for three or more keep alives, the client declares the connection dead and fails the remote procedure call.</span></span> <span data-ttu-id="44cac-146">如果伺服器在指定的時間內傳送回應，則不會開啟 [保持同步]。</span><span class="sxs-lookup"><span data-stu-id="44cac-146">If the server sends a response within the specified time out, keep alives will not be turned on.</span></span> <span data-ttu-id="44cac-147">如果伺服器回應保持連接，但是沒有回應遠端程序呼叫，用戶端就會繼續保持連接。</span><span class="sxs-lookup"><span data-stu-id="44cac-147">If the server responds to keep alives, but does not respond to the remote procedure call, the client continues sending keep alives.</span></span> <span data-ttu-id="44cac-148">一旦伺服器回應 RPC 呼叫，保持連接會關閉。</span><span class="sxs-lookup"><span data-stu-id="44cac-148">Once the server responds to the RPC call, the keep alives are turned off.</span></span> <span data-ttu-id="44cac-149">若為 Windows 2000，則只會針對同步 RPC 呼叫開啟 [保持同步]。</span><span class="sxs-lookup"><span data-stu-id="44cac-149">For Windows 2000, keep alives are turned on only for synchronous RPC calls.</span></span> <span data-ttu-id="44cac-150">若為 Windows XP，則也會開啟非同步 RPC 呼叫的 [保持同步]。</span><span class="sxs-lookup"><span data-stu-id="44cac-150">For Windows XP, keep alives are turned on for asynchronous RPC calls as well.</span></span>

<span data-ttu-id="44cac-151">設定保持在最低的值，以確保用戶端應用程式及時回應網路問題是很吸引人的。</span><span class="sxs-lookup"><span data-stu-id="44cac-151">It is tempting to set keep alives to the lowest value to ensure the client application responds to network problems in a timely fashion.</span></span> <span data-ttu-id="44cac-152">請謹慎考慮這類誘惑，以及套用到是否保證積極價值的審查。</span><span class="sxs-lookup"><span data-stu-id="44cac-152">Careful consideration should be given to such temptation, and scrutiny applied to whether an aggressive value is warranted.</span></span> <span data-ttu-id="44cac-153">暫時失去連線能力的伺服器可能會在連線恢復後，從多個用戶端持續中斷連線。</span><span class="sxs-lookup"><span data-stu-id="44cac-153">A server that temporarily loses connectivity may find itself flooded with keep alives from numerous clients once connectivity is restored.</span></span> <span data-ttu-id="44cac-154">此外，長時間計算工作可能需要兩分鐘以上的時間，而伺服器可能會發現，在執行有用的工作時，伺服器可能會有更多的 CPU 時間回應持續進行。</span><span class="sxs-lookup"><span data-stu-id="44cac-154">In addition, long computational tasks can take more than two minutes, and the server may find itself spending more CPU time answering keep alives than performing useful work.</span></span> <span data-ttu-id="44cac-155">因此，請儘量避免使用與仲裁。</span><span class="sxs-lookup"><span data-stu-id="44cac-155">Therefore, keep alives should be used with moderation.</span></span> <span data-ttu-id="44cac-156">如果用戶端無法容忍其執行緒長時間遭到系結，則應該考慮非同步 RPC。</span><span class="sxs-lookup"><span data-stu-id="44cac-156">If the client cannot tolerate its thread being tied up for long periods, asynchronous RPC should be considered.</span></span>

<span data-ttu-id="44cac-157">根據所使用的傳輸而定，其他通訊協定順序可能會執行不同的機制來偵測沒有回應的伺服器。</span><span class="sxs-lookup"><span data-stu-id="44cac-157">Other protocol sequences may implement different mechanisms for detecting unresponsive servers, depending on which transport is used.</span></span> <span data-ttu-id="44cac-158">[**Ncalrpc**](/windows/desktop/Midl/ncalrpc)傳輸不會使用 keep-alive。</span><span class="sxs-lookup"><span data-stu-id="44cac-158">The [**ncalrpc**](/windows/desktop/Midl/ncalrpc) transport does not use keep alives.</span></span> <span data-ttu-id="44cac-159">由於 **ncalrpc** 中的所有通訊都是本機的，如果伺服器在進行呼叫時變得沒有回應，用戶端上的 RPC 執行時間就會立即無法進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="44cac-159">Since all communications in **ncalrpc** are local, if the server becomes unresponsive while a call is in progress, the RPC run time on the client immediately fails the call.</span></span>

## <a name="call-time-outs"></a><span data-ttu-id="44cac-160">呼叫超時</span><span class="sxs-lookup"><span data-stu-id="44cac-160">Call Time Outs</span></span>

<span data-ttu-id="44cac-161">如果網路連線中斷，或伺服器當機，則 TCP 保持連接是正常的。</span><span class="sxs-lookup"><span data-stu-id="44cac-161">TCP keep alives are fine if network connectivity is lost, or if the server crashes.</span></span> <span data-ttu-id="44cac-162">但是，如果伺服器在使用者模式中鎖死，TCP 會保持連接成功，但永遠不會傳回呼叫。</span><span class="sxs-lookup"><span data-stu-id="44cac-162">But if the server deadlocks in user mode, TCP keep alives return successfully but the call will never return.</span></span> <span data-ttu-id="44cac-163">為了處理此案例，已新增 Windows XP 的新執行時間選項： RPC \_ C \_ OPT \_ 呼叫 \_ 超時。</span><span class="sxs-lookup"><span data-stu-id="44cac-163">To deal with this scenario, a new run-time option was added for Windows XP: RPC\_C\_OPT\_CALL\_TIMEOUT.</span></span> <span data-ttu-id="44cac-164">此選項會指示每次將要求傳送到伺服器時，RPC 執行時間設定計時器。</span><span class="sxs-lookup"><span data-stu-id="44cac-164">This option instructs the RPC run time to set up a timer each time it sends a request to the server.</span></span> <span data-ttu-id="44cac-165">如果計時器過期，則會自動取消呼叫，並在 RPC \_ S 呼叫取消時完成 \_ \_ 。</span><span class="sxs-lookup"><span data-stu-id="44cac-165">If the timer expires, the call is automatically canceled and completes with RPC\_S\_CALL\_CANCELLED.</span></span> <span data-ttu-id="44cac-166">只要伺服器在指定的時間限制內回應，用戶端就不會取消呼叫。</span><span class="sxs-lookup"><span data-stu-id="44cac-166">As long as the server responds within the specified time limit, the client will not cancel the call.</span></span> <span data-ttu-id="44cac-167">這表示 multifragment 呼叫可能需要超過超時時間才能完成，因為從伺服器收到的每個回應都是在超時時間內收到，即使所有回應的時間週期超過超時期限也是一樣。</span><span class="sxs-lookup"><span data-stu-id="44cac-167">This means a multifragment call may take more than the time-out period to complete, as each response from the server is received within the time-out period, even though the time period for all responses to arrive was more than the time-out period.</span></span>

<span data-ttu-id="44cac-168">此外，當呼叫取消時，伺服器不會收到取消通知。</span><span class="sxs-lookup"><span data-stu-id="44cac-168">Also, when a call is canceled the server is not notified of the cancellation.</span></span> <span data-ttu-id="44cac-169">因此，伺服器可能會在某個時間點執行呼叫，而用戶端只會忽略伺服器的回應。</span><span class="sxs-lookup"><span data-stu-id="44cac-169">The server, therefore, will likely execute the call at some point, and the client will simply ignore the response from the server.</span></span>

<span data-ttu-id="44cac-170">呼叫超時的最危險缺陷是建立短暫的時間，然後在同一部伺服器上重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="44cac-170">The most dangerous pitfall with call time outs is establishing a short time out and retrying the call on the same server.</span></span> <span data-ttu-id="44cac-171">下列案例說明這種方法的危險：</span><span class="sxs-lookup"><span data-stu-id="44cac-171">The following scenario illustrates the dangers of this approach:</span></span>

<span data-ttu-id="44cac-172">想像一下運作接近容量的伺服器。</span><span class="sxs-lookup"><span data-stu-id="44cac-172">Imagine a server that operates near capacity.</span></span> <span data-ttu-id="44cac-173">其中有許多用戶端的時間很短，例如五秒。</span><span class="sxs-lookup"><span data-stu-id="44cac-173">It has a number of clients with very short time outs, such as five seconds.</span></span> <span data-ttu-id="44cac-174">在路由器上暫時遺失網路連線或擁塞會導致伺服器回復短暫的幾秒鐘。</span><span class="sxs-lookup"><span data-stu-id="44cac-174">A temporary loss of network connectivity or congestion at a router causes a lapse in server replies for a few seconds.</span></span> <span data-ttu-id="44cac-175">在乙太網路上，此情況很容易由伺服器與另一部電腦共用的連結上的活動高載所造成。</span><span class="sxs-lookup"><span data-stu-id="44cac-175">On Ethernet networks, this situation can easily be caused by a burst of activity on a link that the server shares with another machine.</span></span> <span data-ttu-id="44cac-176">在五秒的時間之前，伺服器不會管理傳送所有回復。用戶端會取消其呼叫，然後立即重試。</span><span class="sxs-lookup"><span data-stu-id="44cac-176">The server does not manage to send all replies before the five-second time out. The clients get their calls canceled, and immediately retry.</span></span> <span data-ttu-id="44cac-177">伺服器不知道呼叫會重試，也會執行這些呼叫。</span><span class="sxs-lookup"><span data-stu-id="44cac-177">The server is not aware the calls are retries, and executes them as well.</span></span> <span data-ttu-id="44cac-178">因此，它會執行30-50% 以上的呼叫，而不是執行其正常的呼叫工作負載，這取決於有多少用戶端超時。如果超過其容量，而且伺服器無法在五秒內回應所有用戶端，則會將另一輪呼叫傳送至伺服器。</span><span class="sxs-lookup"><span data-stu-id="44cac-178">Thus, instead of executing its normal workload of calls, it executes 30-50% more calls, depending on how many clients timed out. If this exceeds its capacity, and the server cannot respond to all clients within five seconds, another round of calls are sent to the server.</span></span> <span data-ttu-id="44cac-179">用戶端會繼續重新發出相同的呼叫，因為伺服器會多載處理先前的呼叫，所以無法在該時間內回應。一旦回應之後，用戶端就會到達時間、發出新的呼叫，然後捨棄答案。</span><span class="sxs-lookup"><span data-stu-id="44cac-179">The clients keep reissuing the same calls, and since the server is overloaded processing previous calls, it is unable to respond within the time out. Once it responds, the clients have hit the time out, issued a new call, and discarded the answer.</span></span> <span data-ttu-id="44cac-180">在最糟的情況下，伺服器在重新開機之前將不會復原，而且視用戶端存取模式而定，必須等到有足夠數目的用戶端停止之後，才能復原。</span><span class="sxs-lookup"><span data-stu-id="44cac-180">In a worst case scenario, the server will not recover until reboot, and depending on client access pattern, may not recover until a sufficient number of clients are stopped.</span></span>

> [!Note]  
> <span data-ttu-id="44cac-181">呼叫超時只適用于 ncacn 的 [**\_ ip \_ tcp**](/windows/desktop/Midl/ncacn-ip-tcp) 和 [**ncacn \_ HTTP**](/windows/desktop/Midl/ncacn-http) 通訊協定序列。</span><span class="sxs-lookup"><span data-stu-id="44cac-181">Call time outs work only on the [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp) and [**ncacn\_http**](/windows/desktop/Midl/ncacn-http) protocol sequences.</span></span>

 

 

 