---
title: 處理連接中斷
description: 處理連接中斷
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103682749"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="ce221-103">處理連接中斷</span><span class="sxs-lookup"><span data-stu-id="ce221-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="ce221-104">在 RPC 呼叫完成之後，連接就不會關閉;它會標示為可用。</span><span class="sxs-lookup"><span data-stu-id="ce221-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="ce221-105">如此一來，當連接在集區中時，伺服器可能會中斷，或在呼叫之間遺失網路連線。</span><span class="sxs-lookup"><span data-stu-id="ce221-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="ce221-106">根據原則，RPC 執行時間只有在符合下列兩個條件時，才會重新嘗試這些呼叫：</span><span class="sxs-lookup"><span data-stu-id="ce221-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="ce221-107">伺服器不可能執行呼叫，或呼叫為等冪。</span><span class="sxs-lookup"><span data-stu-id="ce221-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="ce221-108">用戶端可以用效能有效率的方式來執行重試。</span><span class="sxs-lookup"><span data-stu-id="ce221-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="ce221-109">下列段落將擴充和說明這兩個條件。</span><span class="sxs-lookup"><span data-stu-id="ce221-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="ce221-110">等冪呼叫是指可以在伺服器上執行一次以上的呼叫，而不會有不必要的副作用。</span><span class="sxs-lookup"><span data-stu-id="ce221-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="ce221-111">例如，在銀行中查詢指定帳戶餘額的 RPC 呼叫是等冪的。</span><span class="sxs-lookup"><span data-stu-id="ce221-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="ce221-112">如果此呼叫因為連接中斷而執行兩次，則不會有任何損害。</span><span class="sxs-lookup"><span data-stu-id="ce221-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="ce221-113">等冪呼叫的另一個範例是變更資料庫中客戶的位址。</span><span class="sxs-lookup"><span data-stu-id="ce221-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="ce221-114">執行兩次是正常的，因為第二次執行只會將已存在的位址取代為相同的位址。</span><span class="sxs-lookup"><span data-stu-id="ce221-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="ce221-115">「從帳戶 xyz 減去50美元」之類的作業不具等冪性。</span><span class="sxs-lookup"><span data-stu-id="ce221-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="ce221-116">遺失網路連線不應造成多次執行這類呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="ce221-117">為了安全起見，RPC 執行時間會將所有呼叫視為非等冪。</span><span class="sxs-lookup"><span data-stu-id="ce221-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="ce221-118">\[Ncacn 的 \] [**\_ ip \_ tcp**](/windows/desktop/Midl/ncacn-ip-tcp)不支援等冪屬性，且會忽略。</span><span class="sxs-lookup"><span data-stu-id="ce221-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="ce221-119">因此，上述清單中的第一個條件會縮減為 *無法執行呼叫的伺服器*。</span><span class="sxs-lookup"><span data-stu-id="ce221-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="ce221-120">在許多情況下，RPC 執行時間無法判斷伺服器上尚未執行的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="ce221-121">在這種情況下，用戶端將不會重試執行呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="ce221-122">下列範例說明 RPC 執行時間何時或不重試呼叫：</span><span class="sxs-lookup"><span data-stu-id="ce221-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="ce221-123">伺服器重新開機。</span><span class="sxs-lookup"><span data-stu-id="ce221-123">A server is rebooted.</span></span>

    <span data-ttu-id="ce221-124">在重新開機後未進行任何先前呼叫的介面上，會進行簡單、無安全性的 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="ce221-125">因為未在此介面上進行任何呼叫，所以 RPC 執行時間會先嘗試協調介面的使用。</span><span class="sxs-lookup"><span data-stu-id="ce221-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="ce221-126">它會使用集區中的連接來傳送封包。</span><span class="sxs-lookup"><span data-stu-id="ce221-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="ce221-127">因為伺服器已重新開機，且連接不再有效，所以會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce221-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="ce221-128">由於用戶端 RPC 執行時間尚未開始傳送實際呼叫的資料，因此用戶端會判斷該伺服器可能不會在這些資料上執行。</span><span class="sxs-lookup"><span data-stu-id="ce221-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="ce221-129">因此，它會關閉連線，並尋找集區中的另一個連接。</span><span class="sxs-lookup"><span data-stu-id="ce221-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="ce221-130">如果找不到連接，它會開啟新的連線，並嘗試再次使用介面。</span><span class="sxs-lookup"><span data-stu-id="ce221-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="ce221-131">如果成功，則會進行呼叫， (也就是重試，因為在呼叫啟動之前偵測到失敗) 。</span><span class="sxs-lookup"><span data-stu-id="ce221-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="ce221-132">具有隱私權層級安全性 (加密) 的 RPC 呼叫是在與已經過協商之安全性內容的連接上進行。</span><span class="sxs-lookup"><span data-stu-id="ce221-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="ce221-133">為了確保效能有效率，RPC 執行時間會加密純文字資料) 的封送封包內嵌 (。</span><span class="sxs-lookup"><span data-stu-id="ce221-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="ce221-134">如果傳送資料的嘗試失敗，則 RPC 執行時間無法重試呼叫，因為純文字資料已使用加密的資料覆寫，而且無法使用新的安全性內容重新加密資料。</span><span class="sxs-lookup"><span data-stu-id="ce221-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="ce221-135">因此，不會進行重試。</span><span class="sxs-lookup"><span data-stu-id="ce221-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="ce221-136">非優先片段的傳送失敗。</span><span class="sxs-lookup"><span data-stu-id="ce221-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="ce221-137">不進行重試，因為 RPC 執行時間可能會在完成時選擇捨棄第一個片段的內容，而且無法重試傳送第一個片段。</span><span class="sxs-lookup"><span data-stu-id="ce221-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="ce221-138">已傳送 RPC 要求。</span><span class="sxs-lookup"><span data-stu-id="ce221-138">The RPC request is sent.</span></span>

    <span data-ttu-id="ce221-139">伺服器中止連接。</span><span class="sxs-lookup"><span data-stu-id="ce221-139">The server aborts the connection.</span></span> <span data-ttu-id="ce221-140">不會嘗試重試，因為 RPC 無法分辨伺服器是否已收到呼叫並開始執行。</span><span class="sxs-lookup"><span data-stu-id="ce221-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="ce221-141">如果伺服器使用動態端點，RPC 將不會在重試期間重新解析端點。</span><span class="sxs-lookup"><span data-stu-id="ce221-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="ce221-142">這表示，如果伺服器已關閉並重新啟動，它可能會位於不同的端點，而且 RPC 將不會在呼叫重試時，以透明的方式重新解析端點。</span><span class="sxs-lookup"><span data-stu-id="ce221-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="ce221-143">若要強制重新解析端點，RPC 用戶端應該在重試呼叫之前呼叫 [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) 。</span><span class="sxs-lookup"><span data-stu-id="ce221-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="ce221-144">在許多情況下，如果 RPC 用戶端可以判斷呼叫是否具等冪性，或它是否保留 RPC 捨棄的資料，它可能會選擇在 RPC 之上建立重試機制。</span><span class="sxs-lookup"><span data-stu-id="ce221-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="ce221-145">如果伺服器是叢集，且叢集的不同節點執行不同版本的伺服器軟體，則 RPC 重試可能會在容錯移轉的情況下，于叢集的不同節點上進行呼叫，而且可能會在不同版本的伺服器上進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="ce221-146">在這類部署案例中，請確定用戶端不依賴特定版本的伺服器軟體來執行指定的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce221-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="ce221-147">如果有的話，用戶端應該在偵測和處理這類情況的 RPC 之上建立機制。</span><span class="sxs-lookup"><span data-stu-id="ce221-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 