---
title: 類型序列化
description: MIDL 編譯器會針對套用 \ 編碼 \ 或 \ 解碼 \ 屬性的每個類型，最多產生三個函數。
ms.assetid: 948f1dd7-c8b0-4fa0-88d8-9d122de52ba1
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4674617bc98c92dbc684a29d1a3c91ac6a7429e1
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104092903"
---
# <a name="type-serialization"></a><span data-ttu-id="5c625-103">類型序列化</span><span class="sxs-lookup"><span data-stu-id="5c625-103">Type Serialization</span></span>

<span data-ttu-id="5c625-104">MIDL 編譯器針對套用 \[ [編碼](/windows/desktop/Midl/encode) \] 或解碼 \[ [](/windows/desktop/Midl/decode) \] 屬性的每個類型，最多會產生三個函數。</span><span class="sxs-lookup"><span data-stu-id="5c625-104">The MIDL compiler generates up to three functions for each type to which the \[ [encode](/windows/desktop/Midl/encode)\] or \[ [decode](/windows/desktop/Midl/decode)\] attribute is applied.</span></span> <span data-ttu-id="5c625-105">例如，針對名為 *MyType* 的使用者定義型別，編譯器會針對 MyType \_ 編碼、MyType 解碼 \_ 和 MyType AlignSize 函數產生程式碼 \_ 。</span><span class="sxs-lookup"><span data-stu-id="5c625-105">For example, for a user-defined type named *MyType*, the compiler generates code for the MyType\_Encode, MyType\_Decode, and MyType\_AlignSize functions.</span></span> <span data-ttu-id="5c625-106">針對這些函式，編譯器會將原型寫入至 Stub，並將原始程式碼寫入存根 \_ c.c。</span><span class="sxs-lookup"><span data-stu-id="5c625-106">For these functions, the compiler writes prototypes to Stub.h and source code to Stub\_c.c.</span></span> <span data-ttu-id="5c625-107">一般來說，您可以使用 MyType 解碼，將 *MyType* 物件編碼，並使用 MyType \_ 編碼和解碼緩衝區中的物件 \_ 。</span><span class="sxs-lookup"><span data-stu-id="5c625-107">Generally, you can encode a *MyType* object with MyType\_Encode and decode an object from the buffer using MyType\_Decode.</span></span> <span data-ttu-id="5c625-108">\_如果您需要知道封送處理緩衝區的大小再進行配置，則會使用 MyType AlignSize。</span><span class="sxs-lookup"><span data-stu-id="5c625-108">MyType\_AlignSize is used if you need to know the size of the marshaling buffer before allocating it.</span></span>

<span data-ttu-id="5c625-109">MIDL 編譯器會產生下列編碼函數。</span><span class="sxs-lookup"><span data-stu-id="5c625-109">The following encoding function is generated by the MIDL compiler.</span></span> <span data-ttu-id="5c625-110">此函式會將 pObject 所指向之物件的資料序列化，並根據控制碼中指定的方法取得緩衝區。</span><span class="sxs-lookup"><span data-stu-id="5c625-110">This function serializes the data for the object pointed to by pObject, and the buffer is obtained according to the method specified in the handle.</span></span> <span data-ttu-id="5c625-111">將序列化資料寫入緩衝區之後，您可以控制緩衝區。</span><span class="sxs-lookup"><span data-stu-id="5c625-111">After writing the serialized data to the buffer, you control the buffer.</span></span> <span data-ttu-id="5c625-112">請注意，控制碼會繼承先前呼叫的狀態，而緩衝區必須對齊8。</span><span class="sxs-lookup"><span data-stu-id="5c625-112">Note that the handle inherits the status from the previous calls, and the buffers must be aligned at 8.</span></span>

<span data-ttu-id="5c625-113">針對隱含控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-113">For an implicit handle:</span></span>

``` syntax
void MyType_Encode (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-114">若為明確的控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-114">For an explicit handle:</span></span>

``` syntax
void MyType_Encode (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-115">下列函式會將來自應用程式儲存體的資料還原序列化為 pObject 所指向的物件。</span><span class="sxs-lookup"><span data-stu-id="5c625-115">The following function deserializes the data from the application's storage into the object pointed to by pObject.</span></span> <span data-ttu-id="5c625-116">您可以根據控制碼中指定的方法，提供封送處理的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="5c625-116">You supply a marshaled buffer according to the method specified in the handle.</span></span> <span data-ttu-id="5c625-117">請注意，這個控制碼可以繼承先前呼叫的狀態，而緩衝區必須對齊8。</span><span class="sxs-lookup"><span data-stu-id="5c625-117">Note that the handle can inherit the status from the previous calls and the buffers must be aligned at 8.</span></span>

<span data-ttu-id="5c625-118">針對隱含控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-118">For an implicit handle:</span></span>

``` syntax
void MyType_Decode (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-119">若為明確的控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-119">For an explicit handle:</span></span>

``` syntax
void MyType_Decode (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-120">下列函式會傳回大小（以位元組為單位），其中包含型別實例加上對齊資料所需的任何填補位元組。</span><span class="sxs-lookup"><span data-stu-id="5c625-120">The following function returns a size, in bytes, that includes the type instance plus any padding bytes needed to align the data.</span></span> <span data-ttu-id="5c625-121">這可將相同或不同類型的一組實例序列化為緩衝區，同時確保每個物件的資料都適當對齊。</span><span class="sxs-lookup"><span data-stu-id="5c625-121">This enables serializing a set of instances of the same or different types into a buffer while ensuring that the data for each object is appropriately aligned.</span></span> <span data-ttu-id="5c625-122">MyType \_ AlignSize 假設 pObject 所指向的實例將會封送處理到從以8對齊的位移開始的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="5c625-122">MyType\_AlignSize assumes that the instance pointed to by pObject will be marshaled into a buffer beginning at the offset aligned at 8.</span></span>

<span data-ttu-id="5c625-123">針對隱含控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-123">For an implicit handle:</span></span>

``` syntax
size_t MyType_AlignSize (MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-124">若為明確的控制碼：</span><span class="sxs-lookup"><span data-stu-id="5c625-124">For an explicit handle:</span></span>

``` syntax
size_t MyType_AlignSize (handle_t Handle, MyType __RPC_FAR * pObject);
```

<span data-ttu-id="5c625-125">請注意，具有隱含序列化控制碼之隱含系結控制碼和序列化型別的兩個遠端程式都會使用相同的全域控制碼變數。</span><span class="sxs-lookup"><span data-stu-id="5c625-125">Note that both remote procedures with implicit binding handles and serialized types with implicit serialization handles use the same global handle variable.</span></span> <span data-ttu-id="5c625-126">因此，建議不要將型別序列化和遠端程式混合在具有隱含控制碼的介面中。</span><span class="sxs-lookup"><span data-stu-id="5c625-126">Therefore, it is advisable not to mix type serialization and remote procedures in an interface with implicit handles.</span></span> <span data-ttu-id="5c625-127">如需詳細資訊，請參閱 [隱含與明確的控制碼](implicit-versus-explicit-handles.md)。</span><span class="sxs-lookup"><span data-stu-id="5c625-127">For details, see [Implicit Versus Explicit Handles](implicit-versus-explicit-handles.md).</span></span>

 

 