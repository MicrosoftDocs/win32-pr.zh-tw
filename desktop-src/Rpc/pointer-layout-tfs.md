---
title: 指標版面配置
description: 指標版面配置描述結構或陣列的指標。
ms.assetid: 1a4984c1-97b9-4e95-a17e-851b67fa94a3
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6616cc7d1000b042c6039b2abf3f79d4900cd0e5fadac748881666610b139c57
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "120019190"
---
# <a name="pointer-layout"></a>指標版面配置

指標版面配置描述結構或陣列的指標。

## <a name="pointer_layout"></a>指標 \_ 版面配置<>

指標 \_ 版面配置<> 欄位包含格式化字元 FC \_ PP fc \_ 板，後面接著一或多個指標描述（如稍後所述），並以 FC \_ 結束格式字元終止：

``` syntax
FC_PP
FC_PAD
{ pointer_instance_layout<> }*
FC_END
```

指標 \_ 實例配置 \_<> 欄位是一種格式字串，描述指標的單一或多個實例。 下欄欄位適用于這些描述項：

-   \_記憶體中的位移 \_

    指標在記憶體中位置的帶正負號位移。 針對位於結構中的指標，此位移是結構結尾的負位移， (符合標準結構的 nonconformant 部分結尾) ;如果是陣列，則位移是從陣列的開頭算起。

-   \_緩衝區中的位移 \_

    緩衝區中指標位置的帶正負號位移。 針對位於結構中的指標，此位移是從結構結尾算起的負位移， (符合標準結構的 nonconformant 部分結尾) ：若為數組，則位移是從陣列的開頭算起。

-   \_陣列的 \_ 位移

    從封閉結構到要處理其指標的內嵌陣列之間的位移。 若為最上層陣列，此欄位永遠為零。

-   反覆運算

    <> 描述具有相同配置的指標總數。

-   increment

    重複期間連續指標之間的遞增。

-   \_指標數目 \_

    重複實例中的不同指標數目。

-   指標 \_ 描述

    指標描述。

所有指標實例配置都會使用下列 \_<8> 的單一指標實例：

``` syntax
offset_to_pointer_in_memory<2> 
offset_to_pointer_in_buffer<2> 
pointer_description<4>
```

以下是實例描述項：

**簡單類型之指標的單一實例：**

``` syntax
FC_NO_REPEAT FC_PAD 
pointer_instance<8>
```

**固定的重複指標：**

``` syntax
FC_FIXED_REPEAT FC_PAD 
iterations<2> 
increment<2> 
offset_to_array<2> 
number_of_pointers<2>
{ pointer_instance<8> }*
```

**變數重複指標：**

``` syntax
FC_VARIABLE_REPEAT (FC_FIXED_OFFSET | FC_VARIABLE_OFFSET) 
increment<2> 
offset_to_array<2> 
number_of_pointers<2> 
{ pointer_instance<8> }*
```

針對固定的重複和變數重複指標實例，重複實例中的每個指標都有一組位移和指標描述。

## <a name="pointers-layout-design-issues"></a>指標版面配置設計問題

本節說明與處理一致結構和內嵌指標相關的問題。 問題是編譯器會針對具有某些冗余的結構和陣列產生指標版面配置。 這項功能很有説明，因為這項資訊很有用，因此，符合標準的結構可以引導一個指標配置，以提供來自結構的所有指標，以及符合標準之結構的標準陣列。 不過，有一些內嵌的情況需要 NDR 引擎執行額外的工作，以適當的連續處理所有指標版面配置，並剛好處理每個指標一次。

## <a name="what-the-compiler-generates"></a>編譯器產生的內容

本節中討論的每個物件都有指標，因此，符合標準的結構在結構部分以及陣列元素中都具有指標。 元素是具有指標的簡單結構。

1.  符合標準的結構，單一層級

    符合的描述項具有 PP 部分，其中所有指標都會從結構和陣列描述。 成員清單有 FC \_ 長的長度，而不是指標。 CARRAY 陣列描述項具有使用內嵌複雜的元素 \_ ，而且完全沒有指標描述項。 元素仍有其單一指標描述元。 指標配置優先于符合結構和簡單結構描述項中的成員配置。

2.  符合標準的結構，兩個或更多層級

    PP 描述具有來自所有層級的指標。 它會重複使用與內部一致結構相同的陣列描述。 成員清單有 FC \_ 長的長度，而不是指標。 內嵌的結構是透過使用內嵌複雜的。 符合標準的結構描述項會依原樣重複使用。 結構的一般部分大小也是完整的，這表示最上層結構大小會包含內嵌結構的一般大小。

3.  複雜結構，單一層級

    指標成員是以 FC \_ 指標標記。 已簡化指標配置，因此清單中每個 FC 指標專案的指標描述項 (4 個位元組) \_ 。 指標配置會與成員逐步進行平行處理，也就是說，FC \_ 指標會導致下一個指標描述的處理。 CARRAY 陣列具有指標配置，其中包含陣列的所有描述元，然後是使用內嵌複雜專案的元素。 元素描述項會重複使用。 結構的平面部分大小已完成;換句話說，最上層結構的平面大小包含內嵌結構的一般大小。 成員配置優先于複雜結構的指標版面配置。

    因此，符合標準的陣列描述會根據其是符合結構的陣列，還是在複雜結構內，而產生差異。

4.  複雜結構、2個以上的層級、複雜的複雜

    最上層複雜結構具有其成員指標，內嵌複雜結構具有其成員指標。 一致的結構描述項會重複使用。 頂端的陣列描述項是內嵌結構中重複使用的陣列。

5.  具有內嵌一致結構的複雜結構

    Top = 符合層級的結構具有其成員指標。 符合標準的結構描述項會依原樣重複使用。 陣列描述元會從內嵌一致的結構重複使用;換句話說，它沒有陣列描述項的任何指標。 元素有其指標描述元。

6.  具有指標的結構陣列

    根據陣列的大小，會將具有指標的簡單結構陣列產生為 SMFARRAY 或 CARRAY，但在這兩種情況下，它都具有完整 (固定 \_ 重複或變數重複) 的指標配置 \_ 。 指標版面配置位於成員配置之前。

    具有指標的複雜結構陣列會產生為假 \_ 陣列，不論它是固定或調整大小，而且在這兩種情況下，都不會有任何指標版面配置。

## <a name="what-the-ndr-engine-does"></a>NDR 引擎的作用

本節說明 NDR 引擎的行為。

**封送處理傳遞**

1.  符合標準的結構以及符合內嵌式的結構。

    最上層結構的行為就像單一層級結構一樣。

2.  具有符合標準陣列的內嵌複雜結構

    任何複雜的結構都會強制外部結構成為複雜的結構。 內嵌結構絕不會將其陣列封送處理。 每個結構一律會透過直接封送處理成員，而將成員視為 FC 指標，來通過內嵌指標 \_ 。

3.  具有符合結構的複雜結構

    最上層的內嵌一致結構會將符合的陣列和所有 pointees 封送處理。 如果有的話，NDR 引擎永遠不會向更深層的符合結構的結構進行遞減。這會簡化方案，因為符合的結構是在内嵌物件的封送處理時所關心的分葉物件。 最上層複雜結構會略過陣列封送處理。

**封送處理、bufsizing 和釋放行程**

封送處理已對稱至封送處理;它針對複雜結構執行的第一項作業是透過呼叫 **NdrComplexStructBufferSize** 函式的方式，找出緩衝區中的 pointees 位置。 然後，它會以平行方式拆收 pointees，啟用相同的配置以正確地將 pointees 重新封送處理。 應該不會與調整大小的物件和等位混淆;記憶體影像不應該用於調整大小的物件和等位，只適用于緩衝區內容。

用來正確執行封送處理和封送處理的旗標會以 bufsizing 和釋出的相同方式來使用，以確保 pointees 只會進行一次。

**Endianess pass**

一開始，endianess 階段有點類似封送處理/封送處理;需要兩個階段來處理複雜的結構。 第一次傳遞會轉換平面元件，並在緩衝區中尋找 pointees 的位置，類似于 bufsizing 如何執行這項作業以進行封送處理。 第二次傳遞會轉換 pointees。

Endianess 的傳遞會以下列方式不同：每個結構和每個成員都必須逐步執行，直到分葉成員或元素是簡單類型。 這與封送的不同;例如，在進行封送處理時，永遠不需要處理內嵌在符合標準結構中的符合結構，也不需要處理任何符合標準之結構的成員。 另一個問題是，轉換不是等冪作業，因此，封送處理階段可能會取消對部分片段的封送處理，而不會造成損害，而轉換必須針對每個簡單的類型執行。

因此，endianess 演算法可摘要如下所示。 NDR 具有最上層一致結構的概念，以及適當的旗標。 當您第一次進行時（例如轉換一般部分以及取得 pointees 的位置），不會使用這個概念。 NDR 會流經所有層級結構的一般部分，而且永遠不會進入指標處理。 最後，NDR 會在最上層轉換陣列。

當您第二次進行時，旗標會用來標示內嵌指標的傳遞，以避免輸入較深層的符合結構，然後是最符合標準的結構。 如此一來，旗標會強制執行常見的封送處理/封送處理行為，這是為了避免將較深層的一致性結構遞減。

具有一致陣列的複雜結構的第二個傳遞會如下所示：複雜結構的運作方式如下：這表示更深層的層級絕對不會查看或略過其一致大小或其符合標準的陣列，而是只會在不觸及陣列的情況下引導其成員。

對於具有符合結構的複雜結構，符合標準的結構必須知道它是否為最上層，以及它是否在複雜的結構中。 陣列的平面部分是由最上層最符合標準的結構所處理。 在第二次行程中，最符合標準的結構會略過一般部分，並經過指標配置，然後再返回。 最上層的複雜結構會略過它的一般部分，也會略過指標版面配置。

**Endianess 逐步解說的強大層面**

Endianess 逐步檢查常見的緩衝區外狀況，並執行其他不相關本質的檢查。 以關聯值為目標的檢查 (例如，調整大小引數與一致大小) 無法使用此步驟執行;它們會在稍後進行封送時執行。

 

 




