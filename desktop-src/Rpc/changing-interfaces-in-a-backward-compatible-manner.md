---
title: 以回溯相容的方式變更介面
description: 基於許多原因，可能無法接受 RPC 和 COM 的版本控制理論中所述的方法。
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 314daecc6b55aaf4a348411010eb578149f86921
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103682983"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a><span data-ttu-id="8eaa2-103">以回溯相容的方式變更介面</span><span class="sxs-lookup"><span data-stu-id="8eaa2-103">Changing Interfaces in a Backward Compatible Manner</span></span>

<span data-ttu-id="8eaa2-104">基於許多原因，可能無法接受 [RPC 和 COM 的版本控制理論](the-versioning-theory-for-rpc-and-com.md) 中所述的方法。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-104">The methods explained in [The Versioning Theory for RPC and COM](the-versioning-theory-for-rpc-and-com.md) may be unacceptable for many reasons.</span></span> <span data-ttu-id="8eaa2-105">根據規則變更介面版本，基本上需要新的用戶端無法與舊的伺服器通訊。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-105">Changing an interface version according to the rules essentially requires that new clients not communicate with old servers.</span></span> <span data-ttu-id="8eaa2-106">這通常無法在現場部署商務軟體。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-106">This is frequently impossible with commercial software deployed in the field.</span></span> <span data-ttu-id="8eaa2-107">Windows 有時引進了變更的 Guid 或版本不存在的介面變更。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-107">Sometimes, Windows has introduced interface changes absent of changed GUIDs or versions.</span></span> <span data-ttu-id="8eaa2-108">這是因為新用戶端需要與舊版伺服器通訊的結果，而且因為新用戶端支援舊的和新介面的解決方案被視為不必要。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-108">This was a result of new clients needing to communicate with legacy servers, and because the solution that a new client would support both the old and new interfaces was deemed undesirable.</span></span>

## <a name="best-practice"></a><span data-ttu-id="8eaa2-109">最佳做法</span><span class="sxs-lookup"><span data-stu-id="8eaa2-109">Best practice</span></span>

<span data-ttu-id="8eaa2-110">當介面 GUID 和版本無法變更時，這些是解決網路不相容問題的合理方法。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-110">These are the reasonable methods of working around the wire incompatibility issue when the interface GUID and version cannot be changed.</span></span>

1.  <span data-ttu-id="8eaa2-111">讓應用程式知道另一端的功能。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-111">Have the application be aware of the other side's capabilities.</span></span>

    <span data-ttu-id="8eaa2-112">用戶端和伺服器有一種通訊協定，可讓每個 (或至少新的用戶端) 建立夥伴的身分識別。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-112">The client and server have a protocol that enables each (or at least the new client) to establish the identity of the partner.</span></span> <span data-ttu-id="8eaa2-113">一般來說，讓新的用戶端知道舊伺服器和新伺服器所支援的功能就夠了。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-113">Typically it is sufficient to have the new client be aware of features supported by old and new servers.</span></span> <span data-ttu-id="8eaa2-114">當應用程式保存到連接內容時，很容易就能完成這項作業，並且在執行任何 RPC 作業之前，透過用戶端所執行的 *XxxGetInfo* 類型函式呼叫來提供支援。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-114">This may easily be done when an application holds on to a connection context, and be supported through an *XxxGetInfo* type of function call executed by the client before performing any RPC operations.</span></span> <span data-ttu-id="8eaa2-115">當應用程式以每一伺服器版本為基礎管理功能時，可能永遠不會發生與舊伺服器/用戶端不相容的呼叫，因為應用程式會控制發出哪些呼叫給哪些伺服器。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-115">When an application manages the features on a per-server release basis, a call with an incompatibility to the old server/client can never occur, since the application controls which calls are issued to which server.</span></span> <span data-ttu-id="8eaa2-116">重點是，應用程式會主動防止不相符的情況發生。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-116">The bottom line is that the application is proactive in preventing a mismatch from happening.</span></span> <span data-ttu-id="8eaa2-117">這可能會與第二個實務搭配執行。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-117">This may be performed in conjunction with the second practice.</span></span>

2.  <span data-ttu-id="8eaa2-118">引進新的遠端 API。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-118">Introduce a new remote API.</span></span>

    <span data-ttu-id="8eaa2-119">新的遠端方法如果在介面的最一端加入，就不會與現有方法衝突。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-119">A new remote method does not collide with existing methods if it is added at the very end of the interface.</span></span> <span data-ttu-id="8eaa2-120">舊的用戶端可以隨時呼叫新的伺服器。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-120">Old clients can call new servers as they always have.</span></span> <span data-ttu-id="8eaa2-121">新的用戶端可以呼叫新方法，而不需要知道伺服器的身分識別，但前提是它會監看來自所呼叫之伺服器的錯誤。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-121">The new client can call the new method without knowing the server's identity, provided it watches for the errors coming from the server being called.</span></span> <span data-ttu-id="8eaa2-122">在分派之前，RPC 執行時間一律會檢查每個介面的方法編號，以確保方法位於適當的 v 資料表內。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-122">The RPC run time always checks the method number for each interface before a dispatch to ensure the method is within an appropriate v-table.</span></span> <span data-ttu-id="8eaa2-123">針對伺服器未知的方法，RPC 執行時間會引發 \_ \_ PROCNUM \_ 超出 \_ 範圍的例外狀況 rpc S \_ 。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-123">For a method that is unknown to a server, the RPC run time raises the exception RPC\_S\_PROCNUM\_OUT\_OF\_RANGE.</span></span> <span data-ttu-id="8eaa2-124">只有在這種情況下，才會引發此例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-124">This exception is raised only in this particular situation.</span></span> <span data-ttu-id="8eaa2-125">因此，新的用戶端可以監看此例外狀況是否為呼叫進入舊伺服器的正負號，並可正常地修改其行為。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-125">Therefore, a new client can watch for the exception as a sign that the call went to an old server and can modify its behavior gracefully.</span></span>

3.  <span data-ttu-id="8eaa2-126">只在新的方法中引進新的參數或新的資料類型。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-126">Introduce new parameters or new data types only in the new methods.</span></span>

    <span data-ttu-id="8eaa2-127">引進新方法的其中一個原因是為了避免資料不相容。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-127">One reason to introduce a new method is to avoid data incompatibility.</span></span> <span data-ttu-id="8eaa2-128">如果引進或單純修改了新的資料類型，則在主體中，它只能用在新方法 (或) 方法。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-128">If a new data type is introduced or simply modified, in principle it should be used only in a new method (or methods).</span></span> <span data-ttu-id="8eaa2-129">如需不相容資料類型變更的範例，請參閱 [不相容變更的範例](examples-of-incompatible-changes.md) 。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-129">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples of incompatible data type changes.</span></span> <span data-ttu-id="8eaa2-130">這項規則唯一值得注意的例外狀況會在第四個專案中描述。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-130">The only notable exception to this rule is described in item four.</span></span>

4.  <span data-ttu-id="8eaa2-131">透過包裝函式對應新的參數或新的資料類型。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-131">Map new parameters or new data types through a wrapper.</span></span>

    <span data-ttu-id="8eaa2-132">此方案適用于必須向使用者公開新的參數或資料類型時，但實際上不需要個別遠端或可對應至舊的資料類型或參數。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-132">This solution applies when a new parameter or data type must be exposed to a user, but actually does not have to be remoted separately or can be mapped to the old data types or parameters.</span></span> <span data-ttu-id="8eaa2-133">例如，許多系統 Api 都會轉換並執行遠端呼叫。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-133">For example, many system APIs turn around and execute a remote call.</span></span> <span data-ttu-id="8eaa2-134">它們不一定會執行某種類型的對應，從使用者已知的資料型別，到實際在基礎 RPC 呼叫中使用的資料類型。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-134">They may or may not be doing some kind of mapping from the user known data types to the data types actually used in the underlying RPC call.</span></span> <span data-ttu-id="8eaa2-135">因此，一定要檢查使用者介面的變更是否需要傳播為遠端介面的變更。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-135">It is therefore always worth examining if the change in the user interface needs to propagate as a change to a remote interface.</span></span>

    <span data-ttu-id="8eaa2-136">當使用者直接呼叫遠端 API 時，可能會發生類似的情況，但可能會導入包裝函式來執行新的類型對應或其他已成為必要的其他動作。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-136">A similar situation may happen when the user calls a remote API directly, but a wrapper could be introduced to do a new type mapping or some other additional actions that have become necessary.</span></span> <span data-ttu-id="8eaa2-137">介面定義語言 (IDL) 有數種方式可以促進這類重新對應，也就是 \[ [**呼叫 \_**](/windows/desktop/Midl/call-as) \] 、 \[ [**傳輸 \_ 為**](/windows/desktop/Midl/transmit-as) \] 和 \[ [**電匯 \_**](/windows/desktop/Midl/wire-marshal) \] 。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-137">Interface Definition Language (IDL) has several ways of facilitating such remapping, namely \[[**call\_as**](/windows/desktop/Midl/call-as)\], \[[**transmit\_as**](/windows/desktop/Midl/transmit-as)\], and \[[**wire\_marshal**](/windows/desktop/Midl/wire-marshal)\].</span></span> <span data-ttu-id="8eaa2-138">\[ **Call \_ as** \] 屬性會在用戶端和伺服器上引進函式包裝函式。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-138">The \[**call\_as**\] attribute introduces a function wrapper on the client and server.</span></span> <span data-ttu-id="8eaa2-139">兩者都放在使用者程式碼與封送處理器之間。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-139">Both are placed between the user code and the marshaler.</span></span> <span data-ttu-id="8eaa2-140">其他屬性則會處理直接型別對應。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-140">The other attributes deal with direct type mapping.</span></span> <span data-ttu-id="8eaa2-141">針對延伸模組的問題， \[ **呼叫的 \_ 方式** \] 最常使用，而且最容易瞭解並操作，不會有任何陷阱。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-141">For extension problems, \[**call\_as**\] is the most frequently used, and is easiest to understand and manipulate without pitfalls.</span></span>

5.  <span data-ttu-id="8eaa2-142">透過 defaultless 聯集來修改資料類型。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-142">Modify data types through a defaultless union.</span></span>

    <span data-ttu-id="8eaa2-143">變更屬性或資料類型通常會導致網路不相容。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-143">Changing an attribute or data type typically leads to wire incompatibility.</span></span> <span data-ttu-id="8eaa2-144">請參閱範例 [中不相容的變更](examples-of-incompatible-changes.md) 範例。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-144">See [Examples of Incompatible Changes](examples-of-incompatible-changes.md) for examples.</span></span> <span data-ttu-id="8eaa2-145">不過，在沒有 default 子句的等位的情況下，不相容的管理方式可能會與程式範圍外的案例類似，如先前所述。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-145">However, in the case of a union without a default clause, the incompatibility may be managed in a way similar to the case of a procedure out of range, as described previously.</span></span> <span data-ttu-id="8eaa2-146">此配置可立即適用于使用等位的熱門 *XxxINFO* 類型。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-146">This scheme is readily applicable to the popular *XxxINFO* types that use unions.</span></span>

    <span data-ttu-id="8eaa2-147">例如，像這樣的呼叫</span><span class="sxs-lookup"><span data-stu-id="8eaa2-147">For example, a call like this</span></span>

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    <span data-ttu-id="8eaa2-148">可以傳回層級1、2或3的資訊，其中 *XxxINFO* 是具有三個分支的聯集：1、2和3。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-148">could return information at level 1, 2 or 3, with *XxxINFO* being a union with three branches: 1, 2 and 3.</span></span>

6.  <span data-ttu-id="8eaa2-149">使用 [ \[ [**範圍**](/windows/desktop/Midl/range)] \] 屬性指定 [範圍]。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-149">Use the \[[**range**](/windows/desktop/Midl/range)\] attribute to specify range.</span></span>

    <span data-ttu-id="8eaa2-150">您可以 \[ [](/windows/desktop/Midl/range) \] 在簡單的調整型別上指定 range 屬性，而不會中斷回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-150">You can specify the \[[**range**](/windows/desktop/Midl/range)\] attribute on a simple scale type without breaking backward compatibility.</span></span> <span data-ttu-id="8eaa2-151">此屬性不會影響電傳格式，但在 unmarshalling RPC 期間會檢查網路上的值，以確認它是否在 .idl 檔案中指定的範圍內。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-151">This attribute does not affect wire format, but during unmarshalling RPC checks the value on wire to confirm that it is within the range specified in the .idl file.</span></span> <span data-ttu-id="8eaa2-152">如果沒有，則會擲回 RPC \_ X 無效系結 \_ 例外狀況 \_ 。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-152">If not, a RPC\_X\_INVALID\_BOUND exception is thrown.</span></span> <span data-ttu-id="8eaa2-153">如果伺服器知道大小陣列的大小上限，這會特別有用。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-153">This is especially useful if the server knows the maximum size of a sized array.</span></span>

    <span data-ttu-id="8eaa2-154">例如：</span><span class="sxs-lookup"><span data-stu-id="8eaa2-154">For example:</span></span>

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

<span data-ttu-id="8eaa2-155">當指定層級為4且 arm 遺失時的 RPC 行為，取決於聯集的定義。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-155">The RPC behavior when the indicated level is 4 and the arm is missing, depends on the definition of the union.</span></span> <span data-ttu-id="8eaa2-156">針對已定義 default 子句的聯集，RPC 會針對不同于已知 arm 標籤的值，傳輸 default 子句中所指定的類型 (在此案例中，除了1、2或 3) 以外的任何其他作業。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-156">For a union with the default clause defined, RPC transmits a type indicated in the default clause for anything different than the known arm labels (in this case, anything other than 1, 2 or 3).</span></span> <span data-ttu-id="8eaa2-157">針對 defaultless 聯集，unmarshaler 會引發例外狀況，因為根據定義，沒有預設值會切換回。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-157">For a defaultless union, the unmarshaler raises an exception because by definition there is no default to fall back to.</span></span> <span data-ttu-id="8eaa2-158">例外狀況是 RPC \_ S \_ 不正確 \_ 標記。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-158">The exception is RPC\_S\_INVALID\_TAG.</span></span>

<span data-ttu-id="8eaa2-159">同樣地，新的用戶端可以在發現它稱為舊伺服器時，調整其行為。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-159">Again, a new client can adjust its behavior upon discovering that it called an old server.</span></span>

<span data-ttu-id="8eaa2-160">接下來的建議作法是，如果必須針對可在未來延伸的遠端資料類型進行設計，請在 IDL 檔案中使用 defaultless 聯集。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-160">What follows from these recommended practices is that if a remotable data type must be designed that can be extended in future, use a defaultless union in the IDL file.</span></span> <span data-ttu-id="8eaa2-161">有了一個選擇之後，封裝聯集就稍微簡潔。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-161">Given a choice, an encapsulated union is slightly cleaner.</span></span>

<span data-ttu-id="8eaa2-162">由於 NDR64 網路通訊協定的內部標記法的緣故，在本節稍早所提供的新增 arm 的建議必須符合下列條件：新增的 arm 無法變更等位的對齊方式，尤其是不應變更 arm 的最大對齊。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-162">Due to quirks of internal representation of the NDR64 wire protocol, the recommendation for adding arms provided earlier in this section needs to be qualified as follows: The new arm being added cannot change the alignment of the union, and in particular, the biggest alignment of the arms should not change.</span></span> <span data-ttu-id="8eaa2-163">這通常不是問題，因為 arm 中的指標會強制調整為8。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-163">This is typically not an issue, as a pointer in an arm forces alignment to 8.</span></span> <span data-ttu-id="8eaa2-164">每個 arm 都是 arm 類型指標的設計，是滿足需求的一種全新方式。</span><span class="sxs-lookup"><span data-stu-id="8eaa2-164">A design where each arm is a pointer to an arm type is one clean way of satisfying the requirement.</span></span>

 

 