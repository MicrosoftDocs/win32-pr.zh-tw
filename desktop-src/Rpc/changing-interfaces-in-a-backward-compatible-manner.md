---
title: 以回溯相容的方式變更介面
description: 基於許多原因，可能無法接受 RPC 和 COM 的版本控制理論中所述的方法。
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8fbe06be3106b4c599baed2d625eefa1f9c7d035c70ef89ac325406bb8c2037d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "120022958"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a>以回溯相容的方式變更介面

基於許多原因，可能無法接受 [RPC 和 COM 的版本控制理論](the-versioning-theory-for-rpc-and-com.md) 中所述的方法。 根據規則變更介面版本，基本上需要新的用戶端無法與舊的伺服器通訊。 這通常無法在現場部署商務軟體。 有時候，Windows 引進了變更的 guid 或版本不存在的介面變更。 這是因為新用戶端需要與舊版伺服器通訊的結果，而且因為新用戶端支援舊的和新介面的解決方案被視為不必要。

## <a name="best-practice"></a>最佳做法

當介面 GUID 和版本無法變更時，這些是解決網路不相容問題的合理方法。

1.  讓應用程式知道另一端的功能。

    用戶端和伺服器有一種通訊協定，可讓每個 (或至少新的用戶端) 建立夥伴的身分識別。 一般來說，讓新的用戶端知道舊伺服器和新伺服器所支援的功能就夠了。 當應用程式保存到連接內容時，很容易就能完成這項作業，並且在執行任何 RPC 作業之前，透過用戶端所執行的 *XxxGetInfo* 類型函式呼叫來提供支援。 當應用程式以每一伺服器版本為基礎管理功能時，可能永遠不會發生與舊伺服器/用戶端不相容的呼叫，因為應用程式會控制發出哪些呼叫給哪些伺服器。 重點是，應用程式會主動防止不相符的情況發生。 這可能會與第二個實務搭配執行。

2.  引進新的遠端 API。

    新的遠端方法如果在介面的最一端加入，就不會與現有方法衝突。 舊的用戶端可以隨時呼叫新的伺服器。 新的用戶端可以呼叫新方法，而不需要知道伺服器的身分識別，但前提是它會監看來自所呼叫之伺服器的錯誤。 在分派之前，RPC 執行時間一律會檢查每個介面的方法編號，以確保方法位於適當的 v 資料表內。 針對伺服器未知的方法，RPC 執行時間會引發 \_ \_ PROCNUM \_ 超出 \_ 範圍的例外狀況 rpc S \_ 。 只有在這種情況下，才會引發此例外狀況。 因此，新的用戶端可以監看此例外狀況是否為呼叫進入舊伺服器的正負號，並可正常地修改其行為。

3.  只在新的方法中引進新的參數或新的資料類型。

    引進新方法的其中一個原因是為了避免資料不相容。 如果引進或單純修改了新的資料類型，則在主體中，它只能用在新方法 (或) 方法。 如需不相容資料類型變更的範例，請參閱 [不相容變更的範例](examples-of-incompatible-changes.md) 。 這項規則唯一值得注意的例外狀況會在第四個專案中描述。

4.  透過包裝函式對應新的參數或新的資料類型。

    此方案適用于必須向使用者公開新的參數或資料類型時，但實際上不需要個別遠端或可對應至舊的資料類型或參數。 例如，許多系統 Api 都會轉換並執行遠端呼叫。 它們不一定會執行某種類型的對應，從使用者已知的資料型別，到實際在基礎 RPC 呼叫中使用的資料類型。 因此，一定要檢查使用者介面的變更是否需要傳播為遠端介面的變更。

    當使用者直接呼叫遠端 API 時，可能會發生類似的情況，但可能會導入包裝函式來執行新的類型對應或其他已成為必要的其他動作。 介面定義語言 (IDL) 有數種方式可以促進這類重新對應，也就是 \[ [**呼叫 \_**](/windows/desktop/Midl/call-as) \] 、 \[ [**傳輸 \_ 為**](/windows/desktop/Midl/transmit-as) \] 和 \[ [**電匯 \_**](/windows/desktop/Midl/wire-marshal) \] 。 \[ **Call \_ as** \] 屬性會在用戶端和伺服器上引進函式包裝函式。 兩者都放在使用者程式碼與封送處理器之間。 其他屬性則會處理直接型別對應。 針對延伸模組的問題， \[ **呼叫的 \_ 方式** \] 最常使用，而且最容易瞭解並操作，不會有任何陷阱。

5.  透過 defaultless 聯集來修改資料類型。

    變更屬性或資料類型通常會導致網路不相容。 請參閱範例 [中不相容的變更](examples-of-incompatible-changes.md) 範例。 不過，在沒有 default 子句的等位的情況下，不相容的管理方式可能會與程式範圍外的案例類似，如先前所述。 此配置可立即適用于使用等位的熱門 *XxxINFO* 類型。

    例如，像這樣的呼叫

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    可以傳回層級1、2或3的資訊，其中 *XxxINFO* 是具有三個分支的聯集：1、2和3。

6.  使用 [ \[ [**範圍**](/windows/desktop/Midl/range)] \] 屬性指定 [範圍]。

    您可以 \[ [](/windows/desktop/Midl/range) \] 在簡單的調整型別上指定 range 屬性，而不會中斷回溯相容性。 此屬性不會影響電傳格式，但在 unmarshalling RPC 期間會檢查網路上的值，以確認它是否在 .idl 檔案中指定的範圍內。 如果沒有，則會擲回 RPC \_ X 無效系結 \_ 例外狀況 \_ 。 如果伺服器知道大小陣列的大小上限，這會特別有用。

    例如：

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

當指定層級為4且 arm 遺失時的 RPC 行為，取決於聯集的定義。 針對已定義 default 子句的聯集，RPC 會針對不同于已知 arm 標籤的值，傳輸 default 子句中所指定的類型 (在此案例中，除了1、2或 3) 以外的任何其他作業。 針對 defaultless 聯集，unmarshaler 會引發例外狀況，因為根據定義，沒有預設值會切換回。 例外狀況是 RPC \_ S \_ 不正確 \_ 標記。

同樣地，新的用戶端可以在發現它稱為舊伺服器時，調整其行為。

接下來的建議作法是，如果必須針對可在未來延伸的遠端資料類型進行設計，請在 IDL 檔案中使用 defaultless 聯集。 有了一個選擇之後，封裝聯集就稍微簡潔。

由於 NDR64 網路通訊協定的內部標記法的緣故，在本節稍早所提供的新增 arm 的建議必須符合下列條件：新增的 arm 無法變更等位的對齊方式，尤其是不應變更 arm 的最大對齊。 這通常不是問題，因為 arm 中的指標會強制調整為8。 每個 arm 都是 arm 類型指標的設計，是滿足需求的一種全新方式。

 

 