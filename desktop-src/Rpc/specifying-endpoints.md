---
title: 指定端點
description: 在遠端程序呼叫中指定已知和動態的端點， (RPC) 。
ms.assetid: fc39b527-11e6-45a7-b3b5-8bcf469633d8
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 373fb2818dd14670f5a939aa524c81fcdb05e20b
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106968297"
---
# <a name="specifying-endpoints"></a><span data-ttu-id="5083b-103">指定端點</span><span class="sxs-lookup"><span data-stu-id="5083b-103">Specifying Endpoints</span></span>

<span data-ttu-id="5083b-104">端點是遠端程序呼叫之伺服器進程的網路特定位址。</span><span class="sxs-lookup"><span data-stu-id="5083b-104">An endpoint is a network-specific address of a server process for remote procedure calls.</span></span> <span data-ttu-id="5083b-105">端點的實際名稱取決於所使用的通訊協定順序。</span><span class="sxs-lookup"><span data-stu-id="5083b-105">The actual name of the endpoint depends on the protocol sequence used.</span></span> <span data-ttu-id="5083b-106">例如，TCP、UDP 和 HTTP 使用埠。</span><span class="sxs-lookup"><span data-stu-id="5083b-106">For example, TCP, UDP, and HTTP use ports.</span></span> <span data-ttu-id="5083b-107">具名管道使用具名管道名稱。</span><span class="sxs-lookup"><span data-stu-id="5083b-107">Named pipes uses a named pipe name.</span></span> <span data-ttu-id="5083b-108">用戶端/伺服器應用程式可以使用已知的端點或動態端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-108">Client/server applications can use a well-known endpoint or a dynamic endpoint.</span></span> <span data-ttu-id="5083b-109">本節提供伺服器程式用來指定已知和動態端點的技巧。</span><span class="sxs-lookup"><span data-stu-id="5083b-109">This section presents the techniques that server programs use to specify well-known and dynamic endpoints.</span></span> <span data-ttu-id="5083b-110">下列主題將討論這項資訊：</span><span class="sxs-lookup"><span data-stu-id="5083b-110">The information is discussed in the following topics:</span></span>

-   [<span data-ttu-id="5083b-111">指定知名端點</span><span class="sxs-lookup"><span data-stu-id="5083b-111">Specifying Well-known Endpoints</span></span>](#specifying-well-known-endpoints)
-   [<span data-ttu-id="5083b-112">指定動態端點</span><span class="sxs-lookup"><span data-stu-id="5083b-112">Specifying Dynamic Endpoints</span></span>](#specifying-dynamic-endpoints)

## <a name="specifying-well-known-endpoints"></a><span data-ttu-id="5083b-113">指定知名端點</span><span class="sxs-lookup"><span data-stu-id="5083b-113">Specifying Well-known Endpoints</span></span>

<span data-ttu-id="5083b-114">當您的伺服器使用已知的端點時，它可以在名稱服務資料庫專案中包含端點資料。</span><span class="sxs-lookup"><span data-stu-id="5083b-114">When your server uses a well-known endpoint, it can include the endpoint data as part of its name service database entry.</span></span> <span data-ttu-id="5083b-115">如果有，當用戶端從伺服器專案匯入系結控制碼時，用戶端的系結控制碼就會包含完整的伺服器位址，包括已知的端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-115">If it does, the client's binding handle contains a complete server address that includes the well-known endpoint when the client imports the binding handle from the server entry.</span></span>

<span data-ttu-id="5083b-116">您的伺服器程式也可以指定已知的端點，同時指定通訊協定順序。</span><span class="sxs-lookup"><span data-stu-id="5083b-116">Your server program can also specify well-known endpoints at the same time it specifies protocol sequences.</span></span> <span data-ttu-id="5083b-117">叫用 [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep) 或 [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) 函數。</span><span class="sxs-lookup"><span data-stu-id="5083b-117">Invoke either the [**RpcServerUseProtseqEp**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep) or [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) function.</span></span> <span data-ttu-id="5083b-118">兩者之間的差異在於，後者的函式有一個額外的參數，可讓您的伺服器用來控制動態埠配置。</span><span class="sxs-lookup"><span data-stu-id="5083b-118">The difference between the two is that the latter function has an extra parameter your server can use to control dynamic port allocation.</span></span>

<span data-ttu-id="5083b-119">如果您的伺服器程式以這種方式指定其端點資訊，它也應該呼叫 [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) 函式，以在端點對應中註冊端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-119">If your server program specifies its endpoint information in this way, it should also call the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) function to register the endpoint in the endpoint map.</span></span> <span data-ttu-id="5083b-120">雖然端點一律是相同的，但用戶端可能會使用端點對應來尋找伺服器。</span><span class="sxs-lookup"><span data-stu-id="5083b-120">Even though the endpoint is always the same, the client may use the endpoint map to find the server.</span></span>

<span data-ttu-id="5083b-121">和通訊協定順序一樣，應用程式可以在其 IDL 檔案中指定端點資訊。</span><span class="sxs-lookup"><span data-stu-id="5083b-121">Like protocol sequences, an application can specify endpoint information in its IDL file.</span></span> <span data-ttu-id="5083b-122">當它執行時，應叫用 [**RpcServerUseAllProtseqsIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsif) 或 [**RpcServerUseAllProtseqsIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex) 函式，同時註冊通訊協定序列和端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-122">When it does, it should register both the protocol sequences and endpoints at the same time by invoking the [**RpcServerUseAllProtseqsIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsif) or [**RpcServerUseAllProtseqsIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex) function.</span></span> <span data-ttu-id="5083b-123">在此情況下，用戶端可以透過 IDL 檔案中的介面規格來存取端點資訊。</span><span class="sxs-lookup"><span data-stu-id="5083b-123">In this case, the client has access to the endpoint information through the interface specification in the IDL file.</span></span> <span data-ttu-id="5083b-124">因此，不需要呼叫 [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) 函數。</span><span class="sxs-lookup"><span data-stu-id="5083b-124">Therefore, it is not necessary to call the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) function.</span></span>

## <a name="specifying-dynamic-endpoints"></a><span data-ttu-id="5083b-125">指定動態端點</span><span class="sxs-lookup"><span data-stu-id="5083b-125">Specifying Dynamic Endpoints</span></span>

<span data-ttu-id="5083b-126">動態端點是伺服器主機電腦在伺服器開始執行時所指派的端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-126">A dynamic endpoint is an endpoint that the server host computer assigns when the server begins execution.</span></span> <span data-ttu-id="5083b-127">大部分的伺服器應用程式會使用動態端點，以避免在伺服器主機電腦系統上的可用埠數量有限時，與其他程式發生衝突。</span><span class="sxs-lookup"><span data-stu-id="5083b-127">Most server applications use dynamic endpoints to avoid conflict with other programs over the limited number of ports that are available on the server host computer system.</span></span> <span data-ttu-id="5083b-128">不過，使用具名管道或 [**ncalrpc**](/windows/desktop/Midl/ncalrpc) 通訊協定序列的程式會有非常大的端點命名空間。</span><span class="sxs-lookup"><span data-stu-id="5083b-128">However, programs using named pipes or the [**ncalrpc**](/windows/desktop/Midl/ncalrpc) protocol sequence have a very large endpoint name space.</span></span> <span data-ttu-id="5083b-129">相較于使用其他傳輸的程式，其受益于動態端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-129">They benefit less from dynamic endpoints than programs using other transports.</span></span>

<span data-ttu-id="5083b-130">伺服器程式會在端點對應資料庫中註冊動態端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-130">Server programs register dynamic endpoints in an endpoint map database.</span></span> <span data-ttu-id="5083b-131">如果您想要讓伺服器使用任何可用的端點，請呼叫 [**RpcServerUseAllProtSeqs**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs)、 [**RpcServerUseAllProtseqsEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsex)、 [**RpcServerUseProtseq**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) 或 [**RpcServerUseProtseqEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqex)。</span><span class="sxs-lookup"><span data-stu-id="5083b-131">If you want the server to use any available endpoint, call [**RpcServerUseAllProtSeqs**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs), [**RpcServerUseAllProtseqsEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqsex), [**RpcServerUseProtseq**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) or [**RpcServerUseProtseqEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqex).</span></span> <span data-ttu-id="5083b-132">這會將 RPC 執行時間程式庫設定為使用動態端點)  (s 的所有或一個有效的通訊協定順序。</span><span class="sxs-lookup"><span data-stu-id="5083b-132">This sets the RPC run-time library to use all or one valid protocol sequence(s) with dynamic endpoints.</span></span> <span data-ttu-id="5083b-133">然後，伺服器應該呼叫 [**RpcServerInqBindings**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) 來取得一組有效的系結控制碼。</span><span class="sxs-lookup"><span data-stu-id="5083b-133">The server should then call [**RpcServerInqBindings**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) to obtain a set of valid binding handles.</span></span> <span data-ttu-id="5083b-134">伺服器會將一組系結控制碼或系結向量傳遞至函式 [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) ，以註冊端點對應中所有適合的端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-134">The server passes the set of binding handles, or binding vector, to the function [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) to register all suitable endpoints in the endpoint map.</span></span> <span data-ttu-id="5083b-135">針對您的伺服器對 **RpcEpRegister** 進行的每個呼叫，應該會有對應的 [**RpcBindingVectorFree**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingvectorfree) 呼叫，以釋放系結向量所使用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="5083b-135">For each call your server makes to **RpcEpRegister**, there should be a corresponding call to [**RpcBindingVectorFree**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingvectorfree) to release the memory that the binding vector uses.</span></span>

<span data-ttu-id="5083b-136">請注意，伺服器程式可以使用 [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) 函數，而不是 [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister)。</span><span class="sxs-lookup"><span data-stu-id="5083b-136">Note that server programs can use the [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) function rather than [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister).</span></span> <span data-ttu-id="5083b-137">當伺服器程式的多個複本必須在伺服器主機系統上執行時，程式通常會使用 **RpcEpRegisterNoReplace** 。</span><span class="sxs-lookup"><span data-stu-id="5083b-137">Programs typically use **RpcEpRegisterNoReplace** when multiple copies of a server program must run on a server host system.</span></span>

<span data-ttu-id="5083b-138">[**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister)和 [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace)函數都會將伺服器的介面和系結控制碼新增至端點對應程式資料庫。</span><span class="sxs-lookup"><span data-stu-id="5083b-138">Both the [**RpcEpRegister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregister) and [**RpcEpRegisterNoReplace**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepregisternoreplace) functions add the server's interfaces and binding handles to the endpoint mapper database.</span></span> <span data-ttu-id="5083b-139">當用戶端使用部分系結的控制碼進行遠端程序呼叫時，用戶端的執行時間程式庫會向伺服器電腦的端點對應程式要求相容伺服器實例的端點對應程式。</span><span class="sxs-lookup"><span data-stu-id="5083b-139">When the client makes a remote procedure call using a partially bound handle, the client's run-time library asks the server computer's endpoint mapper for the endpoint of a compatible server instance.</span></span> <span data-ttu-id="5083b-140">用戶端程式庫會在用戶端系結控制碼中提供介面 UUID、通訊協定順序，以及（如果有的話）物件 UUID。</span><span class="sxs-lookup"><span data-stu-id="5083b-140">The client library supplies the interface UUID, protocol sequence, and, if present, the object UUID in the client binding handle.</span></span> <span data-ttu-id="5083b-141">端點對應程式會尋找符合用戶端資訊的資料庫專案。</span><span class="sxs-lookup"><span data-stu-id="5083b-141">The endpoint mapper looks for a database entry that matches the client's information.</span></span> <span data-ttu-id="5083b-142">用戶端/伺服器介面 UUID、介面主要版本和通訊協定順序都必須完全相符。</span><span class="sxs-lookup"><span data-stu-id="5083b-142">The client/server interface UUID, the interface major version, and protocol sequence must all match exactly.</span></span> <span data-ttu-id="5083b-143">此外，伺服器的介面次要版本必須大於或等於用戶端的次要版本。</span><span class="sxs-lookup"><span data-stu-id="5083b-143">In addition, the server's interface minor version must be greater than or equal to the client's minor version.</span></span>

<span data-ttu-id="5083b-144">如果所有測試都成功，則端點對應程式會傳回有效的端點，而用戶端執行時間程式庫會更新系結控制碼中的端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-144">If all tests are successful, the endpoint mapper returns the valid endpoint and the client run-time library updates the endpoint in the binding handle.</span></span>

<span data-ttu-id="5083b-145">當伺服器進程停止執行時，系統會自動從端點對應程式資料庫清除動態端點。</span><span class="sxs-lookup"><span data-stu-id="5083b-145">Dynamic endpoints are automatically purged from the endpoint mapper database when the server process stops running.</span></span> <span data-ttu-id="5083b-146">您可以先從端點對應程式資料庫移除端點，然後再使用 [**RpcEpUnregister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepunregister) 函式結束伺服器程式，或者您可以允許自動清除來管理端點的移除作業。</span><span class="sxs-lookup"><span data-stu-id="5083b-146">You can either remove the endpoint from the endpoint mapper database before the server program exits using the [**RpcEpUnregister**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepunregister) function, or you can allow automatic cleanup to manage removal of the endpoint.</span></span>

 

 