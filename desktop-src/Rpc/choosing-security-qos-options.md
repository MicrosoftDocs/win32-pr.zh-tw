---
title: 選擇安全性 QOS 選項
description: 安全性 QOS 選項會做為 SecurityQOS 參數的一部分傳遞給 RpcBindingSetAuthInfoEx 函數。 使用下列最佳做法。
ms.assetid: 43befe3d-079a-4389-a1ff-6bda90935769
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8c286b516438eae78117ef8d73939c3b4bed396d
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106968114"
---
# <a name="choosing-security-qos-options"></a><span data-ttu-id="19245-104">選擇安全性 QOS 選項</span><span class="sxs-lookup"><span data-stu-id="19245-104">Choosing Security QOS Options</span></span>

<span data-ttu-id="19245-105">安全性 QOS 選項會做為 *SecurityQOS* 參數的一部分傳遞給 [**RpcBindingSetAuthInfoEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa) 函數。</span><span class="sxs-lookup"><span data-stu-id="19245-105">The security QOS options are passed as part of the *SecurityQOS* parameter given to the [**RpcBindingSetAuthInfoEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa) function.</span></span> <span data-ttu-id="19245-106">使用下列最佳做法。</span><span class="sxs-lookup"><span data-stu-id="19245-106">Use the following best practices.</span></span>

## <a name="use-mutual-authentication"></a><span data-ttu-id="19245-107">使用相互驗證</span><span class="sxs-lookup"><span data-stu-id="19245-107">Use Mutual Authentication</span></span>

<span data-ttu-id="19245-108">只有特定的安全性提供者才能使用真正的相互驗證：協商 (當協調 Kerberos) 、Kerberos 和 Schannel 時。</span><span class="sxs-lookup"><span data-stu-id="19245-108">True mutual authentication is available only for certain security providers: Negotiate (when it negotiates Kerberos), Kerberos, and Schannel.</span></span> <span data-ttu-id="19245-109">NTLM 不支援相互驗證。</span><span class="sxs-lookup"><span data-stu-id="19245-109">NTLM does not support mutual authentication.</span></span> <span data-ttu-id="19245-110">使用相互驗證需要提供格式正確的伺服器主體名稱。</span><span class="sxs-lookup"><span data-stu-id="19245-110">Using mutual authentication requires that a well formed server principal name be provided.</span></span> <span data-ttu-id="19245-111">許多開發人員使用下列錯誤的安全性作法：系統會呼叫伺服器來要求其主體名稱 ([**RpcMgmtInqServerPrincName**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqserverprincname)) ，然後使用該主體名稱盲目地要求相互驗證。</span><span class="sxs-lookup"><span data-stu-id="19245-111">Many developers use the following faulty security practice: The server is called to ask for its principal name ([**RpcMgmtInqServerPrincName**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqserverprincname)), and then they blindly ask for mutual authentication using that principal name.</span></span> <span data-ttu-id="19245-112">這種方法會打破相互驗證的整個概念;相互驗證的概念是，只會呼叫特定的伺服器，因為它們受信任可以剖析和處理您的資料。</span><span class="sxs-lookup"><span data-stu-id="19245-112">This approach breaks the whole idea of mutual authentication; the idea of mutual authentication is that only certain servers are called because they are trusted to parse and handle your data.</span></span> <span data-ttu-id="19245-113">使用剛剛所述的錯誤安全性作法，開發人員將其資料提供給任何聰明的人，以傳回其名稱。</span><span class="sxs-lookup"><span data-stu-id="19245-113">Using the faulty security practice just described, developers give their data to anyone smart enough to return their name.</span></span>

<span data-ttu-id="19245-114">例如，如果用戶端軟體應該只呼叫 Joe、Pete 或 Alice 帳戶下執行的伺服器，就應該呼叫 [**RpcMgmtInqServerPrincName**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqserverprincname) 函式，並檢查傳回的名稱。</span><span class="sxs-lookup"><span data-stu-id="19245-114">As an example, if the client software should call only a server running under Joe, Pete, or Alice's accounts, the [**RpcMgmtInqServerPrincName**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqserverprincname) function should be called, and the name sent back should be checked.</span></span> <span data-ttu-id="19245-115">如果是 Joe、Pete 或 Alice，應使用其伺服器主體名稱要求相互驗證。</span><span class="sxs-lookup"><span data-stu-id="19245-115">If it is Joe, Pete or Alice, mutual authentication should be requested using their server principal name.</span></span> <span data-ttu-id="19245-116">這可確保兩個交談的一半都會移至相同的主體。</span><span class="sxs-lookup"><span data-stu-id="19245-116">This ensures both halves of the conversation go to the same principal.</span></span>

<span data-ttu-id="19245-117">如果用戶端軟體應該只呼叫 Joe 帳戶下執行的服務，請直接撰寫 Joe 的伺服器主體名稱並進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="19245-117">If client software should call a service running under Joe's account only, directly compose Joe's server principal name and make the call.</span></span> <span data-ttu-id="19245-118">如果伺服器不是 Joe，則呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="19245-118">If the server is not Joe, the call will simply fail.</span></span>

<span data-ttu-id="19245-119">許多時候，服務都是以 Windows 系統服務的方式執行，這表示它們是在電腦帳戶下執行。</span><span class="sxs-lookup"><span data-stu-id="19245-119">Many times, services run as Windows system services, which means they run under the machine account.</span></span> <span data-ttu-id="19245-120">仍建議使用相互驗證和建立伺服器主體名稱。</span><span class="sxs-lookup"><span data-stu-id="19245-120">Mutual authentication and creation of a server principal name is still recommended.</span></span>

## <a name="use-the-lowest-impersonationtype-that-allows-the-call-to-go-through"></a><span data-ttu-id="19245-121">使用可讓呼叫進入的最低 ImpersonationType</span><span class="sxs-lookup"><span data-stu-id="19245-121">Use the Lowest ImpersonationType that Allows the Call to Go Through</span></span>

<span data-ttu-id="19245-122">這項最佳作法很容易理解。</span><span class="sxs-lookup"><span data-stu-id="19245-122">This Best Practice is fairly self explanatory.</span></span> <span data-ttu-id="19245-123">即使使用相互驗證，請勿授與伺服器比所需更多的許可權;合法的伺服器可能已遭入侵，即使您傳送的資料在這種情況下遇到錯誤的情況，至少伺服器也不能代表您存取網路上的其他資料。</span><span class="sxs-lookup"><span data-stu-id="19245-123">Even if mutual authentication is used, do not give the server more rights than necessary; a legitimate server may have been compromised, and even though the data you send falls into the wrong hands in such cases, at least the server will not be able to access other data on the network on your behalf.</span></span> <span data-ttu-id="19245-124">有些伺服器將會拒絕沒有足夠資訊的呼叫，以判斷呼叫端，也可能模擬呼叫端。</span><span class="sxs-lookup"><span data-stu-id="19245-124">Some servers will reject a call that does not have sufficient information to determine, and possibly impersonate, the caller.</span></span> <span data-ttu-id="19245-125">此外，請注意，某些通訊協定順序支援傳輸層級安全性 ([**ncacn \_ np**](/windows/desktop/Midl/ncacn-np) 和 [**ncalrpc**](/windows/desktop/Midl/ncalrpc)) 。</span><span class="sxs-lookup"><span data-stu-id="19245-125">Also, be aware that some protocol sequences support transport level security ([**ncacn\_np**](/windows/desktop/Midl/ncacn-np) and [**ncalrpc**](/windows/desktop/Midl/ncalrpc)).</span></span> <span data-ttu-id="19245-126">在這種情況下，如果您在建立系結控制碼時，透過 *NetworkOptions* 參數指定夠高的模擬等級，伺服器一律會模擬您。</span><span class="sxs-lookup"><span data-stu-id="19245-126">In such cases, the server can always impersonate you if you specify a sufficiently high impersonation level through the *NetworkOptions* parameter when you create the binding handle.</span></span>

<span data-ttu-id="19245-127">最後，某些安全性提供者或傳輸可能會以透明方式將 ImpersonationType 與指定的層級相較之下。</span><span class="sxs-lookup"><span data-stu-id="19245-127">Finally, some security providers or transports may transparently bump ImpersonationType to a higher level than that specified.</span></span> <span data-ttu-id="19245-128">開發程式時，請確定您嘗試使用預期的 ImpersonationType 進行呼叫，並檢查您是否在伺服器上取得較高的 ImpersonationType。</span><span class="sxs-lookup"><span data-stu-id="19245-128">When developing a program, make sure you try to make calls with the intended ImpersonationType and check whether you are getting higher ImpersonationType on the server.</span></span>

 

 