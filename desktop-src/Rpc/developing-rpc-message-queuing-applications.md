---
title: 開發 RPC-Message 佇列應用程式
description: 若要在 RPC 應用程式中利用 MSMQ 傳輸，很少需要投入很多時間。
ms.assetid: 1ea97df8-cdf5-43b8-88aa-9e8fa6ae845a
keywords:
- 遠端程序呼叫 RPC、工作、開發訊息佇列應用程式
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f3e51707c0a6903200e51dd35e50e998430c8eae
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104023982"
---
# <a name="developing-rpc-message-queuing-applications"></a><span data-ttu-id="2a271-104">開發 RPC-Message 佇列應用程式</span><span class="sxs-lookup"><span data-stu-id="2a271-104">Developing RPC-Message Queuing Applications</span></span>

<span data-ttu-id="2a271-105">若要在 RPC 應用程式中利用 MSMQ 傳輸，很少需要投入很多時間。</span><span class="sxs-lookup"><span data-stu-id="2a271-105">Very little effort is necessary to take advantage of the MSMQ transport in your RPC application.</span></span> <span data-ttu-id="2a271-106">針對同步訊息，您只需要將訊息佇列傳輸 ([**ncadg \_ mq**](/windows/desktop/Midl/ncadg-mq)) 指定為通訊協定順序。</span><span class="sxs-lookup"><span data-stu-id="2a271-106">For synchronous messaging you need only specify the message queue transport ([**ncadg\_mq**](/windows/desktop/Midl/ncadg-mq)) as the protocol sequence.</span></span> <span data-ttu-id="2a271-107">**Ncadg \_ mq** 通訊協定支援所有標準資料包功能，但廣播呼叫除外。</span><span class="sxs-lookup"><span data-stu-id="2a271-107">The **ncadg\_mq** protocol supports all of the standard datagram features except broadcasting calls.</span></span> <span data-ttu-id="2a271-108">此外，請注意，目前訊息佇列傳輸不支援動態端點。</span><span class="sxs-lookup"><span data-stu-id="2a271-108">Also, note that currently the message-queue transport does not support dynamic endpoints.</span></span>

<span data-ttu-id="2a271-109">藉由將 \[ [**訊息**](/windows/desktop/Midl/message) \] 屬性套用至 IDL 檔案中的遠端過程聲明，您會自動針對這些呼叫來執行非同步模式訊息佇列。</span><span class="sxs-lookup"><span data-stu-id="2a271-109">By applying the \[[**message**](/windows/desktop/Midl/message)\] attribute to remote procedure declarations in the IDL file, you automatically implement asynchronous-mode message queuing for those calls.</span></span> <span data-ttu-id="2a271-110">這可讓用戶端和伺服器應用程式控制許多與訊息和訊息佇列相關聯的屬性，包括：</span><span class="sxs-lookup"><span data-stu-id="2a271-110">This makes it possible for the client and server applications to control many of the properties associated with messages and message queues, including:</span></span>

-   <span data-ttu-id="2a271-111">服務品質</span><span class="sxs-lookup"><span data-stu-id="2a271-111">Quality of service</span></span>
-   <span data-ttu-id="2a271-112">收條的確認</span><span class="sxs-lookup"><span data-stu-id="2a271-112">Acknowledgment of receipt</span></span>
-   <span data-ttu-id="2a271-113">日誌</span><span class="sxs-lookup"><span data-stu-id="2a271-113">Journaling</span></span>
-   <span data-ttu-id="2a271-114">呼叫優先順序</span><span class="sxs-lookup"><span data-stu-id="2a271-114">Call priority</span></span>
-   <span data-ttu-id="2a271-115">伺服器進程佇列的持續性</span><span class="sxs-lookup"><span data-stu-id="2a271-115">Persistence of Server Process Queue</span></span>

<span data-ttu-id="2a271-116">服務品質是為了將呼叫傳遞給伺服器進程所做的努力。</span><span class="sxs-lookup"><span data-stu-id="2a271-116">Quality of service is the effort that the transport will make to deliver the call to the server process.</span></span> <span data-ttu-id="2a271-117">快速傳遞將會排入記憶體中，因此相當快速，但如果電腦或網路連線在錯誤的時間中斷，呼叫就會遺失。</span><span class="sxs-lookup"><span data-stu-id="2a271-117">An express delivery will be queued in memory, so it is fairly fast, but the call will be lost if a computer or network connection goes down at the wrong time.</span></span> <span data-ttu-id="2a271-118">可復原的傳遞將會張貼到磁片檔案，直到傳遞為止，因此即使在電腦損毀的情況下，呼叫也不會遺失。</span><span class="sxs-lookup"><span data-stu-id="2a271-118">A recoverable delivery will be posted to a disk file until it is delivered, so the call will not be lost, even in the face of a computer crash.</span></span> <span data-ttu-id="2a271-119">這會提供保證的傳遞，但在每次呼叫寫入磁片時，效能會降低。</span><span class="sxs-lookup"><span data-stu-id="2a271-119">This gives guaranteed delivery, but at a cost in performance as each call is written to disk.</span></span>

<span data-ttu-id="2a271-120">您也可以在傳回之前，告知 MSMQ 傳輸等候呼叫已到達目的地 (server) 佇列。</span><span class="sxs-lookup"><span data-stu-id="2a271-120">You can also tell the MSMQ transport to wait for acknowledgment that the call reached the destination (server) queue before returning.</span></span> <span data-ttu-id="2a271-121">選擇這個選項會封鎖用戶端，直到伺服器確認呼叫為止，否則控制權會在進行呼叫時立即回到用戶端。</span><span class="sxs-lookup"><span data-stu-id="2a271-121">Choosing this option blocks the client until the server acknowledges the call, otherwise control returns to the client immediately upon making the call.</span></span>

<span data-ttu-id="2a271-122">藉由使用日誌，可將通話記錄至磁片。</span><span class="sxs-lookup"><span data-stu-id="2a271-122">By using journaling, calls can be logged to disk.</span></span> <span data-ttu-id="2a271-123">如果開啟日誌功能，每個呼叫都會記錄到磁片上，因為它會傳送至伺服器進程的下一個躍點。</span><span class="sxs-lookup"><span data-stu-id="2a271-123">If journaling is turned on, each call is logged to disk as it is transmitted to the next hop on its way to the server process.</span></span>

<span data-ttu-id="2a271-124">呼叫優先順序可以與 RPC \[ [**message**](/windows/desktop/Midl/message) \] function 屬性搭配使用，以允許優先順序較高的呼叫優先于較低優先順序的呼叫，即使高優先順序呼叫稍後抵達也是如此。</span><span class="sxs-lookup"><span data-stu-id="2a271-124">Call priority can be used in conjunction with the RPC \[[**message**](/windows/desktop/Midl/message)\] function attribute to allow calls with higher priority to take precedence over calls with lower priority, even if the high priority calls arrive later.</span></span> <span data-ttu-id="2a271-125">呼叫優先順序也可使用同步 RPC 以有限的方式運作，但同步 RPC 呼叫無法以與非同步呼叫相同的方式堆疊。</span><span class="sxs-lookup"><span data-stu-id="2a271-125">Call priority will also work in a limited fashion with synchronous RPC, but synchronous RPC calls cannot stack up in the same manner as asynchronous calls.</span></span>

<span data-ttu-id="2a271-126">用戶端進程會藉由呼叫 [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption)來控制上述所有屬性。</span><span class="sxs-lookup"><span data-stu-id="2a271-126">The client process controls all of the above properties by calling [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption).</span></span> <span data-ttu-id="2a271-127">一旦設定之後，這些屬性就會維持有效，直到在另一次呼叫 **RpcBindingSetOption** 時才會變更。</span><span class="sxs-lookup"><span data-stu-id="2a271-127">Once set, these properties remain in effect until they are changed in another call to **RpcBindingSetOption**.</span></span>

<span data-ttu-id="2a271-128">RPC 伺服器進程可以控制其接收佇列的存留期。</span><span class="sxs-lookup"><span data-stu-id="2a271-128">The RPC server process can control the lifetime of its receive queue.</span></span> <span data-ttu-id="2a271-129">根據預設，佇列會在伺服器進程結束時刪除。</span><span class="sxs-lookup"><span data-stu-id="2a271-129">By default the queue is deleted when the server process exits.</span></span> <span data-ttu-id="2a271-130">不過，在設定端點時，伺服器進程可以使用 [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) ，告知傳輸允許佇列繼續存在，以及即使在伺服器進程未執行時也接受呼叫要求。</span><span class="sxs-lookup"><span data-stu-id="2a271-130">However, the server process can use [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) when setting up its endpoint to tell the transport to allow the queue to continue to exist and to accept call requests even when the server process is not running.</span></span> <span data-ttu-id="2a271-131">在此情況下，呼叫會排入佇列，並于稍後在伺服器進程恢復上線時執行。</span><span class="sxs-lookup"><span data-stu-id="2a271-131">In this case, the calls are queued up and executed later, when the server process comes back online.</span></span>

> [!Note]  
> <span data-ttu-id="2a271-132">如果您 \[ [](/windows/desktop/Midl/message) \] 在介面中使用非同步訊息呼叫，則必須先呼叫 [**RpcServerRegisterIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterif)或 [**RpcServerRegisterIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterifex)來註冊介面，然後再呼叫 [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) **(ncadg \_ mq)**。</span><span class="sxs-lookup"><span data-stu-id="2a271-132">If you are using asynchronous \[[**message**](/windows/desktop/Midl/message)\] calls in an interface, you must register the interface by calling [**RpcServerRegisterIf**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterif) or [**RpcServerRegisterIfEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverregisterifex) before calling [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex)**(ncadg\_mq)**.</span></span> <span data-ttu-id="2a271-133">一旦開啟通訊協定順序，任何已在佇列中等候伺服器的呼叫，就會開始讀取佇列。</span><span class="sxs-lookup"><span data-stu-id="2a271-133">Once you turn on the protocol sequence, any calls already waiting on the queue for the server will begin to be read off the queue.</span></span> <span data-ttu-id="2a271-134">如果對應的 RPC 介面尚未註冊，則呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="2a271-134">If the corresponding RPC interface has not been registered, the calls will fail.</span></span> <span data-ttu-id="2a271-135">如果您已設定遠端程序呼叫的永久端點、伺服器已經關閉，而且用戶端繼續傳送呼叫給伺服器，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="2a271-135">This situation can happen if you have a setup a permanent endpoint for your remote procedure calls, the server has been shut down, and clients have continued to send calls to the server.</span></span> <span data-ttu-id="2a271-136">這些呼叫會堆疊在佇列中，等候在伺服器重新上線時讀取。</span><span class="sxs-lookup"><span data-stu-id="2a271-136">These calls will be stacked up in the queue, waiting to be read once the server comes back online.</span></span>

 

<span data-ttu-id="2a271-137">如需詳細資訊，請參閱 [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption)、 [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex)和 \[ [**message**](/windows/desktop/Midl/message) \] [**ncadg \_ mq**](/windows/desktop/Midl/ncadg-mq)。</span><span class="sxs-lookup"><span data-stu-id="2a271-137">For more information, see [**RpcBindingSetOption**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetoption), [**RpcServerUseProtseqEpEx**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex), and \[[**message**](/windows/desktop/Midl/message)\], [**ncadg\_mq**](/windows/desktop/Midl/ncadg-mq).</span></span>

 

 