---
title: 管理 (關聯) 的網路連接集
description: 從 Windows 2000 開始，RPC 執行時間可能會在用戶端與伺服器之間維護一個以上的連線。
ms.assetid: 9b9c42e9-8ed5-46a6-b6ec-4093ce0128bb
keywords:
- 管理網路連接集
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 81e99afe23d90e44d85dc7a2ec9301b45e1f20b1
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "104183860"
---
# <a name="managing-network-connection-sets-associations"></a><span data-ttu-id="b0ad2-104">管理 (關聯) 的網路連接集</span><span class="sxs-lookup"><span data-stu-id="b0ad2-104">Managing Network Connection Sets (Associations)</span></span>

<span data-ttu-id="b0ad2-105">從 Windows 2000 開始，RPC 執行時間可能會在用戶端與伺服器之間維護一個以上的連線。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-105">Starting with Windows 2000, the RPC run time may maintain more than one connection between the client and the server.</span></span> <span data-ttu-id="b0ad2-106">這有助於在不需要重新建立連線、多執行緒用戶端和非同步用戶端的情況下，于不支援變更用戶端身分識別的傳輸上進行操作。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-106">This facilitates operation on transports that do not support changing the client identity without reestablishing the connection, multithreaded clients, and asynchronous clients.</span></span> <span data-ttu-id="b0ad2-107">用戶端進程與伺服器端點之間的連接集合稱為 RPC 術語中的 *關聯* 。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-107">The set of connections between a client process and a server endpoint is called an *association* in RPC terminology.</span></span> <span data-ttu-id="b0ad2-108">瞭解關聯可以改善 RPC 的實作為。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-108">Understanding associations can improve the implementation of RPC.</span></span>

<span data-ttu-id="b0ad2-109">在單一線程的單一用戶端身分識別案例中，RPC 會開啟用戶端進程與伺服器端點之間的一個連接，以進行 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-109">In a single-thread, single-client identity scenario, RPC opens one connection between a client process and a server endpoint to make RPC calls.</span></span> <span data-ttu-id="b0ad2-110">進行同步 RPC 呼叫時，用戶端會在此連線上將要求傳送至伺服器，並在其上接收回複。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-110">When a synchronous RPC call is made, the client sends the request to the server on this connection, and receives the reply on it as well.</span></span> <span data-ttu-id="b0ad2-111">當用戶端進程中進行 RPC 呼叫的執行緒數目增加時，用戶端的安全性識別可以變更。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-111">When the number of threads making RPC calls in the client process grows, the security identity of the client can change.</span></span> <span data-ttu-id="b0ad2-112">當非同步/管道呼叫與用戶端上的同步呼叫混合時，RPC 可能需要一個以上的網路連接。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-112">When asynchronous/pipe calls are mixed with synchronous calls on the client, RPC may need more than one network connection.</span></span> <span data-ttu-id="b0ad2-113">集合中的所有連接都會放在名為關聯的連接集區中。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-113">All connections in the set are put in a connection pool called an association.</span></span>

<span data-ttu-id="b0ad2-114">同步遠端程序呼叫會以獨佔方式使用指定的連接來符合 RPC 標準。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-114">A synchronous remote procedure call exclusively uses a given connection to conform with RPC standards.</span></span> <span data-ttu-id="b0ad2-115">如果傳送了要求，但尚未收到回應，則同步 RPC 呼叫所使用的連接會被視為忙碌。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-115">A connection used by a synchronous RPC call is considered busy if a request has been sent, but a response has not been received.</span></span> <span data-ttu-id="b0ad2-116">在收到回應之前，該連接上不允許任何其他流量。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-116">No other traffic is allowed on that connection until the response is received.</span></span> <span data-ttu-id="b0ad2-117">RPC 執行時間會嘗試在相同連接上多工的非同步和管線 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-117">The RPC run time attempts to multiplex asynchronous and pipe RPC calls on the same connection.</span></span> <span data-ttu-id="b0ad2-118">同步和非同步/管道呼叫無法在相同的連接上混用，這表示指定的連接可用於同步 RPC 呼叫或非同步/管道 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-118">Synchronous and asynchronous/pipe calls cannot be mixed on the same connection, which means that a given connection can be used for either synchronous RPC calls or for asynchronous/pipe RPC calls.</span></span>

<span data-ttu-id="b0ad2-119">RPC 積極地嘗試重複使用來自集區的連接。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-119">RPC aggressively tries to reuse connections from the pool.</span></span> <span data-ttu-id="b0ad2-120">進行新的 RPC 呼叫時，RPC 會嘗試從集區尋找適當的連接，而且只有在找不到適合的連接時，才會建立新的連接。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-120">When a new RPC call is made, RPC attempts to find a suitable connection from the pool, and creates a new connection only if a suitable connection cannot be found.</span></span> <span data-ttu-id="b0ad2-121">若要將連線視為適當，則必須：</span><span class="sxs-lookup"><span data-stu-id="b0ad2-121">For a connection to be considered suitable, it must:</span></span>

-   <span data-ttu-id="b0ad2-122"> (同步或非同步/管道) 的適當類型。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-122">Be of the appropriate type (synchronous, or asynchronous/pipe).</span></span>
-   <span data-ttu-id="b0ad2-123">免費。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-123">Be free.</span></span>
-   <span data-ttu-id="b0ad2-124">具有與進行呼叫的系結控制碼相同的安全性識別。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-124">Have the same security identity as the binding handle on which the call is made.</span></span> <span data-ttu-id="b0ad2-125">如果使用動態身分識別追蹤，系結控制碼的識別會從呼叫開頭的執行緒 token 重新整理。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-125">If dynamic identity tracking is used, the identity of the binding handle is refreshed from the thread token at the beginning of the call.</span></span> <span data-ttu-id="b0ad2-126">如果使用靜態身分識別追蹤，則會使用系結控制碼上戳記的用戶端身分識別。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-126">If static identity tracking is used, the client identity stamped on the binding handle is used.</span></span>

<span data-ttu-id="b0ad2-127">當呼叫完成時，一旦收到回應，就會將連接標示為可用，並可用於其他 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-127">When the call is complete, once the response is received, the connection is marked as free and can be used for other RPC calls.</span></span>

<span data-ttu-id="b0ad2-128">連接上的安全性識別無法變更。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-128">The security identity on a connection cannot change.</span></span> <span data-ttu-id="b0ad2-129">例如，如果在不同的安全性識別下對相同的伺服器進行大量呼叫，執行緒集區中的連接數目就會增加。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-129">For example, if a large number of calls to the same server are made under different security identities, the number of connections in the thread pool grows.</span></span> <span data-ttu-id="b0ad2-130">關聯本身為參考計數，而且當所有參考都消失時，就會停止並關閉所有連接。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-130">The association itself is reference-counted, and when all references are gone, it stops and closes all connections.</span></span> <span data-ttu-id="b0ad2-131">每個系結控制碼和每個內容控制碼都會保留關聯的參考。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-131">Every binding handle and every context handle hold a reference on the association.</span></span> <span data-ttu-id="b0ad2-132">當全部關閉時，關聯就會消失。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-132">When all are closed, the association disappears.</span></span> <span data-ttu-id="b0ad2-133">在 Windows XP 上，關聯不一定會立即消失;它們可能會保留一小段時間， (目標期間為20秒，但是如果沒有可用的執行緒可執行工作) ，則 RPC 執行時間可能會選擇延遲終結關聯。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-133">On Windows XP, associations do not necessarily disappear immediately; they may remain for a short period (the target period is 20 seconds, but the RPC run time may choose to delay destroying the association if no threads are available to execute the task).</span></span> <span data-ttu-id="b0ad2-134">如果您不希望在最後一個內容控制碼/系結控制碼關閉之後讓關聯保持運作，請使用 RPC \_ C \_ OPT 未 \_ \_ 逗留選項強制 rpc 執行時間立即關閉連接。</span><span class="sxs-lookup"><span data-stu-id="b0ad2-134">If you do not want the association to stay alive after the last context handle/binding handle is closed, use the RPC\_C\_OPT\_DONT\_LINGER option to force the RPC Runtime to immediately close the connection.</span></span>

 

 




