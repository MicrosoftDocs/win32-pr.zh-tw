---
description: Wait 函數可讓執行緒封鎖本身的執行。
ms.assetid: 9c66c71d-fdfd-42ae-895c-2fc842b5bc7a
title: Wait 函式
ms.topic: article
ms.date: 06/25/2020
ms.openlocfilehash: f5a21b0d95a316b926fcaad037004edc8c418246
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106998320"
---
# <a name="wait-functions"></a><span data-ttu-id="47f1b-103">Wait 函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-103">Wait Functions</span></span>

<span data-ttu-id="47f1b-104">*Wait 函數* 可讓執行緒封鎖本身的執行。</span><span class="sxs-lookup"><span data-stu-id="47f1b-104">*Wait functions* allow a thread to block its own execution.</span></span> <span data-ttu-id="47f1b-105">直到符合指定的準則時，等候函式才會傳回。</span><span class="sxs-lookup"><span data-stu-id="47f1b-105">The wait functions do not return until the specified criteria have been met.</span></span> <span data-ttu-id="47f1b-106">Wait 函式的類型會決定所使用的準則集合。</span><span class="sxs-lookup"><span data-stu-id="47f1b-106">The type of wait function determines the set of criteria used.</span></span> <span data-ttu-id="47f1b-107">呼叫 wait 函式時，它會檢查是否符合等候準則。</span><span class="sxs-lookup"><span data-stu-id="47f1b-107">When a wait function is called, it checks whether the wait criteria have been met.</span></span> <span data-ttu-id="47f1b-108">如果未符合準則，呼叫端執行緒會進入等候狀態，直到符合等候準則的條件或超過指定的逾時間隔為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-108">If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the specified time-out interval elapses.</span></span>

-   [<span data-ttu-id="47f1b-109">單一物件等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-109">Single-object Wait Functions</span></span>](#single-object-wait-functions)
-   [<span data-ttu-id="47f1b-110">多物件等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-110">Multiple-object Wait Functions</span></span>](#multiple-object-wait-functions)
-   [<span data-ttu-id="47f1b-111">可提供警示 Wait 函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-111">Alertable Wait Functions</span></span>](#alertable-wait-functions)
-   [<span data-ttu-id="47f1b-112">已註冊的等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-112">Registered Wait Functions</span></span>](#registered-wait-functions)
-   [<span data-ttu-id="47f1b-113">等候位址</span><span class="sxs-lookup"><span data-stu-id="47f1b-113">Waiting on an Address</span></span>](#waiting-on-an-address)
-   [<span data-ttu-id="47f1b-114">等候函式和逾時間隔</span><span class="sxs-lookup"><span data-stu-id="47f1b-114">Wait Functions and Time-out Intervals</span></span>](#wait-functions-and-time-out-intervals)
-   [<span data-ttu-id="47f1b-115">Wait 函數和同步處理物件</span><span class="sxs-lookup"><span data-stu-id="47f1b-115">Wait Functions and Synchronization Objects</span></span>](#wait-functions-and-synchronization-objects)
-   [<span data-ttu-id="47f1b-116">等候函式和建立視窗</span><span class="sxs-lookup"><span data-stu-id="47f1b-116">Wait Functions and Creating Windows</span></span>](#wait-functions-and-creating-windows)

## <a name="single-object-wait-functions"></a><span data-ttu-id="47f1b-117">單一物件等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-117">Single-object Wait Functions</span></span>

<span data-ttu-id="47f1b-118">[**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait)、 [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)和 [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex)函數需要一個同步處理物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="47f1b-118">The [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) functions require a handle to one synchronization object.</span></span> <span data-ttu-id="47f1b-119">當發生下列其中一種情況時，這些函數會傳回：</span><span class="sxs-lookup"><span data-stu-id="47f1b-119">These functions return when one of the following occurs:</span></span>

-   <span data-ttu-id="47f1b-120">指定的物件處於已發出信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="47f1b-120">The specified object is in the signaled state.</span></span>
-   <span data-ttu-id="47f1b-121">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="47f1b-121">The time-out interval elapses.</span></span> <span data-ttu-id="47f1b-122">逾時間隔可以設定為 [ **無限** ]，以指定等待時間不會過期。</span><span class="sxs-lookup"><span data-stu-id="47f1b-122">The time-out interval can be set to **INFINITE** to specify that the wait will not time out.</span></span>

<span data-ttu-id="47f1b-123">[**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait)函式可讓呼叫執行緒以不可部分完成的方式將物件的狀態設定為已發出信號，並等候另一個物件的狀態設定為已發出信號。</span><span class="sxs-lookup"><span data-stu-id="47f1b-123">The [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait) function enables the calling thread to atomically set the state of an object to signaled and wait for the state of another object to be set to signaled.</span></span>

## <a name="multiple-object-wait-functions"></a><span data-ttu-id="47f1b-124">多物件等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-124">Multiple-object Wait Functions</span></span>

<span data-ttu-id="47f1b-125">[**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects)、 [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex)、 [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects)和 [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)函數可讓呼叫執行緒指定包含一或多個同步處理物件控制碼的陣列。</span><span class="sxs-lookup"><span data-stu-id="47f1b-125">The [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects), [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects), and [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) functions enable the calling thread to specify an array containing one or more synchronization object handles.</span></span> <span data-ttu-id="47f1b-126">當發生下列其中一種情況時，這些函數會傳回：</span><span class="sxs-lookup"><span data-stu-id="47f1b-126">These functions return when one of the following occurs:</span></span>

-   <span data-ttu-id="47f1b-127">任何一個指定物件的狀態會設定為 [已發出信號]，或所有物件的狀態都已設定為 [已發出信號]。</span><span class="sxs-lookup"><span data-stu-id="47f1b-127">The state of any one of the specified objects is set to signaled or the states of all objects have been set to signaled.</span></span> <span data-ttu-id="47f1b-128">您可以控制是否要在函式呼叫中使用一個或所有的狀態。</span><span class="sxs-lookup"><span data-stu-id="47f1b-128">You control whether one or all of the states will be used in the function call.</span></span>
-   <span data-ttu-id="47f1b-129">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="47f1b-129">The time-out interval elapses.</span></span> <span data-ttu-id="47f1b-130">逾時間隔可以設定為 [ **無限** ]，以指定等待時間不會過期。</span><span class="sxs-lookup"><span data-stu-id="47f1b-130">The time-out interval can be set to **INFINITE** to specify that the wait will not time out.</span></span>

<span data-ttu-id="47f1b-131">[**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects)和 [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)函數可讓您指定物件控制碼陣列中的輸入事件物件。</span><span class="sxs-lookup"><span data-stu-id="47f1b-131">The [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) and [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex) function allow you to specify input event objects in the object handle array.</span></span> <span data-ttu-id="47f1b-132">當您線上程的輸入佇列中指定要等候的輸入類型時，就會執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="47f1b-132">This is done when you specify the type of input to wait for in the thread's input queue.</span></span> <span data-ttu-id="47f1b-133">例如，執行緒可以使用 **MsgWaitForMultipleObjects** 來封鎖其執行，直到指定物件的狀態已設定為 [已發出信號]，並且線上程的輸入佇列中有可用的滑鼠輸入為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-133">For example, a thread could use **MsgWaitForMultipleObjects** to block its execution until the state of a specified object has been set to signaled and there is mouse input available in the thread's input queue.</span></span> <span data-ttu-id="47f1b-134">執行緒可以使用 [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) 或 [**PeekMessageA**](/windows/win32/api/winuser/nf-winuser-peekmessagea) 或 [**PeekMessageW**](/windows/win32/api/winuser/nf-winuser-peekmessagew) 函數來取出輸入。</span><span class="sxs-lookup"><span data-stu-id="47f1b-134">The thread can use the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessageA**](/windows/win32/api/winuser/nf-winuser-peekmessagea) or [**PeekMessageW**](/windows/win32/api/winuser/nf-winuser-peekmessagew) function to retrieve the input.</span></span>

<span data-ttu-id="47f1b-135">在等候所有物件的狀態設定為已發出信號時，這些多物件函式不會修改指定物件的狀態，直到所有物件的狀態都已設定為信號為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-135">When waiting for the states of all objects to be set to signaled, these multiple-object functions do not modify the states of the specified objects until the states of all objects have been set signaled.</span></span> <span data-ttu-id="47f1b-136">例如，mutex 物件的狀態可以是信號，但是呼叫的執行緒不會取得擁有權，直到陣列中所指定之其他物件的狀態也已設定為已發出信號為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-136">For example, the state of a mutex object can be signaled, but the calling thread does not get ownership until the states of the other objects specified in the array have also been set to signaled.</span></span> <span data-ttu-id="47f1b-137">在此同時，其他執行緒可能會取得 mutex 物件的擁有權，因此將其狀態設定為未收到信號。</span><span class="sxs-lookup"><span data-stu-id="47f1b-137">In the meantime, some other thread may get ownership of the mutex object, thereby setting its state to nonsignaled.</span></span>

<span data-ttu-id="47f1b-138">在等候單一物件的狀態設定為已發出信號時，這些多物件函式會依序從索引0開始檢查陣列中的控制碼，直到其中一個物件有信號為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-138">When waiting for the state of a single object to be set to signaled, these multiple-object functions check the handles in the array in order starting with index 0, until one of the objects is signaled.</span></span> <span data-ttu-id="47f1b-139">如果有多個物件變成信號，則函式會傳回陣列中物件的第一個控制碼的索引。</span><span class="sxs-lookup"><span data-stu-id="47f1b-139">If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.</span></span>

## <a name="alertable-wait-functions"></a><span data-ttu-id="47f1b-140">可提供警示 Wait 函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-140">Alertable Wait Functions</span></span>

<span data-ttu-id="47f1b-141">[**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)、 [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait)、 [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex)和 [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex)函數與其他等候函式不同，因為它們可以選擇性地執行 *可提供警示等候* 作業。</span><span class="sxs-lookup"><span data-stu-id="47f1b-141">The [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**WaitForMultipleObjectsEx**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), and [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) functions differ from the other wait functions in that they can optionally perform an *alertable wait operation*.</span></span> <span data-ttu-id="47f1b-142">在可提供警示等候作業中，此函式會在符合指定的條件時傳回，但如果系統將 i/o 完成常式或 APC 排入佇列以供等候執行緒執行，則也會傳回此函式。</span><span class="sxs-lookup"><span data-stu-id="47f1b-142">In an alertable wait operation, the function can return when the specified conditions are met, but it can also return if the system queues an I/O completion routine or an APC for execution by the waiting thread.</span></span> <span data-ttu-id="47f1b-143">如需可提供警示等候作業和 i/o 完成常式的詳細資訊，請參閱 [同步處理和重迭的輸入和輸出](synchronization-and-overlapped-input-and-output.md)。</span><span class="sxs-lookup"><span data-stu-id="47f1b-143">For more information about alertable wait operations and I/O completion routines, see [Synchronization and Overlapped Input and Output](synchronization-and-overlapped-input-and-output.md).</span></span> <span data-ttu-id="47f1b-144">如需 Apc 的詳細資訊，請參閱 [非同步程序呼叫](asynchronous-procedure-calls.md)。</span><span class="sxs-lookup"><span data-stu-id="47f1b-144">For more information about APCs, see [Asynchronous Procedure Calls](asynchronous-procedure-calls.md).</span></span>

## <a name="registered-wait-functions"></a><span data-ttu-id="47f1b-145">已註冊的等候函式</span><span class="sxs-lookup"><span data-stu-id="47f1b-145">Registered Wait Functions</span></span>

<span data-ttu-id="47f1b-146">[**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject)函式與其他等候函式不同，因為等候作業是由執行緒 [集](../procthread/thread-pooling.md)區中的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="47f1b-146">The [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) function differs from the other wait functions in that the wait operation is performed by a thread from the [thread pool](../procthread/thread-pooling.md).</span></span> <span data-ttu-id="47f1b-147">當符合指定的條件時，回呼函式會由執行緒集區中的工作者執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="47f1b-147">When the specified conditions are met, the callback function is executed by a worker thread from the thread pool.</span></span>

<span data-ttu-id="47f1b-148">依預設，已註冊的等候作業是一項多等待操作。</span><span class="sxs-lookup"><span data-stu-id="47f1b-148">By default, a registered wait operation is a multiple-wait operation.</span></span> <span data-ttu-id="47f1b-149">系統會在每次發出事件時將計時器重設 (或逾時間隔) 直到您呼叫 [**UnregisterWaitEx**](unregisterwaitex.md) 函式來取消作業為止。</span><span class="sxs-lookup"><span data-stu-id="47f1b-149">The system resets the timer every time the event is signaled (or the time-out interval elapses) until you call the [**UnregisterWaitEx**](unregisterwaitex.md) function to cancel the operation.</span></span> <span data-ttu-id="47f1b-150">若要指定只執行一次等待作業，請將 [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject)的 *dwFlags* 參數設定為 **wt. \_ EXECUTEONLYONCE**。</span><span class="sxs-lookup"><span data-stu-id="47f1b-150">To specify that a wait operation should be executed only once, set the *dwFlags* parameter of [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) to **WT\_EXECUTEONLYONCE**.</span></span>

<span data-ttu-id="47f1b-151">如果執行緒呼叫使用 Apc 的函數，請將 [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject)的 *dwFlags* 參數設定為 **wt. \_ EXECUTEINPERSISTENTTHREAD**。</span><span class="sxs-lookup"><span data-stu-id="47f1b-151">If the thread calls functions that use APCs, set the *dwFlags* parameter of [**RegisterWaitForSingleObject**](/windows/desktop/api/WinBase/nf-winbase-registerwaitforsingleobject) to **WT\_EXECUTEINPERSISTENTTHREAD**.</span></span>

## <a name="waiting-on-an-address"></a><span data-ttu-id="47f1b-152">等候位址</span><span class="sxs-lookup"><span data-stu-id="47f1b-152">Waiting on an Address</span></span>

<span data-ttu-id="47f1b-153">執行緒可以使用 [**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) 函式，等候目標位址的值從某些不想要的值變更為任何其他值。</span><span class="sxs-lookup"><span data-stu-id="47f1b-153">A thread can use the [**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) function to wait for the value of a target address to change from some undesired value to any other value.</span></span> <span data-ttu-id="47f1b-154">這可讓執行緒等候值變更，而不需要微調或處理當執行緒捕捉到不想要的值，但線上程可以等候之前的值變更時可能會發生的同步處理問題。</span><span class="sxs-lookup"><span data-stu-id="47f1b-154">This enables threads to wait for a value to change without having to spin or handle the synchronization problems that can arise when the thread captures an undesired value but the value changes before the thread can wait.</span></span>

<span data-ttu-id="47f1b-155">修改目標值的程式碼會藉由呼叫 [**WakeByAddressSingle**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddresssingle)喚醒單一等候執行緒或 [**WakeByAddressAll**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddressall)來喚醒所有等候中的執行緒，以 [**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress)傳回的變更。</span><span class="sxs-lookup"><span data-stu-id="47f1b-155">[**WaitOnAddress**](/windows/desktop/api/SynchAPI/nf-synchapi-waitonaddress) returns when code that modifies the target value signals the change by calling [**WakeByAddressSingle**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddresssingle) to wake a single waiting thread or [**WakeByAddressAll**](/windows/desktop/api/SynchAPI/nf-synchapi-wakebyaddressall) to wake all waiting threads.</span></span> <span data-ttu-id="47f1b-156">如果使用 **WaitOnAddress** 指定逾時間隔，而且沒有任何執行緒呼叫喚醒函式，則函式會在逾時間隔過期時傳回。</span><span class="sxs-lookup"><span data-stu-id="47f1b-156">If a time-out interval is specified with **WaitOnAddress** and no thread calls a wake function, the function returns when the time-out interval elapses.</span></span> <span data-ttu-id="47f1b-157">如果未指定逾時間隔，執行緒就會無限期等候。</span><span class="sxs-lookup"><span data-stu-id="47f1b-157">If no time-out interval is specified, the thread waits indefinitely.</span></span>

## <a name="wait-functions-and-time-out-intervals"></a><span data-ttu-id="47f1b-158">等候函式和逾時間隔</span><span class="sxs-lookup"><span data-stu-id="47f1b-158">Wait Functions and Time-out Intervals</span></span>

<span data-ttu-id="47f1b-159">指定逾時間隔的精確度取決於系統時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="47f1b-159">The accuracy of the specified time-out interval depends on the resolution of the system clock.</span></span> <span data-ttu-id="47f1b-160">以固定速率的系統時鐘「刻度」。</span><span class="sxs-lookup"><span data-stu-id="47f1b-160">The system clock "ticks" at a constant rate.</span></span> <span data-ttu-id="47f1b-161">如果逾時間隔小於系統時鐘的解析度，等候時間可能會低於指定的時間長度。</span><span class="sxs-lookup"><span data-stu-id="47f1b-161">If the time-out interval is less than the resolution of the system clock, the wait may time out in less than the specified length of time.</span></span> <span data-ttu-id="47f1b-162">如果逾時間隔大於一個刻度但小於二，則等候可以是介於一到兩個刻度之間的任何位置，依此類推。</span><span class="sxs-lookup"><span data-stu-id="47f1b-162">If the time-out interval is greater than one tick but less than two, the wait can be anywhere between one and two ticks, and so on.</span></span>

<span data-ttu-id="47f1b-163">若要增加等候函式的逾時間隔精確度，請呼叫 **timeGetDevCaps** 函式來判斷支援的最小計時器解析度，以及 **timeBeginPeriod** 函數將計時器解析度設定為最小值。</span><span class="sxs-lookup"><span data-stu-id="47f1b-163">To increase the accuracy of the time-out interval for the wait functions, call the **timeGetDevCaps** function to determine the supported minimum timer resolution and the **timeBeginPeriod** function to set the timer resolution to its minimum.</span></span> <span data-ttu-id="47f1b-164">呼叫 **timeBeginPeriod** 時請特別小心，因為頻繁的呼叫可能會大幅影響系統時鐘、系統電源使用量和排程器。</span><span class="sxs-lookup"><span data-stu-id="47f1b-164">Use caution when calling **timeBeginPeriod**, as frequent calls can significantly affect the system clock, system power usage, and the scheduler.</span></span> <span data-ttu-id="47f1b-165">如果您呼叫 **timeBeginPeriod**，請在應用程式初期呼叫它一次，並務必在應用程式的最一端呼叫 **timeEndPeriod** 函式。</span><span class="sxs-lookup"><span data-stu-id="47f1b-165">If you call **timeBeginPeriod**, call it one time early in the application and be sure to call the **timeEndPeriod** function at the very end of the application.</span></span>

## <a name="wait-functions-and-synchronization-objects"></a><span data-ttu-id="47f1b-166">Wait 函數和同步處理物件</span><span class="sxs-lookup"><span data-stu-id="47f1b-166">Wait Functions and Synchronization Objects</span></span>

<span data-ttu-id="47f1b-167">等候函式可以修改某些類型的 [同步處理物件](synchronization-objects.md)的狀態。</span><span class="sxs-lookup"><span data-stu-id="47f1b-167">The wait functions can modify the states of some types of [synchronization objects](synchronization-objects.md).</span></span> <span data-ttu-id="47f1b-168">只有當物件或物件的已發出信號狀態導致函式傳回時，才會進行修改。</span><span class="sxs-lookup"><span data-stu-id="47f1b-168">Modification occurs only for the object or objects whose signaled state caused the function to return.</span></span> <span data-ttu-id="47f1b-169">Wait 函數可以修改同步處理物件的狀態，如下所示：</span><span class="sxs-lookup"><span data-stu-id="47f1b-169">Wait functions can modify the states of synchronization objects as follows:</span></span>

-   <span data-ttu-id="47f1b-170">信號物件的計數會減少1，而且如果其計數為零，則會將信號的狀態設定為未收到信號。</span><span class="sxs-lookup"><span data-stu-id="47f1b-170">The count of a semaphore object decreases by one, and the state of the semaphore is set to nonsignaled if its count is zero.</span></span>
-   <span data-ttu-id="47f1b-171">Mutex、自動重設事件和變更通知物件的狀態會設定為未收到信號。</span><span class="sxs-lookup"><span data-stu-id="47f1b-171">The states of mutex, auto-reset event, and change-notification objects are set to nonsignaled.</span></span>
-   <span data-ttu-id="47f1b-172">同步處理計時器的狀態設定為未收到信號。</span><span class="sxs-lookup"><span data-stu-id="47f1b-172">The state of a synchronization timer is set to nonsignaled.</span></span>
-   <span data-ttu-id="47f1b-173">手動重設事件、手動重設計時器、進程、執行緒和主控台輸入物件的狀態不會受到 wait 函式的影響。</span><span class="sxs-lookup"><span data-stu-id="47f1b-173">The states of manual-reset event, manual-reset timer, process, thread, and console input objects are not affected by a wait function.</span></span>

## <a name="wait-functions-and-creating-windows"></a><span data-ttu-id="47f1b-174">等候函式和建立視窗</span><span class="sxs-lookup"><span data-stu-id="47f1b-174">Wait Functions and Creating Windows</span></span>

<span data-ttu-id="47f1b-175">當您使用直接或間接建立視窗的等候函式和程式碼時，必須特別小心。</span><span class="sxs-lookup"><span data-stu-id="47f1b-175">You have to be careful when using the wait functions and code that directly or indirectly creates windows.</span></span> <span data-ttu-id="47f1b-176">如果執行緒建立任何視窗，則必須處理訊息。</span><span class="sxs-lookup"><span data-stu-id="47f1b-176">If a thread creates any windows, it must process messages.</span></span> <span data-ttu-id="47f1b-177">系統會將訊息廣播傳送至系統中的所有視窗。</span><span class="sxs-lookup"><span data-stu-id="47f1b-177">Message broadcasts are sent to all windows in the system.</span></span> <span data-ttu-id="47f1b-178">如果您有使用 wait 函式且沒有逾時間隔的執行緒，系統將會鎖死。</span><span class="sxs-lookup"><span data-stu-id="47f1b-178">If you have a thread that uses a wait function with no time-out interval, the system will deadlock.</span></span> <span data-ttu-id="47f1b-179">間接建立 windows 的兩個程式碼範例是 DDE 和 **CoInitialize** 函數。</span><span class="sxs-lookup"><span data-stu-id="47f1b-179">Two examples of code that indirectly creates windows are DDE and the **CoInitialize** function.</span></span> <span data-ttu-id="47f1b-180">因此，如果您有建立 windows 的執行緒，請使用 [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) 或 [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)，而不是其他等候函式。</span><span class="sxs-lookup"><span data-stu-id="47f1b-180">Therefore, if you have a thread that creates windows, use [**MsgWaitForMultipleObjects**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjects) or [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), rather than the other wait functions.</span></span>

 

 
