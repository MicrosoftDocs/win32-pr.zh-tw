---
description: 重要區段物件提供的同步處理與 mutex 物件所提供的類似，不同之處在于，只有單一進程的執行緒可以使用重要區段。
ms.assetid: 2ec11a42-3d12-4d60-9dd7-dc38926d56e1
title: 重要區段物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cbcada1f2ddbc6d370445f36a3dbd51c5c9f54bf
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106980407"
---
# <a name="critical-section-objects"></a><span data-ttu-id="34618-103">重要區段物件</span><span class="sxs-lookup"><span data-stu-id="34618-103">Critical Section Objects</span></span>

<span data-ttu-id="34618-104">*重要區段物件* 提供的同步處理與 mutex 物件所提供的類似，不同之處在于，只有單一進程的執行緒可以使用重要區段。</span><span class="sxs-lookup"><span data-stu-id="34618-104">A *critical section object* provides synchronization similar to that provided by a mutex object, except that a critical section can be used only by the threads of a single process.</span></span> <span data-ttu-id="34618-105">不可跨進程共用重要區段物件。</span><span class="sxs-lookup"><span data-stu-id="34618-105">Critical section objects cannot be shared across processes.</span></span>

<span data-ttu-id="34618-106">事件、mutex 和信號物件也可以在單一進程應用程式中使用，但重要區段物件可提供稍微更快、更有效率的機制來進行相互排除的同步處理 (處理器特定的測試和設定指令) 。</span><span class="sxs-lookup"><span data-stu-id="34618-106">Event, mutex, and semaphore objects can also be used in a single-process application, but critical section objects provide a slightly faster, more efficient mechanism for mutual-exclusion synchronization (a processor-specific test and set instruction).</span></span> <span data-ttu-id="34618-107">就像 mutex 物件一樣，一次只能有一個執行緒擁有一個重要區段物件，這有助於保護共用的資源，使其不會同時存取。</span><span class="sxs-lookup"><span data-stu-id="34618-107">Like a mutex object, a critical section object can be owned by only one thread at a time, which makes it useful for protecting a shared resource from simultaneous access.</span></span> <span data-ttu-id="34618-108">與 mutex 物件不同的是，沒有任何方法可分辨是否已放棄重要區段。</span><span class="sxs-lookup"><span data-stu-id="34618-108">Unlike a mutex object, there is no way to tell whether a critical section has been abandoned.</span></span>

<span data-ttu-id="34618-109">從 Windows Server 2003 （含 Service Pack 1） (SP1) 開始，在重要區段上等候的執行緒，並不會以先進先出的基礎來取得重要區段。</span><span class="sxs-lookup"><span data-stu-id="34618-109">Starting with Windows Server 2003 with Service Pack 1 (SP1), threads waiting on a critical section do not acquire the critical section on a first-come, first-serve basis.</span></span> <span data-ttu-id="34618-110">這種變更可大幅提高大部分程式碼的效能。</span><span class="sxs-lookup"><span data-stu-id="34618-110">This change increases performance significantly for most code.</span></span> <span data-ttu-id="34618-111">不過，有些應用程式相依于先進先出 (FIFO) 順序，而且可能會在目前的 (Windows 版本上執行效能不佳的情況，例如，已使用重要區段作為速率限制器) 的應用程式。</span><span class="sxs-lookup"><span data-stu-id="34618-111">However, some applications depend on first-in, first-out (FIFO) ordering and may perform poorly or not at all on current versions of Windows (for example, applications that have been using critical sections as a rate-limiter).</span></span> <span data-ttu-id="34618-112">為了確保您的程式碼能繼續正常運作，您可能需要新增額外的同步處理層級。</span><span class="sxs-lookup"><span data-stu-id="34618-112">To ensure that your code continues to work correctly, you may need to add an additional level of synchronization.</span></span> <span data-ttu-id="34618-113">例如，假設您有一個生產者執行緒和一個取用者執行緒，其使用重要區段物件來同步處理其工作。</span><span class="sxs-lookup"><span data-stu-id="34618-113">For example, suppose you have a producer thread and a consumer thread that are using a critical section object to synchronize their work.</span></span> <span data-ttu-id="34618-114">建立兩個事件物件，每個執行緒都有一個，用來表示它已準備好讓其他執行緒繼續執行。</span><span class="sxs-lookup"><span data-stu-id="34618-114">Create two event objects, one for each thread to use to signal that it is ready for the other thread to proceed.</span></span> <span data-ttu-id="34618-115">取用者執行緒會等待產生者在進入重要區段之前發出其事件的信號，而生產者執行緒會等待取用者執行緒在進入重要區段之前，先對其事件發出信號。</span><span class="sxs-lookup"><span data-stu-id="34618-115">The consumer thread will wait for the producer to signal its event before entering the critical section, and the producer thread will wait for the consumer thread to signal its event before entering the critical section.</span></span> <span data-ttu-id="34618-116">在每個執行緒離開重要區段之後，它會通知其事件釋放另一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="34618-116">After each thread leaves the critical section, it signals its event to release the other thread.</span></span>

<span data-ttu-id="34618-117">**Windows Server 2003 和 WINDOWS XP：** 等候重要區段的執行緒會新增至等候佇列;它們是喚醒的，而且通常會依新增至佇列的順序取得重要區段。</span><span class="sxs-lookup"><span data-stu-id="34618-117">**Windows Server 2003 and Windows XP:** Threads that are waiting on a critical section are added to a wait queue; they are woken and generally acquire the critical section in the order in which they were added to the queue.</span></span> <span data-ttu-id="34618-118">但是，如果以速度夠快的速度將執行緒新增至此佇列，效能可能會因為將每個等候執行緒所需的時間而下降。</span><span class="sxs-lookup"><span data-stu-id="34618-118">However, if threads are added to this queue at a fast enough rate, performance can be degraded because of the time it takes to awaken each waiting thread.</span></span>

<span data-ttu-id="34618-119">此處理程式負責配置重要區段所使用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="34618-119">The process is responsible for allocating the memory used by a critical section.</span></span> <span data-ttu-id="34618-120">一般來說，只要宣告類型 **重要 \_ 區段** 的變數就可以完成這項工作。</span><span class="sxs-lookup"><span data-stu-id="34618-120">Typically, this is done by simply declaring a variable of type **CRITICAL\_SECTION**.</span></span> <span data-ttu-id="34618-121">在進程的執行緒可以使用它之前，請先使用 [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) 或 [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) 函數來初始化重要區段。</span><span class="sxs-lookup"><span data-stu-id="34618-121">Before the threads of the process can use it, initialize the critical section by using the [**InitializeCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection) or [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) function.</span></span>

<span data-ttu-id="34618-122">執行緒使用 [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) 或 [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) 函數來要求重要區段的擁有權。</span><span class="sxs-lookup"><span data-stu-id="34618-122">A thread uses the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="34618-123">它會使用 [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) 函式來釋放重要區段的擁有權。</span><span class="sxs-lookup"><span data-stu-id="34618-123">It uses the [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) function to release ownership of a critical section.</span></span> <span data-ttu-id="34618-124">如果重要區段物件目前是由另一個執行緒所擁有， **EnterCriticalSection** 會無限期等候擁有權。</span><span class="sxs-lookup"><span data-stu-id="34618-124">If the critical section object is currently owned by another thread, **EnterCriticalSection** waits indefinitely for ownership.</span></span> <span data-ttu-id="34618-125">相反地，當 mutex 物件用於相互排除時， [等候](wait-functions.md) 函式會接受指定的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="34618-125">In contrast, when a mutex object is used for mutual exclusion, the [wait functions](wait-functions.md) accept a specified time-out interval.</span></span> <span data-ttu-id="34618-126">**TryEnterCriticalSection** 函式會嘗試進入重要區段，而不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="34618-126">The **TryEnterCriticalSection** function attempts to enter a critical section without blocking the calling thread.</span></span>

<span data-ttu-id="34618-127">當執行緒擁有重要區段時，它可以對 [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) 或 [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) 進行額外的呼叫，而不會封鎖它的執行。</span><span class="sxs-lookup"><span data-stu-id="34618-127">When a thread owns a critical section, it can make additional calls to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) or [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) without blocking its execution.</span></span> <span data-ttu-id="34618-128">這可防止在等候已擁有的重要區段時，死結本身的執行緒。</span><span class="sxs-lookup"><span data-stu-id="34618-128">This prevents a thread from deadlocking itself while waiting for a critical section that it already owns.</span></span> <span data-ttu-id="34618-129">若要釋放其擁有權，執行緒必須在每次進入重要區段時呼叫 [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) 一次。</span><span class="sxs-lookup"><span data-stu-id="34618-129">To release its ownership, the thread must call [**LeaveCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection) one time for each time that it entered the critical section.</span></span> <span data-ttu-id="34618-130">等待中的執行緒取得重要區段擁有權的順序並不會有任何保證。</span><span class="sxs-lookup"><span data-stu-id="34618-130">There is no guarantee about the order in which waiting threads will acquire ownership of the critical section.</span></span>

<span data-ttu-id="34618-131">執行緒使用 [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) 或 [**SetCriticalSectionSpinCount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) 函數來指定重要區段物件的微調計數。</span><span class="sxs-lookup"><span data-stu-id="34618-131">A thread uses the [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) or [**SetCriticalSectionSpinCount**](/windows/win32/api/synchapi/nf-synchapi-setcriticalsectionspincount) function to specify a spin count for the critical section object.</span></span> <span data-ttu-id="34618-132">旋轉表示當執行緒嘗試取得已鎖定的重要區段時，執行緒會進入迴圈、檢查鎖定是否已釋放，如果未釋放鎖定，執行緒就會進入睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="34618-132">Spinning means that when a thread tries to acquire a critical section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not released, the thread goes to sleep.</span></span> <span data-ttu-id="34618-133">在單處理器系統上，會忽略微調計數，並將關鍵區段微調計數設為 0 (零) 。</span><span class="sxs-lookup"><span data-stu-id="34618-133">On single-processor systems, the spin count is ignored and the critical section spin count is set to 0 (zero).</span></span> <span data-ttu-id="34618-134">在多處理器系統上，如果重要區段無法使用，呼叫執行緒會在與重要區段相關聯的信號上執行等候作業之前，先旋轉 *dwSpinCount* 時間。</span><span class="sxs-lookup"><span data-stu-id="34618-134">On multiprocessor systems, if the critical section is unavailable, the calling thread spins *dwSpinCount* times before performing a wait operation on a semaphore that is associated with the critical section.</span></span> <span data-ttu-id="34618-135">如果重要區段在微調作業期間變成可用，則呼叫執行緒會避免等候作業。</span><span class="sxs-lookup"><span data-stu-id="34618-135">If the critical section becomes free during the spin operation, the calling thread avoids the wait operation.</span></span>

<span data-ttu-id="34618-136">進程的任何執行緒都可以使用 [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) 函式來釋放在初始化重要區段物件時所配置的系統資源。</span><span class="sxs-lookup"><span data-stu-id="34618-136">Any thread of the process can use the [**DeleteCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-deletecriticalsection) function to release the system resources that are allocated when the critical section object is initialized.</span></span> <span data-ttu-id="34618-137">呼叫此函式之後，無法使用重要區段物件進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="34618-137">After this function is called, the critical section object cannot be used for synchronization.</span></span>

<span data-ttu-id="34618-138">當重要區段物件擁有時，唯一受影響的其他執行緒是在 [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection)呼叫中等候擁有權的執行緒。</span><span class="sxs-lookup"><span data-stu-id="34618-138">When a critical section object is owned, the only other threads affected are the threads that are waiting for ownership in a call to [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection).</span></span> <span data-ttu-id="34618-139">未等候的執行緒可以繼續執行。</span><span class="sxs-lookup"><span data-stu-id="34618-139">Threads that are not waiting are free to continue running.</span></span>

## <a name="related-topics"></a><span data-ttu-id="34618-140">相關主題</span><span class="sxs-lookup"><span data-stu-id="34618-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="34618-141">Mutex 物件</span><span class="sxs-lookup"><span data-stu-id="34618-141">Mutex Objects</span></span>](mutex-objects.md)
</dt> <dt>

[<span data-ttu-id="34618-142">使用重要區段物件</span><span class="sxs-lookup"><span data-stu-id="34618-142">Using Critical Section Objects</span></span>](using-critical-section-objects.md)
</dt> </dl>

 

 
