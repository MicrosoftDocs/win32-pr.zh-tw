---
description: 命名物件提供簡單的方法，讓處理常式共用物件控制碼。
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: 物件名稱
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106987697"
---
# <a name="object-names"></a><span data-ttu-id="0eb01-103">物件名稱</span><span class="sxs-lookup"><span data-stu-id="0eb01-103">Object Names</span></span>

<span data-ttu-id="0eb01-104">命名物件提供簡單的方法，讓處理常式共用物件控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eb01-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="0eb01-105">在處理常式建立了命名的事件、mutex、信號或計時器物件之後，其他進程就可以使用此名稱來呼叫適當的函式 ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa)、 [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw)、 [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)或 [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) 來開啟物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eb01-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="0eb01-106">名稱比較會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="0eb01-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="0eb01-107">事件、信號、mutex、可等候計時器、檔案對應和工作物件的名稱會共用相同的命名空間。</span><span class="sxs-lookup"><span data-stu-id="0eb01-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="0eb01-108">如果您嘗試使用其他類型的物件所使用的名稱來建立物件，則函式會失敗，而 [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) 會傳回 **錯誤的 \_ \_ 控制碼**。</span><span class="sxs-lookup"><span data-stu-id="0eb01-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="0eb01-109">因此，在建立命名物件時，請使用唯一名稱，並務必檢查函式傳回值中是否有重複名稱錯誤。</span><span class="sxs-lookup"><span data-stu-id="0eb01-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="0eb01-110">如果您嘗試使用相同類型的物件所使用的名稱來建立物件，則函式會成功，並將控制碼傳回至現有的物件，而 [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) 傳回 **錯誤 \_ 已經 \_ 存在**。</span><span class="sxs-lookup"><span data-stu-id="0eb01-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="0eb01-111">例如，如果在對 [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) 函式的呼叫中指定的名稱與現有 mutex 物件的名稱相符，則函式會傳回現有物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="0eb01-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="0eb01-112">在此情況下，呼叫 **CreateMutex** 相當於 [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) 函數的呼叫。</span><span class="sxs-lookup"><span data-stu-id="0eb01-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="0eb01-113">因此，擁有多個處理常式的相同 mutex 使用 **CreateMutex** 相當於擁有一個進程，在其他進程呼叫 **OpenMutex** 時呼叫 **CreateMutex** ，但它不需要確保先啟動建立進程。</span><span class="sxs-lookup"><span data-stu-id="0eb01-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="0eb01-114">不過，針對 mutex 物件使用這項技術時，沒有任何呼叫進程應該要求 mutex 的立即擁有權。</span><span class="sxs-lookup"><span data-stu-id="0eb01-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="0eb01-115">如果有多個處理常式要求立即擁有權，可能會很難預測哪些程式實際獲得初始擁有權。</span><span class="sxs-lookup"><span data-stu-id="0eb01-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="0eb01-116">終端機服務環境具有適用于事件、信號、mutex、可等候計時器、檔案對應物件和工作物件的全域命名空間。</span><span class="sxs-lookup"><span data-stu-id="0eb01-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="0eb01-117">此外，每個終端機服務用戶端會話對於這些物件都有自己的個別命名空間。</span><span class="sxs-lookup"><span data-stu-id="0eb01-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="0eb01-118">終端機服務用戶端進程可以使用具有「全域」或「本機」前置詞的物件名稱 \\ \\ ，在全域或會話命名空間中明確建立物件。</span><span class="sxs-lookup"><span data-stu-id="0eb01-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="0eb01-119">如需詳細資訊，請參閱 [核心物件命名空間](../termserv/kernel-object-namespaces.md)。</span><span class="sxs-lookup"><span data-stu-id="0eb01-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="0eb01-120">使用終端機服務會話來執行快速切換使用者， (每個使用者登入不同的會話) 。</span><span class="sxs-lookup"><span data-stu-id="0eb01-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="0eb01-121">核心物件名稱必須遵循針對終端機服務所述的指導方針，讓應用程式能夠支援多個使用者。</span><span class="sxs-lookup"><span data-stu-id="0eb01-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="0eb01-122">您可以在私用命名空間中建立同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="0eb01-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="0eb01-123">如需詳細資訊，請參閱 [物件命名空間](object-namespaces.md)。</span><span class="sxs-lookup"><span data-stu-id="0eb01-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="0eb01-124">相關主題</span><span class="sxs-lookup"><span data-stu-id="0eb01-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0eb01-125">使用命名物件</span><span class="sxs-lookup"><span data-stu-id="0eb01-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
