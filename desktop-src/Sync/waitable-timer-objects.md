---
description: 可等候計時器物件是一種同步處理物件，其狀態會在指定的到期時間到達時設為已發出信號。
ms.assetid: 5d39ada0-ea31-40d7-b075-aeb657ee508c
title: 可等候計時器物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2b9597617705fcd78bb71f63e33a475e3bca78e3
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106994437"
---
# <a name="waitable-timer-objects"></a><span data-ttu-id="6a509-103">可等候計時器物件</span><span class="sxs-lookup"><span data-stu-id="6a509-103">Waitable Timer Objects</span></span>

<span data-ttu-id="6a509-104">*可等候計時器物件* 是一種同步處理物件，其狀態會在指定的到期時間到達時設為已發出信號。</span><span class="sxs-lookup"><span data-stu-id="6a509-104">A *waitable timer object* is a synchronization object whose state is set to signaled when the specified due time arrives.</span></span> <span data-ttu-id="6a509-105">您可以建立兩種類型的可等候計時器：手動重設和同步處理。</span><span class="sxs-lookup"><span data-stu-id="6a509-105">There are two types of waitable timers that can be created: manual-reset and synchronization.</span></span> <span data-ttu-id="6a509-106">這兩種類型的計時器也可以是週期性計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-106">A timer of either type can also be a periodic timer.</span></span>



| <span data-ttu-id="6a509-107">Object</span><span class="sxs-lookup"><span data-stu-id="6a509-107">Object</span></span>                | <span data-ttu-id="6a509-108">描述</span><span class="sxs-lookup"><span data-stu-id="6a509-108">Description</span></span>                                                                                                                                                                                             |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="6a509-109">手動重設計時器</span><span class="sxs-lookup"><span data-stu-id="6a509-109">manual-reset timer</span></span>    | <span data-ttu-id="6a509-110">在呼叫 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) 來建立新的到期時間之前，其狀態會維持為信號的計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-110">A timer whose state remains signaled until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) is called to establish a new due time.</span></span>                                                                          |
| <span data-ttu-id="6a509-111">同步處理計時器</span><span class="sxs-lookup"><span data-stu-id="6a509-111">synchronization timer</span></span> | <span data-ttu-id="6a509-112">線上程完成計時器物件的等候作業之前，其狀態會維持為信號的計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-112">A timer whose state remains signaled until a thread completes a wait operation on the timer object.</span></span>                                                                                                     |
| <span data-ttu-id="6a509-113">定期計時器</span><span class="sxs-lookup"><span data-stu-id="6a509-113">periodic timer</span></span>        | <span data-ttu-id="6a509-114">每次指定期間過期時，會重新開機的計時器，直到計時器重設或取消為止。</span><span class="sxs-lookup"><span data-stu-id="6a509-114">A timer that is reactivated each time the specified period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="6a509-115">定期計時器是定期手動重設計時器或定期同步處理計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-115">A periodic timer is either a periodic manual-reset timer or a periodic synchronization timer.</span></span> |



 

> [!Note]  
> <span data-ttu-id="6a509-116">當計時器收到信號時，處理器必須執行以處理相關聯的指令。</span><span class="sxs-lookup"><span data-stu-id="6a509-116">When a timer is signaled, the processor must run to process the associated instructions.</span></span> <span data-ttu-id="6a509-117">高頻率的定期計時器會讓處理器持續忙碌，以防止系統以較低的 [電源狀態](../power/system-power-states.md) 維持任何有意義的時間長度。</span><span class="sxs-lookup"><span data-stu-id="6a509-117">High-frequency periodic timers keep the processor continually busy, which prevents the system from remaining in a lower [power state](../power/system-power-states.md) for any meaningful amount of time.</span></span> <span data-ttu-id="6a509-118">這可能會對可攜式電腦的電池壽命和案例造成負面影響，這取決於有效的電源管理（例如大型資料中心）。</span><span class="sxs-lookup"><span data-stu-id="6a509-118">This can have a negative impact on portable computer battery life and scenarios that depend on effective power management, such as large datacenters.</span></span> <span data-ttu-id="6a509-119">為了提高能源效率，請考慮在應用程式中使用以事件為基礎的通知，而不是以時間為基礎的通知。</span><span class="sxs-lookup"><span data-stu-id="6a509-119">For greater energy efficiency, consider using event-based notifications instead of time-based notifications in your application.</span></span> <span data-ttu-id="6a509-120">如果需要計時器，請使用一次發出信號的計時器，而不是定期計時器，或將間隔設定為大於一秒的值。</span><span class="sxs-lookup"><span data-stu-id="6a509-120">If a timer is necessary, use a timer that is signaled once rather than a periodic timer, or set the interval to a value greater than one second.</span></span>

 

<span data-ttu-id="6a509-121">執行緒使用 [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) 或 [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) 函數來建立計時器物件。</span><span class="sxs-lookup"><span data-stu-id="6a509-121">A thread uses the [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) or [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) function to create a timer object.</span></span> <span data-ttu-id="6a509-122">建立執行緒會指定計時器是手動重設計時器或同步處理計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-122">The creating thread specifies whether the timer is a manual-reset timer or a synchronization timer.</span></span> <span data-ttu-id="6a509-123">建立執行緒可以指定計時器物件的名稱。</span><span class="sxs-lookup"><span data-stu-id="6a509-123">The creating thread can specify a name for the timer object.</span></span> <span data-ttu-id="6a509-124">其他進程中的執行緒可以藉由在 [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) 函式的呼叫中指定其名稱，來開啟現有計時器的控制碼。</span><span class="sxs-lookup"><span data-stu-id="6a509-124">Threads in other processes can open a handle to an existing timer by specifying its name in a call to the [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) function.</span></span> <span data-ttu-id="6a509-125">任何具有計時器物件之控制碼的執行緒都可以使用其中一個 [等候](wait-functions.md) 函式來等候計時器狀態設定為已發出信號。</span><span class="sxs-lookup"><span data-stu-id="6a509-125">Any thread with a handle to a timer object can use one of the [wait functions](wait-functions.md) to wait for the timer state to be set to signaled.</span></span>

-   <span data-ttu-id="6a509-126">執行緒會呼叫 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) 函數來啟動計時器。</span><span class="sxs-lookup"><span data-stu-id="6a509-126">The thread calls the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to activate the timer.</span></span> <span data-ttu-id="6a509-127">請注意下列 **SetWaitableTimer** 參數的用法：</span><span class="sxs-lookup"><span data-stu-id="6a509-127">Note the use of the following parameters for **SetWaitableTimer**:</span></span>
-   <span data-ttu-id="6a509-128">使用 *lpDueTime* 參數來指定計時器設定為信號狀態的時間。</span><span class="sxs-lookup"><span data-stu-id="6a509-128">Use the *lpDueTime* parameter to specify the time at which the timer is to be set to the signaled state.</span></span> <span data-ttu-id="6a509-129">當手動重設計時器設定為已發出信號的狀態時，它會維持在此狀態中，直到 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) 建立新的到期時間為止。</span><span class="sxs-lookup"><span data-stu-id="6a509-129">When a manual-reset timer is set to the signaled state, it remains in this state until [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) establishes a new due time.</span></span> <span data-ttu-id="6a509-130">當同步處理計時器設定為已發出信號的狀態時，它會維持在此狀態中，直到執行緒完成計時器物件的等候作業為止。</span><span class="sxs-lookup"><span data-stu-id="6a509-130">When a synchronization timer is set to the signaled state, it remains in this state until a thread completes a wait operation on the timer object.</span></span>
-   <span data-ttu-id="6a509-131">使用 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer)函數的 *lPeriod* 參數來指定計時器週期。</span><span class="sxs-lookup"><span data-stu-id="6a509-131">Use the *lPeriod* parameter of the [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) function to specify the timer period.</span></span> <span data-ttu-id="6a509-132">如果句號不是零，則計時器是定期計時器;它會在每次過期期間重新開機，直到計時器重設或取消為止。</span><span class="sxs-lookup"><span data-stu-id="6a509-132">If the period is not zero, the timer is a periodic timer; it is reactivated each time the period expires, until the timer is reset or canceled.</span></span> <span data-ttu-id="6a509-133">如果句號為零，則計時器不是定期計時器;它會發出一次信號，然後停用。</span><span class="sxs-lookup"><span data-stu-id="6a509-133">If the period is zero, the timer is not a periodic timer; it is signaled once and then deactivated.</span></span>

<span data-ttu-id="6a509-134">執行緒可以使用 [**CancelWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) 函數將計時器設為非使用中狀態。</span><span class="sxs-lookup"><span data-stu-id="6a509-134">A thread can use the [**CancelWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) function to set the timer to the inactive state.</span></span> <span data-ttu-id="6a509-135">若要重設計時器，請呼叫 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer)。</span><span class="sxs-lookup"><span data-stu-id="6a509-135">To reset the timer, call [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer).</span></span> <span data-ttu-id="6a509-136">當您完成計時器物件時，請呼叫 [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) 來關閉計時器物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="6a509-136">When you are finished with the timer object, call [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) to close the handle to the timer object.</span></span>

<span data-ttu-id="6a509-137">可等候計時器的行為可摘要如下：</span><span class="sxs-lookup"><span data-stu-id="6a509-137">The behavior of a waitable timer can be summarized as follows:</span></span>

-   <span data-ttu-id="6a509-138">設定計時器之後，如果計時器已在使用中，則會將其取消，計時器的狀態為未收到信號，而計時器則放置於核心計時器佇列中。</span><span class="sxs-lookup"><span data-stu-id="6a509-138">When a timer is set, it is canceled if it was already active, the state of the timer is nonsignaled, and the timer is placed in the kernel timer queue.</span></span>
-   <span data-ttu-id="6a509-139">當計時器過期時，計時器會設定為已發出信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="6a509-139">When a timer expires, the timer is set to the signaled state.</span></span> <span data-ttu-id="6a509-140">如果計時器有完成常式，則會將它排入設定計時器的執行緒佇列。</span><span class="sxs-lookup"><span data-stu-id="6a509-140">If the timer has a completion routine, it is queued to the thread that set the timer.</span></span> <span data-ttu-id="6a509-141">完成常式會線上程進入可提供警示等候狀態之前，線上程的 (APC) 佇列中保持在 [非同步程序呼叫](asynchronous-procedure-calls.md) 中。</span><span class="sxs-lookup"><span data-stu-id="6a509-141">The completion routine remains in the [asynchronous procedure call](asynchronous-procedure-calls.md) (APC) queue of the thread until the thread enters an alertable wait state.</span></span> <span data-ttu-id="6a509-142">屆時，會分派 APC 並呼叫完成常式。</span><span class="sxs-lookup"><span data-stu-id="6a509-142">At that time, the APC is dispatched and the completion routine is called.</span></span> <span data-ttu-id="6a509-143">如果計時器是週期性的，則會將它放回核心計時器佇列中。</span><span class="sxs-lookup"><span data-stu-id="6a509-143">If the timer is periodic, it is placed back in the kernel timer queue.</span></span>
-   <span data-ttu-id="6a509-144">當計時器取消時，它會從核心計時器佇列中移除（如果已暫止）。</span><span class="sxs-lookup"><span data-stu-id="6a509-144">When a timer is canceled, it is removed from the kernel timer queue if it was pending.</span></span> <span data-ttu-id="6a509-145">如果計時器已過期，但仍有一個 APC 排入設定計時器的執行緒，則會從執行緒的 APC 佇列中移除 APC。</span><span class="sxs-lookup"><span data-stu-id="6a509-145">If the timer had expired and there is still an APC queued to the thread that set the timer, the APC is removed from the thread's APC queue.</span></span> <span data-ttu-id="6a509-146">計時器的信號狀態不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="6a509-146">The signaled state of the timer is not affected.</span></span>

## <a name="related-topics"></a><span data-ttu-id="6a509-147">相關主題</span><span class="sxs-lookup"><span data-stu-id="6a509-147">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6a509-148">非同步程序呼叫</span><span class="sxs-lookup"><span data-stu-id="6a509-148">Asynchronous Procedure Calls</span></span>](asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="6a509-149">使用可等候計時器物件</span><span class="sxs-lookup"><span data-stu-id="6a509-149">Using Waitable Timer Objects</span></span>](using-waitable-timer-objects.md)
</dt> </dl>

 

 
