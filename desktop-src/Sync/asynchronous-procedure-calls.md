---
description: " (APC) 的非同步程序呼叫，是在特定執行緒內容中以非同步方式執行的函式。"
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: 非同步程序呼叫
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103944743"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="e6c5e-103">非同步程序呼叫</span><span class="sxs-lookup"><span data-stu-id="e6c5e-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="e6c5e-104"> (APC) 的 *非同步程序呼叫* ，是在特定執行緒內容中以非同步方式執行的函式。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="e6c5e-105">當 APC 排入執行緒佇列時，系統會發出軟體插斷。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="e6c5e-106">下次排程執行緒時，它會執行 APC 函數。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="e6c5e-107">系統所產生的 APC 稱為 *核心模式 apc*。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="e6c5e-108">應用程式所產生的一個 APC 稱為 *使用者模式*。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="e6c5e-109">執行緒必須處於可提供警示狀態，才能執行使用者模式的 APC。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="e6c5e-110">每個執行緒都有自己的 APC 佇列。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="e6c5e-111">應用程式會藉由呼叫 [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) 函式，將 APC 排入執行緒佇列。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="e6c5e-112">呼叫執行緒會在呼叫 **QueueUserAPC** 時指定 APC 函數的位址。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="e6c5e-113">APC 的佇列是要求執行緒呼叫 APC 函數的要求。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="e6c5e-114">當使用者模式 APC 排入佇列時，除非它處於可提供警示狀態，否則它排入佇列的執行緒不會被導向呼叫 APC 函數。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="e6c5e-115">執行緒在呼叫 [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex)、 [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait)、 [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex)、 [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)或 [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) 函數時進入可提供警示狀態。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="e6c5e-116">如果在 APC 排入佇列之前滿足等候，執行緒就不再處於可提供警示等候狀態，因此不會執行 APC 函數。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="e6c5e-117">不過，APC 仍會排入佇列，所以當執行緒呼叫另一個可提供警示 wait 函式時，就會執行 APC 函數。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="e6c5e-118">[**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex)、 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer)、 [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)和 [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex)函式是使用 APC 作為完成通知回呼機制來執行。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="e6c5e-119">如果您使用 [執行緒集](../procthread/thread-pools.md)區，請注意，apc 無法運作，以及其他信號機制，因為系統會控制執行緒集區執行緒的存留期，因此在傳遞通知之前，執行緒可能會終止。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="e6c5e-120">與其使用以 APC 為基礎的信號機制（例如 [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer)或 [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)的 *pfnCompletionRoutine* 參數），您不需要使用可等候物件，例如使用 [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer)建立的計時器。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="e6c5e-121">針對 i/o，請使用以 [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio)建立的 i/o 完成物件或以 *hEvent*[**為基礎的**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped)重迭結構，其中事件可傳遞至 [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait)函數。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="e6c5e-122">同步處理內部</span><span class="sxs-lookup"><span data-stu-id="e6c5e-122">Synchronization Internals</span></span>

<span data-ttu-id="e6c5e-123">發出 i/o 要求時，會配置結構以代表要求。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="e6c5e-124">此結構稱為 i/o 要求封包 (IRP) 。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="e6c5e-125">使用同步 i/o 時，執行緒會建立 IRP、將它傳送至裝置堆疊，並在核心中等待 IRP 完成。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="e6c5e-126">使用非同步 i/o 時，執行緒會建立 IRP，並將其傳送至裝置堆疊。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="e6c5e-127">堆疊可能會立即完成 IRP，或可能會傳回暫止狀態，表示要求正在進行中。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="e6c5e-128">發生這種情況時，IRP 仍會與執行緒相關聯，因此如果執行緒終止或呼叫函式（例如 [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio)），就會取消此作業。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="e6c5e-129">在此同時，當裝置堆疊繼續處理 IRP 時，執行緒可以繼續執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="e6c5e-130">有幾種方式可讓系統指出 IRP 已完成：</span><span class="sxs-lookup"><span data-stu-id="e6c5e-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="e6c5e-131">將重迭的結構更新為作業的結果，讓執行緒可以進行輪詢，以判斷作業是否已完成。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="e6c5e-132">以重迭的結構表示事件，讓執行緒可以在事件上進行同步處理，並在作業完成時喚醒。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="e6c5e-133">將 IRP 排入執行緒的擱置中，使執行緒在進入可提供警示等候狀態並從等待作業傳回時執行 APC 常式，並將狀態指出它已執行一或多個 APC 常式。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="e6c5e-134">將 IRP 排入 i/o 完成埠的佇列，以等候完成埠的下一個執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="e6c5e-135">等候 i/o 完成埠的執行緒不會在可提供警示狀態等候。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="e6c5e-136">因此，如果這些執行緒發出的 Irp 設定為完成執行緒的 Apc，這些 IPC 完成將不會及時發生;只有當執行緒從 i/o 完成埠收取要求，然後進入可提供警示等候時，才會發生這些情況。</span><span class="sxs-lookup"><span data-stu-id="e6c5e-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e6c5e-137">相關主題</span><span class="sxs-lookup"><span data-stu-id="e6c5e-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e6c5e-138">使用具有非同步程序呼叫的可等候計時器</span><span class="sxs-lookup"><span data-stu-id="e6c5e-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
