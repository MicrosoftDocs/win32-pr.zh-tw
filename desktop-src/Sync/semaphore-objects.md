---
description: 信號物件是一種同步處理物件，可維護介於零和指定最大值之間的計數。
ms.assetid: d9da1d98-a306-4e2d-a149-1eef6a724751
title: 信號物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a77f36313d76c5d98c786a76f10ad8439965f180
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106981206"
---
# <a name="semaphore-objects"></a><span data-ttu-id="c1072-103">信號物件</span><span class="sxs-lookup"><span data-stu-id="c1072-103">Semaphore Objects</span></span>

<span data-ttu-id="c1072-104">*信號物件* 是一種同步處理物件，可維護介於零和指定最大值之間的計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-104">A *semaphore object* is a synchronization object that maintains a count between zero and a specified maximum value.</span></span> <span data-ttu-id="c1072-105">每次執行緒完成信號物件的等候，而且每次執行緒釋放信號時，就會增加計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-105">The count is decremented each time a thread completes a wait for the semaphore object and incremented each time a thread releases the semaphore.</span></span> <span data-ttu-id="c1072-106">當計數達到零時，就不會有其他執行緒成功等候信號物件狀態變成已發出信號。</span><span class="sxs-lookup"><span data-stu-id="c1072-106">When the count reaches zero, no more threads can successfully wait for the semaphore object state to become signaled.</span></span> <span data-ttu-id="c1072-107">旗號的狀態會在其計數大於零時設定為已收到訊號，並在計數為零時設定為未收到訊號。</span><span class="sxs-lookup"><span data-stu-id="c1072-107">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>

<span data-ttu-id="c1072-108">在控制可支援有限使用者數量的共用資源時，信號物件相當有用。</span><span class="sxs-lookup"><span data-stu-id="c1072-108">The semaphore object is useful in controlling a shared resource that can support a limited number of users.</span></span> <span data-ttu-id="c1072-109">它會將共用資源的執行緒數目限制為指定的最大數目，作為閘道。</span><span class="sxs-lookup"><span data-stu-id="c1072-109">It acts as a gate that limits the number of threads sharing the resource to a specified maximum number.</span></span> <span data-ttu-id="c1072-110">例如，應用程式可能會限制其所建立的視窗數目。</span><span class="sxs-lookup"><span data-stu-id="c1072-110">For example, an application might place a limit on the number of windows that it creates.</span></span> <span data-ttu-id="c1072-111">它會使用最大計數等於視窗限制的信號，並在每次建立視窗時遞減計數，並在視窗關閉時遞增。</span><span class="sxs-lookup"><span data-stu-id="c1072-111">It uses a semaphore with a maximum count equal to the window limit, decrementing the count whenever a window is created and incrementing it whenever a window is closed.</span></span> <span data-ttu-id="c1072-112">應用程式會在每個視窗建立之前，指定呼叫其中一個 [等候函數](wait-functions.md) 的信號物件。</span><span class="sxs-lookup"><span data-stu-id="c1072-112">The application specifies the semaphore object in call to one of the [wait functions](wait-functions.md) before each window is created.</span></span> <span data-ttu-id="c1072-113">當計數為零時（表示已達到視窗限制），等候函式會封鎖視窗建立程式碼的執行。</span><span class="sxs-lookup"><span data-stu-id="c1072-113">When the count is zero—indicating that the window limit has been reached—the wait function blocks execution of the window-creation code.</span></span>

<span data-ttu-id="c1072-114">執行緒使用 [**CreateSemaphore**](/windows/desktop/api/WinBase/nf-winbase-createsemaphorea) 或 [**CreateSemaphoreEx**](/windows/desktop/api/WinBase/nf-winbase-createsemaphoreexa) 函數來建立信號物件。</span><span class="sxs-lookup"><span data-stu-id="c1072-114">A thread uses the [**CreateSemaphore**](/windows/desktop/api/WinBase/nf-winbase-createsemaphorea) or [**CreateSemaphoreEx**](/windows/desktop/api/WinBase/nf-winbase-createsemaphoreexa) function to create a semaphore object.</span></span> <span data-ttu-id="c1072-115">建立執行緒會指定物件之計數的初始計數和最大值。</span><span class="sxs-lookup"><span data-stu-id="c1072-115">The creating thread specifies the initial count and the maximum value of the count for the object.</span></span> <span data-ttu-id="c1072-116">初始計數必須小於零，也不能大於最大值。</span><span class="sxs-lookup"><span data-stu-id="c1072-116">The initial count must be neither less than zero nor greater than the maximum value.</span></span> <span data-ttu-id="c1072-117">建立執行緒也可以指定信號物件的名稱。</span><span class="sxs-lookup"><span data-stu-id="c1072-117">The creating thread can also specify a name for the semaphore object.</span></span> <span data-ttu-id="c1072-118">其他進程中的執行緒可以藉由在 [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew) 函式的呼叫中指定其名稱，來開啟現有信號物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="c1072-118">Threads in other processes can open a handle to an existing semaphore object by specifying its name in a call to the [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew) function.</span></span> <span data-ttu-id="c1072-119">如需 mutex、事件、信號和計時器物件之名稱的詳細資訊，請參閱 [進程間同步](interprocess-synchronization.md)處理。</span><span class="sxs-lookup"><span data-stu-id="c1072-119">For additional information about names for mutex, event, semaphore, and timer objects, see [Interprocess Synchronization](interprocess-synchronization.md).</span></span>

<span data-ttu-id="c1072-120">如果有一個以上的執行緒正在等候信號，則會選取等候中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="c1072-120">If more than one thread is waiting on a semaphore, a waiting thread is selected.</span></span> <span data-ttu-id="c1072-121">請勿採用先進先出 (FIFO) 順序。</span><span class="sxs-lookup"><span data-stu-id="c1072-121">Do not assume a first-in, first-out (FIFO) order.</span></span> <span data-ttu-id="c1072-122">外來事件（例如核心模式 Apc）可以變更等候順序。</span><span class="sxs-lookup"><span data-stu-id="c1072-122">External events such as kernel-mode APCs can change the wait order.</span></span>

<span data-ttu-id="c1072-123">每次 [等候](wait-functions.md) 函式的其中一個因為信號的狀態設為「已發出信號」而傳回，則信號的計數會減少一。</span><span class="sxs-lookup"><span data-stu-id="c1072-123">Each time one of the [wait functions](wait-functions.md) returns because the state of a semaphore was set to signaled, the count of the semaphore is decreased by one.</span></span> <span data-ttu-id="c1072-124">[**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore)函式會以指定的數量來增加信號的計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-124">The [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) function increases a semaphore's count by a specified amount.</span></span> <span data-ttu-id="c1072-125">計數絕不能小於零或大於最大值。</span><span class="sxs-lookup"><span data-stu-id="c1072-125">The count can never be less than zero or greater than the maximum value.</span></span>

<span data-ttu-id="c1072-126">信號的初始計數通常會設定為最大值。</span><span class="sxs-lookup"><span data-stu-id="c1072-126">The initial count of a semaphore is typically set to the maximum value.</span></span> <span data-ttu-id="c1072-127">然後，會在取用受保護的資源時，從該層級遞減計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-127">The count is then decremented from that level as the protected resource is consumed.</span></span> <span data-ttu-id="c1072-128">或者，您可以建立初始計數為零的信號，以在應用程式初始化時封鎖對受保護資源的存取。</span><span class="sxs-lookup"><span data-stu-id="c1072-128">Alternatively, you can create a semaphore with an initial count of zero to block access to the protected resource while the application is being initialized.</span></span> <span data-ttu-id="c1072-129">初始化之後，您可以使用 [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) 將計數遞增到最大值。</span><span class="sxs-lookup"><span data-stu-id="c1072-129">After initialization, you can use [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) to increment the count to the maximum value.</span></span>

<span data-ttu-id="c1072-130">擁有 mutex 物件的執行緒可以針對相同的 mutex 物件重複等候，使其不會被封鎖。</span><span class="sxs-lookup"><span data-stu-id="c1072-130">A thread that owns a mutex object can wait repeatedly for the same mutex object to become signaled without its execution becoming blocked.</span></span> <span data-ttu-id="c1072-131">但是，針對相同的信號物件重複等候的執行緒，會在每次等候作業完成時遞減信號的計數;當計數到達零時，會封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="c1072-131">A thread that waits repeatedly for the same semaphore object, however, decrements the semaphore's count each time a wait operation is completed; the thread is blocked when the count gets to zero.</span></span> <span data-ttu-id="c1072-132">同樣地，只有擁有 mutex 的執行緒可以成功呼叫 [**ReleaseMutex**](/windows/win32/api/synchapi/nf-synchapi-releasemutex) 函式，不過任何執行緒都可以使用 [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) 來增加信號物件的計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-132">Similarly, only the thread that owns a mutex can successfully call the [**ReleaseMutex**](/windows/win32/api/synchapi/nf-synchapi-releasemutex) function, though any thread can use [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) to increase the count of a semaphore object.</span></span>

<span data-ttu-id="c1072-133">執行緒可以在對任何 [等候](wait-functions.md)函式的呼叫中重複指定相同的信號物件，藉此遞減信號的計數。</span><span class="sxs-lookup"><span data-stu-id="c1072-133">A thread can decrement a semaphore's count more than once by repeatedly specifying the same semaphore object in calls to any of the [wait functions](wait-functions.md).</span></span> <span data-ttu-id="c1072-134">不過，使用包含相同信號之多個控制碼的陣列來呼叫其中一個多物件等候函式，不會導致多個遞減。</span><span class="sxs-lookup"><span data-stu-id="c1072-134">However, calling one of the multiple-object wait functions with an array that contains multiple handles of the same semaphore does not result in multiple decrements.</span></span>

<span data-ttu-id="c1072-135">當您完成使用信號物件時，請呼叫 [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) 函數來關閉控制碼。</span><span class="sxs-lookup"><span data-stu-id="c1072-135">When you have finished using the semaphore object, call the [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) function to close the handle.</span></span> <span data-ttu-id="c1072-136">當最後一個控制碼關閉時，就會終結信號物件。</span><span class="sxs-lookup"><span data-stu-id="c1072-136">The semaphore object is destroyed when its last handle has been closed.</span></span> <span data-ttu-id="c1072-137">關閉控制碼並不會影響信號計數;因此，請務必在關閉控制碼之前或進程終止之前呼叫 [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) 。</span><span class="sxs-lookup"><span data-stu-id="c1072-137">Closing the handle does not affect the semaphore count; therefore, be sure to call [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) before closing the handle or before the process terminates.</span></span> <span data-ttu-id="c1072-138">否則，暫止的等候作業可能會無限期或繼續無限期，視是否已指定超時值而定。</span><span class="sxs-lookup"><span data-stu-id="c1072-138">Otherwise, pending wait operations will either time out or continue indefinitely, depending on whether a time-out value has been specified.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c1072-139">相關主題</span><span class="sxs-lookup"><span data-stu-id="c1072-139">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="c1072-140">使用信號物件</span><span class="sxs-lookup"><span data-stu-id="c1072-140">Using Semaphore Objects</span></span>](using-semaphore-objects.md)
</dt> </dl>

 

 
