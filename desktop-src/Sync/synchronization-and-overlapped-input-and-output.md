---
description: 您可以在檔案、具名管道和序列通訊裝置上執行同步或非同步 (也稱為重迭) i/o 作業。
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: 同步處理和重迭的輸入和輸出
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e263bb39badc7cbfadd67d80eb169dc1fe6d6c35
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106978360"
---
# <a name="synchronization-and-overlapped-input-and-output"></a><span data-ttu-id="21fc2-103">同步處理和重迭的輸入和輸出</span><span class="sxs-lookup"><span data-stu-id="21fc2-103">Synchronization and Overlapped Input and Output</span></span>

<span data-ttu-id="21fc2-104">您可以在檔案、具名管道和序列通訊裝置上執行同步或非同步 (也稱為重迭) i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="21fc2-104">You can perform either synchronous or asynchronous (also called overlapped) I/O operations on files, named pipes, and serial communications devices.</span></span> <span data-ttu-id="21fc2-105">[**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile)、 [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile)、 [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol)、 [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent)、 [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)和 [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)函數可以同步或非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="21fc2-105">The [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe), and [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) functions can be performed either synchronously or asynchronously.</span></span> <span data-ttu-id="21fc2-106">[**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex)和 [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex)函數只能以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="21fc2-106">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions can be performed only asynchronously.</span></span>

<span data-ttu-id="21fc2-107">以同步方式執行函式時，會等到作業完成時才會傳回。</span><span class="sxs-lookup"><span data-stu-id="21fc2-107">When a function is executed synchronously, it does not return until the operation has been completed.</span></span> <span data-ttu-id="21fc2-108">這表示，呼叫執行緒的執行可能會在等候耗時的作業完成時，封鎖無限期的執行時間。</span><span class="sxs-lookup"><span data-stu-id="21fc2-108">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to finish.</span></span> <span data-ttu-id="21fc2-109">針對重迭作業呼叫的函式可能會立即傳回，即使作業尚未完成也一樣。</span><span class="sxs-lookup"><span data-stu-id="21fc2-109">Functions called for overlapped operation can return immediately, even though the operation has not been completed.</span></span> <span data-ttu-id="21fc2-110">這可讓您在背景執行耗時的 i/o 作業，而呼叫執行緒可以自由執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="21fc2-110">This enables a time-consuming I/O operation to be executed in the background while the calling thread is free to perform other tasks.</span></span> <span data-ttu-id="21fc2-111">例如，單一執行緒可以在不同的控制碼上執行同時的 i/o 作業，或在相同的控制碼上執行同時的讀取和寫入作業。</span><span class="sxs-lookup"><span data-stu-id="21fc2-111">For example, a single thread can perform simultaneous I/O operations on different handles, or even simultaneous read and write operations on the same handle.</span></span>

<span data-ttu-id="21fc2-112">為了在完成重迭的作業時同步處理其執行，呼叫執行緒會使用 [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) 函式、 [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) 函式或其中一個 [等候](wait-functions.md) 函式來判斷已完成重迭作業的時間。</span><span class="sxs-lookup"><span data-stu-id="21fc2-112">To synchronize its execution with the completion of the overlapped operation, the calling thread uses the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, the [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function, or one of the [wait functions](wait-functions.md) to determine when the overlapped operation has been completed.</span></span> <span data-ttu-id="21fc2-113">您也可以使用 [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) 宏來輪詢是否完成。</span><span class="sxs-lookup"><span data-stu-id="21fc2-113">You can also use the [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) macro to poll for completion.</span></span>

<span data-ttu-id="21fc2-114">若要取消所有暫止的非同步 i/o 作業，請使用 [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) 函數，並 [**提供可指定**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) 要取消之要求的重迭結構。</span><span class="sxs-lookup"><span data-stu-id="21fc2-114">To cancel all pending asynchronous I/O operations, use the [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) function and provide an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure that specifies the request to cancel.</span></span> <span data-ttu-id="21fc2-115">您可以使用 [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) 函式來取消呼叫執行緒針對指定檔案控制代碼發出的暫止非同步 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="21fc2-115">Use the [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) function to cancel pending asynchronous I/O operations issued by the calling thread for the specified file handle.</span></span>

<span data-ttu-id="21fc2-116">重迭作業需要使用檔案旗標重迭旗標建立的檔案、命名 **管道 \_ \_** 或通訊裝置。</span><span class="sxs-lookup"><span data-stu-id="21fc2-116">Overlapped operations require a file, named pipe, or communications device that was created with the **FILE\_FLAG\_OVERLAPPED** flag.</span></span> <span data-ttu-id="21fc2-117">當執行緒呼叫函式 (例如 [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) 函式) 來執行重迭的作業時，呼叫的執行緒必須指定重 [**迭結構的**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) 指標。</span><span class="sxs-lookup"><span data-stu-id="21fc2-117">When a thread calls a function (such as the [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) function) to perform an overlapped operation, the calling thread must specify a pointer to an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="21fc2-118"> (如果此指標為 **Null**，則函式傳回值可能會不正確地表示作業已完成。 ) 重 **迭結構的** 所有成員都必須初始化為零，除非事件將用來指示 i/o 作業的完成。</span><span class="sxs-lookup"><span data-stu-id="21fc2-118">(If this pointer is **NULL**, the function return value may incorrectly indicate that the operation completed.) All of the members of the **OVERLAPPED** structure must be initialized to zero unless an event will be used to signal completion of an I/O operation.</span></span> <span data-ttu-id="21fc2-119">如果使用事件，重 **迭結構的** **hEvent** 成員會指定已配置事件物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="21fc2-119">If an event is used, the **hEvent** member of the **OVERLAPPED** structure specifies a handle to the allocated event object.</span></span> <span data-ttu-id="21fc2-120">系統會在作業完成之前，將事件物件的狀態設定為未收到信號，以進行 i/o 函數的呼叫。</span><span class="sxs-lookup"><span data-stu-id="21fc2-120">The system sets the state of the event object to nonsignaled when a call to the I/O function returns before the operation has been completed.</span></span> <span data-ttu-id="21fc2-121">當作業完成時，系統會將事件物件的狀態設定為收到信號。</span><span class="sxs-lookup"><span data-stu-id="21fc2-121">The system sets the state of the event object to signaled when the operation has been completed.</span></span> <span data-ttu-id="21fc2-122">只有在同時有一個以上的未處理 i/o 作業時，才需要事件。</span><span class="sxs-lookup"><span data-stu-id="21fc2-122">An event is needed only if there will be more than one outstanding I/O operation at the same time.</span></span> <span data-ttu-id="21fc2-123">如果未使用事件，每個完成的 i/o 作業都會表示檔案、具名管道或通訊裝置。</span><span class="sxs-lookup"><span data-stu-id="21fc2-123">If an event is not used, each completed I/O operation will signal the file, named pipe, or communications device.</span></span>

<span data-ttu-id="21fc2-124">當呼叫函式來執行重迭的作業時，作業可能會在函數傳回之前完成。</span><span class="sxs-lookup"><span data-stu-id="21fc2-124">When a function is called to perform an overlapped operation, the operation might be completed before the function returns.</span></span> <span data-ttu-id="21fc2-125">發生這種情況時，會以同步方式執行作業的方式來處理結果。</span><span class="sxs-lookup"><span data-stu-id="21fc2-125">When this happens, the results are handled as if the operation had been performed synchronously.</span></span> <span data-ttu-id="21fc2-126">但是，如果作業未完成，則函式的傳回值為 **FALSE**，而 [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) 函式會傳回 **錯誤 \_ IO \_ 暫** 止。</span><span class="sxs-lookup"><span data-stu-id="21fc2-126">If the operation was not completed, however, the function's return value is **FALSE**, and the [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns **ERROR\_IO\_PENDING**.</span></span>

<span data-ttu-id="21fc2-127">執行緒可以透過下列兩種方法之一來管理重迭的作業：</span><span class="sxs-lookup"><span data-stu-id="21fc2-127">A thread can manage overlapped operations by either of two methods:</span></span>

-   <span data-ttu-id="21fc2-128">使用 [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) 或 [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) 函式來等候重迭的作業完成。</span><span class="sxs-lookup"><span data-stu-id="21fc2-128">Use the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function to wait for the overlapped operation to be completed.</span></span> <span data-ttu-id="21fc2-129">如果使用 **GetOverlappedResultEx** ，呼叫執行緒可以指定重迭作業的超時，或執行可提供警示等候。</span><span class="sxs-lookup"><span data-stu-id="21fc2-129">If **GetOverlappedResultEx** is used, the calling thread can specify a timeout for the overlapped operation or perform an alertable wait.</span></span>
-   <span data-ttu-id="21fc2-130">在其中一個 [等候](wait-functions.md)函式中，指定重設成重 [**設的事件**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped)物件的控制碼，然後在 wait 函數傳回之後，呼叫 [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult)或 [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex)。</span><span class="sxs-lookup"><span data-stu-id="21fc2-130">Specify a handle to the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure's manual-reset event object in one of the [wait functions](wait-functions.md) and then, after the wait function returns, call [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex).</span></span> <span data-ttu-id="21fc2-131">此函式會傳回已完成重迭作業的結果，以及適合這類資訊的函式，它會報告已傳送的實際位元組數目。</span><span class="sxs-lookup"><span data-stu-id="21fc2-131">The function returns the results of the completed overlapped operation, and for functions in which such information is appropriate, it reports the actual number of bytes that were transferred.</span></span>

<span data-ttu-id="21fc2-132">在單一執行緒上執行多個同時重迭的作業時，呼叫的執行緒 [**必須為每**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) 個作業指定一個重迭的結構。</span><span class="sxs-lookup"><span data-stu-id="21fc2-132">When performing multiple simultaneous overlapped operations on a single thread, the calling thread must specify an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure for each operation.</span></span> <span data-ttu-id="21fc2-133">每個重迭的 **結構都必須** 指定不同的手動重設事件物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="21fc2-133">Each **OVERLAPPED** structure must specify a handle to a different manual-reset event object.</span></span> <span data-ttu-id="21fc2-134">為了等候任何一個重迭的作業完成，執行緒會將所有手動重設的事件控制碼指定為其中一個多物件 [等候](wait-functions.md)函式中的等候準則。</span><span class="sxs-lookup"><span data-stu-id="21fc2-134">To wait for any one of the overlapped operations to be completed, the thread specifies all the manual-reset event handles as wait criteria in one of the multiple-object [wait functions](wait-functions.md).</span></span> <span data-ttu-id="21fc2-135">多物件等候函式的傳回值會指出已發出的手動重設事件物件已收到信號，所以執行緒可以判斷哪一個重迭作業導致等候作業完成。</span><span class="sxs-lookup"><span data-stu-id="21fc2-135">The return value of the multiple-object wait function indicates which manual-reset event object was signaled, so the thread can determine which overlapped operation caused the wait operation to be completed.</span></span>

<span data-ttu-id="21fc2-136">您可以更安全地針對每個重迭的作業使用個別的事件物件，而不是指定事件物件，或針對多個作業重複使用相同的事件物件。</span><span class="sxs-lookup"><span data-stu-id="21fc2-136">It is safer to use a separate event object for each overlapped operation, rather than specify no event object or reuse the same event object for multiple operations.</span></span> <span data-ttu-id="21fc2-137">如果 [**未在重迭的結構中**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) 指定事件物件，系統會在重迭的作業完成時，表示檔案、具名管道或通訊裝置的狀態。</span><span class="sxs-lookup"><span data-stu-id="21fc2-137">If no event object is specified in the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure, the system signals the state of the file, named pipe, or communications device when the overlapped operation has been completed.</span></span> <span data-ttu-id="21fc2-138">因此，您可以將這些控制碼指定為 wait 函式中的同步處理物件，雖然它們的用途可能很難管理，因為當在相同的檔案、具名管道或通訊裝置上執行同時重迭的作業時，並沒有辦法知道哪些作業導致物件的狀態被告知。</span><span class="sxs-lookup"><span data-stu-id="21fc2-138">Thus, you can specify these handles as synchronization objects in a wait function, though their use for this purpose can be difficult to manage because, when performing simultaneous overlapped operations on the same file, named pipe, or communications device, there is no way to know which operation caused the object's state to be signaled.</span></span>

<span data-ttu-id="21fc2-139">執行緒不應該重複使用事件，因為假設事件只會由該執行緒的重迭運算發出信號。</span><span class="sxs-lookup"><span data-stu-id="21fc2-139">A thread should not reuse an event with the assumption that the event will be signaled only by that thread's overlapped operation.</span></span> <span data-ttu-id="21fc2-140">事件會在與正在完成的重迭作業相同的執行緒上收到信號。</span><span class="sxs-lookup"><span data-stu-id="21fc2-140">An event is signaled on the same thread as the overlapped operation that is completing.</span></span> <span data-ttu-id="21fc2-141">在多個執行緒上使用相同的事件可能會導致競爭情形，在此情況中，其作業會針對使用該事件的其他執行緒先和提前完成的執行緒正確地發出信號。</span><span class="sxs-lookup"><span data-stu-id="21fc2-141">Using the same event on multiple threads can lead to a race condition in which the event is signaled correctly for the thread whose operation completes first and prematurely for other threads using that event.</span></span> <span data-ttu-id="21fc2-142">然後，當下一個重迭的作業完成時，所有使用該事件的執行緒都會再次收到事件的信號，依此類推，直到所有重迭的作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="21fc2-142">Then, when the next overlapped operation completes, the event is signaled again for all threads using that event, and so on until all overlapped operations are complete.</span></span>

<span data-ttu-id="21fc2-143">如需說明如何使用重迭作業、完成常式和 [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) 函數的範例，請參閱 [使用管道](../ipc/using-pipes.md)。</span><span class="sxs-lookup"><span data-stu-id="21fc2-143">For examples that illustrate the use of overlapped operations, completion routines, and the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, see [Using Pipes](../ipc/using-pipes.md).</span></span>

<span data-ttu-id="21fc2-144">\* \* Windows Vista、Windows Server 2003 和 Windows XP： \* \*</span><span class="sxs-lookup"><span data-stu-id="21fc2-144">\*\*Windows Vista, Windows Server 2003 and Windows XP:  \*\*</span></span>

<span data-ttu-id="21fc2-145">[**重複使用**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped)重迭的結構時，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="21fc2-145">Be careful when reusing [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structures.</span></span> <span data-ttu-id="21fc2-146">如果 **在** 多個執行緒上重複使用重迭結構，而且 [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) 是在 *bWait* 參數設定為 **TRUE** 的情況下呼叫，則呼叫執行緒必須確定相關聯的事件會在重複使用結構之前收到信號。</span><span class="sxs-lookup"><span data-stu-id="21fc2-146">If **OVERLAPPED** structures are reused on multiple threads and [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) is called with the *bWait* parameter set to **TRUE**, the calling thread must ensure that the associated event is signaled before reusing the structure.</span></span> <span data-ttu-id="21fc2-147">在呼叫 **GetOverlappedResult** 之後，您可以使用 [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject)函式來強制執行緒等候，直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="21fc2-147">This can be accomplished by using the [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) function after calling **GetOverlappedResult** to force the thread to wait until the operation completes.</span></span> <span data-ttu-id="21fc2-148">請注意，事件物件必須是手動重設事件物件。</span><span class="sxs-lookup"><span data-stu-id="21fc2-148">Note that the event object must be a manual-reset event object.</span></span> <span data-ttu-id="21fc2-149">如果使用 autoreset 事件物件，則呼叫 **GetOverlappedResult** 並將 *bWait* 參數設為 **TRUE** ，會導致函式無限期地封鎖。</span><span class="sxs-lookup"><span data-stu-id="21fc2-149">If an autoreset event object is used, calling **GetOverlappedResult** with the *bWait* parameter set to **TRUE** causes the function to be blocked indefinitely.</span></span> <span data-ttu-id="21fc2-150">此行為已從 Windows 7 和 Windows Server 2008 R2 變更，而應用程式會在應用程式資訊清單中指定 Windows 7 作為支援的作業系統。</span><span class="sxs-lookup"><span data-stu-id="21fc2-150">This behavior changed starting with Windows 7 and Windows Server 2008 R2 for applications that specify Windows 7 as the supported operating system in the application manifest.</span></span> <span data-ttu-id="21fc2-151">如需詳細資訊，請參閱 [應用程式資訊清單](/previous-versions/windows/desktop/adrms_sdk/application-manifests)。</span><span class="sxs-lookup"><span data-stu-id="21fc2-151">For more information see [Application Manifests](/previous-versions/windows/desktop/adrms_sdk/application-manifests).</span></span>

## <a name="related-topics"></a><span data-ttu-id="21fc2-152">相關主題</span><span class="sxs-lookup"><span data-stu-id="21fc2-152">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="21fc2-153">I/o 概念</span><span class="sxs-lookup"><span data-stu-id="21fc2-153">I/O Concepts</span></span>](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
