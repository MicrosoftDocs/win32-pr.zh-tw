---
description: 應用程式必須同步存取多個執行緒所共用的變數。
ms.assetid: 729c0e68-ef52-4d6c-b771-a89043a937e6
title: 連鎖變數存取
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ca2e083d3e3420e870ad9781b0d262df3d0786f1
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106994413"
---
# <a name="interlocked-variable-access"></a><span data-ttu-id="149ae-103">連鎖變數存取</span><span class="sxs-lookup"><span data-stu-id="149ae-103">Interlocked Variable Access</span></span>

<span data-ttu-id="149ae-104">應用程式必須同步存取多個執行緒所共用的變數。</span><span class="sxs-lookup"><span data-stu-id="149ae-104">Applications must synchronize access to variables that are shared by multiple threads.</span></span> <span data-ttu-id="149ae-105">應用程式也必須確保這些變數上的作業會以不可部分完成的方式執行， (完全或完全不執行。 ) </span><span class="sxs-lookup"><span data-stu-id="149ae-105">Applications must also ensure that operations on these variables are performed atomically (performed in their entirety or not at all.)</span></span>

<span data-ttu-id="149ae-106">簡單的讀取和寫入，以正確對齊的32位變數是不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="149ae-106">Simple reads and writes to properly-aligned 32-bit variables are atomic operations.</span></span> <span data-ttu-id="149ae-107">換句話說，您最後不會有一個已更新的變數部分。所有位都會以不可部分完成的方式更新。</span><span class="sxs-lookup"><span data-stu-id="149ae-107">In other words, you will not end up with only one portion of the variable updated; all bits are updated in an atomic fashion.</span></span> <span data-ttu-id="149ae-108">但是，不保證會同步存取。</span><span class="sxs-lookup"><span data-stu-id="149ae-108">However, access is not guaranteed to be synchronized.</span></span> <span data-ttu-id="149ae-109">如果有兩個執行緒從相同的變數讀取和寫入，您就無法判斷某個執行緒是否會在另一個執行緒執行寫入作業之前，先執行它的讀取作業。</span><span class="sxs-lookup"><span data-stu-id="149ae-109">If two threads are reading and writing from the same variable, you cannot determine if one thread will perform its read operation before the other performs its write operation.</span></span>

<span data-ttu-id="149ae-110">在64位的 Windows 上，簡單的讀取和寫入可正確對齊的64位變數是不可部分完成的。</span><span class="sxs-lookup"><span data-stu-id="149ae-110">Simple reads and writes to properly aligned 64-bit variables are atomic on 64-bit Windows.</span></span> <span data-ttu-id="149ae-111">64位值的讀取和寫入不保證在32位 Windows 上是不可部分完成的。</span><span class="sxs-lookup"><span data-stu-id="149ae-111">Reads and writes to 64-bit values are not guaranteed to be atomic on 32-bit Windows.</span></span> <span data-ttu-id="149ae-112">在任何平臺上，讀取和寫入其他大小的變數不一定是不可部分完成的。</span><span class="sxs-lookup"><span data-stu-id="149ae-112">Reads and writes to variables of other sizes are not guaranteed to be atomic on any platform.</span></span>

## <a name="the-interlocked-api"></a><span data-ttu-id="149ae-113">連鎖 API</span><span class="sxs-lookup"><span data-stu-id="149ae-113">The Interlocked API</span></span>

<span data-ttu-id="149ae-114">連鎖函數提供簡單的機制，可同步處理多個執行緒所共用之變數的存取。</span><span class="sxs-lookup"><span data-stu-id="149ae-114">The interlocked functions provide a simple mechanism for synchronizing access to a variable that is shared by multiple threads.</span></span> <span data-ttu-id="149ae-115">它們也會以不可部分完成的方式執行變數的作業。</span><span class="sxs-lookup"><span data-stu-id="149ae-115">They also perform operations on variables in an atomic manner.</span></span> <span data-ttu-id="149ae-116">如果變數位於共用記憶體中，則不同進程的執行緒可以使用這些函數。</span><span class="sxs-lookup"><span data-stu-id="149ae-116">The threads of different processes can use these functions if the variable is in shared memory.</span></span>

<span data-ttu-id="149ae-117">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement)和 [**InterlockedDecrement**](/windows/win32/api/winnt/nf-winnt-interlockeddecrement)函式結合了將變數遞增或遞減至不可部分完成作業的相關步驟。</span><span class="sxs-lookup"><span data-stu-id="149ae-117">The [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and [**InterlockedDecrement**](/windows/win32/api/winnt/nf-winnt-interlockeddecrement) functions combine the steps involved in incrementing or decrementing a variable into an atomic operation.</span></span> <span data-ttu-id="149ae-118">這項功能在多工作業系統中相當有用，因為系統可以中斷線程的執行，以將處理器時間的配量授與另一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="149ae-118">This feature is useful in a multitasking operating system, in which the system can interrupt one thread's execution to grant a slice of processor time to another thread.</span></span> <span data-ttu-id="149ae-119">如果沒有這類同步處理，兩個執行緒可以讀取相同的值、將它遞增1，然後將新值儲存為總計增加1而不是2。</span><span class="sxs-lookup"><span data-stu-id="149ae-119">Without such synchronization, two threads could read the same value, increment it by 1, and store the new value for a total increase of 1 instead of 2.</span></span> <span data-ttu-id="149ae-120">連鎖變數存取函式會防止這種錯誤。</span><span class="sxs-lookup"><span data-stu-id="149ae-120">The interlocked variable-access functions protect against this kind of error.</span></span>

<span data-ttu-id="149ae-121">[**InterlockedExchange**](/windows/win32/api/winnt/nf-winnt-interlockedexchange)和 [**InterlockedExchangePointer**](/windows/win32/api/winnt/nf-winnt-interlockedexchangepointer)函式會以不可部分完成的方式交換指定之變數的值。</span><span class="sxs-lookup"><span data-stu-id="149ae-121">The [**InterlockedExchange**](/windows/win32/api/winnt/nf-winnt-interlockedexchange) and [**InterlockedExchangePointer**](/windows/win32/api/winnt/nf-winnt-interlockedexchangepointer) functions atomically exchange the values of the specified variables.</span></span> <span data-ttu-id="149ae-122">[**InterlockedExchangeAdd**](/windows/win32/api/winnt/nf-winnt-interlockedexchangeadd)函式會結合兩個作業：將兩個變數相加，並將結果儲存在其中一個變數中。</span><span class="sxs-lookup"><span data-stu-id="149ae-122">The [**InterlockedExchangeAdd**](/windows/win32/api/winnt/nf-winnt-interlockedexchangeadd) function combines two operations: adding two variables together and storing the result in one of the variables.</span></span>

<span data-ttu-id="149ae-123">[**InterlockedCompareExchange**](/windows/win32/api/winnt/nf-winnt-interlockedcompareexchange)、 [**InterlockedCompare64Exchange128**](/previous-versions/windows/desktop/legacy/ms683553(v=vs.85))和 [**InterlockedCompareExchangePointer**](/windows/win32/api/winnt/nf-winnt-interlockedcompareexchangepointer)函數會結合兩個作業：比較兩個值，並根據比較結果將第三個值儲存在其中一個變數中。</span><span class="sxs-lookup"><span data-stu-id="149ae-123">The [**InterlockedCompareExchange**](/windows/win32/api/winnt/nf-winnt-interlockedcompareexchange), [**InterlockedCompare64Exchange128**](/previous-versions/windows/desktop/legacy/ms683553(v=vs.85)), and [**InterlockedCompareExchangePointer**](/windows/win32/api/winnt/nf-winnt-interlockedcompareexchangepointer) functions combine two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span>

<span data-ttu-id="149ae-124">[**InterlockedAnd**](/windows/win32/api/winnt/nf-winnt-interlockedand)、 [**InterlockedOr**](/windows/win32/api/winnt/nf-winnt-interlockedor)和 [**InterlockedXor**](/windows/win32/api/winnt/nf-winnt-interlockedxor)函式會以原子方式分別執行 and、OR 和 XOR 作業。</span><span class="sxs-lookup"><span data-stu-id="149ae-124">The [**InterlockedAnd**](/windows/win32/api/winnt/nf-winnt-interlockedand), [**InterlockedOr**](/windows/win32/api/winnt/nf-winnt-interlockedor), and [**InterlockedXor**](/windows/win32/api/winnt/nf-winnt-interlockedxor) functions atomically perform AND, OR, and XOR operations, respectively.</span></span>

<span data-ttu-id="149ae-125">有一些函式是專為在64位記憶體值和位址上執行連鎖變數存取而設計，並且已針對64位 Windows 優化。</span><span class="sxs-lookup"><span data-stu-id="149ae-125">There are functions that are specifically designed to perform interlocked variable access on 64-bit memory values and addresses, and are optimized for use on 64-bit Windows.</span></span> <span data-ttu-id="149ae-126">這些函式中的每一個都包含名稱中的 "64";例如， [**InterlockedDecrement64**](/windows/win32/api/winnt/nf-winnt-interlockeddecrement64) 和 [**InterlockedCompareExchangeAcquire64**](/previous-versions/windows/desktop/legacy/ms683566(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="149ae-126">Each of these functions contains "64" in the name; for example, [**InterlockedDecrement64**](/windows/win32/api/winnt/nf-winnt-interlockeddecrement64) and [**InterlockedCompareExchangeAcquire64**](/previous-versions/windows/desktop/legacy/ms683566(v=vs.85)).</span></span>

<span data-ttu-id="149ae-127">大部分的連鎖函式在所有 Windows 平臺上都提供完整的記憶體障礙。</span><span class="sxs-lookup"><span data-stu-id="149ae-127">Most of the interlocked functions provide full memory barriers on all Windows platforms.</span></span> <span data-ttu-id="149ae-128">此外，也有一些函數可結合基本連鎖變數存取作業，以及特定處理器所支援的取得和釋放記憶體順序的語法。</span><span class="sxs-lookup"><span data-stu-id="149ae-128">There are also functions that combine the basic interlocked variable access operations with the acquire and release memory ordering semantics supported by certain processors.</span></span> <span data-ttu-id="149ae-129">這些函式中的每一個都會在其名稱中包含 "取得" 或 "Release" 這個字。例如， [**InterlockedDecrementAcquire**](/previous-versions/windows/desktop/legacy/ms683583(v=vs.85)) 和 [**InterlockedDecrementRelease**](/previous-versions/windows/desktop/legacy/ms683586(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="149ae-129">Each of these functions contains the word "Acquire" or "Release" in their names; for example, [**InterlockedDecrementAcquire**](/previous-versions/windows/desktop/legacy/ms683583(v=vs.85)) and [**InterlockedDecrementRelease**](/previous-versions/windows/desktop/legacy/ms683586(v=vs.85)).</span></span> <span data-ttu-id="149ae-130">取得記憶體語義：指定在嘗試任何其他記憶體作業之前，目前線程所執行的記憶體作業將會顯示。</span><span class="sxs-lookup"><span data-stu-id="149ae-130">Acquire memory semantics specify that the memory operation being performed by the current thread will be visible before any other memory operations are attempted.</span></span> <span data-ttu-id="149ae-131">釋放記憶體語義：指定完成其他所有記憶體作業之後，目前線程所執行的記憶體作業將會顯示。</span><span class="sxs-lookup"><span data-stu-id="149ae-131">Release memory semantics specify that the memory operation being performed by the current thread will be visible after all other memory operations have been completed.</span></span> <span data-ttu-id="149ae-132">這些語義可讓您強制以特定循序執行記憶體作業。</span><span class="sxs-lookup"><span data-stu-id="149ae-132">These semantics allow you to force memory operations to be performed in a specific order.</span></span> <span data-ttu-id="149ae-133">在輸入受保護的區域時，請使用取得語義，並在離開時使用該語義。</span><span class="sxs-lookup"><span data-stu-id="149ae-133">Use acquire semantics when entering a protected region and release semantics when leaving it.</span></span>

## <a name="related-topics"></a><span data-ttu-id="149ae-134">相關主題</span><span class="sxs-lookup"><span data-stu-id="149ae-134">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="149ae-135">編譯器內建函式</span><span class="sxs-lookup"><span data-stu-id="149ae-135">Compiler Intrinsics</span></span>](/cpp/intrinsics/compiler-intrinsics?view=vs-2019)
</dt> <dt>

[<span data-ttu-id="149ae-136">同步處理和多處理器問題</span><span class="sxs-lookup"><span data-stu-id="149ae-136">Synchronization and Multiprocessor Issues</span></span>](synchronization-and-multiprocessor-issues.md)
</dt> </dl>

 

 
