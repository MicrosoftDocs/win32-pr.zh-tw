---
description: 元件的設計通常是在第一次呼叫時執行初始化工作，而不是在載入時執行。
ms.assetid: 404c083c-7bee-44c2-b8e7-da1901b6ab2f
title: One-Time 初始化
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 16f451e3c51716b4ff6f33b55d8d8602b5d5c28f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106971615"
---
# <a name="one-time-initialization"></a><span data-ttu-id="9836f-103">One-Time 初始化</span><span class="sxs-lookup"><span data-stu-id="9836f-103">One-Time Initialization</span></span>

<span data-ttu-id="9836f-104">元件的設計通常是在第一次呼叫時執行初始化工作，而不是在載入時執行。</span><span class="sxs-lookup"><span data-stu-id="9836f-104">Components are often designed to perform initialization tasks when they are first called, rather than when they are loaded.</span></span> <span data-ttu-id="9836f-105">單次初始化函式可確保此初始化只會發生一次，即使有多個執行緒可能會嘗試初始化亦同。</span><span class="sxs-lookup"><span data-stu-id="9836f-105">The one-time initialization functions ensure that this initialization occurs only once, even when multiple threads may attempt the initialization.</span></span>

<span data-ttu-id="9836f-106">**Windows Server 2003 和 WINDOWS XP：** 應用程式必須使用 [連鎖函數](interlocked-variable-access.md) 或其他同步處理機制，提供自己的同步處理進行單次初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-106">**Windows Server 2003 and Windows XP:** Applications must provide their own synchronization for one-time initialization by using the [interlocked functions](interlocked-variable-access.md) or other synchronization mechanism.</span></span> <span data-ttu-id="9836f-107">從 Windows Vista 和 Windows Server 2008 開始，可以使用一次性的初始化函數。</span><span class="sxs-lookup"><span data-stu-id="9836f-107">The one-time initialization functions are available starting with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="9836f-108">單次初始化函數可提供顯著的優點，以確保只有一個執行緒執行初始化：</span><span class="sxs-lookup"><span data-stu-id="9836f-108">The one-time initialization functions provide significant advantages to ensure that only one thread performs the initialization:</span></span>

-   <span data-ttu-id="9836f-109">它們已針對速度優化。</span><span class="sxs-lookup"><span data-stu-id="9836f-109">They are optimized for speed.</span></span>
-   <span data-ttu-id="9836f-110">他們會在需要它們的處理器架構上建立適當的阻礙。</span><span class="sxs-lookup"><span data-stu-id="9836f-110">They create the appropriate barriers on processor architectures that require them.</span></span>
-   <span data-ttu-id="9836f-111">它們支援鎖定和平行初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-111">They support both locked and parallel initialization.</span></span>
-   <span data-ttu-id="9836f-112">它們可避免內部鎖定，因此程式碼可以非同步或同步方式運作。</span><span class="sxs-lookup"><span data-stu-id="9836f-112">They avoid internal locking so the code can operate asynchronously or synchronously.</span></span>

<span data-ttu-id="9836f-113">系統會透過不透明的 **INIT \_ 一** 結構（包含資料和狀態資訊）來管理初始化程式。</span><span class="sxs-lookup"><span data-stu-id="9836f-113">The system manages the initialization process through an opaque **INIT\_ONCE** structure that contains data and state information.</span></span> <span data-ttu-id="9836f-114">呼叫端會配置此結構，並藉由呼叫 [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (初始化結構，以動態方式初始化結構，) 或將常數 init 指派給結構變數 (以) 靜態方式初始化結構。 **\_ \_ \_**</span><span class="sxs-lookup"><span data-stu-id="9836f-114">The caller allocates this structure and initializes it by either calling [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (to initialize the structure dynamically) or assigning the constant **INIT\_ONCE\_STATIC\_INIT** to the structure variable (to initialize the structure statically).</span></span> <span data-ttu-id="9836f-115">一開始，儲存在單次初始化結構中的資料是 Null，且其狀態為未初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-115">Initially, the data stored in the one-time initialization structure is NULL and its state is uninitialized.</span></span>

<span data-ttu-id="9836f-116">無法跨進程共用一次性的初始化結構。</span><span class="sxs-lookup"><span data-stu-id="9836f-116">One-time initialization structures cannot be shared across processes.</span></span>

<span data-ttu-id="9836f-117">執行初始化的執行緒可以選擇性地設定在初始化完成之後可供呼叫端使用的內容。</span><span class="sxs-lookup"><span data-stu-id="9836f-117">The thread that performs the initialization can optionally set a context that is available to the caller after initialization is complete.</span></span> <span data-ttu-id="9836f-118">內容可以是同步處理物件，也可以是值或資料結構。</span><span class="sxs-lookup"><span data-stu-id="9836f-118">The context can be a synchronization object or it can be a value or data structure.</span></span> <span data-ttu-id="9836f-119">如果內容是一個值，則 **\_ \_ CTX \_ 保留的 \_ 位一旦** 必須為零，則其低順序初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-119">If the context is a value, its low-order **INIT\_ONCE\_CTX\_RESERVED\_BITS** must be zero.</span></span> <span data-ttu-id="9836f-120">如果內容是資料結構，資料結構必須對齊 **DWORD**。</span><span class="sxs-lookup"><span data-stu-id="9836f-120">If the context is a data structure, the data structure must be **DWORD**-aligned.</span></span> <span data-ttu-id="9836f-121">在 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize)或 [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce)函數的 *lpCoNtext* output 參數中，會將內容傳回給呼叫端。</span><span class="sxs-lookup"><span data-stu-id="9836f-121">The context is returned to the caller in the *lpContext* output parameter of the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) or [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function.</span></span>

<span data-ttu-id="9836f-122">單次初始化可以同步或非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="9836f-122">One-time initialization can be performed synchronously or asynchronously.</span></span> <span data-ttu-id="9836f-123">選擇性的回呼函數可以用於同步單次初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-123">An optional callback function can be used for synchronous one-time initialization.</span></span>

## <a name="synchronous-one-time-initialization"></a><span data-ttu-id="9836f-124">同步單次初始化</span><span class="sxs-lookup"><span data-stu-id="9836f-124">Synchronous One-time Initialization</span></span>

<span data-ttu-id="9836f-125">下列步驟描述未使用回呼函數的同步單次初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-125">The following steps describe synchronous one-time initialization that does not use a callback function.</span></span>

1.  <span data-ttu-id="9836f-126">呼叫 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) 函式的第一個執行緒成功導致單次初始化開始。</span><span class="sxs-lookup"><span data-stu-id="9836f-126">The first thread to call the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) function successfully causes one-time initialization to begin.</span></span> <span data-ttu-id="9836f-127">若為同步單次初始化，則必須呼叫 **InitOnceBeginInitialize** ，而不需要 **INIT one \_ \_ ASYNC** 旗標。</span><span class="sxs-lookup"><span data-stu-id="9836f-127">For synchronous one-time initialization, **InitOnceBeginInitialize** must be called without the **INIT\_ONCE\_ASYNC** flag.</span></span>
2.  <span data-ttu-id="9836f-128">嘗試初始化的後續執行緒會被封鎖，直到第一個執行緒完成初始化或失敗為止。</span><span class="sxs-lookup"><span data-stu-id="9836f-128">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="9836f-129">如果第一個執行緒失敗，則會允許下一個執行緒嘗試初始化，依此類推。</span><span class="sxs-lookup"><span data-stu-id="9836f-129">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="9836f-130">初始化完成時，執行緒會呼叫 [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) 函數。</span><span class="sxs-lookup"><span data-stu-id="9836f-130">When initialization is finished, the thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="9836f-131">執行緒可以選擇性地建立 (或其他內容資料) 的同步處理物件，並在 **InitOnceComplete** 函數的 *lpCoNtext* 參數中指定它。</span><span class="sxs-lookup"><span data-stu-id="9836f-131">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of the **InitOnceComplete** function.</span></span>
4.  <span data-ttu-id="9836f-132">如果初始化成功，則會將單次初始化結構的狀態變更為已初始化，而如果有任何) 儲存在初始化結構中，則 *lpCoNtext* 控制碼 (。</span><span class="sxs-lookup"><span data-stu-id="9836f-132">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="9836f-133">後續的初始化嘗試會傳回此內容資料。</span><span class="sxs-lookup"><span data-stu-id="9836f-133">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="9836f-134">如果初始化失敗，資料會是 **Null**。</span><span class="sxs-lookup"><span data-stu-id="9836f-134">If the initialization fails, the data is **NULL**.</span></span>

<span data-ttu-id="9836f-135">下列步驟描述使用回呼函數的同步單次初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-135">The following steps describe synchronous one-time initialization that uses a callback function.</span></span>

1.  <span data-ttu-id="9836f-136">成功呼叫 [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) 函式的第一個執行緒會將指標傳遞至應用程式定義的 [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) 回呼函式，以及回呼函數所需的任何資料。</span><span class="sxs-lookup"><span data-stu-id="9836f-136">The first thread to successfully call the [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function passes a pointer to an application-defined [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) callback function and any data required by the callback function.</span></span> <span data-ttu-id="9836f-137">如果呼叫成功，則會執行 *InitOnceCallback* 回呼函數。</span><span class="sxs-lookup"><span data-stu-id="9836f-137">If the call succeeds, the *InitOnceCallback* callback function executes.</span></span>
2.  <span data-ttu-id="9836f-138">嘗試初始化的後續執行緒會被封鎖，直到第一個執行緒完成初始化或失敗為止。</span><span class="sxs-lookup"><span data-stu-id="9836f-138">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="9836f-139">如果第一個執行緒失敗，則會允許下一個執行緒嘗試初始化，依此類推。</span><span class="sxs-lookup"><span data-stu-id="9836f-139">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="9836f-140">初始化完成時，回呼函數會傳回。</span><span class="sxs-lookup"><span data-stu-id="9836f-140">When initialization is finished, the callback function returns.</span></span> <span data-ttu-id="9836f-141">回呼函數可以選擇性地建立 (或其他內容資料) 的同步處理物件，並在其 *內容* 輸出參數中指定。</span><span class="sxs-lookup"><span data-stu-id="9836f-141">The callback function can optionally create a synchronization object (or other context data) and specify it in its *Context* output parameter.</span></span>
4.  <span data-ttu-id="9836f-142">如果初始化成功，則會將一次性初始化結構的狀態變更為已初始化，而如果有任何) 儲存在初始化結構中，則 *內容* 控制碼 (。</span><span class="sxs-lookup"><span data-stu-id="9836f-142">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *Context* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="9836f-143">後續的初始化嘗試會傳回此內容資料。</span><span class="sxs-lookup"><span data-stu-id="9836f-143">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="9836f-144">如果初始化失敗，資料會是 **Null**。</span><span class="sxs-lookup"><span data-stu-id="9836f-144">If the initialization fails, the data is **NULL**.</span></span>

## <a name="asynchronous-one-time-initialization"></a><span data-ttu-id="9836f-145">非同步單次初始化</span><span class="sxs-lookup"><span data-stu-id="9836f-145">Asynchronous One-time Initialization</span></span>

<span data-ttu-id="9836f-146">下列步驟說明非同步一次性初始化。</span><span class="sxs-lookup"><span data-stu-id="9836f-146">The following steps describe asynchronous one-time initialization.</span></span>

1.  <span data-ttu-id="9836f-147">如果多個執行緒同時嘗試在 **\_ \_ ASYNC** 呼叫 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize)和 INIT 來開始初始化，則將 *fPending* 參數設為 **TRUE** 的所有線程都能成功執行該函式。</span><span class="sxs-lookup"><span data-stu-id="9836f-147">If multiple threads simultaneously attempt to begin initialization by calling [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_ASYNC**, the function succeeds for all of the threads with the *fPending* parameter set to **TRUE**.</span></span> <span data-ttu-id="9836f-148">只有一個執行緒在初始化時實際上會成功：其他並行嘗試則不會變更初始化狀態。</span><span class="sxs-lookup"><span data-stu-id="9836f-148">Only one thread will actually succeed at initialization; other concurrent attempts do not change the initialization state.</span></span>
2.  <span data-ttu-id="9836f-149">當 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) 傳回時， *fPending* 參數會指出初始化狀態：</span><span class="sxs-lookup"><span data-stu-id="9836f-149">When [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) returns, the *fPending* parameter indicates the initialization status:</span></span>
    -   <span data-ttu-id="9836f-150">如果 *fPending* 為 **FALSE**，則表示一個執行緒在初始化時成功。</span><span class="sxs-lookup"><span data-stu-id="9836f-150">If *fPending* is **FALSE**, one thread has succeeded at initialization.</span></span> <span data-ttu-id="9836f-151">其他執行緒應清除其所建立的任何內容資料，並使用 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize)之 *lpCoNtext* 輸出參數中的內容資料。</span><span class="sxs-lookup"><span data-stu-id="9836f-151">Other threads should clean up any context data they have created and use the context data in the *lpContext* output parameter of [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span></span>
    -   <span data-ttu-id="9836f-152">如果 *fPending* 為 **TRUE**，表示初始化尚未完成，而且其他執行緒應該繼續。</span><span class="sxs-lookup"><span data-stu-id="9836f-152">If *fPending* is **TRUE**, initialization has not yet completed and other threads should continue.</span></span>
3.  <span data-ttu-id="9836f-153">每個執行緒都會呼叫 [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) 函數。</span><span class="sxs-lookup"><span data-stu-id="9836f-153">Each thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="9836f-154">執行緒可以選擇性地建立 (或其他內容資料) 的同步處理物件，並在 **InitOnceComplete** 的 *lpCoNtext* 參數中指定它。</span><span class="sxs-lookup"><span data-stu-id="9836f-154">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of **InitOnceComplete**.</span></span>
4.  <span data-ttu-id="9836f-155">當 [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) 傳回時，它的傳回值會指出呼叫執行緒是否在初始化時成功。</span><span class="sxs-lookup"><span data-stu-id="9836f-155">When [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) returns, its return value indicates whether the calling thread succeeded at initialization.</span></span>
    -   <span data-ttu-id="9836f-156">如果 [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) 成功，呼叫的執行緒就會在初始化時成功。</span><span class="sxs-lookup"><span data-stu-id="9836f-156">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) succeeds, the calling thread has succeeded at initialization.</span></span> <span data-ttu-id="9836f-157">如果任何) 儲存在初始化結構中，則一次性初始化結構的狀態會變更為已初始化，而 *lpCoNtext* 控制碼 (。</span><span class="sxs-lookup"><span data-stu-id="9836f-157">The state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span>
    -   <span data-ttu-id="9836f-158">如果 [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) 失敗，則另一個執行緒在初始化時成功。</span><span class="sxs-lookup"><span data-stu-id="9836f-158">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) fails, another thread has succeeded at initialization.</span></span> <span data-ttu-id="9836f-159">呼叫端執行緒應該清除其所建立的任何內容資料，並使用 INIT 呼叫 [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) **\_ 一次，只要 \_ 檢查 \_** 一次就能取出儲存在單次初始化結構中的任何內容資料。</span><span class="sxs-lookup"><span data-stu-id="9836f-159">The calling thread should clean up any context data it has created and call [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_CHECK\_ONLY** to retrieve any context data stored in the one-time initialization structure.</span></span>

## <a name="calling-one-time-initialization-from-multiple-sites"></a><span data-ttu-id="9836f-160">從多個網站呼叫 One-Time 初始化</span><span class="sxs-lookup"><span data-stu-id="9836f-160">Calling One-Time Initialization from multiple sites</span></span>

<span data-ttu-id="9836f-161">一次由單一 INIT 所保護的 **單次 \_** 初始化結構可以從多個網站執行; 您可以從每個網站傳遞不同的回呼，而且可以混合使用與不含回呼的同步處理。</span><span class="sxs-lookup"><span data-stu-id="9836f-161">One-time initialization guarded by a single **INIT\_ONCE** structure may be performed from mutiple sites; different callback may be passed from each site, and synchronization with and without callback may be mixed.</span></span> <span data-ttu-id="9836f-162">初始化仍 guaranted 為只執行一次 sucesfully。</span><span class="sxs-lookup"><span data-stu-id="9836f-162">Initialization is still guaranted to perform sucesfully just once.</span></span>

<span data-ttu-id="9836f-163">但是，非同步和同步初始化無法混用：一旦嘗試非同步初始化，嘗試啟動同步初始化會失敗。</span><span class="sxs-lookup"><span data-stu-id="9836f-163">However, asynchronous and synchronous initialization cannot be mixed: once asynchronous initialization is attempted, attempts to start synchronous initialization would fail.</span></span>

## <a name="related-topics"></a><span data-ttu-id="9836f-164">相關主題</span><span class="sxs-lookup"><span data-stu-id="9836f-164">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="9836f-165">使用 One-Time 初始化</span><span class="sxs-lookup"><span data-stu-id="9836f-165">Using One-Time Initialization</span></span>](using-one-time-initialization.md)
</dt> </dl>

 

 
