---
title: BITS 工作的生命週期
description: 當您建立作業時，會開始 BITS 工作的生命週期。
ms.assetid: b765a8ef-74bd-475e-9cd9-e9e2cf4f0305
ms.topic: article
ms.date: 11/13/2018
ms.openlocfilehash: c6ac23c598d28681968e9c0cbed776ba24c57e98
ms.sourcegitcommit: de72a1294df274b0a71dc0fdc42d757e5f6df0f3
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/05/2021
ms.locfileid: "106991401"
---
# <a name="bits-job-states"></a><span data-ttu-id="0b29f-103">BITS 作業狀態</span><span class="sxs-lookup"><span data-stu-id="0b29f-103">BITS Job states</span></span>
<span data-ttu-id="0b29f-104">有四種類型 [**的位：**](/windows/desktop/api/Bits/ne-bits-bg_job_state)開始、動作、傳輸和最終。</span><span class="sxs-lookup"><span data-stu-id="0b29f-104">There are four classes of BITS [**states**](/windows/desktop/api/Bits/ne-bits-bg_job_state): starting, action, transferred, and final.</span></span> <span data-ttu-id="0b29f-105">當作業執行時，它會在不同狀態類別的狀態之間轉換。</span><span class="sxs-lookup"><span data-stu-id="0b29f-105">As a job runs, it transitions between states in the different state classes.</span></span> <span data-ttu-id="0b29f-106">一旦作業處於最終狀態之後，就不會移出最後的狀態，也不會顯示在 [作業列舉](/windows/desktop/api/bits/nf-bits-ibackgroundcopymanager-enumjobs)中。</span><span class="sxs-lookup"><span data-stu-id="0b29f-106">Once a job is in a final state, it won't move out of the final state and won't show up in a [job enumeration](/windows/desktop/api/bits/nf-bits-ibackgroundcopymanager-enumjobs).</span></span>

## <a name="state-changing-methods"></a><span data-ttu-id="0b29f-107">狀態變更方法</span><span class="sxs-lookup"><span data-stu-id="0b29f-107">State-changing methods</span></span>
<span data-ttu-id="0b29f-108">作業有四個狀態變更方法： [**取消**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-cancel)、 [**完成**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete)、 [**繼續**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-resume)和 [**暫**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-suspend)止。</span><span class="sxs-lookup"><span data-stu-id="0b29f-108">There are four state-changing methods on a job: [**Cancel**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-cancel), [**Complete**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete), [**Resume**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-resume), and [**Suspend**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-suspend).</span></span> <span data-ttu-id="0b29f-109">只要作業不是最終狀態，您就可以呼叫任何狀態變更方法。</span><span class="sxs-lookup"><span data-stu-id="0b29f-109">As long as a job is not in a final state, you can call any of the state-changing methods.</span></span> 

<span data-ttu-id="0b29f-110">「 [**暫停**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-suspend) 」方法是用來將作業切換至暫停狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-110">The [**Suspend**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-suspend) method is used to switch a job to the SUSPENDED state.</span></span> <span data-ttu-id="0b29f-111">當工作暫停時，其所有傳輸都會停止，而且在您呼叫 Resume 之前不會繼續。</span><span class="sxs-lookup"><span data-stu-id="0b29f-111">When a job is suspended, all of its transfers will be stopped and won't resume until you call Resume.</span></span>
<span data-ttu-id="0b29f-112">已暫停的工作只會保持暫止狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-112">A job that's already suspended will simply stay suspended.</span></span>

<span data-ttu-id="0b29f-113">[**Resume**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-resume)方法是用來啟動已暫止的工作。</span><span class="sxs-lookup"><span data-stu-id="0b29f-113">The [**Resume**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-resume) method is used to start a job that's suspended.</span></span> <span data-ttu-id="0b29f-114">錯誤或暫時性錯誤狀態中的作業將會設定為重試。</span><span class="sxs-lookup"><span data-stu-id="0b29f-114">Jobs in an error or transient error state will be set up to be retried.</span></span> <span data-ttu-id="0b29f-115">目前處於動作狀態的作業將會維持在該狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-115">Jobs that are currently in an action state will stay in that state.</span></span>

<span data-ttu-id="0b29f-116">[**Cancel**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-cancel)方法是用來取消作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-116">The [**Cancel**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-cancel) method is used to cancel a job.</span></span> <span data-ttu-id="0b29f-117">狀態會切換為 [已取消]。</span><span class="sxs-lookup"><span data-stu-id="0b29f-117">The state will switch to cancelled.</span></span> <span data-ttu-id="0b29f-118">目前傳送的任何檔案都不會完成。</span><span class="sxs-lookup"><span data-stu-id="0b29f-118">Any files currently being transferred will not be completed.</span></span> <span data-ttu-id="0b29f-119">所有完全傳輸和部分傳送的檔案將會遭到刪除。</span><span class="sxs-lookup"><span data-stu-id="0b29f-119">All completely transferred and partially transferred files will be deleted.</span></span>

<span data-ttu-id="0b29f-120">[**完成**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete)的方法將會完成傳輸。</span><span class="sxs-lookup"><span data-stu-id="0b29f-120">The [**Complete**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete) method will finish a transfer.</span></span> <span data-ttu-id="0b29f-121">將會保留任何完整下載的檔案;未完全傳輸的檔案將會被刪除。</span><span class="sxs-lookup"><span data-stu-id="0b29f-121">Any fully downloaded files will be kept; files that are not fully transferred will be deleted.</span></span>

<span data-ttu-id="0b29f-122">您必須呼叫 [取消] 或 [完成]，才能將作業移至最終狀態並清除。</span><span class="sxs-lookup"><span data-stu-id="0b29f-122">You must call either Cancel or Complete to move your job to a final state and be cleaned up.</span></span> <span data-ttu-id="0b29f-123">未轉換為最終狀態的作業將會浪費系統資源。</span><span class="sxs-lookup"><span data-stu-id="0b29f-123">Jobs that aren't transitioned to a final state will waste system resources.</span></span> <span data-ttu-id="0b29f-124">BITS 最終將會自動取消舊的作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-124">BITS will eventually automatically cancel old jobs.</span></span> <span data-ttu-id="0b29f-125">預設 [JobInactivityTimeout](/windows/desktop/Bits/group-policies) 是在90天后取消作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-125">The default [JobInactivityTimeout](/windows/desktop/Bits/group-policies) is to cancel jobs after 90 days.</span></span>


## <a name="starting-state"></a><span data-ttu-id="0b29f-126">開始狀態</span><span class="sxs-lookup"><span data-stu-id="0b29f-126">Starting state</span></span> 
<span data-ttu-id="0b29f-127">啟動狀態為 [已 **暫停**]。</span><span class="sxs-lookup"><span data-stu-id="0b29f-127">The starting state is **SUSPENDED**.</span></span> <span data-ttu-id="0b29f-128">您可以從這裡將檔案新增至作業，並設定作業和檔案屬性。</span><span class="sxs-lookup"><span data-stu-id="0b29f-128">From here, you can add files to the job and set job and file properties.</span></span> <span data-ttu-id="0b29f-129">若要開始傳送作業，請在作業上呼叫 Resume。</span><span class="sxs-lookup"><span data-stu-id="0b29f-129">To start a job transferring, call Resume on the job.</span></span> <span data-ttu-id="0b29f-130">如果您繼續執行不含任何檔案的作業，則會傳回 BG_E_EMPTY 錯誤碼，而且工作會保持暫停狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-130">If you resume a job with no files, it will return a BG_E_EMPTY error code and the job will stay suspended.</span></span>

## <a name="action-states"></a><span data-ttu-id="0b29f-131">動作狀態</span><span class="sxs-lookup"><span data-stu-id="0b29f-131">Action states</span></span>
<span data-ttu-id="0b29f-132">已 **排入佇列**、 **連接** 和 **傳輸** 狀態會顯示您作業目前的內部活動。</span><span class="sxs-lookup"><span data-stu-id="0b29f-132">The **QUEUED**, **CONNECTING** and **TRANSFERRING** states show the current internal activity of your job.</span></span> <span data-ttu-id="0b29f-133">已排入佇列的作業已準備好進行排程，可能正在等候 BITS 排程器或等候使用者登入。</span><span class="sxs-lookup"><span data-stu-id="0b29f-133">A job that's QUEUED is ready to be scheduled, possibly waiting for the BITS scheduler or waiting for the user to log in.</span></span> <span data-ttu-id="0b29f-134">正在連線的作業正在嘗試連接到伺服器，以開始傳輸檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-134">A job that's CONNECTING is attempting to connect to the server to start transferring files.</span></span> <span data-ttu-id="0b29f-135">正在傳送的作業會主動上傳或下載檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-135">A job that's TRANSFERRING is actively uploading or downloading your files.</span></span>

<span data-ttu-id="0b29f-136">**暫時性錯誤** 狀態表示作業已嘗試，但無法傳送檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-136">The **TRANSIENT ERROR** state means that the job tried and failed to transfer the file.</span></span> <span data-ttu-id="0b29f-137">這可能是因為網路原則的緣故。作業可能會因為目前的網路太昂貴而遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="0b29f-137">This might be for network policy reasons; the job might be blocked because the current network is too expensive.</span></span> <span data-ttu-id="0b29f-138">系統可能也會封鎖系統原因，例如系統處於省電模式或遊戲模式，或因為沒有網際網路連線能力。</span><span class="sxs-lookup"><span data-stu-id="0b29f-138">It might also be blocked for system reasons like the system being in battery saver or game mode, or because there's no internet connectivity.</span></span> 

<span data-ttu-id="0b29f-139">處於暫時性錯誤狀態的工作會在適當時自動以 BITS 重試。</span><span class="sxs-lookup"><span data-stu-id="0b29f-139">Jobs in the transient error state will be retried automatically by BITS when appropriate.</span></span> <span data-ttu-id="0b29f-140">BITS 包含 [MinimumRetryDelay](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setminimumretrydelay) 和 [NoProgressTimeout](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setnoprogresstimeout) 值，可控制重試作業的時間，以及 bits 最後將停止重試的時間。</span><span class="sxs-lookup"><span data-stu-id="0b29f-140">BITS includes a [MinimumRetryDelay](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setminimumretrydelay) and [NoProgressTimeout](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setnoprogresstimeout) value to control when a job is retried and when BITS will finally stop retrying.</span></span>


## <a name="transferred-states"></a><span data-ttu-id="0b29f-141">已傳送狀態</span><span class="sxs-lookup"><span data-stu-id="0b29f-141">Transferred states</span></span>
<span data-ttu-id="0b29f-142">當不再傳送完成時，會發生傳送的狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-142">The transferred states happen when there's no more transferring to be done.</span></span> <span data-ttu-id="0b29f-143">您必須取消或完成處於此狀態的作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-143">You must either cancel or complete a job in this state.</span></span> <span data-ttu-id="0b29f-144">您也可以新增更多檔案來傳送和呼叫 Resume () ，但這不是常見的作法。</span><span class="sxs-lookup"><span data-stu-id="0b29f-144">You may also add more files to transfer and call Resume(), but this isn't a common practice.</span></span>

<span data-ttu-id="0b29f-145">當傳送完成時，會發生 **錯誤** 狀態 () 不會重試，但未完全成功。</span><span class="sxs-lookup"><span data-stu-id="0b29f-145">The **ERROR** state happens when a transfer is done (it won't be retried), but didn't fully succeed.</span></span> <span data-ttu-id="0b29f-146">所有檔案都必須傳送才能成功;如果有任何永久失敗，作業將會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="0b29f-146">All the files must be transferred to be successful; if any have permanently failed the job will be in error.</span></span> <span data-ttu-id="0b29f-147">您通常會呼叫 [取消] 或 [完成]，將工作移至最終狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-147">You will typically either call Cancel or Complete to move the job to a final state.</span></span> <span data-ttu-id="0b29f-148">實際的差異在於，當您呼叫 Cancel 時，將會刪除任何成功傳輸的檔案，但如果您呼叫 Complete，將不會刪除任何成功傳輸的檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-148">The practical difference is that when you call Cancel, any successfully transferred file will be deleted, but if you call Complete, any successfully transferred file will not be deleted.</span></span>

<span data-ttu-id="0b29f-149">處於錯誤狀態的原因包括</span><span class="sxs-lookup"><span data-stu-id="0b29f-149">Reasons for being in an ERROR state include</span></span> 
* <span data-ttu-id="0b29f-150">在暫時性錯誤狀態中保持太長的時間， (超出 [NoProgressTimeout](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setnoprogresstimeout) 設定) 。</span><span class="sxs-lookup"><span data-stu-id="0b29f-150">Staying too long in a TRANSIENT ERROR state (beyond the [NoProgressTimeout](/windows/desktop/api/bits/nf-bits-ibackgroundcopyjob-setnoprogresstimeout) setting).</span></span>
* <span data-ttu-id="0b29f-151">取得 BG_E_TOKEN_REQUIRED 的錯誤，並需要協助程式 [權杖](/windows/desktop/Bits/helper-tokens-for-bits-transfer-jobs)</span><span class="sxs-lookup"><span data-stu-id="0b29f-151">Getting a BG_E_TOKEN_REQUIRED error and needing assistance with [helper tokens](/windows/desktop/Bits/helper-tokens-for-bits-transfer-jobs)</span></span>

<span data-ttu-id="0b29f-152">常見的作法是重新設定錯誤作業，然後呼叫 Resume 以重試作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-152">It's a common practice to reconfigure an ERROR'd job and then call Resume to retry the job.</span></span> <span data-ttu-id="0b29f-153">例如，您的應用程式可能需要透過 [SetRemoteName](/windows/desktop/api/bits2_0/nf-bits2_0-ibackgroundcopyfile2-setremotename)更新檔案的遠端名稱。</span><span class="sxs-lookup"><span data-stu-id="0b29f-153">For example, your app might need to update a file's remote name via [SetRemoteName](/windows/desktop/api/bits2_0/nf-bits2_0-ibackgroundcopyfile2-setremotename).</span></span>

<span data-ttu-id="0b29f-154">當傳送完成且成功時，就會發生 **傳輸** 狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-154">The **TRANSFERRED** state happens when a transfer is done and it succeeded.</span></span> <span data-ttu-id="0b29f-155">您必須呼叫 Complete 才能完成工作;若為下載工作，在您呼叫 Complete 之後，將無法使用下載的檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-155">You must call Complete to finalize the job; for download jobs the downloaded files won't be available until after you call Complete.</span></span> <span data-ttu-id="0b29f-156">這項規則的例外狀況是 (高效能工作的工作，而且您仍應呼叫完整的) 。</span><span class="sxs-lookup"><span data-stu-id="0b29f-156">The exception to this rule is jobs which are the high performance jobs (and you should still call Complete).</span></span>

## <a name="final-states"></a><span data-ttu-id="0b29f-157">最終狀態</span><span class="sxs-lookup"><span data-stu-id="0b29f-157">Final states</span></span>
<span data-ttu-id="0b29f-158">當工作處於最終狀態時，您就無法呼叫任何狀態變更方法。</span><span class="sxs-lookup"><span data-stu-id="0b29f-158">Once a job is in a final state, you can't call any of the state-changing methods.</span></span> <span data-ttu-id="0b29f-159">作業會在您呼叫 Complete () 之後 **認可** ，而且所有完成的下載檔案都將可供使用。</span><span class="sxs-lookup"><span data-stu-id="0b29f-159">The job will be **ACKNOWLEDGED** after you call Complete() and all completed downloaded files will be available.</span></span> <span data-ttu-id="0b29f-160">作業將會在您呼叫 Cancel () 後 **取消** ，而且所有下載的檔案都將被刪除。</span><span class="sxs-lookup"><span data-stu-id="0b29f-160">The job will be **CANCELLED** after you call Cancel() and all downloaded files will be deleted.</span></span> 


## <a name="life-cycle-of-a-bits-job"></a><span data-ttu-id="0b29f-161">BITS 工作的生命週期</span><span class="sxs-lookup"><span data-stu-id="0b29f-161">Life Cycle of a BITS job</span></span>

<span data-ttu-id="0b29f-162">當您建立作業時，會開始 BITS 工作的生命週期。</span><span class="sxs-lookup"><span data-stu-id="0b29f-162">The life cycle of a BITS job begins when you create a job.</span></span> <span data-ttu-id="0b29f-163">作業是包含一或多個要傳送之檔案的容器。</span><span class="sxs-lookup"><span data-stu-id="0b29f-163">A job is a container that contains one or more files to transfer.</span></span> <span data-ttu-id="0b29f-164">作業也有屬性，可指定 BITS 如何傳送檔案，以及如何與您的應用程式互動。</span><span class="sxs-lookup"><span data-stu-id="0b29f-164">A job also has properties that specify how BITS transfers the files and interacts with your application.</span></span> <span data-ttu-id="0b29f-165">例如，您可以指定作業的優先順序、作業為上傳或下載作業，以及您想要接收通知的事件。</span><span class="sxs-lookup"><span data-stu-id="0b29f-165">For example, you can specify the priority of the job, whether the job is an upload or download job, and for which events you want to receive notification.</span></span>

<span data-ttu-id="0b29f-166">在您建立作業之後，請新增一或多個檔案 (上傳工作只能包含一個) 到該作業的檔案，並視需要變更應用程式的任何屬性值。</span><span class="sxs-lookup"><span data-stu-id="0b29f-166">After you create the job, add one or more files (upload jobs can contain only one file) to the job and change any of the property values as appropriate for your application.</span></span> <span data-ttu-id="0b29f-167">當您將檔案新增至工作時，請同時指定本機 (用戶端) 和遠端 (伺服器) 的檔案名。</span><span class="sxs-lookup"><span data-stu-id="0b29f-167">When you add a file to the job, specify both the local (client) and remote (server) name of the file.</span></span> <span data-ttu-id="0b29f-168">遠端檔案名必須使用 HTTP、HTTPS 或 SMB 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="0b29f-168">The remote file name must use the HTTP, HTTPS, or SMB protocol.</span></span> <span data-ttu-id="0b29f-169">作業內的檔案會依序 (先出) 來處理。</span><span class="sxs-lookup"><span data-stu-id="0b29f-169">Files within a job are processed sequentially (first in, first out).</span></span>

<span data-ttu-id="0b29f-170">BITS 會在建立作業時自動暫停作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-170">BITS automatically suspends jobs when they are created.</span></span> <span data-ttu-id="0b29f-171">您必須繼續工作，才能在傳送佇列中啟用它。</span><span class="sxs-lookup"><span data-stu-id="0b29f-171">You must resume the job to activate it in the transfer queue.</span></span> <span data-ttu-id="0b29f-172">您可以隨時暫停或繼續作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-172">You can suspend or resume a job at any time.</span></span> <span data-ttu-id="0b29f-173">繼續作業可將工作從暫停狀態移至佇列狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-173">Resuming the job moves the job from the suspended state to the queued state.</span></span> <span data-ttu-id="0b29f-174">作業會保持佇列狀態，直到排程器判斷它是否為作業轉換檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-174">The job stays in the queued state until the scheduler determines it is the job's turn to transfer files.</span></span> <span data-ttu-id="0b29f-175">所有的前景作業都會與一個背景工作同時執行。</span><span class="sxs-lookup"><span data-stu-id="0b29f-175">All foreground jobs run concurrently with one background job.</span></span> <span data-ttu-id="0b29f-176">BITS 會以序列方式處理前景工作中的檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-176">BITS processes the files within foreground jobs serially.</span></span>

<span data-ttu-id="0b29f-177">當作業轉換檔案時，此作業會移至 [連線] 狀態，而 BITS 會連接到遠端伺服器 (在 [遠端檔案名]) 中指定。</span><span class="sxs-lookup"><span data-stu-id="0b29f-177">When it is a job's turn to transfer files, the job moves to the connecting state while BITS connects to the remote server (specified in the remote file name).</span></span> <span data-ttu-id="0b29f-178">如果 BITS 能夠連線到遠端伺服器，則作業會移至「傳輸中」狀態，直到其時間配量結束、傳輸完成、發生錯誤或應用程式暫停作業為止。</span><span class="sxs-lookup"><span data-stu-id="0b29f-178">If BITS is able to connect to the remote server, the job moves to the transferring state where it stays until its time slice ends, the transfer is complete, an error occurs, or the application suspends the job.</span></span>

<span data-ttu-id="0b29f-179">作業會在已排入佇列、連接和傳輸狀態之間移動，直到 BITS 傳送作業中的所有檔案為止。</span><span class="sxs-lookup"><span data-stu-id="0b29f-179">The job moves between the queued, connecting, and transferring states until BITS transfers all files in the job.</span></span> <span data-ttu-id="0b29f-180">屆時，作業會移至已傳送的狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-180">At that point, the job moves to the transferred state.</span></span> <span data-ttu-id="0b29f-181">BITS 會使用迴圈配置資源排程來排程相同優先權層級的作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-181">BITS uses round-robin scheduling to schedule jobs that are at the same priority level.</span></span> <span data-ttu-id="0b29f-182">每項作業都會有一段時間來處理其檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-182">Each job is given a slice of time to process its files.</span></span> <span data-ttu-id="0b29f-183">如果作業未在其時間配量內完成，則作業會回到已排入佇列的狀態，並啟動佇列中的下一個工作。</span><span class="sxs-lookup"><span data-stu-id="0b29f-183">If the job does not complete during its time slice, the job goes back to the queued state and the next job in the queue is activated.</span></span> <span data-ttu-id="0b29f-184">這可防止大型作業封鎖較小的作業。</span><span class="sxs-lookup"><span data-stu-id="0b29f-184">This prevents large jobs from blocking smaller jobs.</span></span> <span data-ttu-id="0b29f-185">作業主要是在先進先出 (FIFO) 基礎上進行處理;不過，BITS 無法保證 FIFO 處理，因為迴圈配置資源排程、作業錯誤和服務重新開機。</span><span class="sxs-lookup"><span data-stu-id="0b29f-185">Jobs are processed largely on a first in, first out (FIFO) basis; however, BITS cannot guarantee FIFO processing because of round-robin scheduling, job errors, and service restarts.</span></span>

<span data-ttu-id="0b29f-186">在應用程式呼叫 [**IBackgroundCopyJob：： Complete**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete) 方法，將檔案的擁有權從 BITS 傳送給使用者之前，用戶端無法使用傳送的檔案。</span><span class="sxs-lookup"><span data-stu-id="0b29f-186">The transferred files are not available to the client until the application calls the [**IBackgroundCopyJob::Complete**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete) method to transfer ownership of the files from BITS to the user.</span></span> <span data-ttu-id="0b29f-187">當伺服器順利接收到檔案時，上傳作業也會設定為已傳輸狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-187">Upload jobs are also set to the transferred state when the file is successfully received by the server.</span></span> <span data-ttu-id="0b29f-188">當檔案成功傳送至伺服器，且從伺服器應用程式的回復成功傳送至用戶端之後，上傳-回復作業會設定為已傳輸狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-188">Upload-reply jobs are set to the transferred state after the file is successfully sent to the server and the reply from the server application is successfully transferred to the client.</span></span>

<span data-ttu-id="0b29f-189">如果發生錯誤，工作會移至嚴重或暫時性錯誤狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-189">If an error occurs, the job moves to either the fatal or transient error state.</span></span> <span data-ttu-id="0b29f-190">嚴重錯誤是指 BITS 無法從復原或需要介入來修正的錯誤。</span><span class="sxs-lookup"><span data-stu-id="0b29f-190">Fatal errors are errors that BITS cannot recover from or which require intervention to fix.</span></span> <span data-ttu-id="0b29f-191">如果應用程式能夠修正錯誤，應用程式會繼續作業，而 BITS 會將作業移至佇列狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-191">If the application is able to fix the error, the application resumes the job and BITS moves the job to the queued state.</span></span> <span data-ttu-id="0b29f-192">暫時性錯誤是可自行解決的錯誤。</span><span class="sxs-lookup"><span data-stu-id="0b29f-192">Transient errors are errors that may resolve themselves.</span></span> <span data-ttu-id="0b29f-193">BITS 會重試處於暫時性錯誤狀態的工作，直到傳輸成功或作業超時為止。當應用程式指定的期間內未進行任何進度時，作業就會超時。</span><span class="sxs-lookup"><span data-stu-id="0b29f-193">BITS retries jobs in the transient error state until the transfer is successful or the job times out. The job times out when no progress is made within an application-specified period.</span></span> <span data-ttu-id="0b29f-194">如果作業超時，BITS 會將作業移到嚴重錯誤狀態。</span><span class="sxs-lookup"><span data-stu-id="0b29f-194">If the job times out, BITS moves the job to fatal error state.</span></span>

<span data-ttu-id="0b29f-195">如需有關工作狀態的詳細資訊，請參閱 [**BG \_ 工作 \_ 狀態**](/windows/desktop/api/Bits/ne-bits-bg_job_state)。</span><span class="sxs-lookup"><span data-stu-id="0b29f-195">For more information on job states, see [**BG\_JOB\_STATE**](/windows/desktop/api/Bits/ne-bits-bg_job_state).</span></span>
