---
title: 使用 USNChanged 輪詢變更
description: 您也可以藉由查詢 uSNChanged 屬性來取得 Active Directory 的變更，以避免 DirSync 控制項的限制。
ms.assetid: 83bda359-09e5-4abf-8f60-9c63bccfcdd1
ms.tgt_platform: multiple
keywords:
- 使用 USNChanged AD 輪詢變更
- USNChanged AD
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a8e062c84fae575f837f45d78be7c92e5e284c1e
ms.sourcegitcommit: 803f3ccd65bdefe36bd851b9c6e7280be9489016
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/17/2020
ms.locfileid: "103842048"
---
# <a name="polling-for-changes-using-usnchanged"></a><span data-ttu-id="fe234-105">使用 USNChanged 輪詢變更</span><span class="sxs-lookup"><span data-stu-id="fe234-105">Polling for Changes Using USNChanged</span></span>

<span data-ttu-id="fe234-106">DirSync 控制項的功能強大且有效率，但有兩大限制：</span><span class="sxs-lookup"><span data-stu-id="fe234-106">The DirSync control is powerful and efficient, but has two significant limitations:</span></span>

-   <span data-ttu-id="fe234-107">僅適用于高許可權的應用程式：若要使用 DirSync 控制項，應用程式必須在網域控制站上具有 **SE \_ 同步代理程式 \_ \_ 名稱** 許可權的帳戶下執行。</span><span class="sxs-lookup"><span data-stu-id="fe234-107">Only for highly privileged applications: To use the DirSync control, an application must run under an account that has the **SE\_SYNC\_AGENT\_NAME** privilege on the domain controller.</span></span> <span data-ttu-id="fe234-108">少數帳戶具有高度許可權，因此一般使用者無法執行使用 DirSync 控制項的應用程式。</span><span class="sxs-lookup"><span data-stu-id="fe234-108">Few accounts are so highly privileged, so an application that uses the DirSync control cannot be run by ordinary users.</span></span>
-   <span data-ttu-id="fe234-109">沒有子樹範圍： DirSync 控制項會傳回在命名內容中發生的所有變更。</span><span class="sxs-lookup"><span data-stu-id="fe234-109">No subtree scoping: The DirSync control returns all changes that occur within a naming context.</span></span> <span data-ttu-id="fe234-110">只對命名內容的小型子樹中發生的變更感興趣的應用程式，必須經過許多不相關的變更，這對應用程式和網域控制站都沒有效率。</span><span class="sxs-lookup"><span data-stu-id="fe234-110">An application interested only in changes that occur in a small subtree of a naming context must wade through many irrelevant changes, which is inefficient both for the application and for the domain controller.</span></span>

<span data-ttu-id="fe234-111">您也可以藉由查詢 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 屬性來取得 Active Directory 的變更，以避免 DirSync 控制項的限制。</span><span class="sxs-lookup"><span data-stu-id="fe234-111">Changes from Active Directory can also be obtained by querying the [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) attribute, which avoids the limitations of the DirSync control.</span></span> <span data-ttu-id="fe234-112">這種替代方式不優於 DirSync 控制項，因為它牽涉到在任何屬性變更時傳輸所有屬性，且需要應用程式開發人員提供更多工作，才能正確處理特定的失敗案例。</span><span class="sxs-lookup"><span data-stu-id="fe234-112">This alternative is not better than the DirSync control in all respects because it involves transmitting all attributes when any attribute changes and it requires more work from the application developer to handle certain failure scenarios correctly.</span></span> <span data-ttu-id="fe234-113">目前，這是撰寫某些變更追蹤應用程式的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="fe234-113">It is, currently, the best way to write certain change-tracking applications.</span></span>

<span data-ttu-id="fe234-114">當網域控制站修改物件時，它會將該物件的 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 屬性設定為大於該物件之 **uSNChanged** 屬性先前值的值，且大於該網域控制站上所有其他物件的 **uSNChanged** 屬性目前值。</span><span class="sxs-lookup"><span data-stu-id="fe234-114">When a domain controller modifies an object it sets that object's [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) attribute to a value that is larger than the previous value of the **uSNChanged** attribute for that object, and larger than the current value of the **uSNChanged** attribute for all other objects held on that domain controller.</span></span> <span data-ttu-id="fe234-115">因此，應用程式可以藉由尋找具有最大 **uSNChanged** 值的物件，在網域控制站上找到最近變更的物件。</span><span class="sxs-lookup"><span data-stu-id="fe234-115">As a consequence, an application can find the most recently changed object on a domain controller by finding the object with the largest **uSNChanged** value.</span></span> <span data-ttu-id="fe234-116">網域控制站上最近變更的第二個物件會有第二個最大的 **uSNChanged** 值，依此類推。</span><span class="sxs-lookup"><span data-stu-id="fe234-116">The second most recently changed object on a domain controller will have the second largest **uSNChanged** value, and so on.</span></span>

<span data-ttu-id="fe234-117">[**USNChanged**](/windows/desktop/ADSchema/a-usnchanged)屬性不會複寫，因此在兩個不同網域控制站上讀取物件的 **uSNChanged** 屬性通常會提供不同的值。</span><span class="sxs-lookup"><span data-stu-id="fe234-117">The [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) attribute is not replicated, therefore reading an object's **uSNChanged** attribute at two different domain controllers will typically give different values.</span></span>

<span data-ttu-id="fe234-118">例如， [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 屬性可以用來追蹤子樹中的變更。首先，執行子樹的「完整同步處理」。假設 S 中任何物件的最大 **uSNChanged** 值為 U。會定期查詢子樹中其 **USNChanged** 值大於 u 的所有物件。此查詢會傳回自完整同步處理後已變更的所有物件。將您設定為這些變更的物件之間的最大 **uSNChanged** ，您便已準備好輪詢。</span><span class="sxs-lookup"><span data-stu-id="fe234-118">For example, the [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) attribute can be used to track changes in a subtree S. First, perform a "full sync" of the subtree S. Suppose the largest **uSNChanged** value for any object in S is U. Periodically query for all objects in subtree S whose **uSNChanged** value is greater than U. The query will return all objects that have changed since the full sync. Set U to the largest **uSNChanged** among these changed objects, and you are ready to poll again.</span></span>

<span data-ttu-id="fe234-119">執行 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 同步處理應用程式的微妙之處包括：</span><span class="sxs-lookup"><span data-stu-id="fe234-119">The subtleties of implementing a [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) synchronization application include:</span></span>

-   <span data-ttu-id="fe234-120">使用 rootDSE 的 **highestCommittedUSN** 屬性來系結您的 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 篩選準則。</span><span class="sxs-lookup"><span data-stu-id="fe234-120">Use the **highestCommittedUSN** attribute of rootDSE to bound your [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) filters.</span></span> <span data-ttu-id="fe234-121">也就是說，在開始進行完整同步處理之前，請先閱讀附屬網域控制站的 **highestCommittedUSN** 。</span><span class="sxs-lookup"><span data-stu-id="fe234-121">That is, before starting a full sync, read the **highestCommittedUSN** of your affiliated domain controller.</span></span> <span data-ttu-id="fe234-122">然後，執行完整同步處理查詢 (使用分頁的結果) 初始化資料庫。</span><span class="sxs-lookup"><span data-stu-id="fe234-122">Then, perform a full synchronization query (using paged results) to initialize the database.</span></span> <span data-ttu-id="fe234-123">完成時，請將 **highestCommittedUSN** 值儲存在完整同步處理查詢之前;用於下一個同步處理的 **uSNChanged** 屬性下限。</span><span class="sxs-lookup"><span data-stu-id="fe234-123">When this is complete, store the **highestCommittedUSN** value read before the full sync query; to use as the lower bounds of the **uSNChanged** attribute for the next synchronization.</span></span> <span data-ttu-id="fe234-124">之後，若要執行增量同步處理，請重新讀取 **highestCommittedUSN** rootDSE 屬性。</span><span class="sxs-lookup"><span data-stu-id="fe234-124">Later, to perform an incremental synchronization, reread the **highestCommittedUSN** rootDSE attribute.</span></span> <span data-ttu-id="fe234-125">然後查詢相關的物件，使用分頁的結果，其 **uSNChanged** 大於先前的同步處理所儲存的 **uSNChanged** 屬性值下限。</span><span class="sxs-lookup"><span data-stu-id="fe234-125">Then query for relevant objects, using paged results, whose **uSNChanged** is greater than the lower bounds of the **uSNChanged** attribute value saved from the previous synchronization.</span></span> <span data-ttu-id="fe234-126">使用此資訊更新資料庫。</span><span class="sxs-lookup"><span data-stu-id="fe234-126">Update the database using this information.</span></span> <span data-ttu-id="fe234-127">完成時，從增量同步處理查詢之前讀取的 **highestCommittedUSN** 值，更新 **uSNChanged** 屬性的下限。</span><span class="sxs-lookup"><span data-stu-id="fe234-127">When complete, update the lower bounds of the **uSNChanged** attribute from the **highestCommittedUSN** value read before the incremental synchronization query.</span></span> <span data-ttu-id="fe234-128">一律將 **uSNChanged** 屬性值的下限儲存在應用程式與網域控制站內容同步處理的相同儲存體中。</span><span class="sxs-lookup"><span data-stu-id="fe234-128">Always store the lower bounds of the **uSNChanged** attribute value in the same storage that the application is synchronizing with the domain controller content.</span></span>

    <span data-ttu-id="fe234-129">遵循此程式，而不是根據抓取物件上的 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 值，避免讓伺服器重新檢查已更新的物件，而該物件落在適用于應用程式的集合之外。</span><span class="sxs-lookup"><span data-stu-id="fe234-129">Following this procedure, rather than that based on [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) values on retrieved objects, avoids making the server reexamine updated objects that fall outside the set that is applicable to the application.</span></span>

-   <span data-ttu-id="fe234-130">因為 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 是非複寫的屬性，所以每次執行應用程式時，都必須系結至相同的網域控制站。</span><span class="sxs-lookup"><span data-stu-id="fe234-130">Because [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) is a non-replicated attribute, the application must bind to the same domain controller every time it runs.</span></span> <span data-ttu-id="fe234-131">如果它無法系結至該網域控制站，則必須等到它可以執行此動作，或與一些新網域控制站的分支機搆，然後執行與該網域控制站的完整同步處理。</span><span class="sxs-lookup"><span data-stu-id="fe234-131">If it cannot bind to that domain controller it must either wait until it can do so, or affiliate with some new domain controller and perform a full synchronization with that domain controller.</span></span> <span data-ttu-id="fe234-132">當應用程式關係企業具有網域控制站時，它會在穩定儲存體中記錄該網域控制站的 DNS 名稱，這是與網域控制站內容保持一致的相同儲存體。</span><span class="sxs-lookup"><span data-stu-id="fe234-132">When the application affiliates with a domain controller it records the DNS name of that domain controller in stable storage, which is the same storage it is keeping consistent with the domain controller content.</span></span> <span data-ttu-id="fe234-133">然後，它會使用儲存的 DNS 名稱來系結至相同的網域控制站，以進行後續的同步處理。</span><span class="sxs-lookup"><span data-stu-id="fe234-133">Then it uses the stored DNS name to bind to the same domain controller for subsequent synchronizations.</span></span>
-   <span data-ttu-id="fe234-134">應用程式必須偵測到它目前關聯的網域控制站是否已從備份還原，因為這可能會造成不一致的情況。</span><span class="sxs-lookup"><span data-stu-id="fe234-134">The application must detect when the domain controller it is currently affiliated with has been restored from backup, because this can cause inconsistency.</span></span> <span data-ttu-id="fe234-135">當應用程式關係企業具有網域控制站時，它會在穩定的儲存體中快取該網域控制站的「調用識別碼」，也就是與網域控制站內容保持一致的相同儲存體。</span><span class="sxs-lookup"><span data-stu-id="fe234-135">When the application affiliates with a domain controller it caches the "invocation id" of that domain controller in stable storage, that is, the same storage it is keeping consistent with the domain controller content.</span></span> <span data-ttu-id="fe234-136">網域控制站的「調用識別碼」是儲存在網域控制站服務物件之 **invocationID** 屬性中的 GUID。</span><span class="sxs-lookup"><span data-stu-id="fe234-136">The "invocation id" of a domain controller is a GUID stored in the **invocationID** attribute of the domain controller's service object.</span></span> <span data-ttu-id="fe234-137">若要取得網域控制站服務物件的辨別名稱，請讀取 rootDSE 的 **dsServiceName** 屬性。</span><span class="sxs-lookup"><span data-stu-id="fe234-137">To get the distinguished name of a domain controller's service object, read the **dsServiceName** attribute of the rootDSE.</span></span>

    <span data-ttu-id="fe234-138">請注意，從備份還原應用程式的穩定儲存體時，不會有一致性問題，因為 [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) 屬性值的網域控制站名稱、調用識別碼和下限會與網域控制站內容同步處理的資料一起儲存。</span><span class="sxs-lookup"><span data-stu-id="fe234-138">Be aware that when the application's stable storage is restored from backup there are no consistency problems because the domain controller name, invocation id, and lower bounds of the [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) attribute value are stored with the data synchronized with the domain controller content.</span></span>

-   <span data-ttu-id="fe234-139">查詢伺服器時使用分頁（包括完整和增量同步處理），以避免同時抓取大型結果集的可能性。</span><span class="sxs-lookup"><span data-stu-id="fe234-139">Use paging when querying the server, both full and incremental synchronizations, to avoid the possibility of retrieving large result sets simultaneously.</span></span> <span data-ttu-id="fe234-140">如需詳細資訊，請參閱 [指定其他搜尋選項](specifying-other-search-options.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-140">For more information, see [Specifying Other Search Options](specifying-other-search-options.md).</span></span>
-   <span data-ttu-id="fe234-141">執行以索引為基礎的查詢，以避免在使用分頁的結果時強制服務器儲存大型的中繼結果。</span><span class="sxs-lookup"><span data-stu-id="fe234-141">Perform index-based queries to avoid forcing the server to store large intermediate results when using paged results.</span></span> <span data-ttu-id="fe234-142">如需詳細資訊，請參閱 [索引屬性](indexed-attributes.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-142">For more information, see [Indexed Attributes](indexed-attributes.md).</span></span>
-   <span data-ttu-id="fe234-143">一般情況下，請不要使用伺服器端排序搜尋結果，這會強制服務器儲存和排序大型的中繼結果。</span><span class="sxs-lookup"><span data-stu-id="fe234-143">In general, do not use server-side sorting of search results, which can force the server to store and sort large intermediate results.</span></span> <span data-ttu-id="fe234-144">這同時適用于完整和增量同步處理。</span><span class="sxs-lookup"><span data-stu-id="fe234-144">This applies to both full and incremental synchronizations.</span></span> <span data-ttu-id="fe234-145">如需詳細資訊，請參閱 [指定其他搜尋選項](specifying-other-search-options.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-145">For more information, see [Specifying Other Search Options](specifying-other-search-options.md).</span></span>
-   <span data-ttu-id="fe234-146">不正常處理任何父條件。</span><span class="sxs-lookup"><span data-stu-id="fe234-146">Handle no parent conditions gracefully.</span></span> <span data-ttu-id="fe234-147">應用程式可能會先辨識物件，才能辨識其父代。</span><span class="sxs-lookup"><span data-stu-id="fe234-147">The application may recognize an object before it has recognized its parent.</span></span> <span data-ttu-id="fe234-148">視應用程式而定，這可能不是問題。</span><span class="sxs-lookup"><span data-stu-id="fe234-148">Depending upon the application, this may or may not be a problem.</span></span> <span data-ttu-id="fe234-149">應用程式一律會從目錄讀取父系的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="fe234-149">The application can always read the current state of the parent from the directory.</span></span>
-   <span data-ttu-id="fe234-150">若要處理已移動或已刪除的物件，請儲存每個追蹤物件的 [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) 屬性。</span><span class="sxs-lookup"><span data-stu-id="fe234-150">To handle moved or deleted objects, store the [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) attribute of each tracked object.</span></span> <span data-ttu-id="fe234-151">無論物件在整個樹系中移動的位置為何，物件的 **objectGUID** 屬性都會保持不變。</span><span class="sxs-lookup"><span data-stu-id="fe234-151">An object's **objectGUID** attribute remains unchanged regardless of where it is moved throughout the forest.</span></span>
-   <span data-ttu-id="fe234-152">若要處理已移動的物件，請執行定期完整同步處理或增加搜尋範圍，並在用戶端上篩選出不想要的變更。</span><span class="sxs-lookup"><span data-stu-id="fe234-152">To handle moved objects, either perform periodic full synchronizations or increase the search scope and filter out uninteresting changes at the client end.</span></span>
-   <span data-ttu-id="fe234-153">若要處理已刪除的物件，請在執行增量同步處理時，執行定期完整同步處理，或執行個別搜尋已刪除的物件。</span><span class="sxs-lookup"><span data-stu-id="fe234-153">To handle deleted objects, either perform periodic full synchronizations or perform a separate search for deleted objects when you perform an incremental synchronization.</span></span> <span data-ttu-id="fe234-154">當您查詢已刪除的物件時，請取出已刪除之物件的 [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) ，以判斷要從資料庫中刪除的物件。</span><span class="sxs-lookup"><span data-stu-id="fe234-154">When you query for deleted objects, retrieve the [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) of the deleted objects to determine the objects to delete from your database.</span></span> <span data-ttu-id="fe234-155">如需詳細資訊，請參閱 [取出已刪除的物件](retrieving-deleted-objects.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-155">For more information, see [Retrieving Deleted Objects](retrieving-deleted-objects.md).</span></span>
-   <span data-ttu-id="fe234-156">請注意，搜尋結果只會包含呼叫端有權讀取 (的物件和屬性，這些物件和屬性是根據不同物件) 上的安全描述項和 Dacl。</span><span class="sxs-lookup"><span data-stu-id="fe234-156">Be aware that the search results include only the objects and attributes that the caller has permission to read (based on the security descriptors and DACLs on the various objects).</span></span> <span data-ttu-id="fe234-157">如需詳細資訊，請參閱 [查詢安全性的影響](effects-of-security-on-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-157">For more information, see [Effects of Security on Queries](effects-of-security-on-queries.md).</span></span>

<span data-ttu-id="fe234-158">如需詳細資訊，以及顯示 USNChanged 同步處理應用程式基本概念的程式碼範例，請參閱 [使用 USNChanged 抓取變更的範例程式碼](example-code-to-retrieve-changes-using-usnchanged.md)。</span><span class="sxs-lookup"><span data-stu-id="fe234-158">For more information, and a code example that shows the basics of a USNChanged synchronization application, see [Example Code to Retrieve Changes Using USNChanged](example-code-to-retrieve-changes-using-usnchanged.md).</span></span>

 

 