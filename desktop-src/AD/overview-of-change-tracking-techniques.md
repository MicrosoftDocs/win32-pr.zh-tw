---
title: 變更追蹤技術總覽
description: 有幾種方式可讓變更追蹤機制不同範圍來追蹤變更，應用程式可以追蹤單一物件的單一屬性變更、網域中的所有物件等等。
ms.assetid: 7359e851-61b7-420d-beb0-f7f33f79b007
ms.tgt_platform: multiple
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91fce20dc5e9fe8fe98937bb13885be577185e04
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "104020836"
---
# <a name="overview-of-change-tracking-techniques"></a><span data-ttu-id="79a2c-103">變更追蹤技術總覽</span><span class="sxs-lookup"><span data-stu-id="79a2c-103">Overview of Change Tracking Techniques</span></span>

<span data-ttu-id="79a2c-104">有幾種方式可讓變更追蹤機制有所不同：</span><span class="sxs-lookup"><span data-stu-id="79a2c-104">There are several ways that change tracking mechanisms can differ:</span></span>

-   <span data-ttu-id="79a2c-105">追蹤變更的範圍：應用程式可以追蹤單一物件之單一屬性的變更、網域中的所有物件等等。</span><span class="sxs-lookup"><span data-stu-id="79a2c-105">Scope for tracking changes: An application can track changes to a single attribute of a single object, to all objects in a domain, and so on.</span></span> <span data-ttu-id="79a2c-106">如果機制符合應用程式的需求，應用程式就會收到最少不相關的資料，因此這會增強效能。</span><span class="sxs-lookup"><span data-stu-id="79a2c-106">If the mechanism matches the requirements of the application, the application receives a minimum of irrelevant data, and thus this enhances performance.</span></span>
-   <span data-ttu-id="79a2c-107">時效性：應用程式會在每次發生變更時收到通知，或可在一段分鐘或幾小時內收到變更的淨影響通知。</span><span class="sxs-lookup"><span data-stu-id="79a2c-107">Timeliness: An application is notified of every change as it happens, or can be notified of the net effect of changes over a period of minutes or hours.</span></span>

    <span data-ttu-id="79a2c-108">處理較不及時的資料可能更有效率，因為許多變更可能會折迭成一個。</span><span class="sxs-lookup"><span data-stu-id="79a2c-108">Processing less timely data may be more efficient, because several changes may be collapsed into one.</span></span> <span data-ttu-id="79a2c-109">例如，如果屬性在一小時的間隔內變更三次，則在一小時內累積變更的應用程式將只會收到一個屬性變更的通知，而非三個。</span><span class="sxs-lookup"><span data-stu-id="79a2c-109">For example, if an attribute changes three times within a one hour interval, an application notified of changes accumulated over an hour will be notified of just one attribute change, not three.</span></span>

    <span data-ttu-id="79a2c-110">考慮時效性時，請考慮複寫延遲的影響。</span><span class="sxs-lookup"><span data-stu-id="79a2c-110">When thinking about timeliness, consider the effect of replication latency.</span></span> <span data-ttu-id="79a2c-111">源自某個網域控制站的更新不會立即複寫到另一個網域控制站。</span><span class="sxs-lookup"><span data-stu-id="79a2c-111">An update that originates on one domain controller does not replicate to another domain controller instantly.</span></span> <span data-ttu-id="79a2c-112">比預期的複寫延遲需要更好的變更追蹤時效性，通常對應用程式沒有真正的好處。</span><span class="sxs-lookup"><span data-stu-id="79a2c-112">Requiring change-tracking timeliness much better than the expected replication latency often gives no real benefit to the application.</span></span>

-   <span data-ttu-id="79a2c-113">輪詢與通知：使用輪詢時，應用程式會定期對網域控制站提出要求，以接收變更追蹤資料。</span><span class="sxs-lookup"><span data-stu-id="79a2c-113">Polling versus notification: With polling, an application periodically makes a request to a domain controller to receive change tracking data.</span></span> <span data-ttu-id="79a2c-114">使用通知時，網域控制站只會在發生變更時將變更傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="79a2c-114">With notification the domain controller sends changes to the application only when changes occur.</span></span>

    <span data-ttu-id="79a2c-115">輪詢的額外負荷很明顯：應用程式可能會在未發生任何重大狀況時要求變更追蹤資料。</span><span class="sxs-lookup"><span data-stu-id="79a2c-115">The overhead of polling is obvious: The application may request change tracking data when nothing significant has occurred.</span></span> <span data-ttu-id="79a2c-116">通知的額外負荷更微妙。</span><span class="sxs-lookup"><span data-stu-id="79a2c-116">The overhead of notification is more subtle.</span></span> <span data-ttu-id="79a2c-117">伺服器必須維護通知要求的相關資料，而且必須參考此資料來決定是否要傳送通知。</span><span class="sxs-lookup"><span data-stu-id="79a2c-117">The server must maintain data about notification requests and must consult this data to decide whether or not to send a notification.</span></span> <span data-ttu-id="79a2c-118">這可能會增加一般更新要求的負擔。</span><span class="sxs-lookup"><span data-stu-id="79a2c-118">This can add overhead to normal update requests.</span></span>

-   <span data-ttu-id="79a2c-119">表示應用程式的知識：持續性和暫時性：每個變更追蹤機制都必須包含部分伺服器的方法，讓伺服器保留追蹤的資料，以瞭解應用程式的知識狀態，以便妥善定義「變更」的概念。</span><span class="sxs-lookup"><span data-stu-id="79a2c-119">Expressing the application's knowledge: persistent versus temporary: Every change tracking mechanism must include some method for the server holding the data tracked to understand the application's state of knowledge, so that the idea of "change" is well defined.</span></span> <span data-ttu-id="79a2c-120">例如，應用程式的知識狀態可能會表示為「已更新，並以 DC d 之前發生的所有變更」。</span><span class="sxs-lookup"><span data-stu-id="79a2c-120">For example, the application's state of knowledge might be expressed as "Updated with all changes that occurred on DC d before time t."</span></span> <span data-ttu-id="79a2c-121">以這種方式來表示應用程式知識的機制，可提供有效率的方式讓應用程式取得晚于指定時間所發生的變更。</span><span class="sxs-lookup"><span data-stu-id="79a2c-121">A mechanism based on this way of expressing an application's state of knowledge would provide an efficient way for the application to obtain changes that have occurred later than a specified time.</span></span>

    <span data-ttu-id="79a2c-122">如果應用程式知識的運算式可保存，也就是儲存 recoverably （如同在檔案或資料庫中），則應用程式重新開機所耗用的資源會比無法進行的資源更少。</span><span class="sxs-lookup"><span data-stu-id="79a2c-122">If the expression of the application's knowledge can be persisted, that is, stored recoverably, as in a file or database, application restart is less resource intensive than if it cannot.</span></span> <span data-ttu-id="79a2c-123">在上述範例中，您可以藉由錄製 DC d 和 time t 來保存應用程式知識的運算式。</span><span class="sxs-lookup"><span data-stu-id="79a2c-123">In the example above, the expression of the application's knowledge can be persisted by recording the DC d and the time t.</span></span> <span data-ttu-id="79a2c-124">某些變更通知機制不允許保存此資料。</span><span class="sxs-lookup"><span data-stu-id="79a2c-124">Some change notification mechanisms do not allow this data to be persisted.</span></span> <span data-ttu-id="79a2c-125">當應用程式啟動時，伺服器和應用程式必須與一些其他機制進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="79a2c-125">The server and application must synchronize with some other mechanism when the application starts.</span></span> <span data-ttu-id="79a2c-126">如果涉及多個物件，則這會耗用大量資源，而且可能牽涉到複雜的程式設計。</span><span class="sxs-lookup"><span data-stu-id="79a2c-126">This is resource-intensive if multiple objects are involved, and can involve complex programming.</span></span>

<span data-ttu-id="79a2c-127">使用下列技巧來追蹤 Active Directory Domain Services 中的變更：</span><span class="sxs-lookup"><span data-stu-id="79a2c-127">Use the following techniques to track changes in Active Directory Domain Services:</span></span>

-   <span data-ttu-id="79a2c-128">使用變更通知控制項，針對符合指定篩選準則的變更起始持續性非同步搜尋。</span><span class="sxs-lookup"><span data-stu-id="79a2c-128">Use the change notification control to initiate a persistent asynchronous search for changes that match a specified filter.</span></span> <span data-ttu-id="79a2c-129">如需詳細資訊，請參閱 [Active Directory Domain Services 中的變更通知](change-notifications-in-active-directory-domain-services.md)。</span><span class="sxs-lookup"><span data-stu-id="79a2c-129">For more information, see [Change Notifications in Active Directory Domain Services](change-notifications-in-active-directory-domain-services.md).</span></span>
-   <span data-ttu-id="79a2c-130">使用目錄同步作業 (DirSync) 搜尋來取出先前的 DirSync 搜尋之後發生的變更。</span><span class="sxs-lookup"><span data-stu-id="79a2c-130">Use a directory synchronization (DirSync) search to retrieve changes that have occurred since the previous DirSync search.</span></span> <span data-ttu-id="79a2c-131">如需詳細資訊，請參閱 [使用 DirSync 控制項輪詢變更](polling-for-changes-using-the-dirsync-control.md)。</span><span class="sxs-lookup"><span data-stu-id="79a2c-131">For more information, see [Polling for Changes Using the DirSync Control](polling-for-changes-using-the-dirsync-control.md).</span></span>
-   <span data-ttu-id="79a2c-132">使用 USNChanged 屬性來搜尋自上一次搜尋之後變更的物件。</span><span class="sxs-lookup"><span data-stu-id="79a2c-132">Use the USNChanged attribute to search for objects that have changed since the previous search.</span></span> <span data-ttu-id="79a2c-133">如需詳細資訊，請參閱 [使用 USNChanged 輪詢變更](polling-for-changes-using-usnchanged.md)。</span><span class="sxs-lookup"><span data-stu-id="79a2c-133">For more information, see [Polling for Changes Using USNChanged](polling-for-changes-using-usnchanged.md).</span></span>

<span data-ttu-id="79a2c-134">變更通知控制項是針對需要對不頻繁變更的適當提示通知的應用程式或服務所設計。</span><span class="sxs-lookup"><span data-stu-id="79a2c-134">The change notification control is designed for applications or services that require reasonably prompt notification of infrequent changes.</span></span> <span data-ttu-id="79a2c-135">其中一個範例是將設定資料儲存在 Active Directory 伺服器上的服務或程式，且必須在發生變更時立即收到通知。</span><span class="sxs-lookup"><span data-stu-id="79a2c-135">An example is a service or program that stores configuration data on the Active Directory server and must be notified promptly when a change occurs.</span></span> <span data-ttu-id="79a2c-136">請注意，通知控制項有一些限制。</span><span class="sxs-lookup"><span data-stu-id="79a2c-136">Be aware that there are limitations of the notification control.</span></span>

-   <span data-ttu-id="79a2c-137">通知 promptness 取決於複寫延遲和發生變更的位置。</span><span class="sxs-lookup"><span data-stu-id="79a2c-137">The promptness of notifications depends on replication latency and where the change occurred.</span></span> <span data-ttu-id="79a2c-138">當變更複寫到您正在監視的複本時，您可能會收到通知，但變更可能會在較早的部分複本上產生。</span><span class="sxs-lookup"><span data-stu-id="79a2c-138">You may be notified promptly when a change replicates into the replica you are monitoring, but the change may have originated much earlier on some other replica.</span></span>
-   <span data-ttu-id="79a2c-139">控制項受限於監視單一物件或容器的直屬子系。</span><span class="sxs-lookup"><span data-stu-id="79a2c-139">The control is restricted to monitoring a single object or the immediate children of a container.</span></span> <span data-ttu-id="79a2c-140">必須監視多個容器或不相關物件的應用程式，最多可以註冊五個通知要求。</span><span class="sxs-lookup"><span data-stu-id="79a2c-140">Applications that must monitor multiple containers or unrelated objects can register up to five notification requests.</span></span>
-   <span data-ttu-id="79a2c-141">如果有太多用戶端接聽頻繁發生的變更，就會影響伺服器的效能。</span><span class="sxs-lookup"><span data-stu-id="79a2c-141">If too many clients are listening for changes that occur frequently, it will impact the performance of the server.</span></span> <span data-ttu-id="79a2c-142">一般而言，應用程式應該限制在伺服器上使用此控制項的效能原因。</span><span class="sxs-lookup"><span data-stu-id="79a2c-142">In general, applications should limit their use of this control for performance reasons on the server.</span></span> <span data-ttu-id="79a2c-143">如果您不需要立即瞭解變更，最好是定期輪詢變更，而不是使用變更通知。</span><span class="sxs-lookup"><span data-stu-id="79a2c-143">If you do not need to know about changes immediately, it may be best to periodically poll for changes instead of using change notification.</span></span>

<span data-ttu-id="79a2c-144">DirSync 和 USNChanged 搜尋技術是針對在 Active Directory 伺服器上的資料與某些其他儲存體中的對應資料維持一致性的應用程式所設計。</span><span class="sxs-lookup"><span data-stu-id="79a2c-144">The DirSync and USNChanged search techniques are designed for applications that maintain consistency between data on the Active Directory server and corresponding data in some other storage.</span></span> <span data-ttu-id="79a2c-145">這些技術是由定期輪詢變更的應用程式所使用。</span><span class="sxs-lookup"><span data-stu-id="79a2c-145">These techniques are used by applications that periodically poll for changes.</span></span> <span data-ttu-id="79a2c-146">DirSync 技術是以您可以透過 ADSI 或 LDAP Api 使用的 LDAP 伺服器控制項為基礎。</span><span class="sxs-lookup"><span data-stu-id="79a2c-146">The DirSync technique is based on an LDAP server control that you can use through ADSI or LDAP APIs.</span></span> <span data-ttu-id="79a2c-147">DirSync 控制項的缺點是它只能由高度許可權的帳戶（例如網域系統管理員）使用。</span><span class="sxs-lookup"><span data-stu-id="79a2c-147">The disadvantages of the DirSync control are that it can only be used by a highly privileged account, such as a domain administrator.</span></span> <span data-ttu-id="79a2c-148">以下是 DirSync 控制項的限制清單：</span><span class="sxs-lookup"><span data-stu-id="79a2c-148">The following is a list of limitations of DirSync control:</span></span>

-   <span data-ttu-id="79a2c-149">DirSync 控制項只能由高度許可權的帳戶（例如網域系統管理員）使用。</span><span class="sxs-lookup"><span data-stu-id="79a2c-149">The DirSync control can only be used by a highly privileged account, such as a domain administrator.</span></span>
-   <span data-ttu-id="79a2c-150">DirSync 控制項只能監視整個命名內容。</span><span class="sxs-lookup"><span data-stu-id="79a2c-150">The DirSync control can only monitor an entire naming context.</span></span> <span data-ttu-id="79a2c-151">您無法限制 DirSync 搜尋的範圍，只監視命名內容中特定的子樹、容器或物件。</span><span class="sxs-lookup"><span data-stu-id="79a2c-151">You cannot limit the scope of a DirSync search to monitor only a specific subtree, container, or object in a naming context.</span></span>

<span data-ttu-id="79a2c-152">USNChanged 技術並沒有這些限制，不過它比 DirSync 更複雜一點。</span><span class="sxs-lookup"><span data-stu-id="79a2c-152">The USNChanged technique does not have these limitations, although it is somewhat more complicated to use than DirSync.</span></span>

 

 




