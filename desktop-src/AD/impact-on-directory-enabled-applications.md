---
title: 對 Directory-Enabled 應用程式的影響
description: 本主題說明當版本扭曲、部分更新或發生衝突時，對啟用目錄的應用程式所造成的影響。
ms.assetid: 0aec6fe3-7757-4472-bc18-add2327d4e1b
ms.tgt_platform: multiple
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 061818fc791e1c75d440d0c477a321b8c4e5edfb
ms.sourcegitcommit: 803f3ccd65bdefe36bd851b9c6e7280be9489016
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/17/2020
ms.locfileid: "103933061"
---
# <a name="impact-on-directory-enabled-applications"></a><span data-ttu-id="70a00-103">對 Directory-Enabled 應用程式的影響</span><span class="sxs-lookup"><span data-stu-id="70a00-103">Impact on Directory-Enabled Applications</span></span>

## <a name="version-skew"></a><span data-ttu-id="70a00-104">版本扭曲</span><span class="sxs-lookup"><span data-stu-id="70a00-104">Version Skew</span></span>

<span data-ttu-id="70a00-105">當應用程式在複寫變更之前從不同的複本讀取相同的物件時，就會發生版本誤差。</span><span class="sxs-lookup"><span data-stu-id="70a00-105">Version skew occurs when applications read the same objects from different replicas before a change has replicated.</span></span> <span data-ttu-id="70a00-106">讀取遠端複本的應用程式會辨識未變更的物件。</span><span class="sxs-lookup"><span data-stu-id="70a00-106">Applications reading the remote replica recognize the unchanged object.</span></span> <span data-ttu-id="70a00-107">當指定的應用程式或一組應用程式使用目錄中的資料進行交互操作時，就會發生版本扭曲的問題。</span><span class="sxs-lookup"><span data-stu-id="70a00-107">Version skew is an issue when a given application or set of applications use the data in the directory to interoperate.</span></span>

<span data-ttu-id="70a00-108">例如，RPC 服務可以使用標準 RPC (Api （例如 [**RpcNsBindingExport**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta)) ）在目錄中發佈其端點。</span><span class="sxs-lookup"><span data-stu-id="70a00-108">For example, an RPC Service can publish its endpoints in the directory using standard RPC APIs (such as [**RpcNsBindingExport**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta)).</span></span> <span data-ttu-id="70a00-109">用戶端會藉由查詢目錄中所需的端點 ( [**RpcNsBindingLookupBegin**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina)、 [**RpcNsBindingLookupNext**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext)等方式來連線至服務，並) 並系結至該端點。</span><span class="sxs-lookup"><span data-stu-id="70a00-109">Clients connect to the service by looking up the desired endpoint in the directory ( [**RpcNsBindingLookupBegin**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina), [**RpcNsBindingLookupNext**](/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext), and so on) and binding to it.</span></span>

<span data-ttu-id="70a00-110">假設 RPC Service S ₁發佈了端點 Es ₁，然後再移至另一部電腦。</span><span class="sxs-lookup"><span data-stu-id="70a00-110">Assume that an RPC Service S₁ publishes endpoint Eₛ₁ and subsequently moves to a different computer.</span></span> <span data-ttu-id="70a00-111">原始端點 Es ₁會變更為 E<sub>s2，</sub> 以反映新電腦的位址。</span><span class="sxs-lookup"><span data-stu-id="70a00-111">The original endpoint Eₛ₁ is changed to E<sub>s2,</sub> reflecting the new computer's address.</span></span> <span data-ttu-id="70a00-112">讀取目錄服務遠端複本的用戶端無法連線到服務，直到複寫更新的端點為止。</span><span class="sxs-lookup"><span data-stu-id="70a00-112">Clients reading remote replicas of the directory service are unable to connect to the service until the updated endpoint is replicated.</span></span> <span data-ttu-id="70a00-113">不過，將服務從一部電腦移到另一部電腦是很罕見的情況;因此，您應該很少遇到此中斷/延遲，特別是在服務的移動已妥善規劃的情況下。</span><span class="sxs-lookup"><span data-stu-id="70a00-113">However, moving a service from one computer to another is a rare occurrence; therefore, this interruption/delay should rarely be encountered, especially if the movement of the service is well-planned.</span></span>

## <a name="partial-updates"></a><span data-ttu-id="70a00-114">部分更新</span><span class="sxs-lookup"><span data-stu-id="70a00-114">Partial Updates</span></span>

<span data-ttu-id="70a00-115">一般來說，當某個應用程式正在讀取一組資料，而另一個應用程式正在寫入相同的資料集時，就會發生部分更新。</span><span class="sxs-lookup"><span data-stu-id="70a00-115">In general, partial update occurs when one application is reading a set of data while another application is writing to that same set of data.</span></span> <span data-ttu-id="70a00-116">這種情況可能會發生在多個主要系統中的任何應用程式。</span><span class="sxs-lookup"><span data-stu-id="70a00-116">This is a situation that can occur with any application in a multi-mastered system.</span></span> <span data-ttu-id="70a00-117">有許多方式可以進行。</span><span class="sxs-lookup"><span data-stu-id="70a00-117">There are many ways this can occur.</span></span> <span data-ttu-id="70a00-118">您可能會有一個以上的應用程式同時寫入相同的資料集。</span><span class="sxs-lookup"><span data-stu-id="70a00-118">You could have more than one application writing to the same data set at once.</span></span> <span data-ttu-id="70a00-119">如果您以這種方式查看，目錄複寫服務就是另一個應用程式，可能會寫入到另一個應用程式可能正在讀取的相同資料集。</span><span class="sxs-lookup"><span data-stu-id="70a00-119">If you look at it this way, the directory replication service is just another application that could potentially be writing to the same data set that another application may be reading.</span></span> <span data-ttu-id="70a00-120">這可能是應用程式的潛在問題。</span><span class="sxs-lookup"><span data-stu-id="70a00-120">This could be a potential problem for an application.</span></span> <span data-ttu-id="70a00-121">但是，部分更新可能影響您應用程式的時間範圍相當小。</span><span class="sxs-lookup"><span data-stu-id="70a00-121">However, the window of time in which a partial update can affect your application is relatively small.</span></span> <span data-ttu-id="70a00-122">如果應用程式不依賴多個物件的同步處理，這應該很少發生。</span><span class="sxs-lookup"><span data-stu-id="70a00-122">This should rarely if ever be an issue for applications that are not dependent on the synchronization of multiple objects.</span></span> <span data-ttu-id="70a00-123">如果您的應用程式高度依賴一組相關物件的同步處理，您應該考慮在應用程式設計中進行部分更新的影響。</span><span class="sxs-lookup"><span data-stu-id="70a00-123">If your application is highly dependent on the synchronization of a related set of objects, you should consider the effects of a partial update in your application design.</span></span>

<span data-ttu-id="70a00-124">就目錄複寫而言，當應用程式在進行複寫時，從不同的複本讀取一組相同的物件時，就會發生部分更新。</span><span class="sxs-lookup"><span data-stu-id="70a00-124">In terms of the directory replication, partial update occurs when applications read the same set of objects from different replicas while replication is in progress.</span></span> <span data-ttu-id="70a00-125">遠端複本上的應用程式會看到部分（但不是全部）的變更。</span><span class="sxs-lookup"><span data-stu-id="70a00-125">Applications at the remote replica see some, but not all, of the changes.</span></span>

> [!Note]  
> <span data-ttu-id="70a00-126">部分更新會對應用程式造成影響的視窗很小：當輸入複寫正在進行時，應用程式必須開始讀取物件，但在收到一或多個相關的已變更物件之後，但在收到全部之前。</span><span class="sxs-lookup"><span data-stu-id="70a00-126">The window in which partial update can affect an application is small: the application must start reading objects while inbound replication is in progress, after one or more of the related, changed objects have been received but before all have been received.</span></span> <span data-ttu-id="70a00-127">來源複本上的更新之間的時間會直接影響此視窗的大小，同時會在一段時間內關閉更新。</span><span class="sxs-lookup"><span data-stu-id="70a00-127">The time between the updates at the source replica directly affects the size of this window—updates that occur close together in time are replicated close together in time.</span></span> <span data-ttu-id="70a00-128">當應用程式使用一組相關物件時，部分更新可能會產生問題。</span><span class="sxs-lookup"><span data-stu-id="70a00-128">Partial update can be an issue when an application uses a related set of objects.</span></span>

 

<span data-ttu-id="70a00-129">例如，遠端存取服務可以使用目錄來儲存原則和設定檔資料。</span><span class="sxs-lookup"><span data-stu-id="70a00-129">For example, a remote access service can use the directory to store policy and profile data.</span></span> <span data-ttu-id="70a00-130">原則資料會儲存在一組物件中，而設定檔則儲存在另一個集合中。</span><span class="sxs-lookup"><span data-stu-id="70a00-130">The policy data is stored in one set of objects, and the profile in another set.</span></span> <span data-ttu-id="70a00-131">當使用者連線到遠端存取服務時，遠端存取服務會讀取原則以判斷是否允許使用者連線，以及要將哪個設定檔套用至使用者會話。</span><span class="sxs-lookup"><span data-stu-id="70a00-131">When a user connects to the remote access service, the remote access service reads the policy to determine whether the user is allowed to connect, and if so what profile to apply to the user session.</span></span> <span data-ttu-id="70a00-132">部分更新會以數種方式影響遠端存取服務：</span><span class="sxs-lookup"><span data-stu-id="70a00-132">Partial update can affect the remote access service in several ways:</span></span>

-   <span data-ttu-id="70a00-133">如果原則很複雜，而且是由多個物件所組成，則遠端存取服務可能會讀取部分更新的原則，導致不正確地拒絕或授與使用者的服務、無法處理原則，因為內部不一致等等。</span><span class="sxs-lookup"><span data-stu-id="70a00-133">If the policy is complex and consists of multiple objects, the remote access service might read a partially updated policy resulting in incorrect denial or granting of service to the user, inability to process the policy due to internal inconsistency, and so on.</span></span>
-   <span data-ttu-id="70a00-134">如果原則和設定檔都已更新，則服務可能會正確地處理原則，但會套用過時的設定檔，因為原則物件已複寫，但設定檔物件尚未進行複製。</span><span class="sxs-lookup"><span data-stu-id="70a00-134">If both the policy and profiles have been updated, the service might correctly process the policy but apply a stale profile, because the policy objects have replicated but the profile objects have not.</span></span>
-   <span data-ttu-id="70a00-135">如果設定檔很複雜，且包含多個物件，則服務可能會正確處理原則，但會套用部分更新的設定檔，因為原則物件已複寫，但只有部分設定檔物件已完成。</span><span class="sxs-lookup"><span data-stu-id="70a00-135">If the profile is complex and consists of multiple objects, the service might correctly process the policy but apply a partially updated profile because the policy objects have replicated, but only some of the profile objects have done so.</span></span>

## <a name="collisions"></a><span data-ttu-id="70a00-136">衝突</span><span class="sxs-lookup"><span data-stu-id="70a00-136">Collisions</span></span>

<span data-ttu-id="70a00-137">當指定物件的兩個或多個複本的相同屬性在相同複寫間隔期間變更時，就會發生衝突。</span><span class="sxs-lookup"><span data-stu-id="70a00-137">Collisions occur when the same attributes of two or more replicas of a given object are changed during the same replication interval.</span></span> <span data-ttu-id="70a00-138">複寫進程會協調衝突;因為對使用者或應用程式的對帳可能會「看到」非它們所寫入的值。</span><span class="sxs-lookup"><span data-stu-id="70a00-138">The replication process reconciles the collision; because of reconciliation a user or application may "see" a value other than the one they wrote.</span></span>

<span data-ttu-id="70a00-139">簡單的範例是使用者位址資訊：使用者變更了複本 R1 的郵寄地址，而系統管理員在複本 R2 上變更相同的郵寄地址。</span><span class="sxs-lookup"><span data-stu-id="70a00-139">A simple example is user address information: A user changes a mailing address at replica R1 and an administrator changes the same mailing address at replica R2.</span></span> <span data-ttu-id="70a00-140">寫入的值會傳播到另一個值是由衝突對帳機制選取該值之前。</span><span class="sxs-lookup"><span data-stu-id="70a00-140">A written value propagates until another value is selected over that value by the collision reconciliation mechanism.</span></span> <span data-ttu-id="70a00-141">只要值持續針對碰撞解析程式中的其他值「獲勝」，此值就會持續傳播。</span><span class="sxs-lookup"><span data-stu-id="70a00-141">As long as a value continues to "win" against other values in the collision resolution process, the value continues to propagate.</span></span> <span data-ttu-id="70a00-142">最後，如果未進行其他變更，則會將此「獲勝」值傳播至 R1、R2 和所有其他複本。</span><span class="sxs-lookup"><span data-stu-id="70a00-142">Ultimately, this "winning" value will be propagated to R1,R2, and all other replicas if no other changes are made.</span></span>

<span data-ttu-id="70a00-143">衝突解決是針對物件或物件集的內部一致性假設的應用程式所造成的問題。</span><span class="sxs-lookup"><span data-stu-id="70a00-143">Collision resolution is an issue for applications that make assumptions about the internal consistency of objects or sets of objects.</span></span> <span data-ttu-id="70a00-144">例如，網路頻寬建構管理服務會將指定之網路區段的網路頻寬資料儲存在物件 O1 的目錄中。</span><span class="sxs-lookup"><span data-stu-id="70a00-144">For example, a network bandwidth allocation management service stores network bandwidth data for a given network segment in the directory in an object O1.</span></span> <span data-ttu-id="70a00-145">此物件包含每秒位可用的頻寬，以及任何單一使用者可保留的最大頻寬。</span><span class="sxs-lookup"><span data-stu-id="70a00-145">The object contains the bandwidth available in bits-per-second and the maximum bandwidth any single user can reserve.</span></span> <span data-ttu-id="70a00-146">服務預期使用者可保留頻寬一律會小於或等於可用的頻寬。</span><span class="sxs-lookup"><span data-stu-id="70a00-146">The service expects that the user reservable bandwidth will always be less than or equal to the bandwidth available.</span></span>

<span data-ttu-id="70a00-147">考量以下事件順序：</span><span class="sxs-lookup"><span data-stu-id="70a00-147">Consider the following sequence of events:</span></span>

-   <span data-ttu-id="70a00-148">處於初始完整複寫狀態的物件會提供每秒 56 kb 的可用頻寬，而使用者可保留頻寬為每秒9600位。</span><span class="sxs-lookup"><span data-stu-id="70a00-148">The object in the initial fully replicated state gives the available bandwidth as 56 kilobits-per-second, and the user reservable bandwidth as 9,600 bits-per-second.</span></span>
-   <span data-ttu-id="70a00-149">複本 R ₁的系統管理員會分別將值變更為64k 和19200。</span><span class="sxs-lookup"><span data-stu-id="70a00-149">An administrator at replica R₁ changes the values to 64k and 19,200 respectively.</span></span>
-   <span data-ttu-id="70a00-150">複本 R ₂的系統管理員會在 R ₁抵達的更新之前，分別將值變更為10000000和1000000。</span><span class="sxs-lookup"><span data-stu-id="70a00-150">An administrator at replica R₂ changes the values to 10 million and 1 million respectively before the update from R₁ arrives.</span></span>

<span data-ttu-id="70a00-151">如果有問題的屬性在發生更新時具有相同的版本號碼，則物件的最大頻寬可能是最大的，但如果應用程式以個別的寫入作業來執行更新，則物件的最大頻寬可能會有最大的最大頻寬和1百萬的使用者可保留。</span><span class="sxs-lookup"><span data-stu-id="70a00-151">Assuming the attributes in question have equal version numbers when the updates occur, there is a small, but real, possibility that the object will end up with a maximum bandwidth of 64k and a user reservable maximum of 1 million—if the application performs the updates as separate write operations.</span></span> <span data-ttu-id="70a00-152">應用程式一律會在單一作業中更新這兩個屬性。</span><span class="sxs-lookup"><span data-stu-id="70a00-152">The application should always update both properties in a single operation.</span></span>

 

 