---
title: 輸出合併階段
description: " (OM) 階段的輸出合併會使用管線狀態的組合、圖元著色器所產生的圖元資料、轉譯目標的內容，以及深度/樣板緩衝區的內容，來產生最終呈現的圖元色彩。"
ms.assetid: 8be68c15-2deb-4804-b683-30080a876189
keywords:
- " (Direct3D 10) 的輸出合併階段"
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ec77eaff506a0be87a3f0e98de691b50c27c0c3f
ms.sourcegitcommit: a716ca2a6a22a400f02c6b31699cf4da83ee3619
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/04/2020
ms.locfileid: "104383294"
---
# <a name="output-merger-stage"></a><span data-ttu-id="8c7ec-104">輸出合併階段</span><span class="sxs-lookup"><span data-stu-id="8c7ec-104">Output-Merger Stage</span></span>

<span data-ttu-id="8c7ec-105"> (OM) 階段的輸出合併會使用管線狀態的組合、圖元著色器所產生的圖元資料、轉譯目標的內容，以及深度/樣板緩衝區的內容，來產生最終呈現的圖元色彩。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-105">The output-merger (OM) stage generates the final rendered pixel color using a combination of pipeline state, the pixel data generated by the pixel shaders, the contents of the render targets, and the contents of the depth/stencil buffers.</span></span> <span data-ttu-id="8c7ec-106">OM 階段是決定哪些圖元可見 (具有深度樣板測試) 和混合最後圖元色彩的最後一個步驟。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-106">The OM stage is the final step for determining which pixels are visible (with depth-stencil testing) and blending the final pixel colors.</span></span>



|                                                                                                                                                                                                                                                                                                                                                                                                             |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="8c7ec-107">Direct3D 9 與 Direct3D 10 之間的差異： Direct3D 9 使用 [Alpha 測試狀態](/windows/desktop/direct3d9/alpha-testing-state) 來實行 Alpha 測試 (，) 控制是否要將圖元寫入輸出轉譯目標。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-107">Differences between Direct3D 9 and Direct3D 10: Direct3D 9 implements alpha testing (using [alpha-testing state](/windows/desktop/direct3d9/alpha-testing-state)) to control whether a pixel is written to an output render target.</span></span><br/> <span data-ttu-id="8c7ec-108">Direct3D 10 和更新版本不會) 執行 Alpha 測試 (或 Alpha 測試狀態。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-108">Direct3D 10 and higher does not implement an alpha test (or alpha testing state).</span></span> <span data-ttu-id="8c7ec-109">這可以使用圖元著色器或深度/樣板功能來控制。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-109">This can be controlled using a pixel shader or with depth/stencil functionality.</span></span><br/> |



 

## <a name="depth-stencil-testing-overview"></a><span data-ttu-id="8c7ec-110">Depth-Stencil 測試總覽</span><span class="sxs-lookup"><span data-stu-id="8c7ec-110">Depth-Stencil Testing Overview</span></span>

<span data-ttu-id="8c7ec-111">深度樣板緩衝區，這會建立為紋理資源，可以包含深度資料和樣板資料這兩個資料。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-111">A depth-stencil buffer, which is created as a texture resource, can contain both depth data and stencil data.</span></span> <span data-ttu-id="8c7ec-112">深度資料用於判斷哪些像素最靠近相機，以及樣板資料用於遮罩哪一個可以更新的像素。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-112">The depth data is used to determine which pixels lie closest to the camera, and the stencil data is used to mask which pixels can be updated.</span></span> <span data-ttu-id="8c7ec-113">最後，深度與樣板數值資料二者都由輸出合併階段，用於判斷是否已繪製像素。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-113">Ultimately, both the depth and stencil values data are used by the output-merger stage to determine if a pixel should be drawn or not.</span></span> <span data-ttu-id="8c7ec-114">下圖顯示如何完成深度樣板測試的概念方式。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-114">The following diagram shows conceptually how depth-stencil testing is done.</span></span>

![深度樣板測試的運作方式的圖表](images/d3d10-depth-stencil-test.png)

<span data-ttu-id="8c7ec-116">若要設定深度樣板測試，請參閱[設定深度樣板功能](d3d10-graphics-programming-guide-depth-stencil.md)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-116">To configure depth-stencil testing, see [Configuring Depth-Stencil Functionality](d3d10-graphics-programming-guide-depth-stencil.md).</span></span> <span data-ttu-id="8c7ec-117">深度樣板物件封裝深度樣板狀態。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-117">A depth-stencil object encapsulates depth-stencil state.</span></span> <span data-ttu-id="8c7ec-118">應用程式可以指定深度樣板的狀態，否則 OM 階段將會使用預設值。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-118">An application can specify depth-stencil state, or the OM stage will use default values.</span></span> <span data-ttu-id="8c7ec-119">如果已停用多重取樣，就以像素為基礎執行混合作業。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-119">Blending operations are performed on a per-pixel basis if multisampling is disabled.</span></span> <span data-ttu-id="8c7ec-120">如果啟用多重取樣，會以每個多重取樣為基礎進行混合。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-120">If multisampling is enabled, blending occurs on a per-multisample basis.</span></span>

<span data-ttu-id="8c7ec-121">使用深度緩衝區的程序來判斷哪一個像素應繪製，這稱為「深度緩衝」，有時也稱為「z 緩衝」。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-121">The process of using the depth buffer to determine which pixel should be drawn is called depth buffering, also sometimes called z-buffering.</span></span>

<span data-ttu-id="8c7ec-122">一旦深度值到達輸出合併階段 (不論從插補或從像素著色器)，它們永遠都箝制︰z = min(Viewport.MaxDepth,max(Viewport.MinDepth,z))，根據深度緩衝區的格式/精準度，使用浮點規則。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-122">Once depth values reach the output-merger stage (whether coming from interpolation or from a pixel shader) they are always clamped: z = min(Viewport.MaxDepth,max(Viewport.MinDepth,z)) according to the format/precision of the depth buffer, using floating-point rules.</span></span> <span data-ttu-id="8c7ec-123">鉗制之後，比較深度值 (使用 DepthFunc) 與現有深度緩衝區值。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-123">After clamping, the depth value is compared (using DepthFunc) against the existing depth-buffer value.</span></span> <span data-ttu-id="8c7ec-124">如果未繫結任何深度緩衝區，一律通過深度測試。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-124">If no depth buffer is bound, the depth test always passes.</span></span>

<span data-ttu-id="8c7ec-125">如果沒有任何深度緩衝區格式的樣板元件，或者未繫結任何深度緩衝區，則一律通過樣板測試。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-125">If there is no stencil component in the depth-buffer format, or no depth buffer bound, then the stencil test always passes.</span></span> <span data-ttu-id="8c7ec-126">否則，功能會與 Direct3D 9 的功能不相同。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-126">Otherwise, functionality is unchanged from Direct3D 9.</span></span>

<span data-ttu-id="8c7ec-127">一次只有一個深度/樣板緩衝區可以使用；任何繫結的資源檢視必須符合 (相同的大小和維度) 深度/樣板檢視。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-127">Only one depth/stencil buffer can be active at a time; any bound resource view must match (same size and dimensions) the depth/stencil view.</span></span> <span data-ttu-id="8c7ec-128">這不表示資源大小必須符合，只是檢視大小必須符合。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-128">This does not mean the resource size must match, just that the view size must match.</span></span>

<span data-ttu-id="8c7ec-129">如需深度樣板測試的詳細資訊，請參閱 [教學課程 14](https://msdn.microsoft.com/library/Ee416550(v=VS.85).aspx)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-129">For more information about depth-stencil testing, see [tutorial 14](https://msdn.microsoft.com/library/Ee416550(v=VS.85).aspx).</span></span>

## <a name="blending-overview"></a><span data-ttu-id="8c7ec-130">混色總覽</span><span class="sxs-lookup"><span data-stu-id="8c7ec-130">Blending Overview</span></span>

<span data-ttu-id="8c7ec-131">混合結合了一個或多個像素值，以建立最終像素色彩。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-131">Blending combines one or more pixel values to create a final pixel color.</span></span> <span data-ttu-id="8c7ec-132">下圖顯示混合像素資料的程序。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-132">The following diagram shows the process involved in blending pixel data.</span></span>

![混合資料的運作方式的圖表](images/d3d10-blend-state.png)

<span data-ttu-id="8c7ec-134">在概念上，您可以將此流程圖表視覺化在輸出合併階段中執行兩次：第一個是混合 RGB 資料，而第二個則會混合 Alpha 資料。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-134">Conceptually, you can visualize this flow chart implemented twice in the output-merger stage: the first one blends RGB data, while in parallel, a second one blends alpha data.</span></span> <span data-ttu-id="8c7ec-135">若要瞭解如何使用 API 建立並設定混合狀態，請參閱[設定混合功能](d3d10-graphics-programming-guide-blend-state.md)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-135">To see how to use the API to create and set blend state, see [Configuring Blending Functionality](d3d10-graphics-programming-guide-blend-state.md).</span></span>

<span data-ttu-id="8c7ec-136">固定函式混合可以針對每個轉譯目標單獨啟用。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-136">Fixed-function blend can be enabled independently for each render target.</span></span> <span data-ttu-id="8c7ec-137">不過，只有一組混合控制項，如此相同混合才會套用到所有啟用混合的 RenderTarget。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-137">However there is only one set of blend controls, so that the same blend is applied to all RenderTargets with blending enabled.</span></span> <span data-ttu-id="8c7ec-138">混合值 (包括 BlendFactor) 始終會限制為混合之前的轉譯目標格式的範圍之內。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-138">Blend values (including BlendFactor) are always clamped to the range of the render-target format before blending.</span></span> <span data-ttu-id="8c7ec-139">關於轉譯目標類型，按照每個轉譯目標完成鉗制。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-139">Clamping is done per render target, respecting the render target type.</span></span> <span data-ttu-id="8c7ec-140">唯一例外是，位鉗制的 float16、float11 或 float10 格式，如此這些格式的混合作業都可以至少等於精確度/範圍，完成為輸出格式。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-140">The only exception is for the float16, float11 or float10 formats which are not clamped so that blend operations on these formats can be done with at least equal precision/range as the output format.</span></span> <span data-ttu-id="8c7ec-141">NaN 的及簽署的零會針對所有案例傳播 (包括 0.0 混合重量)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-141">NaN's and signed zeros are propagated for all cases (including 0.0 blend weights).</span></span>

<span data-ttu-id="8c7ec-142">當您使用 sRGB 轉譯目標時，執行階段會在執行混合之前，將轉譯目標色彩轉換為線性空間。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-142">When you use sRGB render targets, the runtime converts the render target color into linear space before it performs blending.</span></span> <span data-ttu-id="8c7ec-143">執行階段會在其將值儲存回轉譯目標之前，將最終混合值轉換回 sRGB 空間。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-143">The runtime converts the final blended value back into sRGB space before it saves the value back to the render target.</span></span>



|                                                                                                                                                                                                                                                                                                     |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="8c7ec-144">Direct3D 9 與 Direct3D 10 之間的差異：在 Direct3D 9 中，固定函式的混合可以針對每個轉譯目標獨立啟用。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-144">Differences between Direct3D 9 and Direct3D 10: In Direct3D 9, fixed-function blending can be enabled independently for each render target.</span></span><br/> <span data-ttu-id="8c7ec-145">在 Direct3D 10 和更新版本中，有一個 blend 狀態原因;因此，可以為所有呈現目標設定一個混合值。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-145">In Direct3D 10 and higher, there is one blend-state description; therefore, one blending value can be set for all render targets.</span></span><br/> |



 

### <a name="dual-source-color-blending"></a><span data-ttu-id="8c7ec-146">Dual-Source 色彩混合</span><span class="sxs-lookup"><span data-stu-id="8c7ec-146">Dual-Source Color Blending</span></span>

<span data-ttu-id="8c7ec-147">這項功能可讓輸出合併階段同時使用圖元著色器輸出 (o0 和 o1) 做為混合作業的輸入，並在插槽0使用單一轉譯目標。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-147">This feature enables the output-merger stage to simultaneously use both pixel shader outputs (o0 and o1) as inputs to a blending operation with the single render target at slot 0.</span></span> <span data-ttu-id="8c7ec-148">有效的混合作業包括︰新增、減除和 revsubtract。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-148">Valid blend operations include: add, subtract and revsubtract.</span></span> <span data-ttu-id="8c7ec-149">SrcBlend、DestBlend、SrcBlendAlpha 或 DestBlendAlpha 的有效 blend 選項包括： **D3D11 \_ blend \_ SRC1 \_ color**、 **D3D11 \_ blend \_ INV \_ SRC1 \_ color**、 **D3D11 \_ blend \_ SRC1 \_ ALPHA**、 **D3D11 \_ blend \_ inv \_ SRC1 \_ Alpha**。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-149">Valid blend options for SrcBlend, DestBlend, SrcBlendAlpha or DestBlendAlpha include: **D3D11\_BLEND\_SRC1\_COLOR**, **D3D11\_BLEND\_INV\_SRC1\_COLOR**, **D3D11\_BLEND\_SRC1\_ALPHA**, **D3D11\_BLEND\_INV\_SRC1\_ALPHA**.</span></span> <span data-ttu-id="8c7ec-150">混合方程式和輸出寫入遮罩會指定像素著色器將輸出哪些元件。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-150">The blend equation and the output write mask specify which components the pixel shader is outputting.</span></span> <span data-ttu-id="8c7ec-151">忽略額外的元件。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-151">Extra components are ignored.</span></span>

<span data-ttu-id="8c7ec-152">寫入到其他像素著色器輸出 (o2、o3 等) 未定義；若不是繫結到插槽 0，您可能不寫入轉譯目標。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-152">Writing to other pixel shader outputs (o2, o3 etc.) is undefined; you may not write to a render target if it is not bound to slot 0.</span></span> <span data-ttu-id="8c7ec-153">寫入 oDepth 在雙來源色彩混合期間是有效的。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-153">Writing oDepth is valid during dual source color blending.</span></span>

<span data-ttu-id="8c7ec-154">如需範例，請參閱 [混色圖元著色器輸出](d3d10-graphics-programming-guide-blend-state.md)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-154">For examples, see [blending pixel shader outputs](d3d10-graphics-programming-guide-blend-state.md).</span></span>

## <a name="multiple-rendertargets-overview"></a><span data-ttu-id="8c7ec-155">多個 RenderTargets 總覽</span><span class="sxs-lookup"><span data-stu-id="8c7ec-155">Multiple RenderTargets Overview</span></span>

<span data-ttu-id="8c7ec-156">像素著色器可用來轉譯為至少 8 個不同轉譯目標，所有都必須是相同類型 (緩衝、Texture1D、Texture1DArray 等等）。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-156">A pixel shader can be used to render to at least 8 separate render targets, all of which must be the same type (buffer, Texture1D, Texture1DArray, and so on).</span></span> <span data-ttu-id="8c7ec-157">此外，所有轉譯目標在所有維度 (寬地、高度、深度、陣列大小、樣本計數) 中必須有相同的大小。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-157">Furthermore, all render targets must have the same size in all dimensions (width, height, depth, array size, sample counts).</span></span> <span data-ttu-id="8c7ec-158">各個轉譯目標可能會有不同的資料格式。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-158">Each render target may have a different data format.</span></span>

<span data-ttu-id="8c7ec-159">您可以使用任何組合的轉譯目標插槽 (最多達 8 個)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-159">You may use any combination of render targets slots (up to 8).</span></span> <span data-ttu-id="8c7ec-160">不過，資源檢視無法同時繫結到多個轉譯目標插槽。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-160">However, a resource view cannot be bound to multiple render-target-slots simultaneously.</span></span> <span data-ttu-id="8c7ec-161">檢視可重複使用，只要不同時使用資源。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-161">A view may be reused as long as the resources are not used simultaneously.</span></span>

## <a name="output-write-mask-overview"></a><span data-ttu-id="8c7ec-162">Output-Write Mask 總覽</span><span class="sxs-lookup"><span data-stu-id="8c7ec-162">Output-Write Mask Overview</span></span>

<span data-ttu-id="8c7ec-163">使用輸出寫入遮罩來控制 (按每個元件) 可寫入轉譯目標的資料。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-163">Use an output-write mask to control (per component) what data can be written to a render target.</span></span>

## <a name="sample-mask-overview"></a><span data-ttu-id="8c7ec-164">範例遮罩總覽</span><span class="sxs-lookup"><span data-stu-id="8c7ec-164">Sample Mask Overview</span></span>

<span data-ttu-id="8c7ec-165">樣本遮罩是 32 位元多重取樣涵蓋範圍的遮罩，判斷哪些樣本在作用中的轉譯目標中已更新。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-165">A sample mask is a 32-bit multisample coverage mask that determines which samples get updated in active render targets.</span></span> <span data-ttu-id="8c7ec-166">只允許一個樣本遮罩。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-166">Only one sample mask is allowed.</span></span> <span data-ttu-id="8c7ec-167">樣本遮罩中位元到資源中樣本的對應，是由使用者定義。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-167">The mapping of bits in a sample mask to the samples in a resource is defined by a user.</span></span> <span data-ttu-id="8c7ec-168">若是 n 樣本轉譯，會使用樣本遮罩的第一個 n 位元 (從 LSB)(32 位元它的上限位元)。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-168">For n-sample rendering, the first n bits (from the LSB) of the sample mask are used (32 bits it the maximum number of bits).</span></span>


## <a name="in-this-section"></a><span data-ttu-id="8c7ec-169">本節內容</span><span class="sxs-lookup"><span data-stu-id="8c7ec-169">In this section</span></span>



| <span data-ttu-id="8c7ec-170">主題</span><span class="sxs-lookup"><span data-stu-id="8c7ec-170">Topic</span></span>                                                                                                    | <span data-ttu-id="8c7ec-171">描述</span><span class="sxs-lookup"><span data-stu-id="8c7ec-171">Description</span></span>                                                                                                                                                                                                                                                      |
|----------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="8c7ec-172">設定 Depth-Stencil 功能</span><span class="sxs-lookup"><span data-stu-id="8c7ec-172">Configuring Depth-Stencil Functionality</span></span>](d3d10-graphics-programming-guide-depth-stencil.md)<br/> | <span data-ttu-id="8c7ec-173">本章節涵蓋的步驟，內容為設定深度樣板緩衝區及輸出合併階段的深度樣板狀態。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-173">This section covers the steps for setting up the depth-stencil buffer, and depth-stencil state for the output-merger stage.</span></span><br/>                                                                                                                           |
| [<span data-ttu-id="8c7ec-174">設定混合功能</span><span class="sxs-lookup"><span data-stu-id="8c7ec-174">Configuring Blending Functionality</span></span>](d3d10-graphics-programming-guide-blend-state.md)<br/>        | <span data-ttu-id="8c7ec-175">在輸出值寫入轉譯目標之前，會對每個圖元著色器輸出 (RGBA 值) 執行混合作業。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-175">Blending operations are performed on every pixel shader output (RGBA value) before the output value is written to a render target.</span></span> <span data-ttu-id="8c7ec-176">如果啟用取樣，則會在每個執行程式上進行混合;否則，會在每個圖元上執行混色。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-176">If multisampling is enabled, blending is done on each multisample; otherwise, blending is performed on each pixel.</span></span><br/> |
| [<span data-ttu-id="8c7ec-177">深度偏差</span><span class="sxs-lookup"><span data-stu-id="8c7ec-177">Depth Bias</span></span>](d3d10-graphics-programming-guide-output-merger-stage-depth-bias.md)<br/>             | <span data-ttu-id="8c7ec-178">在3D 空間中有共置的多邊形，會顯示為不是共置的多邊形，方法是將 z 偏差 (或深度偏差) 新增至每一個。</span><span class="sxs-lookup"><span data-stu-id="8c7ec-178">Polygons that are coplanar in 3D space can be made to appear as if they are not coplanar by adding a z-bias (or depth bias) to each one.</span></span><br/>                                                                                                              |



 

## <a name="related-topics"></a><span data-ttu-id="8c7ec-179">相關主題</span><span class="sxs-lookup"><span data-stu-id="8c7ec-179">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8c7ec-180">圖形管線</span><span class="sxs-lookup"><span data-stu-id="8c7ec-180">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="8c7ec-181"> (Direct3D 10) 的管線階段 </span><span class="sxs-lookup"><span data-stu-id="8c7ec-181">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

