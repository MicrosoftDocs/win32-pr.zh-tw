---
title: 封送處理詳細資料
description: 如果您使用標準封送處理，COM 會為您處理此處所述的所有詳細資料。
ms.assetid: bf3fe212-648e-4d00-ad1d-43d2e5e6a7ae
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f4d0fd46ee29c712c6f2b5b286df76a30f1047e6
ms.sourcegitcommit: d39e82e232f6510f843fdb8d55d25b4e9e02e880
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/03/2021
ms.locfileid: "106997297"
---
# <a name="marshaling-details"></a>封送處理詳細資料

如果您使用標準封送處理，COM 會為您處理此處所述的所有詳細資料。 不過，有幾個程式設計師需要這些詳細資料，以及對基礎資訊感興趣的人員。 封送處理是封裝和解除封裝參數的程式，因此可以進行遠端程序呼叫。

不同的參數類型會以不同的方式進行封送處理。 例如，封送處理整數參數只需要將值複製到訊息緩衝區。  (雖然在這個簡單的案例中，仍有一些問題，例如在跨電腦呼叫中處理的位元組順序。不過，) 封送處理陣列的程式更複雜。 陣列成員會以特定順序複製，讓另一端可以完全重建陣列。 當將指標封送處理時，指標所指向的資料會複製到在結構中處理嵌套指標的下列規則和慣例。 唯一的函式存在，可處理每個參數類型的封送處理。

使用標準封送處理時，proxy 和存根是介面的全系統資源，而且會透過標準通訊協定與通道互動。 標準封送處理可由標準的 COM 定義介面和自訂介面使用，如下所示：

-   在大部分的 COM 介面中，標準封送處理的 proxy 和存根都是同進程元件物件，這些物件是從 COM 在 Ole32.dll 中提供的全系統 DLL 載入的。
-   在自訂介面的情況下，介面設計工具會產生標準封送處理的 proxy 和存根，通常是使用 MIDL。 這些 proxy 和存根是在登錄中靜態設定的，因此任何潛在客戶端都可以跨進程界限使用自訂介面。 這些 proxy 和存根是從使用系統登錄的 DLL 載入的，使用介面識別碼 (IID) 來進行封送處理的自訂介面。
-   使用 MIDL 來產生自訂介面的 proxy 和存根的替代方式，可以改為產生類型程式庫，而提供的系統則是類型 libraryâ€「驅動封送處理引擎將會封送處理介面。

作為標準封送處理的替代方案， (標準或自訂) 的介面可以使用自訂封送處理。 使用自訂封送處理時，物件會在執行時間為其支援的每個介面，動態地執行 proxy。 針對任何指定的介面，物件可以選取 COM 提供的標準封送處理或自訂封送處理。 此選項由物件以介面為基礎進行。 一旦針對指定的介面進行選擇之後，它就會在物件的存留期內保持有效。 不過，物件上的一個介面可以使用自訂封送處理，而另一個則使用標準封送處理。

自訂封送處理本身就是對其執行的物件而言是唯一的。 它會使用物件所執行的 proxy，並在執行時間提供給系統要求。 執行自訂封送處理的物件必須執行 [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) 介面，而支援標準封送處理的物件則不會。

如果您決定要撰寫自訂介面，則必須提供它的封送處理支援。 一般來說，您會為您所設計的介面提供標準封送處理 DLL。 您可以建立 proxy/stub 程式碼和 proxy/stub DLL，也可以建立 COM 將用來執行資料驅動封送處理的類型程式庫， (使用類型程式庫) 中的資料。

若要讓用戶端呼叫另一個進程中之物件的介面方法，需要有數個元件的合作。 標準 proxy 是位於用戶端進程空間中的介面特定程式碼片段，可準備用於傳送的介面參數。 它會將它們封裝或封送處理，以在接收程式中重新建立和瞭解它們。 標準存根（也是介面特定程式碼的一部分）位於伺服器的進程空間中，並會反轉 proxy 的工作。 存根 unpackages （或拆收）已傳送的參數，並將其轉送至物件應用程式。 它也會封裝回復資訊以傳送回用戶端。

> [!Note]  
> 比 COM 更熟悉 RPC 的讀者可能會用來查看用戶端 stub 和伺服器 stub 的條款。 這些詞彙類似于 proxy 和存根。

 

## <a name="components-of-interprocess-communications"></a>處理序間通訊的元件

下圖顯示相關元件之間的通訊流程。 在進程界限的用戶端上，用戶端的方法呼叫會通過 proxy，然後移至通道（COM 程式庫的一部分）。 通道會將包含已封送處理之參數的緩衝區傳送至 RPC 執行時間程式庫，以在整個進程界限之間傳輸。 RPC 執行時間和 COM 程式庫都存在於進程的兩端。 通道與 RPC 執行時間之間的差異是此實作為的特性，而且不是 COM 用戶端/伺服器物件的程式設計模型或概念模型的一部分。 COM 伺服器只會查看 proxy 或存根，以及間接的通道。 未來的實施可能會在通道底下使用不同的層級，或不使用任何層。

![此圖顯示在進程界限的每一邊的 Client.exe 和 Server.exe 流程。](images/457036c1-98b8-4f35-aebe-70de38112b83.png)

## <a name="related-topics"></a>相關主題

<dl> <dt>

[通道](channel.md)
</dt> <dt>

[物件間通訊](inter-object-communication.md)
</dt> <dt>

[Microsoft RPC](microsoft-rpc.md)
</dt> <dt>

[Proxy](proxy.md)
</dt> <dt>

[存根](stub.md)
</dt> </dl>

 

 