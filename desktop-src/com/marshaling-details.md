---
title: 封送處理詳細資料
description: 如果您使用標準封送處理，COM 會為您處理此處所述的所有詳細資料。
ms.assetid: bf3fe212-648e-4d00-ad1d-43d2e5e6a7ae
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f4d0fd46ee29c712c6f2b5b286df76a30f1047e6
ms.sourcegitcommit: d39e82e232f6510f843fdb8d55d25b4e9e02e880
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/03/2021
ms.locfileid: "106997297"
---
# <a name="marshaling-details"></a><span data-ttu-id="8761e-103">封送處理詳細資料</span><span class="sxs-lookup"><span data-stu-id="8761e-103">Marshaling Details</span></span>

<span data-ttu-id="8761e-104">如果您使用標準封送處理，COM 會為您處理此處所述的所有詳細資料。</span><span class="sxs-lookup"><span data-stu-id="8761e-104">If you use standard marshaling, COM handles all of the details described here for you.</span></span> <span data-ttu-id="8761e-105">不過，有幾個程式設計師需要這些詳細資料，以及對基礎資訊感興趣的人員。</span><span class="sxs-lookup"><span data-stu-id="8761e-105">However, there are those few programmers who need these details and for those interested in the underlying information.</span></span> <span data-ttu-id="8761e-106">封送處理是封裝和解除封裝參數的程式，因此可以進行遠端程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="8761e-106">Marshaling is the process of packaging and unpackaging parameters so a remote procedure call can take place.</span></span>

<span data-ttu-id="8761e-107">不同的參數類型會以不同的方式進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="8761e-107">Different parameter types are marshaled in different ways.</span></span> <span data-ttu-id="8761e-108">例如，封送處理整數參數只需要將值複製到訊息緩衝區。</span><span class="sxs-lookup"><span data-stu-id="8761e-108">For example, marshaling an integer parameter involves simply copying the value into the message buffer.</span></span> <span data-ttu-id="8761e-109"> (雖然在這個簡單的案例中，仍有一些問題，例如在跨電腦呼叫中處理的位元組順序。不過，) 封送處理陣列的程式更複雜。</span><span class="sxs-lookup"><span data-stu-id="8761e-109">(Although even in this simple case, there are issues such as byte ordering to deal with in cross-computer calls.) Marshaling an array, however, is a more complex process.</span></span> <span data-ttu-id="8761e-110">陣列成員會以特定順序複製，讓另一端可以完全重建陣列。</span><span class="sxs-lookup"><span data-stu-id="8761e-110">Array members are copied in a specific order so that the other side can reconstruct the array exactly.</span></span> <span data-ttu-id="8761e-111">當將指標封送處理時，指標所指向的資料會複製到在結構中處理嵌套指標的下列規則和慣例。</span><span class="sxs-lookup"><span data-stu-id="8761e-111">When a pointer is marshaled, the data that the pointer is pointing to is copied following rules and conventions for dealing with nested pointers in structures.</span></span> <span data-ttu-id="8761e-112">唯一的函式存在，可處理每個參數類型的封送處理。</span><span class="sxs-lookup"><span data-stu-id="8761e-112">Unique functions exist to handle the marshaling of each parameter type.</span></span>

<span data-ttu-id="8761e-113">使用標準封送處理時，proxy 和存根是介面的全系統資源，而且會透過標準通訊協定與通道互動。</span><span class="sxs-lookup"><span data-stu-id="8761e-113">With standard marshaling, the proxies and stubs are systemwide resources for the interface and they interact with the channel through a standard protocol.</span></span> <span data-ttu-id="8761e-114">標準封送處理可由標準的 COM 定義介面和自訂介面使用，如下所示：</span><span class="sxs-lookup"><span data-stu-id="8761e-114">Standard marshaling can be used both by standard COM-defined interfaces and by custom interfaces, as follows:</span></span>

-   <span data-ttu-id="8761e-115">在大部分的 COM 介面中，標準封送處理的 proxy 和存根都是同進程元件物件，這些物件是從 COM 在 Ole32.dll 中提供的全系統 DLL 載入的。</span><span class="sxs-lookup"><span data-stu-id="8761e-115">In the case of most COM interfaces, the proxies and stubs for standard marshaling are in-process component objects which are loaded from a systemwide DLL provided by COM in Ole32.dll.</span></span>
-   <span data-ttu-id="8761e-116">在自訂介面的情況下，介面設計工具會產生標準封送處理的 proxy 和存根，通常是使用 MIDL。</span><span class="sxs-lookup"><span data-stu-id="8761e-116">In the case of custom interfaces, the proxies and stubs for standard marshaling are generated by the interface designer, typically with MIDL.</span></span> <span data-ttu-id="8761e-117">這些 proxy 和存根是在登錄中靜態設定的，因此任何潛在客戶端都可以跨進程界限使用自訂介面。</span><span class="sxs-lookup"><span data-stu-id="8761e-117">These proxies and stubs are statically configured in the registry, so any potential client can use the custom interface across process boundaries.</span></span> <span data-ttu-id="8761e-118">這些 proxy 和存根是從使用系統登錄的 DLL 載入的，使用介面識別碼 (IID) 來進行封送處理的自訂介面。</span><span class="sxs-lookup"><span data-stu-id="8761e-118">These proxies and stubs are loaded from a DLL that is located via the system registry, using the interface ID (IID) for the custom interface they marshal.</span></span>
-   <span data-ttu-id="8761e-119">使用 MIDL 來產生自訂介面的 proxy 和存根的替代方式，可以改為產生類型程式庫，而提供的系統則是類型 libraryâ€「驅動封送處理引擎將會封送處理介面。</span><span class="sxs-lookup"><span data-stu-id="8761e-119">An alternative to using MIDL to generate proxies and stubs for custom interfaces, a type library can be generated instead and the system provided, type-libraryâ€“driven marshaling engine will marshal the interface.</span></span>

<span data-ttu-id="8761e-120">作為標準封送處理的替代方案， (標準或自訂) 的介面可以使用自訂封送處理。</span><span class="sxs-lookup"><span data-stu-id="8761e-120">As an alternative to standard marshaling, an interface (standard or custom) can use custom marshaling.</span></span> <span data-ttu-id="8761e-121">使用自訂封送處理時，物件會在執行時間為其支援的每個介面，動態地執行 proxy。</span><span class="sxs-lookup"><span data-stu-id="8761e-121">With custom marshaling, an object dynamically implements the proxies at run time for each interface that it supports.</span></span> <span data-ttu-id="8761e-122">針對任何指定的介面，物件可以選取 COM 提供的標準封送處理或自訂封送處理。</span><span class="sxs-lookup"><span data-stu-id="8761e-122">For any given interface, the object can select COM-provided standard marshaling or custom marshaling.</span></span> <span data-ttu-id="8761e-123">此選項由物件以介面為基礎進行。</span><span class="sxs-lookup"><span data-stu-id="8761e-123">This choice is made by the object on an interface-by-interface basis.</span></span> <span data-ttu-id="8761e-124">一旦針對指定的介面進行選擇之後，它就會在物件的存留期內保持有效。</span><span class="sxs-lookup"><span data-stu-id="8761e-124">Once the choice is made for a given interface, it remains in effect during the object's lifetime.</span></span> <span data-ttu-id="8761e-125">不過，物件上的一個介面可以使用自訂封送處理，而另一個則使用標準封送處理。</span><span class="sxs-lookup"><span data-stu-id="8761e-125">However, one interface on an object can use custom marshaling while another uses standard marshaling.</span></span>

<span data-ttu-id="8761e-126">自訂封送處理本身就是對其執行的物件而言是唯一的。</span><span class="sxs-lookup"><span data-stu-id="8761e-126">Custom marshaling is inherently unique to the object that implements it.</span></span> <span data-ttu-id="8761e-127">它會使用物件所執行的 proxy，並在執行時間提供給系統要求。</span><span class="sxs-lookup"><span data-stu-id="8761e-127">It uses proxies implemented by the object and provided to the system on request at run time.</span></span> <span data-ttu-id="8761e-128">執行自訂封送處理的物件必須執行 [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) 介面，而支援標準封送處理的物件則不會。</span><span class="sxs-lookup"><span data-stu-id="8761e-128">Objects that implement custom marshaling must implement the [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) interface, whereas objects that support standard marshaling do not.</span></span>

<span data-ttu-id="8761e-129">如果您決定要撰寫自訂介面，則必須提供它的封送處理支援。</span><span class="sxs-lookup"><span data-stu-id="8761e-129">If you decide to write a custom interface, you must provide marshaling support for it.</span></span> <span data-ttu-id="8761e-130">一般來說，您會為您所設計的介面提供標準封送處理 DLL。</span><span class="sxs-lookup"><span data-stu-id="8761e-130">Typically, you will provide a standard marshaling DLL for the interface you design.</span></span> <span data-ttu-id="8761e-131">您可以建立 proxy/stub 程式碼和 proxy/stub DLL，也可以建立 COM 將用來執行資料驅動封送處理的類型程式庫， (使用類型程式庫) 中的資料。</span><span class="sxs-lookup"><span data-stu-id="8761e-131">You can create the proxy/stub code and the proxy/stub DLL, or you can create a type library that COM will use to do data-driven marshaling (using the data in the type library).</span></span>

<span data-ttu-id="8761e-132">若要讓用戶端呼叫另一個進程中之物件的介面方法，需要有數個元件的合作。</span><span class="sxs-lookup"><span data-stu-id="8761e-132">For a client to make a call to an interface method in an object in another process involves the cooperation of several components.</span></span> <span data-ttu-id="8761e-133">標準 proxy 是位於用戶端進程空間中的介面特定程式碼片段，可準備用於傳送的介面參數。</span><span class="sxs-lookup"><span data-stu-id="8761e-133">The standard proxy is a piece of interface-specific code that resides in the client's process space and prepares the interface parameters for transmittal.</span></span> <span data-ttu-id="8761e-134">它會將它們封裝或封送處理，以在接收程式中重新建立和瞭解它們。</span><span class="sxs-lookup"><span data-stu-id="8761e-134">It packages, or marshals, them in such a way that they can be re-created and understood in the receiving process.</span></span> <span data-ttu-id="8761e-135">標準存根（也是介面特定程式碼的一部分）位於伺服器的進程空間中，並會反轉 proxy 的工作。</span><span class="sxs-lookup"><span data-stu-id="8761e-135">The standard stub, also a piece of interface-specific code, resides in the server's process space and reverses the work of the proxy.</span></span> <span data-ttu-id="8761e-136">存根 unpackages （或拆收）已傳送的參數，並將其轉送至物件應用程式。</span><span class="sxs-lookup"><span data-stu-id="8761e-136">The stub unpackages, or unmarshals, the sent parameters and forwards them to the object application.</span></span> <span data-ttu-id="8761e-137">它也會封裝回復資訊以傳送回用戶端。</span><span class="sxs-lookup"><span data-stu-id="8761e-137">It also packages reply information to send back to the client.</span></span>

> [!Note]  
> <span data-ttu-id="8761e-138">比 COM 更熟悉 RPC 的讀者可能會用來查看用戶端 stub 和伺服器 stub 的條款。</span><span class="sxs-lookup"><span data-stu-id="8761e-138">Readers more familiar with RPC than COM may be used to seeing the terms client stub and server stub.</span></span> <span data-ttu-id="8761e-139">這些詞彙類似于 proxy 和存根。</span><span class="sxs-lookup"><span data-stu-id="8761e-139">These terms are analogous to proxy and stub.</span></span>

 

## <a name="components-of-interprocess-communications"></a><span data-ttu-id="8761e-140">處理序間通訊的元件</span><span class="sxs-lookup"><span data-stu-id="8761e-140">Components of Interprocess Communications</span></span>

<span data-ttu-id="8761e-141">下圖顯示相關元件之間的通訊流程。</span><span class="sxs-lookup"><span data-stu-id="8761e-141">The following diagram shows the flow of communication between the components involved.</span></span> <span data-ttu-id="8761e-142">在進程界限的用戶端上，用戶端的方法呼叫會通過 proxy，然後移至通道（COM 程式庫的一部分）。</span><span class="sxs-lookup"><span data-stu-id="8761e-142">On the client side of the process boundary, the client's method call goes through the proxy and then onto the channel, which is part of the COM library.</span></span> <span data-ttu-id="8761e-143">通道會將包含已封送處理之參數的緩衝區傳送至 RPC 執行時間程式庫，以在整個進程界限之間傳輸。</span><span class="sxs-lookup"><span data-stu-id="8761e-143">The channel sends the buffer containing the marshaled parameters to the RPC run-time library, which transmits it across the process boundary.</span></span> <span data-ttu-id="8761e-144">RPC 執行時間和 COM 程式庫都存在於進程的兩端。</span><span class="sxs-lookup"><span data-stu-id="8761e-144">The RPC run time and the COM libraries exist on both sides of the process.</span></span> <span data-ttu-id="8761e-145">通道與 RPC 執行時間之間的差異是此實作為的特性，而且不是 COM 用戶端/伺服器物件的程式設計模型或概念模型的一部分。</span><span class="sxs-lookup"><span data-stu-id="8761e-145">The distinction between the channel and the RPC run time is a characteristic of this implementation and is not part of the programming model or the conceptual model for COM client/server objects.</span></span> <span data-ttu-id="8761e-146">COM 伺服器只會查看 proxy 或存根，以及間接的通道。</span><span class="sxs-lookup"><span data-stu-id="8761e-146">COM servers see only the proxy or stub and, indirectly, the channel.</span></span> <span data-ttu-id="8761e-147">未來的實施可能會在通道底下使用不同的層級，或不使用任何層。</span><span class="sxs-lookup"><span data-stu-id="8761e-147">Future implementations may use different layers below the channel or no layers.</span></span>

![此圖顯示在進程界限的每一邊的 Client.exe 和 Server.exe 流程。](images/457036c1-98b8-4f35-aebe-70de38112b83.png)

## <a name="related-topics"></a><span data-ttu-id="8761e-149">相關主題</span><span class="sxs-lookup"><span data-stu-id="8761e-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8761e-150">通道</span><span class="sxs-lookup"><span data-stu-id="8761e-150">Channel</span></span>](channel.md)
</dt> <dt>

[<span data-ttu-id="8761e-151">物件間通訊</span><span class="sxs-lookup"><span data-stu-id="8761e-151">Inter-Object Communication</span></span>](inter-object-communication.md)
</dt> <dt>

[<span data-ttu-id="8761e-152">Microsoft RPC</span><span class="sxs-lookup"><span data-stu-id="8761e-152">Microsoft RPC</span></span>](microsoft-rpc.md)
</dt> <dt>

[<span data-ttu-id="8761e-153">Proxy</span><span class="sxs-lookup"><span data-stu-id="8761e-153">Proxy</span></span>](proxy.md)
</dt> <dt>

[<span data-ttu-id="8761e-154">存根</span><span class="sxs-lookup"><span data-stu-id="8761e-154">Stub</span></span>](stub.md)
</dt> </dl>

 

 