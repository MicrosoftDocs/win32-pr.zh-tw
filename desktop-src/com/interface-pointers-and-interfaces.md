---
title: 介面指標和介面
description: 介面指標和介面
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/24/2019
ms.locfileid: "106965963"
---
# <a name="interface-pointers-and-interfaces"></a>介面指標和介面

介面實的實例實際上是指向方法指標陣列的指標，也就是參考介面中指定之所有方法的實作為函式資料表。 具有多個介面的物件可以提供一個以上的函式資料表指標。 任何具有可存取陣列之指標的程式碼都可以呼叫該介面中的方法。

確切地說，這個多個間接取值並不方便，因此在介面函式資料表中，另一個物件必須用來呼叫其方法的指標，就只會被稱為 *介面指標*。 您可以使用 Visual C++ (或其他支援 COM) 的物件導向語言，手動在 C 應用程式中建立函式資料表或幾乎自動建立。

使用 C 和 c + +) 固有的適當編譯器支援 (，用戶端可以透過其名稱（而不是其在陣列中的位置）來呼叫介面方法。 因為介面是一種型別，所以編譯器會提供方法的名稱，可以檢查參數的類型，並傳回每個介面方法呼叫的值。 相反地，如果用戶端使用以位置為基礎的呼叫配置，則即使是在 C 或 c + + 中，也無法使用這類的類型檢查。

每個介面都是一組功能的不可變合約。 您在執行時間使用全域唯一的介面識別碼（ (IID) ）參考介面。 這個 IID 是 COM 所支援的全域唯一識別碼 (GUID) 的特定實例，可讓用戶端精確地要求物件是否支援介面的語法，而不會產生不必要的額外負荷，也不會造成系統中可能發生的混淆，因為系統不會產生具有相同名稱的多個相同介面版本。

總而言之，請務必瞭解 COM 介面是什麼，而不是：

-   COM 介面與 c + + 類別不同。 純虛擬定義不會執行任何工作。 如果您是 c + + 程式設計人員，您可以將介面的實作為類別來定義，但這會落在未指定 COM 的 [執行詳細資料] 標題下方。 必須建立物件的實例，這個實例必須要有介面才能實際存在。 此外，不同的物件類別可能會以不同的方式來執行介面，但前提是該行為符合介面定義。
-   COM 介面不是物件。 這只是一組相關的函式，而且是用戶端和物件用來進行通訊的二進位標準。 只要它可以提供介面方法的指標，就可以使用任何內部狀態標記法來執行物件。
-   COM 介面是強型別。 每個介面都有它自己的介面識別碼 (GUID) ，這樣可以消除任何其他命名配置可能發生重複的可能性。
-   COM 介面是不可變的。 您無法定義新版本的舊介面，並為其指定相同的識別碼。 新增或移除介面或變更語義的方法，會建立新的介面，而不是新的舊介面版本。 因此，新的介面無法與舊的介面發生衝突。 不過，物件可以同時支援多個介面，且可以公開具有不同識別碼之介面的後續修訂介面。 因此，每個介面都是個別的合約，而全系統物件則不需要擔心它們所呼叫的介面版本是否為它們所預期的版本。  (IID 的介面識別碼) 明確且唯一地定義介面合約。

## <a name="related-topics"></a>相關主題

<dl> <dt>

[COM 物件和介面](com-objects-and-interfaces.md)
</dt> </dl>

 

 




