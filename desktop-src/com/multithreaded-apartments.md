---
title: 多執行緒單元
description: 多執行緒單元
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "106968937"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="16ca1-103">多執行緒單元</span><span class="sxs-lookup"><span data-stu-id="16ca1-103">Multithreaded Apartments</span></span>

<span data-ttu-id="16ca1-104">在多執行緒單元模型中，進程中已初始化為自由執行緒的所有線程都位於單一單元中。</span><span class="sxs-lookup"><span data-stu-id="16ca1-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="16ca1-105">因此，不需要線上程之間進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="16ca1-106">執行緒不需要取得和分派訊息，因為 COM 不會在此模型中使用視窗訊息。</span><span class="sxs-lookup"><span data-stu-id="16ca1-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="16ca1-107">呼叫多執行緒單元中的物件方法時，可以在該單元中的任何執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="16ca1-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="16ca1-108">沒有呼叫的序列化;許多呼叫可能會同時對相同的方法或相同物件進行。</span><span class="sxs-lookup"><span data-stu-id="16ca1-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="16ca1-109">在多執行緒單元中建立的物件必須能夠隨時從其他執行緒其方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="16ca1-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="16ca1-110">由於呼叫物件不會以任何方式序列化，因此多執行緒物件並行可提供最高的效能，並充分利用跨執行緒、跨進程和跨電腦呼叫的多處理器硬體。</span><span class="sxs-lookup"><span data-stu-id="16ca1-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="16ca1-111">不過，這表示物件的程式碼必須在其介面實現中提供同步處理，通常是透過使用同步處理原始物件（例如事件物件、重要區段、mutex 或信號），這會在本節稍後說明。</span><span class="sxs-lookup"><span data-stu-id="16ca1-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="16ca1-112">此外，因為物件不會控制正在存取之執行緒的存留期，所以執行緒區域儲存區) 中的物件 (不能儲存任何執行緒特定的狀態。</span><span class="sxs-lookup"><span data-stu-id="16ca1-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="16ca1-113">以下是有關多執行緒單元同步處理的一些重要考慮：</span><span class="sxs-lookup"><span data-stu-id="16ca1-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="16ca1-114">COM 僅提供單一執行緒單元的呼叫同步處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="16ca1-115">多執行緒單元在) 的相同執行緒上呼叫 (時，不會接收呼叫。</span><span class="sxs-lookup"><span data-stu-id="16ca1-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="16ca1-116">多執行緒單元無法進行輸入同步處理呼叫。</span><span class="sxs-lookup"><span data-stu-id="16ca1-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="16ca1-117">非同步呼叫會轉換成多執行緒單元中的同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="16ca1-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="16ca1-118">不會針對多執行緒單元中的任何執行緒呼叫訊息篩選器。</span><span class="sxs-lookup"><span data-stu-id="16ca1-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="16ca1-119">若要將執行緒初始化為無限制執行緒，請呼叫 [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)，並指定 COINIT \_ 多執行緒。</span><span class="sxs-lookup"><span data-stu-id="16ca1-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="16ca1-120">如需同進程伺服器執行緒的詳細資訊，請參閱同 [進程伺服器執行緒問題](in-process-server-threading-issues.md)。</span><span class="sxs-lookup"><span data-stu-id="16ca1-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="16ca1-121">多個用戶端可以同時從不同的執行緒呼叫支援無限制執行緒的物件。</span><span class="sxs-lookup"><span data-stu-id="16ca1-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="16ca1-122">在可自由執行緒的跨進程伺服器（COM）中，透過 RPC 子系統建立的執行緒集區會在伺服器進程中建立執行緒集區，而用戶端呼叫 (或多個用戶端呼叫，) 可以在任何時間由這些執行緒傳遞。</span><span class="sxs-lookup"><span data-stu-id="16ca1-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="16ca1-123">跨進程伺服器也必須在其 class factory 中執行同步處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="16ca1-124">無限制執行緒的同進程物件可以接收來自用戶端多個執行緒的直接呼叫。</span><span class="sxs-lookup"><span data-stu-id="16ca1-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="16ca1-125">用戶端可以在多個執行緒中執行 COM 工作。</span><span class="sxs-lookup"><span data-stu-id="16ca1-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="16ca1-126">所有線程都屬於相同的多執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="16ca1-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="16ca1-127">介面指標會直接從執行緒傳遞至多執行緒單元內的執行緒，因此介面指標不會在其執行緒之間進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="16ca1-128">Imessagefilter.prefiltermessage) 的訊息篩選器 (的[](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) ，不會用於多執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="16ca1-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="16ca1-129">用戶端執行緒會在對跨單元物件進行 COM 呼叫時暫停，而且會在呼叫傳回時繼續。</span><span class="sxs-lookup"><span data-stu-id="16ca1-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="16ca1-130">進程之間的呼叫仍會由 RPC 處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="16ca1-131">以自由執行緒模型初始化的執行緒必須執行自己的同步處理。</span><span class="sxs-lookup"><span data-stu-id="16ca1-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="16ca1-132">如本節稍早所述，Windows 會透過下列同步處理原始物件來啟用此執行：</span><span class="sxs-lookup"><span data-stu-id="16ca1-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="16ca1-133">事件物件提供一種方式，讓一個或多個執行緒發生事件。</span><span class="sxs-lookup"><span data-stu-id="16ca1-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="16ca1-134">進程內的任何執行緒都可以建立事件物件。</span><span class="sxs-lookup"><span data-stu-id="16ca1-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="16ca1-135">事件建立函式會傳回事件的控制碼， [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa)。</span><span class="sxs-lookup"><span data-stu-id="16ca1-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="16ca1-136">一旦建立事件物件之後，具有物件控制碼的執行緒就可以等候它，然後再繼續執行。</span><span class="sxs-lookup"><span data-stu-id="16ca1-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="16ca1-137">重要區段適用于需要對某些共用資料進行獨佔存取才能執行的程式碼區段，而且只有在單一進程內的執行緒才能使用。</span><span class="sxs-lookup"><span data-stu-id="16ca1-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="16ca1-138">重要區段就像是一次只有一個執行緒可以通過的門，如下所示：</span><span class="sxs-lookup"><span data-stu-id="16ca1-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="16ca1-139">為了確保一次不會有一個以上的執行緒存取共用資料，進程的主要執行緒會配置全域關鍵 \_ 區段資料結構，並初始化其成員。</span><span class="sxs-lookup"><span data-stu-id="16ca1-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="16ca1-140">進入重要區段的執行緒會呼叫 [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) 函數，並修改資料結構的成員。</span><span class="sxs-lookup"><span data-stu-id="16ca1-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="16ca1-141">嘗試進入重要區段的執行緒會呼叫 [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) ，以查看重要 \_ 區段資料結構是否已修改。</span><span class="sxs-lookup"><span data-stu-id="16ca1-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="16ca1-142">如果是，則另一個執行緒目前位於重要區段中，後續的執行緒則會進入睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="16ca1-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="16ca1-143">離開重要區段的執行緒會呼叫 [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection)，以重設資料結構。</span><span class="sxs-lookup"><span data-stu-id="16ca1-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="16ca1-144">當執行緒離開重要區段時，系統會將其中一個休眠執行緒喚醒，然後進入重要區段。</span><span class="sxs-lookup"><span data-stu-id="16ca1-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="16ca1-145">Mutex 執行的功能與重要區段相同，不同之處在于在不同進程中執行的執行緒可以存取 mutex。</span><span class="sxs-lookup"><span data-stu-id="16ca1-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="16ca1-146">擁有 mutex 物件就像是在爭論的樓層。</span><span class="sxs-lookup"><span data-stu-id="16ca1-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="16ca1-147">進程會藉由呼叫 [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) 函式來建立 mutex 物件，該函式會傳回控制碼。</span><span class="sxs-lookup"><span data-stu-id="16ca1-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="16ca1-148">要求 mutex 物件的第一個執行緒取得其擁有權。</span><span class="sxs-lookup"><span data-stu-id="16ca1-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="16ca1-149">當執行緒已完成 mutex 時，擁有權會先以先服務的方式傳遞給其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="16ca1-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="16ca1-150">信號是用來維護一些可用資源的參考計數。</span><span class="sxs-lookup"><span data-stu-id="16ca1-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="16ca1-151">執行緒會藉由呼叫 [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) 函式並傳遞資源指標、初始資源計數和資源計數上限，來建立資源的信號。</span><span class="sxs-lookup"><span data-stu-id="16ca1-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="16ca1-152">此函數會傳回控制碼。</span><span class="sxs-lookup"><span data-stu-id="16ca1-152">This function returns a handle.</span></span> <span data-ttu-id="16ca1-153">要求資源的執行緒會在 [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) 函式的呼叫中傳遞其信號控制碼。</span><span class="sxs-lookup"><span data-stu-id="16ca1-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="16ca1-154">信號物件會輪詢資源，以判斷它是否可用。</span><span class="sxs-lookup"><span data-stu-id="16ca1-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="16ca1-155">如果是，則信號會遞減資源計數，並喚醒等候中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="16ca1-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="16ca1-156">如果計數為零，則執行緒會保持睡眠，直到另一個執行緒釋出資源，導致信號將計數遞增一。</span><span class="sxs-lookup"><span data-stu-id="16ca1-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="16ca1-157">相關主題</span><span class="sxs-lookup"><span data-stu-id="16ca1-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="16ca1-158">跨單元存取介面</span><span class="sxs-lookup"><span data-stu-id="16ca1-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="16ca1-159">選擇執行緒模型</span><span class="sxs-lookup"><span data-stu-id="16ca1-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="16ca1-160">同進程伺服器執行緒問題</span><span class="sxs-lookup"><span data-stu-id="16ca1-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="16ca1-161">進程、執行緒和單元</span><span class="sxs-lookup"><span data-stu-id="16ca1-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="16ca1-162">單一執行緒和多執行緒通訊</span><span class="sxs-lookup"><span data-stu-id="16ca1-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="16ca1-163">單一執行緒單元</span><span class="sxs-lookup"><span data-stu-id="16ca1-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 