---
title: 進程、執行緒和單元
description: 進程是虛擬記憶體空間、程式碼、資料和系統資源的集合。
ms.assetid: cb62412a-d079-40f9-89dc-cce0bf3889af
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 320b09d76200739c77c7202af4d53a35089b2eca2e6fd282dd507f048aa7a10b
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "119130030"
---
# <a name="processes-threads-and-apartments"></a>進程、執行緒和單元

*進程* 是虛擬記憶體空間、程式碼、資料和系統資源的集合。 *執行緒* 是在進程內以串列方式執行的程式碼。 處理器會執行執行緒，而不是處理常式，因此每個應用程式都至少有一個處理常式，而處理常式一律至少有一個執行執行緒，又稱為主要執行緒。 除了主要執行緒之外，處理常式可以有多個執行緒。

進程會透過訊息彼此通訊，方法是使用 Microsoft 的遠端程序呼叫， (RPC) 技術，將資訊傳遞給另一個。 從遠端電腦上的處理常式，到來自同一部電腦上另一個進程的呼叫之間，與呼叫端之間沒有任何差異。

當執行緒開始執行時，它會繼續執行，直到它被刪除為止，或直到由使用者動作或核心的執行緒排程器)  (優先順序較高的執行緒中斷為止。 每個執行緒都可以執行不同的程式碼區段，或多個執行緒可以執行相同的程式碼區段。 執行相同程式碼區塊的執行緒會維護不同的堆疊。 進程中的每個執行緒都會共用該進程的全域變數和資源。

執行緒排程器會根據進程的 priority 類別屬性和執行緒的基本優先權組合，決定執行執行緒的時機和頻率。 您可以藉由呼叫 [**SetPriorityClass**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass) 函式來設定進程的 priority 類別屬性，並使用 [**SetThreadPriority**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority)的呼叫來設定執行緒的基底優先順序。

多執行緒應用程式必須避免兩個執行緒問題：*鎖死**和競爭* 情形。 當每個執行緒等候另一個執行緒執行某項作業時，就會發生鎖死。 COM 呼叫控制項有助於防止物件之間的呼叫發生鎖死。 當某個執行緒在其相依的另一個執行緒之前完成，導致前者使用未初始化的值（因為後者尚未提供有效的值）時，就會發生競爭情況。 COM 提供一些特別設計來協助避免跨進程伺服器發生競爭情況的函式。  (查看 [跨進程伺服器的執行](out-of-process-server-implementation-helpers.md)協助程式。 ) 

## <a name="the-apartment-and-the-com-threading-architecture"></a>單元和 COM 執行緒架構

雖然 COM 在導入多個執行緒之前都支援常見的單一執行緒個別進程模型，但您可以撰寫程式碼來利用多個執行緒，進而產生更有效率的應用程式，方法是在另一個執行緒等候一些耗時的作業完成時，允許一個執行緒執行。

> [!Note]  
> 使用多個執行緒無法保證效能較佳。 事實上，因為執行緒的分解是很困難的問題，所以使用多個執行緒通常會造成效能問題。 重要的是，只有在您非常確定所執行的工作時，才會使用多個執行緒。

 

一般而言，若要查看 COM 執行緒架構，最簡單的方式就是將進程中的所有 COM 物件視為分成稱為「 *單元*」的群組。 COM 物件只會存留在一個單元中，也就是說，它的方法只能由屬於該單元的執行緒直接呼叫。 任何其他想要呼叫物件的執行緒都必須經過 proxy。

有兩種類型： [單一執行緒的單元](single-threaded-apartments.md)，以及 [多執行緒單元](multithreaded-apartments.md)。

-   單一執行緒的單元只包含一個執行緒，因此存留于單一執行緒單元中的所有 COM 物件都只能從屬於該單元的一個執行緒接收方法呼叫。 對單一執行緒單元中 COM 物件的所有方法呼叫，都會與單一執行緒單元執行緒的 windows 訊息佇列進行同步處理。 具有單個執行執行緒的進程只是此模型的特殊案例。
-   多執行緒單元是由一或多個執行緒組成，因此存留在多執行緒單元中的所有 COM 物件都可以直接從屬於多執行緒單元的任何執行緒接收方法呼叫。 多執行緒單元中的執行緒會使用稱為「 *自由執行緒*」的模型。 物件本身會同步處理多執行緒單元中 COM 物件的呼叫。

> [!Note]  
> 如需在相同進程內的單一執行緒單元和多執行緒單元之間進行通訊的說明，請參閱 [單一執行緒和多執行緒通訊](single-threaded-and-multithreaded-communication.md)。

 

進程可以有零或多個單一執行緒單元，以及零或一個多執行緒單元。

在進程中，主要的單元是要初始化的第一個單元。 在單一執行緒進程中，這是唯一的單元。 呼叫參數會在單元之間進行封送處理，而 COM 會透過訊息處理同步處理。 如果您將進程中的多個執行緒指定為無限制執行緒，則所有可用的執行緒都位於單一單元中，參數會直接傳遞給該單元中的任何執行緒，您必須處理所有的同步處理。 在具有自由執行緒和單元執行緒的處理常式中，所有的可用執行緒都位於單一單元，而其他所有單元都是單一執行緒的單元。 執行 COM 工作的程式是一組單元集合，最多可有一個多執行緒的單元，但有任意數目的單一執行緒單元。

COM 中的執行緒模型為使用不同執行緒架構的用戶端和伺服器提供了一種機制，以搭配使用。 自然支援在不同進程中使用不同執行緒模型的物件之間的呼叫。 從呼叫物件的觀點來看，無論呼叫的物件如何執行緒，對進程外部的物件所做的所有呼叫都會有相同的行為。 同樣地，從呼叫的物件觀點來看，無論呼叫端的執行緒模型為何，抵達呼叫的行為都相同。

用戶端與跨進程物件之間的互動很簡單，即使它們使用不同的執行緒模型，因為用戶端和物件是在不同的進程中。 用戶端與伺服器之間的 COM （介入）可以提供程式碼，讓執行緒模型使用標準封送處理和 RPC 進行交互操作。 例如，如果多個自由執行緒用戶端同時呼叫單一執行緒物件，則會將對應的視窗訊息放置在伺服器的訊息佇列中，以 COM 同步呼叫。 物件的單元會在每次抓取並分派訊息時接收一個呼叫。 不過，您必須特別小心，以確保同進程伺服器可與用戶端正確互動。  (查看同 [進程伺服器執行緒問題](in-process-server-threading-issues.md)。 ) 

使用多執行緒模型進行程式設計時，最重要的問題是讓您的程式碼具備執行緒安全，使適用于特定執行緒的訊息僅移至該執行緒，並且會保護執行緒的存取。

如需詳細資訊，請參閱下列主題：

-   [選擇執行緒模型](choosing-the-threading-model.md)
-   [單一執行緒單元](single-threaded-apartments.md)
-   [多執行緒單元](multithreaded-apartments.md)
-   [單一執行緒和多執行緒通訊](single-threaded-and-multithreaded-communication.md)
-   [同進程伺服器執行緒問題](in-process-server-threading-issues.md)
-   [跨單元存取介面](accessing-interfaces-across-apartments.md)

 

 