---
title: 進程、執行緒和單元
description: 進程是虛擬記憶體空間、程式碼、資料和系統資源的集合。
ms.assetid: cb62412a-d079-40f9-89dc-cce0bf3889af
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d598fc9d7dd39ab070b58aa7ba45a6e2fcae90db
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382930"
---
# <a name="processes-threads-and-apartments"></a><span data-ttu-id="3e0f5-103">進程、執行緒和單元</span><span class="sxs-lookup"><span data-stu-id="3e0f5-103">Processes, Threads, and Apartments</span></span>

<span data-ttu-id="3e0f5-104">*進程* 是虛擬記憶體空間、程式碼、資料和系統資源的集合。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-104">A *process* is a collection of virtual memory space, code, data, and system resources.</span></span> <span data-ttu-id="3e0f5-105">*執行緒* 是在進程內以串列方式執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-105">A *thread* is code that is to be serially executed within a process.</span></span> <span data-ttu-id="3e0f5-106">處理器會執行執行緒，而不是處理常式，因此每個應用程式都至少有一個處理常式，而處理常式一律至少有一個執行執行緒，又稱為主要執行緒。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-106">A processor executes threads, not processes, so each application has at least one process, and a process always has at least one thread of execution, known as the primary thread.</span></span> <span data-ttu-id="3e0f5-107">除了主要執行緒之外，處理常式可以有多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-107">A process can have multiple threads in addition to the primary thread.</span></span>

<span data-ttu-id="3e0f5-108">進程會透過訊息彼此通訊，方法是使用 Microsoft 的遠端程序呼叫， (RPC) 技術，將資訊傳遞給另一個。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-108">Processes communicate with one another through messages, using Microsoft's Remote Procedure Call (RPC) technology to pass information to one another.</span></span> <span data-ttu-id="3e0f5-109">從遠端電腦上的處理常式，到來自同一部電腦上另一個進程的呼叫之間，與呼叫端之間沒有任何差異。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-109">There is no difference to the caller between a call coming from a process on a remote machine and a call coming from another process on the same machine.</span></span>

<span data-ttu-id="3e0f5-110">當執行緒開始執行時，它會繼續執行，直到它被刪除為止，或直到由使用者動作或核心的執行緒排程器)  (優先順序較高的執行緒中斷為止。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-110">When a thread begins to execute, it continues until it is killed or until it is interrupted by a thread with higher priority (by a user action or the kernel's thread scheduler).</span></span> <span data-ttu-id="3e0f5-111">每個執行緒都可以執行不同的程式碼區段，或多個執行緒可以執行相同的程式碼區段。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-111">Each thread can run separate sections of code, or multiple threads can execute the same section of code.</span></span> <span data-ttu-id="3e0f5-112">執行相同程式碼區塊的執行緒會維護不同的堆疊。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-112">Threads executing the same block of code maintain separate stacks.</span></span> <span data-ttu-id="3e0f5-113">進程中的每個執行緒都會共用該進程的全域變數和資源。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-113">Each thread in a process shares that process's global variables and resources.</span></span>

<span data-ttu-id="3e0f5-114">執行緒排程器會根據進程的 priority 類別屬性和執行緒的基本優先權組合，決定執行執行緒的時機和頻率。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-114">The thread scheduler determines when and how often to execute a thread, according to a combination of the process's priority class attribute and the thread's base priority.</span></span> <span data-ttu-id="3e0f5-115">您可以藉由呼叫 [**SetPriorityClass**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass) 函式來設定進程的 priority 類別屬性，並使用 [**SetThreadPriority**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority)的呼叫來設定執行緒的基底優先順序。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-115">You set a process's priority class attribute by calling the [**SetPriorityClass**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setpriorityclass) function , and you set a thread's base priority with a call to [**SetThreadPriority**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority).</span></span>

<span data-ttu-id="3e0f5-116">多執行緒應用程式必須避免兩個執行緒問題：*鎖死\*\*和競爭* 情形。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-116">Multithreaded applications must avoid two threading problems: *deadlocks* and *races*.</span></span> <span data-ttu-id="3e0f5-117">當每個執行緒等候另一個執行緒執行某項作業時，就會發生鎖死。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-117">A deadlock occurs when each thread is waiting for the other to do something.</span></span> <span data-ttu-id="3e0f5-118">COM 呼叫控制項有助於防止物件之間的呼叫發生鎖死。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-118">The COM call control helps prevent deadlocks in calls between objects.</span></span> <span data-ttu-id="3e0f5-119">當某個執行緒在其相依的另一個執行緒之前完成，導致前者使用未初始化的值（因為後者尚未提供有效的值）時，就會發生競爭情況。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-119">A race condition occurs when one thread finishes before another on which it depends, causing the former to use an uninitialized value because the latter has not yet supplied a valid one.</span></span> <span data-ttu-id="3e0f5-120">COM 提供一些特別設計來協助避免跨進程伺服器發生競爭情況的函式。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-120">COM supplies some functions specifically designed to help avoid race conditions in out-of-process servers.</span></span> <span data-ttu-id="3e0f5-121"> (查看 [跨進程伺服器的執行](out-of-process-server-implementation-helpers.md)協助程式。 ) </span><span class="sxs-lookup"><span data-stu-id="3e0f5-121">(See [Out-of-Process Server Implementation Helpers](out-of-process-server-implementation-helpers.md).)</span></span>

## <a name="the-apartment-and-the-com-threading-architecture"></a><span data-ttu-id="3e0f5-122">單元和 COM 執行緒架構</span><span class="sxs-lookup"><span data-stu-id="3e0f5-122">The Apartment and the COM Threading Architecture</span></span>

<span data-ttu-id="3e0f5-123">雖然 COM 在導入多個執行緒之前都支援常見的單一執行緒個別進程模型，但您可以撰寫程式碼來利用多個執行緒，進而產生更有效率的應用程式，方法是在另一個執行緒等候一些耗時的作業完成時，允許一個執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-123">While COM supports the single-thread-per-process model prevalent before the introduction of multiple threads of execution, you can write code to take advantage of multiple threads, resulting in more efficient applications, by allowing one thread to be executed while another thread waits for some time-consuming operation to complete.</span></span>

> [!Note]  
> <span data-ttu-id="3e0f5-124">使用多個執行緒無法保證效能較佳。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-124">Using multiple threads is not a guarantee of better performance.</span></span> <span data-ttu-id="3e0f5-125">事實上，因為執行緒的分解是很困難的問題，所以使用多個執行緒通常會造成效能問題。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-125">In fact, because thread factoring is a difficult problem, using multiple threads often causes performance problems.</span></span> <span data-ttu-id="3e0f5-126">重要的是，只有在您非常確定所執行的工作時，才會使用多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-126">The key is to use multiple threads only if you are very sure of what you are doing.</span></span>

 

<span data-ttu-id="3e0f5-127">一般而言，若要查看 COM 執行緒架構，最簡單的方式就是將進程中的所有 COM 物件視為分成稱為「 *單元*」的群組。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-127">In general, the simplest way to view the COM threading architecture is to think of all the COM objects in the process as divided into groups called *apartments*.</span></span> <span data-ttu-id="3e0f5-128">COM 物件只會存留在一個單元中，也就是說，它的方法只能由屬於該單元的執行緒直接呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-128">A COM object lives in exactly one apartment, in the sense that its methods can legally be directly called only by a thread that belongs to that apartment.</span></span> <span data-ttu-id="3e0f5-129">任何其他想要呼叫物件的執行緒都必須經過 proxy。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-129">Any other thread that wants to call the object must go through a proxy.</span></span>

<span data-ttu-id="3e0f5-130">有兩種類型： [單一執行緒的單元](single-threaded-apartments.md)，以及 [多執行緒單元](multithreaded-apartments.md)。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-130">There are two types of apartments: [single-threaded apartments](single-threaded-apartments.md), and [multithreaded apartments](multithreaded-apartments.md).</span></span>

-   <span data-ttu-id="3e0f5-131">單一執行緒的單元只包含一個執行緒，因此存留于單一執行緒單元中的所有 COM 物件都只能從屬於該單元的一個執行緒接收方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-131">Single-threaded apartments consist of exactly one thread, so all COM objects that live in a single-threaded apartment can receive method calls only from the one thread that belongs to that apartment.</span></span> <span data-ttu-id="3e0f5-132">對單一執行緒單元中 COM 物件的所有方法呼叫，都會與單一執行緒單元執行緒的 windows 訊息佇列進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-132">All method calls to a COM object in a single-threaded apartment are synchronized with the windows message queue for the single-threaded apartment's thread.</span></span> <span data-ttu-id="3e0f5-133">具有單個執行執行緒的進程只是此模型的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-133">A process with a single thread of execution is simply a special case of this model.</span></span>
-   <span data-ttu-id="3e0f5-134">多執行緒單元是由一或多個執行緒組成，因此存留在多執行緒單元中的所有 COM 物件都可以直接從屬於多執行緒單元的任何執行緒接收方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-134">Multithreaded apartments consist of one or more threads, so all COM objects that live in an multithreaded apartment can receive method calls directly from any of the threads that belong to the multithreaded apartment.</span></span> <span data-ttu-id="3e0f5-135">多執行緒單元中的執行緒會使用稱為「 *自由執行緒*」的模型。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-135">Threads in a multithreaded apartment use a model called *free-threading*.</span></span> <span data-ttu-id="3e0f5-136">物件本身會同步處理多執行緒單元中 COM 物件的呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-136">Calls to COM objects in a multithreaded apartment are synchronized by the objects themselves.</span></span>

> [!Note]  
> <span data-ttu-id="3e0f5-137">如需在相同進程內的單一執行緒單元和多執行緒單元之間進行通訊的說明，請參閱 [單一執行緒和多執行緒通訊](single-threaded-and-multithreaded-communication.md)。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-137">For a description of communication between single-threaded apartments and multithreaded apartments within the same process, see [Single-Threaded and Multithreaded Communication](single-threaded-and-multithreaded-communication.md).</span></span>

 

<span data-ttu-id="3e0f5-138">進程可以有零或多個單一執行緒單元，以及零或一個多執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-138">A process can have zero or more single-threaded apartments and zero or one multithreaded apartment.</span></span>

<span data-ttu-id="3e0f5-139">在進程中，主要的單元是要初始化的第一個單元。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-139">In a process, the main apartment is the first to be initialized.</span></span> <span data-ttu-id="3e0f5-140">在單一執行緒進程中，這是唯一的單元。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-140">In a single-threaded process, this is the only apartment.</span></span> <span data-ttu-id="3e0f5-141">呼叫參數會在單元之間進行封送處理，而 COM 會透過訊息處理同步處理。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-141">Call parameters are marshaled between apartments, and COM handles the synchronization through messaging.</span></span> <span data-ttu-id="3e0f5-142">如果您將進程中的多個執行緒指定為無限制執行緒，則所有可用的執行緒都位於單一單元中，參數會直接傳遞給該單元中的任何執行緒，您必須處理所有的同步處理。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-142">If you designate multiple threads in a process to be free-threaded, all free threads reside in a single apartment, parameters are passed directly to any thread in the apartment, and you must handle all synchronization.</span></span> <span data-ttu-id="3e0f5-143">在具有自由執行緒和單元執行緒的處理常式中，所有的可用執行緒都位於單一單元，而其他所有單元都是單一執行緒的單元。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-143">In a process with both free-threading and apartment threading, all free threads reside in a single apartment and all other apartments are single-threaded apartments.</span></span> <span data-ttu-id="3e0f5-144">執行 COM 工作的程式是一組單元集合，最多可有一個多執行緒的單元，但有任意數目的單一執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-144">A process that does COM work is a collection of apartments with, at most, one multithreaded apartment but any number of single-threaded apartments.</span></span>

<span data-ttu-id="3e0f5-145">COM 中的執行緒模型為使用不同執行緒架構的用戶端和伺服器提供了一種機制，以搭配使用。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-145">The threading models in COM provide the mechanism for clients and servers that use different threading architectures to work together.</span></span> <span data-ttu-id="3e0f5-146">自然支援在不同進程中使用不同執行緒模型的物件之間的呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-146">Calls among objects with different threading models in different processes are naturally supported.</span></span> <span data-ttu-id="3e0f5-147">從呼叫物件的觀點來看，無論呼叫的物件如何執行緒，對進程外部的物件所做的所有呼叫都會有相同的行為。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-147">From the perspective of the calling object, all calls to objects outside a process behave identically, no matter how the object being called is threaded.</span></span> <span data-ttu-id="3e0f5-148">同樣地，從呼叫的物件觀點來看，無論呼叫端的執行緒模型為何，抵達呼叫的行為都相同。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-148">Likewise, from the perspective of the object being called, arriving calls behave identically, regardless of the threading model of the caller.</span></span>

<span data-ttu-id="3e0f5-149">用戶端與跨進程物件之間的互動很簡單，即使它們使用不同的執行緒模型，因為用戶端和物件是在不同的進程中。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-149">Interaction between a client and an out-of-process object is straightforward, even when they use different threading models because the client and object are in different processes.</span></span> <span data-ttu-id="3e0f5-150">用戶端與伺服器之間的 COM （介入）可以提供程式碼，讓執行緒模型使用標準封送處理和 RPC 進行交互操作。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-150">COM, interposed between the client and the server, can provide the code for the threading models to interoperate, using standard marshaling and RPC.</span></span> <span data-ttu-id="3e0f5-151">例如，如果多個自由執行緒用戶端同時呼叫單一執行緒物件，則會將對應的視窗訊息放置在伺服器的訊息佇列中，以 COM 同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-151">For example, if a single-threaded object is called simultaneously by multiple free-threaded clients, the calls will be synchronized by COM by placing corresponding window messages in the server's message queue.</span></span> <span data-ttu-id="3e0f5-152">物件的單元會在每次抓取並分派訊息時接收一個呼叫。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-152">The object's apartment will receive one call each time it retrieves and dispatches messages.</span></span> <span data-ttu-id="3e0f5-153">不過，您必須特別小心，以確保同進程伺服器可與用戶端正確互動。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-153">However, some care must be taken to ensure that in-process servers interact properly with their clients.</span></span> <span data-ttu-id="3e0f5-154"> (查看同 [進程伺服器執行緒問題](in-process-server-threading-issues.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="3e0f5-154">(See [In-Process Server Threading Issues](in-process-server-threading-issues.md).)</span></span>

<span data-ttu-id="3e0f5-155">使用多執行緒模型進行程式設計時，最重要的問題是讓您的程式碼具備執行緒安全，使適用于特定執行緒的訊息僅移至該執行緒，並且會保護執行緒的存取。</span><span class="sxs-lookup"><span data-stu-id="3e0f5-155">The most important issue in programming with a multithreaded model is to make your code thread-safe so that messages intended for a particular thread go only to that thread and access to threads is protected.</span></span>

<span data-ttu-id="3e0f5-156">如需詳細資訊，請參閱下列主題：</span><span class="sxs-lookup"><span data-stu-id="3e0f5-156">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="3e0f5-157">選擇執行緒模型</span><span class="sxs-lookup"><span data-stu-id="3e0f5-157">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
-   [<span data-ttu-id="3e0f5-158">單一執行緒單元</span><span class="sxs-lookup"><span data-stu-id="3e0f5-158">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
-   [<span data-ttu-id="3e0f5-159">多執行緒單元</span><span class="sxs-lookup"><span data-stu-id="3e0f5-159">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
-   [<span data-ttu-id="3e0f5-160">單一執行緒和多執行緒通訊</span><span class="sxs-lookup"><span data-stu-id="3e0f5-160">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
-   [<span data-ttu-id="3e0f5-161">同進程伺服器執行緒問題</span><span class="sxs-lookup"><span data-stu-id="3e0f5-161">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
-   [<span data-ttu-id="3e0f5-162">跨單元存取介面</span><span class="sxs-lookup"><span data-stu-id="3e0f5-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)

 

 