---
title: In-Process 伺服器執行緒問題
description: In-Process 伺服器執行緒問題
ms.assetid: 7bd6f62f-8c91-44bd-9a7f-d47988180eed
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a9d02af739eac11a6adae62de76be9078ee8e32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/21/2020
ms.locfileid: "104383253"
---
# <a name="in-process-server-threading-issues"></a><span data-ttu-id="82e6c-103">In-Process 伺服器執行緒問題</span><span class="sxs-lookup"><span data-stu-id="82e6c-103">In-Process Server Threading Issues</span></span>

<span data-ttu-id="82e6c-104">同進程伺服器不會呼叫 [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize)、 [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)或 [**OleInitialize**](/windows/desktop/api/Ole2/nf-ole2-oleinitialize) 來標記其執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="82e6c-104">An in-process server does not call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), or [**OleInitialize**](/windows/desktop/api/Ole2/nf-ole2-oleinitialize) to mark its threading model.</span></span> <span data-ttu-id="82e6c-105">針對執行緒感知 DLL 型或同進程物件，您必須在登錄中設定執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="82e6c-105">For thread-aware DLL-based or in-process objects, you need to set the threading model in the registry.</span></span> <span data-ttu-id="82e6c-106">當您未指定執行緒模型時，預設模型為單一執行緒的每個進程。</span><span class="sxs-lookup"><span data-stu-id="82e6c-106">The default model when you do not specify a threading model is single-thread-per-process.</span></span> <span data-ttu-id="82e6c-107">若要指定模型，請將 **>threadingmodel** 值新增至登錄中的 [InprocServer32](inprocserver32.md) 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="82e6c-107">To specify a model, you add the **ThreadingModel** value to the [InprocServer32](inprocserver32.md) key in the registry.</span></span>

<span data-ttu-id="82e6c-108">支援類別物件具現化的 Dll 必須執行和匯出函式 [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 和 [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)。</span><span class="sxs-lookup"><span data-stu-id="82e6c-108">DLLs that support instantiation of a class object must implement and export the functions [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow).</span></span> <span data-ttu-id="82e6c-109">當用戶端想要 DLL 支援的類別實例時，直接呼叫 [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (或透過呼叫 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) 會呼叫 **DllGetClassObject** ，在 DLL 中實作為物件的類別物件時取得指標。</span><span class="sxs-lookup"><span data-stu-id="82e6c-109">When a client wants an instance of the class the DLL supports, a call to [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (either directly or through a call to [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) calls **DllGetClassObject** to get a pointer to its class object when the object is implemented in a DLL.</span></span> <span data-ttu-id="82e6c-110">因此， **DllGetClassObject** 應該可以提供多個類別物件或單一安全線程物件 (基本上只是 [](/windows/win32/api/winnt/nf-winnt-interlockedincrement) / 在其內部參考計數) 上使用 InterlockedIncrement [**InterlockedDecrement**](/windows/desktop/api/winbase/nf-winbase-interlockeddecrement) 。</span><span class="sxs-lookup"><span data-stu-id="82e6c-110">**DllGetClassObject** should therefore be able to give away multiple class objects or a single thread-safe object (essentially just using [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement)/[**InterlockedDecrement**](/windows/desktop/api/winbase/nf-winbase-interlockeddecrement) on their internal reference counts).</span></span>

<span data-ttu-id="82e6c-111">顧名思義，會呼叫 [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow) 來判斷執行它的 DLL 是否正在使用中，如果不是，則可讓呼叫者安全地卸載它。</span><span class="sxs-lookup"><span data-stu-id="82e6c-111">As its name implies, [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow) is called to determine whether the DLL that implements it is in use, enabling the caller to safely unload it if it is not.</span></span> <span data-ttu-id="82e6c-112">從任何執行緒呼叫 [**CoFreeUnusedLibraries**](/windows/desktop/api/combaseapi/nf-combaseapi-cofreeunusedlibraries) 一律會路由到主要的單元執行緒，以呼叫 **DllCanUnloadNow**。</span><span class="sxs-lookup"><span data-stu-id="82e6c-112">Calls to [**CoFreeUnusedLibraries**](/windows/desktop/api/combaseapi/nf-combaseapi-cofreeunusedlibraries) from any thread always route through the main apartment's thread to call **DllCanUnloadNow**.</span></span>

<span data-ttu-id="82e6c-113">就像其他伺服器一樣，同進程伺服器也可以是單一執行緒、跨執行緒或無限制執行緒。</span><span class="sxs-lookup"><span data-stu-id="82e6c-113">Like other servers, in-process servers can be single-threaded, apartment-threaded, or free-threaded.</span></span> <span data-ttu-id="82e6c-114">無論該用戶端使用的執行緒模型為何，這些伺服器都可以由任何 OLE 用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="82e6c-114">These servers can be used by any OLE client, regardless of the threading model used by that client.</span></span>

<span data-ttu-id="82e6c-115">用戶端與同進程物件之間允許所有線程模型互通性的組合。</span><span class="sxs-lookup"><span data-stu-id="82e6c-115">All combinations of threading model interoperability are allowed between clients and in-process objects.</span></span> <span data-ttu-id="82e6c-116">用戶端與使用不同執行緒模型的同進程物件之間的互動，與用戶端與跨進程伺服器之間的互動完全一樣。</span><span class="sxs-lookup"><span data-stu-id="82e6c-116">Interaction between a client and an in-process object that use different threading models is exactly like the interaction between clients and out-of-process servers.</span></span> <span data-ttu-id="82e6c-117">針對同進程伺服器，當用戶端和同進程伺服器的執行緒模型不同時，COM 必須在用戶端與物件之間 interpose 本身。</span><span class="sxs-lookup"><span data-stu-id="82e6c-117">For an in-process server, when the threading model of the client and in-process server differ, COM must interpose itself between the client and the object.</span></span>

<span data-ttu-id="82e6c-118">當用戶端的多個執行緒同時呼叫支援單一執行緒模型的同進程物件時，COM 無法允許用戶端執行緒直接存取物件的 interfaceâ€「物件不是針對這類存取而設計。</span><span class="sxs-lookup"><span data-stu-id="82e6c-118">When an in-process object that supports the single-threaded model is called simultaneously by multiple threads of a client, COM cannot allow the client threads to directly access the object's interfaceâ€”the object was not designed for such access.</span></span> <span data-ttu-id="82e6c-119">相反地，COM 必須確保呼叫會進行同步處理，而且只由建立物件的用戶端執行緒進行。</span><span class="sxs-lookup"><span data-stu-id="82e6c-119">Instead, COM must ensure that calls are synchronized and are made only by the client thread that created the object.</span></span> <span data-ttu-id="82e6c-120">因此，COM 會在用戶端的主單元中建立物件，並要求所有其他用戶端單元使用 proxy 來存取該物件。</span><span class="sxs-lookup"><span data-stu-id="82e6c-120">Therefore, COM creates the object in the client's main apartment and requires all the other client apartments to access the object by using proxies.</span></span>

<span data-ttu-id="82e6c-121">當在用戶端中) 的自由執行緒單元 (多執行緒單元模型時，會在用戶端中建立一個執行緒的單元模型「主機」執行緒。</span><span class="sxs-lookup"><span data-stu-id="82e6c-121">When a free-threaded apartment (multithreaded apartment model) in a client creates an apartment-threaded in-process server, COM spins up a single-threaded apartment model "host" thread in the client.</span></span> <span data-ttu-id="82e6c-122">這個主控制項執行緒會建立物件，並將介面指標封送處理回用戶端的自由執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="82e6c-122">This host thread will create the object, and the interface pointer will be marshaled back to the client's free-threaded apartment.</span></span> <span data-ttu-id="82e6c-123">同樣地，當單元模型用戶端中的單一執行緒單元建立無限制執行緒的同進程伺服器時，COM 會將自由執行緒的主執行緒 (在建立物件的多執行緒單元上，然後再封送處理回用戶端單一執行緒的單元) 。</span><span class="sxs-lookup"><span data-stu-id="82e6c-123">Similarly, when a single-threaded apartment in an apartment-model client creates a free-threaded in-process server, COM spins up a free-threaded host thread (multithreaded apartment on which the object will be created and then marshaled back to the client single-threaded apartment).</span></span>

> [!Note]  
> <span data-ttu-id="82e6c-124">一般而言，如果您在同進程伺服器上設計自訂介面，您也應該為它提供封送處理常式代碼，讓 COM 可以封送處理用戶端單元之間的介面。</span><span class="sxs-lookup"><span data-stu-id="82e6c-124">In general, if you design a custom interface on an in-process server, you should also provide the marshaling code for it so that COM can marshal the interface between client apartments.</span></span>

 

<span data-ttu-id="82e6c-125">COM 會要求從其建立所在的相同用戶端單元存取，以協助保護對單一執行緒 DLL 所提供物件的存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-125">COM helps protect access to objects provided by a single-threaded DLL by requiring access from the same client apartment in which they were created.</span></span> <span data-ttu-id="82e6c-126">此外，所有的 DLL 進入點 (例如 [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 和 [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) ，而全域資料應該一律由相同的單元存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-126">In addition, all of the DLL entry points (like [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) and global data should always be accessed by the same apartment.</span></span> <span data-ttu-id="82e6c-127">COM 會在用戶端的主要單元中建立這類物件，讓主單元直接存取物件的指標。</span><span class="sxs-lookup"><span data-stu-id="82e6c-127">COM creates such objects in the main apartment of the client, giving the main apartment direct access to the object's pointers.</span></span> <span data-ttu-id="82e6c-128">來自其他單元的呼叫會使用 interthread 封送處理，從 proxy 移至主要單元中的存根，然後到物件。</span><span class="sxs-lookup"><span data-stu-id="82e6c-128">Calls from the other apartments use interthread marshaling to go from the proxy to the stub in the main apartment and then to the object.</span></span> <span data-ttu-id="82e6c-129">這可讓 COM 同步處理對物件的呼叫。</span><span class="sxs-lookup"><span data-stu-id="82e6c-129">This allows COM to synchronize calls to the object.</span></span> <span data-ttu-id="82e6c-130">Interthread 呼叫的速度很慢，因此建議您重新撰寫這些伺服器，以支援多個單元。</span><span class="sxs-lookup"><span data-stu-id="82e6c-130">Interthread calls are slow, so it is recommended that these servers be rewritten to support multiple apartments.</span></span>

<span data-ttu-id="82e6c-131">就像單一執行緒的同進程伺服器一樣，由單元模型 DLL 所提供的物件，必須由其建立所在的相同用戶端單元來存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-131">Like a single-threaded in-process server, an object provided by an apartment model DLL must be accessed by the same client apartment from which it was created.</span></span> <span data-ttu-id="82e6c-132">不過，此伺服器提供的物件可以在用戶端的多個單元中建立，因此伺服器必須執行其進入點 (例如 [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 和 [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) ，以便進行多執行緒的使用。</span><span class="sxs-lookup"><span data-stu-id="82e6c-132">However, objects provided by this server can be created in multiple apartments of the client, so the server must implement its entry points (like [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) and [**DllCanUnloadNow**](/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow)) for multithreaded use.</span></span> <span data-ttu-id="82e6c-133">例如，如果用戶端的兩個單元嘗試同時建立同進程物件的兩個實例，則這兩個單元都可以同時呼叫 **DllGetClassObject** 。</span><span class="sxs-lookup"><span data-stu-id="82e6c-133">For example, if two apartments of a client try to create two instances of the in-process object simultaneously, **DllGetClassObject** can be called simultaneously by both apartments.</span></span> <span data-ttu-id="82e6c-134">必須撰寫 **DllCanUnloadNow** ，以便在程式碼仍在 dll 中執行時，dll 不會卸載。</span><span class="sxs-lookup"><span data-stu-id="82e6c-134">**DllCanUnloadNow** must be written so that the DLL does not unload while code is still executing in the DLL.</span></span>

<span data-ttu-id="82e6c-135">如果 DLL 只提供一個 class factory 實例來建立所有物件，則類別 factory 的執行也必須設計為多執行緒使用，因為它將會由多個用戶端單元存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-135">If the DLL provides only one instance of the class factory to create all the objects, the class factory implementation must also be designed for multithreaded use, because it will be accessed by multiple client apartments.</span></span> <span data-ttu-id="82e6c-136">如果 DLL 在每次呼叫 [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 時，都會建立 class factory 的新實例，則 class factory 不需要是安全線程。</span><span class="sxs-lookup"><span data-stu-id="82e6c-136">If the DLL creates a new instance of the class factory each time [**DllGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) is called, the class factory need not be thread-safe.</span></span>

<span data-ttu-id="82e6c-137">Class factory 所建立的物件不需要是安全線程。</span><span class="sxs-lookup"><span data-stu-id="82e6c-137">Objects created by the class factory need not be thread-safe.</span></span> <span data-ttu-id="82e6c-138">一旦執行緒建立之後，一律會透過該執行緒存取物件，並由 COM 來同步處理對物件的所有呼叫。</span><span class="sxs-lookup"><span data-stu-id="82e6c-138">Once created by a thread, the object is always accessed through that thread and all calls to the object are synchronized by COM.</span></span> <span data-ttu-id="82e6c-139">建立此物件之用戶端的單元模型單元將會取得物件的直接指標。</span><span class="sxs-lookup"><span data-stu-id="82e6c-139">The apartment model apartment of a client that creates this object will get a direct pointer to the object.</span></span> <span data-ttu-id="82e6c-140">不同于建立物件之單元的用戶端單元必須透過 proxy 存取物件。</span><span class="sxs-lookup"><span data-stu-id="82e6c-140">Client apartments that are different from the apartment in which the object was created must access the object through proxies.</span></span> <span data-ttu-id="82e6c-141">當用戶端在其單元之間封送處理介面時，就會建立這些 proxy。</span><span class="sxs-lookup"><span data-stu-id="82e6c-141">These proxies are created when the client marshals the interface between its apartments.</span></span>

<span data-ttu-id="82e6c-142">當同進程 DLL **>threadingmodel** 值設定為 "Both" 時，就可以在單一執行緒或多執行緒用戶端單元中，直接建立並使用這個 DLL 提供的物件 (而不需要 proxy) 。</span><span class="sxs-lookup"><span data-stu-id="82e6c-142">When an in-process DLL **ThreadingModel** value is set to "Both", an object provided by this DLL can be created and used directly (without a proxy) in single-threaded or multithreaded client apartments.</span></span> <span data-ttu-id="82e6c-143">不過，它只能在建立它的單元內直接使用。</span><span class="sxs-lookup"><span data-stu-id="82e6c-143">However, it can be used directly only within the apartment in which it was created.</span></span> <span data-ttu-id="82e6c-144">若要將物件提供給任何其他的單元，必須封送處理物件。</span><span class="sxs-lookup"><span data-stu-id="82e6c-144">To give the object to any other apartment, the object must be marshaled.</span></span> <span data-ttu-id="82e6c-145">DLL 物件必須執行它自己的同步處理，而且可以同時由多個用戶端單元存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-145">The DLL object must implement its own synchronization and can be accessed by multiple client apartments at the same time.</span></span>

<span data-ttu-id="82e6c-146">為了加速可自由執行緒存取同進程 DLL 物件的效能，COM 提供 [**CoCreateFreeThreadedMarshaler**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreatefreethreadedmarshaler) 函數。</span><span class="sxs-lookup"><span data-stu-id="82e6c-146">To speed performance for free-threaded access to in-process DLL objects, COM provides the [**CoCreateFreeThreadedMarshaler**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreatefreethreadedmarshaler) function.</span></span> <span data-ttu-id="82e6c-147">這個函式會建立一個無限制執行緒封送處理物件，此物件可以使用同進程伺服器物件進行匯總。</span><span class="sxs-lookup"><span data-stu-id="82e6c-147">This function creates a free-threaded marshaling object that can be aggregated with an in-process server object.</span></span> <span data-ttu-id="82e6c-148">當同一進程中的用戶端需要存取另一個單元中的物件時，匯總無限制執行緒封送處理器會提供用戶端直接指標給用戶端，而不是 proxy，當用戶端將物件的介面封送處理至不同的單元時。</span><span class="sxs-lookup"><span data-stu-id="82e6c-148">When a client apartment in the same process needs access to an object in another apartment, aggregating the free-threaded marshaler provides the client with a direct pointer to the server object, rather than to a proxy, when the client marshals the object's interface to a different apartment.</span></span> <span data-ttu-id="82e6c-149">用戶端不需要執行任何同步處理。</span><span class="sxs-lookup"><span data-stu-id="82e6c-149">The client does not need to do any synchronization.</span></span> <span data-ttu-id="82e6c-150">這僅適用于相同的進程;標準封送處理是用於傳送至另一個進程之物件的參考。</span><span class="sxs-lookup"><span data-stu-id="82e6c-150">This works only within the same process; standard marshaling is used for a reference to the object that is sent to another process.</span></span>

<span data-ttu-id="82e6c-151">僅支援無線程執行緒的同進程 DLL 所提供的物件是無限制執行緒的物件。</span><span class="sxs-lookup"><span data-stu-id="82e6c-151">An object provided by an in-process DLL that supports only free threading is a free-threaded object.</span></span> <span data-ttu-id="82e6c-152">它會執行它自己的同步處理，並可同時由多個用戶端執行緒存取。</span><span class="sxs-lookup"><span data-stu-id="82e6c-152">It implements its own synchronization and can be accessed by multiple client threads at the same time.</span></span> <span data-ttu-id="82e6c-153">此伺服器不會線上程之間封送處理介面，因此可以直接建立和使用此伺服器 (而不需要 proxy) 用戶端中的多執行緒單元。</span><span class="sxs-lookup"><span data-stu-id="82e6c-153">This server does not marshal interfaces between threads, so this server can be created and used directly (without a proxy) only by multithreaded apartments in a client.</span></span> <span data-ttu-id="82e6c-154">建立它的單一執行緒單元會透過 proxy 來存取它。</span><span class="sxs-lookup"><span data-stu-id="82e6c-154">Single-threaded apartments that create it will access it through a proxy.</span></span>

## <a name="related-topics"></a><span data-ttu-id="82e6c-155">相關主題</span><span class="sxs-lookup"><span data-stu-id="82e6c-155">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="82e6c-156">跨單元存取介面</span><span class="sxs-lookup"><span data-stu-id="82e6c-156">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="82e6c-157">選擇執行緒模型</span><span class="sxs-lookup"><span data-stu-id="82e6c-157">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="82e6c-158">多執行緒單元</span><span class="sxs-lookup"><span data-stu-id="82e6c-158">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="82e6c-159">進程、執行緒和單元</span><span class="sxs-lookup"><span data-stu-id="82e6c-159">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="82e6c-160">單一執行緒和多執行緒通訊</span><span class="sxs-lookup"><span data-stu-id="82e6c-160">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="82e6c-161">單一執行緒單元</span><span class="sxs-lookup"><span data-stu-id="82e6c-161">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 