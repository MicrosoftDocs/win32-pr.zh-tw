---
title: 重複使用物件
description: 重複使用物件
ms.assetid: 07055fea-bdfe-4c7a-be07-2edcbf609dd9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 71b6ef6d28b23ff2fcda5ed46d9b99a6634389793e48275c36e2f8a708f7266d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "118309419"
---
# <a name="reusing-objects"></a>重複使用物件

任何物件模型的重要目標，是要讓物件作者能夠重複使用，並將其他人所提供的物件，擴充為其本身的實作為片段。 在 Microsoft Visual C++ 和其他語言中執行這項作業的其中一種方式，是使用「*執行繼承*」，這可讓物件繼承 ( 「子類別」 ) 其他物件的部分函數，同時覆寫其他函式。

使用傳統的實作為繼承的全系統物件互動問題，就是不清楚地定義在執行階層中的物件之間的合約 (介面) 。 事實上，它是隱含且不明確的。 當父系或子物件變更其執行時，相關元件的行為可能會變成未定義或 unstably。 在任何單一的應用程式中，只要是可同時更新所有元件的單一工程小組來管理，這不一定是主要的考慮。 在某個小組元件的環境中，透過以黑色的方式重複使用其他小組所建立的其他元件，這類不穩定危及重複使用。 此外，執行繼承通常只能在進程界限內運作。 如此一來，在許多工程團隊所建立的軟體元件所組成的大型、不斷演進的系統中，傳統的執行繼承就不切實際。

建立可重複使用之元件的關鍵是能夠將物件視為不透明的方塊。 這表示，嘗試重複使用另一個物件的程式碼，並不知道任何內容，也不需要知道所使用元件的內部結構或實作為。 換句話說，嘗試重複使用元件的程式碼取決於物件的行為，而不是其實際執行。

為了達到黑箱的重複利用性，COM 採用其他既定的重複利用機制，例如內含專案 */委派* 和 *匯總*。

> [!NOTE]  
> 為了方便起見，要重複使用的物件稱為 *內建物件* ，而使用該內建物件的物件則是 *外部物件*。

 

在這兩種機制中，請務必記住外部物件對其用戶端的外觀。 至於用戶端，這兩個物件都會執行用戶端可以取得指標的任何介面。 用戶端會將外部物件視為不透明的方塊，因此不會在意外部 objectâ的內部結構，也不需要在意。」用戶端只在意行為。

如需詳細資訊，請參閱下列主題：

-   [內含專案/委派](containment-delegation.md)
-   [彙總](aggregation.md)

 

 




