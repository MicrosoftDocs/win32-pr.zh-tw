---
title: Single-Threaded 單元
description: Single-Threaded 單元
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382937"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="43960-103">Single-Threaded 單元</span><span class="sxs-lookup"><span data-stu-id="43960-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="43960-104">使用單一執行緒的單元 (單元模型進程) 提供以訊息為基礎的範例，可處理多個同時執行的物件。</span><span class="sxs-lookup"><span data-stu-id="43960-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="43960-105">它可讓您藉由允許執行緒來撰寫更有效率的程式碼，同時等待一些耗時的作業完成，以允許執行另一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="43960-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="43960-106">進程中的每個執行緒都會初始化為「單元模型」處理常式，並可抓取和分派視窗訊息，是單一執行緒的單元執行緒。</span><span class="sxs-lookup"><span data-stu-id="43960-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="43960-107">每個執行緒都存在於自己的單元中。</span><span class="sxs-lookup"><span data-stu-id="43960-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="43960-108">在一個單元中，介面指標可在不封送處理的情況下傳遞，因此一個單一執行緒的單元執行緒中的所有物件都會直接進行通訊。</span><span class="sxs-lookup"><span data-stu-id="43960-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="43960-109">所有在相同執行緒上執行，因此必須有同步執行的相關物件的邏輯群組，可以存留在相同的單一執行緒的單元執行緒上。</span><span class="sxs-lookup"><span data-stu-id="43960-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="43960-110">但是，一個單元模型物件不能位於一個以上的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="43960-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="43960-111">呼叫其他執行緒中的物件時，必須在主控執行緒的內容中進行，讓分散式 COM 在您于 proxy 上呼叫時，自動為您切換執行緒。</span><span class="sxs-lookup"><span data-stu-id="43960-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="43960-112">進程間和 interthread 模型很類似。</span><span class="sxs-lookup"><span data-stu-id="43960-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="43960-113">當您需要將介面指標傳遞至另一個執行緒上另一個執行緒中的物件時，) 在相同進程中的另一個執行緒上 (，您會使用不同進程中的物件用來跨進程界限傳遞指標的相同封送處理模型。</span><span class="sxs-lookup"><span data-stu-id="43960-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="43960-114">藉由取得標準封送處理物件的指標，您可以在各) 單元之間的執行緒界限之間進行介面指標的封送處理 (的方式，與處理常式之間的方式相同。</span><span class="sxs-lookup"><span data-stu-id="43960-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="43960-115">在單元之間傳遞時，必須封送處理 (介面指標。 ) </span><span class="sxs-lookup"><span data-stu-id="43960-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="43960-116">單一執行緒單元的規則很簡單，但請務必小心遵循：</span><span class="sxs-lookup"><span data-stu-id="43960-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="43960-117">每個物件都應該只存留于單一執行緒的單元) 內的一個執行緒 (。</span><span class="sxs-lookup"><span data-stu-id="43960-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="43960-118">初始化每個執行緒的 COM 程式庫。</span><span class="sxs-lookup"><span data-stu-id="43960-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="43960-119">在單元之間傳遞物件的所有指標封送處理。</span><span class="sxs-lookup"><span data-stu-id="43960-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="43960-120">每個單一執行緒的單元都必須有訊息迴圈，才能處理來自相同進程中其他進程和單元的呼叫。</span><span class="sxs-lookup"><span data-stu-id="43960-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="43960-121">沒有物件的單一執行緒單元 (用戶端僅) 也需要訊息迴圈，以分派某些應用程式所使用的廣播訊息。</span><span class="sxs-lookup"><span data-stu-id="43960-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="43960-122">以 DLL 為基礎或同進程物件不會呼叫 COM 初始化函數;相反地，他們會在登錄中的 [InprocServer32](inprocserver32.md)機碼下，使用 **>threadingmodel** 的名稱-value 來註冊其執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="43960-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="43960-123">可感知單元的物件也必須小心地寫入 DLL 進入點。</span><span class="sxs-lookup"><span data-stu-id="43960-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="43960-124">有一些特殊考慮適用于執行緒內含式伺服器。</span><span class="sxs-lookup"><span data-stu-id="43960-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="43960-125">如需詳細資訊，請參閱同 [進程伺服器執行緒問題](in-process-server-threading-issues.md)。</span><span class="sxs-lookup"><span data-stu-id="43960-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="43960-126">雖然多個物件可以存留在單一線程上，但是沒有任何單元模型物件可以存留在一個以上的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="43960-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="43960-127">用戶端進程或跨進程伺服器的每個執行緒都必須呼叫 [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize)，或呼叫 [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) 並指定 \_ *dwCoInit* 參數的 COINIT APARTMENTTHREADED。</span><span class="sxs-lookup"><span data-stu-id="43960-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="43960-128">主單元是先呼叫 **CoInitializeEx** 的執行緒。</span><span class="sxs-lookup"><span data-stu-id="43960-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="43960-129">如需同進程伺服器的資訊，請參閱同 [進程伺服器執行緒問題](in-process-server-threading-issues.md)。</span><span class="sxs-lookup"><span data-stu-id="43960-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="43960-130">對物件的所有呼叫都必須在其) 的執行緒 (中進行。</span><span class="sxs-lookup"><span data-stu-id="43960-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="43960-131">禁止直接從另一個執行緒呼叫物件;以這種無線程方式使用物件，可能會導致應用程式發生問題。</span><span class="sxs-lookup"><span data-stu-id="43960-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="43960-132">這項規則的含意是，物件的所有指標都必須在單元之間傳遞時進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="43960-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="43960-133">COM 針對此目的提供下列兩個函數：</span><span class="sxs-lookup"><span data-stu-id="43960-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="43960-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) 會將介面封送處理至傳回給呼叫端的資料流程物件。</span><span class="sxs-lookup"><span data-stu-id="43960-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="43960-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) 會從資料流程物件拆收介面指標，並加以釋放。</span><span class="sxs-lookup"><span data-stu-id="43960-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="43960-136">這些函式會將呼叫包裝至 [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) 和 [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) 函式，這需要使用 MSHCTX \_ INPROC 旗標。</span><span class="sxs-lookup"><span data-stu-id="43960-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="43960-137">一般而言，封送處理是由 COM 自動完成。</span><span class="sxs-lookup"><span data-stu-id="43960-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="43960-138">例如，當將介面指標做為方法呼叫中的參數傳遞至另一個單元中的物件時，或在呼叫 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)時，COM 會自動進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="43960-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="43960-139">不過，在某些特殊情況下，如果應用程式寫入器在不同的單元之間傳遞介面指標，而不使用一般的 COM 機制，則寫入器必須手動處理封送處理。</span><span class="sxs-lookup"><span data-stu-id="43960-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="43960-140">如果一個處理常式中的一個單元 (的) 有介面指標，而另一個單元 (的單元 2) 需要使用，則必須呼叫 [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) 來封送處理介面。</span><span class="sxs-lookup"><span data-stu-id="43960-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="43960-141">此函式所建立的資料流程為安全線程，而且必須儲存在可由單元2存取的變數中。</span><span class="sxs-lookup"><span data-stu-id="43960-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="43960-142">單元2必須將此資料流程傳遞至 [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) 以 unmarshal 介面，並且會取得 proxy 的指標，讓它可以存取介面。</span><span class="sxs-lookup"><span data-stu-id="43960-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="43960-143">主要的單元必須保持運作，直到用戶端完成所有的 COM 工作 (，因為部分內含式物件會載入到主單元中，如) 的 [進程伺服器執行緒問題](in-process-server-threading-issues.md) 中所述。</span><span class="sxs-lookup"><span data-stu-id="43960-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="43960-144">以這種方式線上程之間傳遞一個物件之後，就很容易將介面指標當作參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="43960-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="43960-145">如此一來，分散式 COM 會對應用程式進行封送處理和執行緒切換。</span><span class="sxs-lookup"><span data-stu-id="43960-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="43960-146">若要處理相同進程中其他進程和單元的呼叫，每個單一執行緒的單元都必須有訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="43960-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="43960-147">這表示執行緒的工作函式必須有 GetMessage/DispatchMessage 迴圈。</span><span class="sxs-lookup"><span data-stu-id="43960-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="43960-148">如果有其他同步處理原始物件是用來線上程之間進行通訊， [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) 函數可以用來等候訊息和執行緒同步處理事件。</span><span class="sxs-lookup"><span data-stu-id="43960-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="43960-149">此函式的檔有這類組合迴圈的範例。</span><span class="sxs-lookup"><span data-stu-id="43960-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="43960-150">COM 會在每個單一執行緒的單元中使用 Windows 類別 "OleMainThreadWndClass" 建立隱藏視窗。</span><span class="sxs-lookup"><span data-stu-id="43960-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="43960-151">對物件的呼叫會以視窗訊息的形式接收到此隱藏視窗。</span><span class="sxs-lookup"><span data-stu-id="43960-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="43960-152">當物件的單元抓取並分派訊息時，隱藏的視窗就會收到訊息。</span><span class="sxs-lookup"><span data-stu-id="43960-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="43960-153">視窗程式接著會呼叫物件的對應介面方法。</span><span class="sxs-lookup"><span data-stu-id="43960-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="43960-154">當有多個用戶端呼叫物件時，呼叫會排入訊息佇列中，而物件會在每次其單元抓取和分派訊息時接收呼叫。</span><span class="sxs-lookup"><span data-stu-id="43960-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="43960-155">由於呼叫是由 COM 進行同步處理，而且呼叫一律由屬於物件之單元的執行緒傳遞，所以物件的介面執行不需要提供同步處理。</span><span class="sxs-lookup"><span data-stu-id="43960-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="43960-156">單一執行緒單元可以執行 [**imessagefilter.prefiltermessage**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) ，以允許它們在必要時取消呼叫或接收視窗訊息。</span><span class="sxs-lookup"><span data-stu-id="43960-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="43960-157">如果物件的其中一個介面方法實重新輸入抓取並分派訊息，或對另一個執行緒進行 ORPC 呼叫，而導致相同的單元) 將另一個呼叫傳遞給物件 (，則物件可以是的。</span><span class="sxs-lookup"><span data-stu-id="43960-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="43960-158">OLE 不會防止在相同執行緒上重新進入，但有助於提供執行緒安全性。</span><span class="sxs-lookup"><span data-stu-id="43960-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="43960-159">這與視窗程式在處理訊息時，可以重新輸入並分派訊息的方式相同。</span><span class="sxs-lookup"><span data-stu-id="43960-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="43960-160">但是，呼叫跨進程的單一執行緒單元伺服器（呼叫另一個單一執行緒的單元伺服器）將允許重新輸入第一部伺服器。</span><span class="sxs-lookup"><span data-stu-id="43960-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="43960-161">相關主題</span><span class="sxs-lookup"><span data-stu-id="43960-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="43960-162">跨單元存取介面</span><span class="sxs-lookup"><span data-stu-id="43960-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="43960-163">選擇執行緒模型</span><span class="sxs-lookup"><span data-stu-id="43960-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="43960-164">多執行緒單元</span><span class="sxs-lookup"><span data-stu-id="43960-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="43960-165">同進程伺服器執行緒問題</span><span class="sxs-lookup"><span data-stu-id="43960-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="43960-166">進程、執行緒和單元</span><span class="sxs-lookup"><span data-stu-id="43960-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="43960-167">單一執行緒和多執行緒通訊</span><span class="sxs-lookup"><span data-stu-id="43960-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 