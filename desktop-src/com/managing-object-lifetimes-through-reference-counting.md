---
title: 透過參考計數來管理物件存留期
description: 透過參考計數來管理物件存留期
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/17/2020
ms.locfileid: "106983293"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a>透過參考計數來管理物件存留期

在傳統物件系統中，物件的生命週期（也就是建立和刪除物件的問題）是由語言 (或語言執行時間隱含地處理，) 或由應用程式設計人員明確處理。

在不斷演進的 decentrally 結構化系統中，由重複使用的元件所組成，任何用戶端（甚至任何程式設計人員）永遠都能「知道」如何處理元件的存留期。 對於具有適當安全性許可權的用戶端，透過簡單的要求建立物件仍相當簡單，但物件刪除則是完全不同。 當物件不再需要且應該刪除時，不一定清楚。 熟悉垃圾收集程式設計環境（例如 JAVA）的 (讀者可能不同意;不過，JAVA 物件不會跨越機器或甚至處理常式界限，因此垃圾收集會限制為在單一進程空間記憶體留的物件。 此外，JAVA 會強制使用單一程式設計語言 ) 。即使原始用戶端是透過物件完成，也不能直接將物件關閉，因為某些其他用戶端或用戶端可能仍有其參考。

確保物件不再需要的其中一種方式，是完全相依于基礎通道，以在跨進程或跨通道物件的所有連接都消失時通知系統。 不過，使用此方法的配置會有數個原因無法接受。 其中一個問題是，它可能需要跨進程/跨網路程式設計模型和單一進程程式設計模型之間的主要差異。 在跨進程/跨網路程式設計模型中，通訊系統會提供物件存留期管理所需的勾點，而在單一進程程式設計模型中，物件會直接連接，而不需要任何仲介通道。 另一個問題是，此配置也可能會導致系統提供的軟體層影響同進程案例中的元件效能。 此外，以明確監視為基礎的機制，通常不會擴充至數千個或數百萬個物件。

COM 為此一組問題提供可擴充且散佈的方法。 用戶端會在使用它時，以及當物件完成時，將其告知，而當物件不再需要時，則會自行刪除。 這種方法會要求所有物件都會計入對本身的參考。 JAVA 這類程式設計語言（像是 JAVA）本身就會有自己的存留期管理配置（例如垃圾收集），可以使用 COM 的參考計數來內部執行和使用 COM 物件，讓程式設計人員避免處理它。

就像應用程式必須釋出記憶體，一旦記憶體不再使用，物件的用戶端就會在不再需要物件時，負責釋放物件的參考。 在物件導向的系統中，用戶端只能藉由為物件提供可自行釋放的指示，來進行這項作業。

當物件不再使用時，請務必將物件解除配置。 困難之處在于判斷何時適合解除配置物件。 您可以使用自動變數 (在) 堆疊上配置的變數來進行這項工作，因為它們不能用在宣告的區塊之外，因此編譯器會在到達區塊結尾時將它們解除配置。 若是動態配置的 COM 物件，則是由物件的用戶端決定何時不再需要使用該物件，尤其是可能同時由多個用戶端使用的本機或遠端物件。 物件必須等到所有用戶端都完成後，才能釋出其本身。 由於 COM 物件是透過介面指標操作，而且可供不同進程或其他機器上的物件使用，因此系統無法追蹤物件的用戶端。

判斷何時適合解除配置物件的 COM 方法是手動參考計數。 每個物件都會維護一個參考計數來追蹤有多少用戶端連接到它，也就是在任何用戶端的任何介面上有多少指標存在。

如需詳細資訊，請參閱下列主題：

-   [正在執行參考計數](implementing-reference-counting.md)
-   [管理參考計數的規則](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a>相關主題

<dl> <dt>

[使用和執行 IUnknown](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




