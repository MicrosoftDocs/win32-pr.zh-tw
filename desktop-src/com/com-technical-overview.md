---
title: COM 技術總覽
ms.assetid: 519c87cc-b442-4187-af2a-124a1e4e8b49
description: 深入瞭解： COM 技術總覽
keywords:
- COM 技術總覽 COM
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be5dc95ffae5166d86cd8110cab1a6b90e6ffa5c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104110572"
---
# <a name="com-technical-overview"></a><span data-ttu-id="cc214-104">COM 技術總覽</span><span class="sxs-lookup"><span data-stu-id="cc214-104">COM Technical Overview</span></span>

<span data-ttu-id="cc214-105">本主題提供 Microsoft 元件物件模型 (COM) 的總覽：</span><span class="sxs-lookup"><span data-stu-id="cc214-105">This topic provides an overview of the Microsoft Component Object Model (COM):</span></span>

-   [<span data-ttu-id="cc214-106">COM 簡介</span><span class="sxs-lookup"><span data-stu-id="cc214-106">Introduction to COM</span></span>](#introduction-to-com)
-   [<span data-ttu-id="cc214-107">物件和介面</span><span class="sxs-lookup"><span data-stu-id="cc214-107">Objects and Interfaces</span></span>](#objects-and-interfaces)
-   [<span data-ttu-id="cc214-108">介面執行</span><span class="sxs-lookup"><span data-stu-id="cc214-108">Interface implementation</span></span>](#interface-implementation)
-   [<span data-ttu-id="cc214-109">IUnknown 介面</span><span class="sxs-lookup"><span data-stu-id="cc214-109">The IUnknown Interface</span></span>](#the-iunknown-interface)
-   [<span data-ttu-id="cc214-110">用戶端/伺服器模型</span><span class="sxs-lookup"><span data-stu-id="cc214-110">The Client/Server Model</span></span>](#the-clientserver-model)
-   [<span data-ttu-id="cc214-111">服務控制管理員</span><span class="sxs-lookup"><span data-stu-id="cc214-111">Service Control Manager</span></span>](#service-control-manager)
-   [<span data-ttu-id="cc214-112">可 重用</span><span class="sxs-lookup"><span data-stu-id="cc214-112">Reusability</span></span>](#reusability)
-   [<span data-ttu-id="cc214-113">儲存體和資料流程物件</span><span class="sxs-lookup"><span data-stu-id="cc214-113">Storage and Stream Objects</span></span>](#storage-and-stream-objects)
-   [<span data-ttu-id="cc214-114">資料轉送</span><span class="sxs-lookup"><span data-stu-id="cc214-114">Data Transfer</span></span>](#data-transfer)
-   [<span data-ttu-id="cc214-115">遠端</span><span class="sxs-lookup"><span data-stu-id="cc214-115">Remoting</span></span>](#remoting)
-   [<span data-ttu-id="cc214-116">安全性</span><span class="sxs-lookup"><span data-stu-id="cc214-116">Security</span></span>](#security)
-   [<span data-ttu-id="cc214-117">相關主題</span><span class="sxs-lookup"><span data-stu-id="cc214-117">Related topics</span></span>](#related-topics)

## <a name="introduction-to-com"></a><span data-ttu-id="cc214-118">COM 簡介</span><span class="sxs-lookup"><span data-stu-id="cc214-118">Introduction to COM</span></span>

<span data-ttu-id="cc214-119">Microsoft 元件物件模型 (COM) 會定義二進位互通性標準，以建立在執行時間進行互動的可重複使用軟體程式庫。</span><span class="sxs-lookup"><span data-stu-id="cc214-119">The Microsoft Component Object Model (COM) defines a binary interoperability standard for creating reusable software libraries that interact at run time.</span></span> <span data-ttu-id="cc214-120">您可以使用 COM 程式庫，而不需要將它們編譯到應用程式中。</span><span class="sxs-lookup"><span data-stu-id="cc214-120">You can use COM libraries without the requirement of compiling them into your application.</span></span> <span data-ttu-id="cc214-121">COM 是許多 Microsoft 產品和技術的基礎，例如 Windows Media Player 和 Windows Server。</span><span class="sxs-lookup"><span data-stu-id="cc214-121">COM is the foundation for a number of Microsoft products and technologies, such as Windows Media Player and Windows Server.</span></span>

<span data-ttu-id="cc214-122">COM 定義適用于許多作業系統和硬體平臺的二進位標準。</span><span class="sxs-lookup"><span data-stu-id="cc214-122">COM defines a binary standard that applies to many operating systems and hardware platforms.</span></span> <span data-ttu-id="cc214-123">針對網路運算，COM 會定義標準電傳格式和通訊協定，以便在不同硬體平臺上執行的物件之間進行互動。</span><span class="sxs-lookup"><span data-stu-id="cc214-123">For network computing, COM defines a standard wire format and protocol for interaction among objects that run on different hardware platforms.</span></span> <span data-ttu-id="cc214-124">COM 與實語言無關，這表示您可以使用不同的程式設計語言（例如 c + + 和 .NET Framework 中的語言）來建立 COM 程式庫。</span><span class="sxs-lookup"><span data-stu-id="cc214-124">COM is independent of implementation language, which means that you can create COM libraries by using different programming languages, such as C++ and those in the .NET Framework.</span></span>

<span data-ttu-id="cc214-125">COM 規格提供可讓您重複使用跨平臺軟體的所有基本概念：</span><span class="sxs-lookup"><span data-stu-id="cc214-125">The COM specification provides all of the fundamental concepts that enable cross-platform software reuse:</span></span>

-   <span data-ttu-id="cc214-126">元件之間函式呼叫的二進位標準。</span><span class="sxs-lookup"><span data-stu-id="cc214-126">A binary standard for function calls between components.</span></span>
-   <span data-ttu-id="cc214-127">將函數的強型別分組布建至介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-127">A provision for strongly-typed groupings of functions into interfaces.</span></span>
-   <span data-ttu-id="cc214-128">提供多型、功能探索和物件存留期追蹤的基底介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-128">A base interface that provides polymorphism, feature discovery, and object lifetime tracking.</span></span>
-   <span data-ttu-id="cc214-129">可唯一識別元件及其介面的機制。</span><span class="sxs-lookup"><span data-stu-id="cc214-129">A mechanism that uniquely identifies components and their interfaces.</span></span>
-   <span data-ttu-id="cc214-130">從部署建立元件實例的元件載入器。</span><span class="sxs-lookup"><span data-stu-id="cc214-130">A component loader that creates component instances from a deployment.</span></span>

<span data-ttu-id="cc214-131">COM 有許多部分可一起運作，以建立從可重複使用的元件建立的應用程式：</span><span class="sxs-lookup"><span data-stu-id="cc214-131">COM has a number of parts that work together to enable the creation of applications that are built from reusable components:</span></span>

-   <span data-ttu-id="cc214-132">提供符合 COM 規格之執行時間環境的 *主機系統* 。</span><span class="sxs-lookup"><span data-stu-id="cc214-132">A *host system* that provides a run-time environment that conforms to the COM specification.</span></span>
-   <span data-ttu-id="cc214-133">定義功能合約的 *介面*，以及用來執行介面的 *元件*。</span><span class="sxs-lookup"><span data-stu-id="cc214-133">*Interfaces* that define feature contracts, and *components* that implement interfaces.</span></span>
-   <span data-ttu-id="cc214-134">提供元件給系統的 *伺服器*，以及使用元件所提供功能的 *用戶端*。</span><span class="sxs-lookup"><span data-stu-id="cc214-134">*Servers* that provide components to the system, and *clients* that use the features provided by components.</span></span>
-   <span data-ttu-id="cc214-135">追蹤元件部署在本機和遠端主機 *上的登錄* 。</span><span class="sxs-lookup"><span data-stu-id="cc214-135">A *registry* that tracks where components are deployed on local and remote hosts.</span></span>
-   <span data-ttu-id="cc214-136">*服務控制管理員*，可在本機和遠端主機上尋找元件，並將伺服器連接至用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-136">A *Service Control Manager* that locates components on local and remote hosts and connects servers to clients.</span></span>
-   <span data-ttu-id="cc214-137">*結構化儲存體* 通訊協定，定義如何流覽主機檔案系統上的檔案內容。</span><span class="sxs-lookup"><span data-stu-id="cc214-137">A *structured storage* protocol that defines how to navigate the contents of files on the host's file system.</span></span>

<span data-ttu-id="cc214-138">跨主機和平臺啟用程式碼重複使用是 COM 的核心。</span><span class="sxs-lookup"><span data-stu-id="cc214-138">Enabling code re-use across hosts and platforms is central to COM.</span></span> <span data-ttu-id="cc214-139">可重複使用的介面實名為 *元件*、 *元件物件* 或 *COM 物件*。</span><span class="sxs-lookup"><span data-stu-id="cc214-139">A reusable interface implementation is named a *component*, a *component object*, or a *COM object*.</span></span> <span data-ttu-id="cc214-140">元件會執行一個或多個 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-140">A component implements one or more COM interfaces.</span></span>

<span data-ttu-id="cc214-141">您可以藉由設計程式庫所實行的介面來定義自訂 COM 程式庫。</span><span class="sxs-lookup"><span data-stu-id="cc214-141">You define a custom COM library by designing the interfaces that your library implements.</span></span> <span data-ttu-id="cc214-142">您程式庫的取用者可以探索及使用其功能，而不需要瞭解您的程式庫部署和實行詳細資料。</span><span class="sxs-lookup"><span data-stu-id="cc214-142">Consumers of your library can discover and use its features without any knowledge of your library's deployment and implementation details.</span></span>

## <a name="objects-and-interfaces"></a><span data-ttu-id="cc214-143">物件和介面</span><span class="sxs-lookup"><span data-stu-id="cc214-143">Objects and Interfaces</span></span>

<span data-ttu-id="cc214-144">COM 物件會透過 *介面*（成員函式的集合）來公開其功能。</span><span class="sxs-lookup"><span data-stu-id="cc214-144">A COM object exposes its features through an *interface*, which is a collection of member functions.</span></span> <span data-ttu-id="cc214-145">COM 介面會定義元件的預期行為和責任，並且會指定提供一小段相關作業的強型別合約。</span><span class="sxs-lookup"><span data-stu-id="cc214-145">A COM interface defines the expected behavior and responsibilities of a component, and it specifies a strongly-typed contract that provides a small set of related operations.</span></span> <span data-ttu-id="cc214-146">COM 元件之間的所有通訊都是透過介面進行，而元件所提供的所有服務都是透過其介面公開。</span><span class="sxs-lookup"><span data-stu-id="cc214-146">All communication among COM components occurs through interfaces, and all services offered by a component are exposed through its interface.</span></span> <span data-ttu-id="cc214-147">呼叫端只能存取介面成員函式。</span><span class="sxs-lookup"><span data-stu-id="cc214-147">A caller can access only the interface member functions.</span></span> <span data-ttu-id="cc214-148">除非在介面中公開，否則呼叫端無法使用內部狀態。</span><span class="sxs-lookup"><span data-stu-id="cc214-148">Internal state is unavailable to a caller unless it is exposed in the interface.</span></span>

<span data-ttu-id="cc214-149">介面是強型別。</span><span class="sxs-lookup"><span data-stu-id="cc214-149">Interfaces are strongly typed.</span></span> <span data-ttu-id="cc214-150">每個介面都有自己的唯一介面識別碼，名稱為 IID，以消除人們可讀取的名稱可能發生的衝突。</span><span class="sxs-lookup"><span data-stu-id="cc214-150">Every interface has its own unique interface identifier, named an IID, which eliminates collisions that could occur with human-readable names.</span></span> <span data-ttu-id="cc214-151">IID 是 (GUID) 的全域唯一識別碼，這與 Open Software Foundation (憑證) 分散式運算環境 () 中所定義的通用唯一識別碼 (UUID) 相同。</span><span class="sxs-lookup"><span data-stu-id="cc214-151">The IID is a globally unique identifier (GUID), which is the same as the Universally Unique ID (UUID) defined by the Open Software Foundation (OSF) Distributed Computing Environment (DCE).</span></span> <span data-ttu-id="cc214-152">當您建立新的介面時，您必須為該介面建立新的識別碼。</span><span class="sxs-lookup"><span data-stu-id="cc214-152">When you create a new interface, you must create a new identifier for that interface.</span></span> <span data-ttu-id="cc214-153">當呼叫端使用介面時，它必須使用唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="cc214-153">When a caller uses an interface, it must use the unique identifier.</span></span> <span data-ttu-id="cc214-154">這項明確的識別會藉由消除會導致運行時失敗的命名衝突，來改善穩定性。</span><span class="sxs-lookup"><span data-stu-id="cc214-154">This explicit identification improves robustness by eliminating naming conflicts that would result in run-time failure.</span></span>

<span data-ttu-id="cc214-155">當您定義新的介面時，可以使用 (IDL) 的介面定義語言來建立介面定義。</span><span class="sxs-lookup"><span data-stu-id="cc214-155">When you define a new interface, you can create an interface definition by using the interface definition language (IDL).</span></span> <span data-ttu-id="cc214-156">從這個介面定義中，Microsoft IDL 編譯器會產生使用介面的應用程式所使用的標頭檔，以及用來處理遠端程序呼叫的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="cc214-156">From this interface definition, the Microsoft IDL compiler generates header files for use by applications using the interface, and source code to handle remote procedure calls.</span></span> <span data-ttu-id="cc214-157">由 Microsoft 提供的 IDL 是以 DCE IDL 的簡單延伸模組為基礎，這是遠端程序呼叫的業界標準， (RPC) 為基礎的分散式運算。</span><span class="sxs-lookup"><span data-stu-id="cc214-157">The IDL supplied by Microsoft is based on simple extensions to DCE IDL, an industry standard for Remote Procedure Call (RPC)-based distributed computing.</span></span> <span data-ttu-id="cc214-158">IDL 是可方便使用介面設計師的工具，而且不是 COM 互通性的核心。</span><span class="sxs-lookup"><span data-stu-id="cc214-158">IDL is a tool for the convenience of the interface designer and is not central to COM interoperability.</span></span> <span data-ttu-id="cc214-159">使用 IDL 時，您不需要針對每個程式設計環境手動建立標頭檔。</span><span class="sxs-lookup"><span data-stu-id="cc214-159">With IDL, you do not need to create header files manually for each programming environment.</span></span> <span data-ttu-id="cc214-160">如需詳細資訊，請參閱 [定義 COM 介面](defining-com-interfaces.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-160">For more information, see [Defining COM Interfaces](defining-com-interfaces.md).</span></span>

<span data-ttu-id="cc214-161">COM 介面會謹慎使用繼承。</span><span class="sxs-lookup"><span data-stu-id="cc214-161">Inheritance is used sparingly in COM interfaces.</span></span> <span data-ttu-id="cc214-162">COM 僅支援介面繼承，以重複使用與基底介面相關聯的合約。</span><span class="sxs-lookup"><span data-stu-id="cc214-162">COM supports interface inheritance only to reuse a contract associated with a base interface.</span></span> <span data-ttu-id="cc214-163">COM 不支援選擇性繼承;因此，如果某個介面繼承自另一個介面，它會包含基底介面定義的所有函式。</span><span class="sxs-lookup"><span data-stu-id="cc214-163">COM does not support selective inheritance; therefore, if one interface inherits from another, it includes all of the functions that the base interface defines.</span></span> <span data-ttu-id="cc214-164">此外，介面只會使用單一繼承（而不是多個繼承）來取得基底介面的函式。</span><span class="sxs-lookup"><span data-stu-id="cc214-164">In addition, interfaces use only single inheritance, instead of multiple inheritance, to obtain functions from a base interface.</span></span>

## <a name="interface-implementation"></a><span data-ttu-id="cc214-165">介面執行</span><span class="sxs-lookup"><span data-stu-id="cc214-165">Interface implementation</span></span>

<span data-ttu-id="cc214-166">您無法自行建立 COM 介面的實例。</span><span class="sxs-lookup"><span data-stu-id="cc214-166">You cannot create an instance of a COM interface by itself.</span></span> <span data-ttu-id="cc214-167">相反地，您會建立可執行介面之類別的實例。</span><span class="sxs-lookup"><span data-stu-id="cc214-167">Instead, you create an instance of a class that implements the interface.</span></span> <span data-ttu-id="cc214-168">在 c + + 中，COM 介面會模型化為 *抽象基類*，這表示介面是僅包含單純虛擬成員函式的 c + + 類別。</span><span class="sxs-lookup"><span data-stu-id="cc214-168">In C++, a COM interface is modeled as an *abstract base class*, which means that the interface is a C++ class that contains only pure virtual member functions.</span></span> <span data-ttu-id="cc214-169">C + + 程式庫會藉由繼承一或多個介面的成員函式簽章、覆寫每個成員函式，以及為每個函式提供執行，來執行 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-169">A C++ library implements COM objects by inheriting the member function signatures from one or more interfaces, overriding each member function, and providing an implementation for each function.</span></span>

<span data-ttu-id="cc214-170">您可以使用任何支援函式指標概念的程式設計語言來執行 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-170">You can use any programming language that supports the concept of function pointers to implement a COM interface.</span></span> <span data-ttu-id="cc214-171">例如，在 C 中，介面是包含函式指標資料表指標的結構，介面中的每個方法都有一個指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-171">For example, in C, an interface is a structure containing a pointer to a table of function pointers, one for each method in the interface.</span></span>

<span data-ttu-id="cc214-172">當您執行介面時，您的類別必須為介面中的每個函式提供實作為。</span><span class="sxs-lookup"><span data-stu-id="cc214-172">When you implement an interface, your class must provide an implementation for every function in the interface.</span></span> <span data-ttu-id="cc214-173">如果類別沒有任何要在介面函式中執行的工作，則實作為單一 return 語句。</span><span class="sxs-lookup"><span data-stu-id="cc214-173">If the class has no work to do in an interface function, the implementation may be a single return statement.</span></span>

<span data-ttu-id="cc214-174">COM 類別的識別方式是使用唯一的128位類別識別碼 (CLSID) 將類別與檔案系統中的特定部署相關聯，而 Windows 是 DLL 或 EXE。</span><span class="sxs-lookup"><span data-stu-id="cc214-174">A COM class is identified by using a unique 128-bit Class ID (CLSID) that associates a class with a particular deployment in the file system, which for Windows is a DLL or EXE.</span></span> <span data-ttu-id="cc214-175">CLSID 是 GUID，這表示沒有其他類別具有相同的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="cc214-175">A CLSID is a GUID, which means that no other class has the same CLSID.</span></span> <span data-ttu-id="cc214-176">使用唯一類別識別碼可避免類別之間的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="cc214-176">The use of unique class identifiers prevents name collisions among classes.</span></span> <span data-ttu-id="cc214-177">例如，兩個不同的廠商可以撰寫名為 CStack 的類別，但是這兩個類別都有唯一的 CLSID，因此可以避免任何可能發生衝突的情況。</span><span class="sxs-lookup"><span data-stu-id="cc214-177">For example, two different vendors can write a class named CStack, but both classes have a unique CLSID, so any possibility of a collision is avoided.</span></span>

<span data-ttu-id="cc214-178">您可以使用 [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) 函式或使用 COM 撰寫工具（例如 Visual Studio）來取得新的 CLSID，此工具會在內部呼叫此函式。</span><span class="sxs-lookup"><span data-stu-id="cc214-178">You obtain a new CLSID by using the [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) function or by using a COM authoring tool, such as Visual Studio, that calls this function internally.</span></span>

## <a name="the-iunknown-interface"></a><span data-ttu-id="cc214-179">IUnknown 介面</span><span class="sxs-lookup"><span data-stu-id="cc214-179">The IUnknown Interface</span></span>

<span data-ttu-id="cc214-180">所有 COM 介面都會繼承自 [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-180">All COM interfaces inherit from the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="cc214-181">**IUnknown** 介面包含多型和實例存留期管理的基本 COM 作業。</span><span class="sxs-lookup"><span data-stu-id="cc214-181">The **IUnknown** interface contains the fundamental COM operations for polymorphism and instance lifetime management.</span></span> <span data-ttu-id="cc214-182">**IUnknown** 介面有三個成員函式，名為 [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))、 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)和 [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)。</span><span class="sxs-lookup"><span data-stu-id="cc214-182">The **IUnknown** interface has three member functions, named [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref), and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="cc214-183">所有 COM 物件都必須執行 **IUnknown** 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-183">All COM objects are required to implement the **IUnknown** interface.</span></span>

<span data-ttu-id="cc214-184">[**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))成員函式提供 COM 的多型。</span><span class="sxs-lookup"><span data-stu-id="cc214-184">The [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) member function provides polymorphism for COM.</span></span> <span data-ttu-id="cc214-185">呼叫 **QueryInterface** ，在執行時間判斷 COM 物件是否支援特定介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-185">Call **QueryInterface** to determine at run time whether a COM object supports a particular interface.</span></span> <span data-ttu-id="cc214-186">如果 COM 物件會執行所 `ppvObject` 要求的介面，則會傳回參數中的介面指標，否則會傳回 `NULL` 。</span><span class="sxs-lookup"><span data-stu-id="cc214-186">The COM object returns an interface pointer in the `ppvObject` parameter if it implements the requested interface, otherwise it returns `NULL`.</span></span> <span data-ttu-id="cc214-187">**QueryInterface** 成員函式可讓您在 COM 物件支援的所有介面之間進行導覽。</span><span class="sxs-lookup"><span data-stu-id="cc214-187">The **QueryInterface** member function enables navigation among all of the interfaces that a COM object supports.</span></span>

<span data-ttu-id="cc214-188">COM 物件實例的存留期是由其 *參考計數* 所控制。</span><span class="sxs-lookup"><span data-stu-id="cc214-188">The lifetime of a COM object instance is controlled by its *reference count*.</span></span> <span data-ttu-id="cc214-189">[**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown)成員函式 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)和 [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)控制計數。</span><span class="sxs-lookup"><span data-stu-id="cc214-189">The [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) member functions [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) control the count.</span></span> <span data-ttu-id="cc214-190">**AddRef** 會遞增計數， **並將** 計數遞減。</span><span class="sxs-lookup"><span data-stu-id="cc214-190">**AddRef** increments the count and **Release** decrements the count.</span></span> <span data-ttu-id="cc214-191">當參考計數到達零時， **釋放** 成員函式可能會釋放實例，因為沒有任何呼叫端正在使用它。</span><span class="sxs-lookup"><span data-stu-id="cc214-191">When the reference count reaches zero, the **Release** member function may free the instance, because no callers are using it.</span></span>

## <a name="the-clientserver-model"></a><span data-ttu-id="cc214-192">用戶端/伺服器模型</span><span class="sxs-lookup"><span data-stu-id="cc214-192">The Client/Server Model</span></span>

<span data-ttu-id="cc214-193">COM 類別會執行多個 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-193">A COM class implements a number of COM interfaces.</span></span> <span data-ttu-id="cc214-194">此實作為由呼叫端與 COM 類別的實例互動時所執行的二進位檔。</span><span class="sxs-lookup"><span data-stu-id="cc214-194">The implementation consists of binaries that run when a caller interacts with an instance of the COM class.</span></span> <span data-ttu-id="cc214-195">COM 可在不同的應用程式中使用類別，包括在不知道特定類別的情況下撰寫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="cc214-195">COM enables using a class in different applications, including applications written without knowledge of a particular class.</span></span> <span data-ttu-id="cc214-196">在 Windows 平臺上，類別會存在於動態連結的程式庫 (DLL) 或另一個應用程式 (EXE) 中。</span><span class="sxs-lookup"><span data-stu-id="cc214-196">On a Windows platform, classes exist either in a dynamic-linked library (DLL) or in another application (EXE).</span></span>

<span data-ttu-id="cc214-197">在其主機系統上，COM 會針對安裝在系統上的 COM 物件，維護所有 Clsid 的註冊資料庫。</span><span class="sxs-lookup"><span data-stu-id="cc214-197">On its host system, COM maintains a registration database of all the CLSIDs for the COM objects installed on the system.</span></span> <span data-ttu-id="cc214-198">註冊資料庫是每個 CLSID 和裝載對應類別之 DLL 或 EXE 的位置之間的對應。</span><span class="sxs-lookup"><span data-stu-id="cc214-198">The registration database is a mapping between each CLSID and the location of the DLL or EXE that houses the corresponding class.</span></span> <span data-ttu-id="cc214-199">每當呼叫端想要建立 COM 類別的實例時，COM 就會查詢這個資料庫。</span><span class="sxs-lookup"><span data-stu-id="cc214-199">COM queries this database whenever a caller wants to create an instance of a COM class.</span></span> <span data-ttu-id="cc214-200">呼叫端必須知道 CLSID 才能要求類別的新實例。</span><span class="sxs-lookup"><span data-stu-id="cc214-200">The caller needs to know only the CLSID to request a new instance of the class.</span></span>

<span data-ttu-id="cc214-201">COM 物件與其呼叫端之間的互動會模型化為用戶端/伺服器關聯性。</span><span class="sxs-lookup"><span data-stu-id="cc214-201">The interaction between a COM object and its callers is modeled as a client/server relationship.</span></span> <span data-ttu-id="cc214-202">用戶端是從系統要求 COM 物件的呼叫端，而伺服器是裝載提供服務給用戶端之 COM 物件的模組。</span><span class="sxs-lookup"><span data-stu-id="cc214-202">The client is the caller that requests a COM object from the system, and the server is the module that houses COM objects that provides services to clients.</span></span>

<span data-ttu-id="cc214-203">COM 用戶端是任何將 CLSID 傳遞給系統以要求 COM 物件實例的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="cc214-203">A COM client is any caller that passes a CLSID to the system to request an instance of a COM object.</span></span> <span data-ttu-id="cc214-204">建立實例的最簡單方式是呼叫 COM 函式 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)。</span><span class="sxs-lookup"><span data-stu-id="cc214-204">The simplest way to create an instance is to call the COM function, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

<span data-ttu-id="cc214-205">[**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)函式會建立指定之 CLSID 的一個實例，並傳回用戶端所要求之型別的介面指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-205">The [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function creates one instance of the specified CLSID and returns an interface pointer of the type requested by the client.</span></span> <span data-ttu-id="cc214-206">用戶端會負責管理實例的存留期，方法是在用戶端完成使用它時呼叫它的 [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-206">The client is responsible for managing the lifetime of the instance by calling its [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) function when the client has finished using it.</span></span> <span data-ttu-id="cc214-207">若要根據單一 CLSID 建立多個物件，請呼叫 [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) 函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-207">To create multiple objects based on a single CLSID, call the [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) function.</span></span> <span data-ttu-id="cc214-208">若要連接到已經建立並執行的物件，請呼叫 [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) 函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-208">To connect to an object that is already created and running, call the [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) function.</span></span>

<span data-ttu-id="cc214-209">COM 伺服器提供系統的 COM 執行。</span><span class="sxs-lookup"><span data-stu-id="cc214-209">A COM server provides a COM implementation to the system.</span></span> <span data-ttu-id="cc214-210">伺服器會將 CLSID 與 COM 類別產生關聯、裝載類別的實作為來建立類別的實例，並提供用於卸載伺服器的類別 factory。</span><span class="sxs-lookup"><span data-stu-id="cc214-210">A server associates a CLSID with a COM class, houses the implementation of the class, implements a class factory for creating instances of the class, and provides for unloading the server.</span></span>

> [!Note]  
> <span data-ttu-id="cc214-211">COM 伺服器與提供給系統的 COM 物件不同。</span><span class="sxs-lookup"><span data-stu-id="cc214-211">A COM server is not the same as the COM object that it provides to the system.</span></span>

 

<span data-ttu-id="cc214-212">若要啟用 COM 物件的建立，COM 伺服器必須提供 [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) 介面的實作為。</span><span class="sxs-lookup"><span data-stu-id="cc214-212">To enable creating a COM object, a COM server must provide an implementation of the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface.</span></span> <span data-ttu-id="cc214-213">用戶端可以呼叫 [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) 方法來要求 COM 物件的新實例，但這類要求通常會封裝在 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) 函數中。</span><span class="sxs-lookup"><span data-stu-id="cc214-213">Clients can call the [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) method to request a new instance of a COM object, but usually such requests are encapsulated in the [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function.</span></span>

<span data-ttu-id="cc214-214">您可以將 COM 伺服器部署為在執行時間載入至用戶端進程的共用程式庫 (Windows 平臺上的 DLL) 或作為 Windows 平臺上的可執行模組 (EXE) 。</span><span class="sxs-lookup"><span data-stu-id="cc214-214">You can deploy a COM server either as a shared library that is loaded into the client's process at run time (DLL on Windows platforms) or as an executable module (EXE on Windows platforms).</span></span> <span data-ttu-id="cc214-215">如需詳細資訊，請參閱 [註冊 COM 應用程式](registering-com-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-215">For more information, see [Registering COM Applications](registering-com-applications.md).</span></span>

## <a name="service-control-manager"></a><span data-ttu-id="cc214-216">服務控制管理員</span><span class="sxs-lookup"><span data-stu-id="cc214-216">Service Control Manager</span></span>

<span data-ttu-id="cc214-217">服務控制管理員 (SCM) 處理 COM 物件實例的用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="cc214-217">The Service Control Manager (SCM) handles the client request for an instance of a COM object.</span></span> <span data-ttu-id="cc214-218">下列清單顯示事件的順序：</span><span class="sxs-lookup"><span data-stu-id="cc214-218">The following list shows the sequence of events:</span></span>

-   <span data-ttu-id="cc214-219">用戶端會藉由呼叫函式（例如 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) 和 com 物件的 CLSID），向 Com 程式庫要求 com 物件的介面指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-219">A client requests an interface pointer to a COM object from the COM Library by calling a function such as [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) with the CLSID of the COM object.</span></span>
-   <span data-ttu-id="cc214-220">COM 程式庫會查詢 SCM，以找出對應于所要求 CLSID 的伺服器。</span><span class="sxs-lookup"><span data-stu-id="cc214-220">The COM Library queries the SCM to find the server that corresponds with the requested CLSID.</span></span>
-   <span data-ttu-id="cc214-221">SCM 會尋找伺服器，並要求從伺服器所提供的 class factory 建立 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-221">The SCM locates the server and requests the creation of the COM object from the class factory that is provided by the server.</span></span>
-   <span data-ttu-id="cc214-222">如果成功，COM 程式庫會將介面指標傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-222">If successful, the COM Library returns an interface pointer to the client.</span></span>

<span data-ttu-id="cc214-223">在 COM 系統將伺服器物件連接至用戶端之後，用戶端和物件會直接進行通訊。</span><span class="sxs-lookup"><span data-stu-id="cc214-223">After the COM system connects a server object to a client, the client and object communicate directly.</span></span> <span data-ttu-id="cc214-224">透過中繼執行時間呼叫不會增加額外負荷。</span><span class="sxs-lookup"><span data-stu-id="cc214-224">There is no added overhead from calling through an intermediary run time.</span></span>

<span data-ttu-id="cc214-225">當您向主機系統註冊 COM 伺服器時，可以指定不同的伺服器啟動方式。</span><span class="sxs-lookup"><span data-stu-id="cc214-225">When you register a COM server with the host system, you can specify different ways for the server to be activated.</span></span> <span data-ttu-id="cc214-226">下列清單顯示 SCM 可以啟用 COM 伺服器的三種方式：</span><span class="sxs-lookup"><span data-stu-id="cc214-226">The following list shows the three ways that the SCM can activate a COM server:</span></span>

-   <span data-ttu-id="cc214-227">同進程： SCM 會傳回包含物件服務器執行之 DLL 的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="cc214-227">In-process: The SCM returns the file path of the DLL that contains the object server implementation.</span></span> <span data-ttu-id="cc214-228">COM 程式庫會載入 DLL，並針對其 class factory 介面指標進行查詢。</span><span class="sxs-lookup"><span data-stu-id="cc214-228">The COM Library loads the DLL and queries it for its class factory interface pointer.</span></span>
-   <span data-ttu-id="cc214-229">Local： SCM 啟動可在啟動時註冊 class factory 的本機可執行檔，且其介面指標可供系統和用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="cc214-229">Local: The SCM starts the local executable which registers a class factory on startup, and its interface pointer is available to the system and clients.</span></span>
-   <span data-ttu-id="cc214-230">Remote：本機 SCM 從遠端電腦上執行的 SCM 取得 class factory 介面指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-230">Remote: The local SCM acquires a class factory interface pointer from the SCM that is running on a remote computer.</span></span>

<span data-ttu-id="cc214-231">當用戶端要求 COM 物件時，COM 程式庫會聯繫本機主機上的 SCM。</span><span class="sxs-lookup"><span data-stu-id="cc214-231">When a client requests a COM object, the COM Library contacts the SCM on the local host.</span></span> <span data-ttu-id="cc214-232">SCM 會找出適當的 COM 伺服器（可能是本機或遠端），而伺服器會將介面指標傳回伺服器的 class factory。</span><span class="sxs-lookup"><span data-stu-id="cc214-232">The SCM locates the appropriate COM server, which may be local or remote, and the server returns an interface pointer to the server's class factory.</span></span> <span data-ttu-id="cc214-233">當 class factory 可供使用時，COM 程式庫或用戶端可以使用 class factory 來建立要求的物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-233">When the class factory is available, the COM Library or the client can use the class factory to create the requested object.</span></span> <span data-ttu-id="cc214-234">如需詳細資訊，請參閱 [執行 IClassFactory](implementing-iclassfactory.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-234">For more information, see [Implementing IClassFactory](implementing-iclassfactory.md).</span></span>

## <a name="reusability"></a><span data-ttu-id="cc214-235">重複使用性</span><span class="sxs-lookup"><span data-stu-id="cc214-235">Reusability</span></span>

<span data-ttu-id="cc214-236">COM 支援 *黑箱* 重複使用性，這表示可重複使用元件的執行詳細資料不會公開給用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-236">COM supports *black-box reusability*, which means that the implementation details of a reusable component are not exposed to clients.</span></span> <span data-ttu-id="cc214-237">為了達到黑箱重複使用性，COM 支援兩種機制，其中一個物件可以重複使用另一個物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-237">To achieve black-box reusability, COM supports two mechanisms through which one object may reuse another.</span></span> <span data-ttu-id="cc214-238">這兩種重複使用 *形式稱為內含專案和\*\*匯總*。</span><span class="sxs-lookup"><span data-stu-id="cc214-238">The two forms of reuse are named *containment* and *aggregation*.</span></span> <span data-ttu-id="cc214-239">依照慣例，所要使用的物件會命名為 *內建物件*，而使用內建物件的物件會命名為 *外部物件*。</span><span class="sxs-lookup"><span data-stu-id="cc214-239">By convention, the object being reused is named the *inner object*, and the object that is making use of the inner object is named the *outer object*.</span></span>

<span data-ttu-id="cc214-240">在內含專案中，外部物件的行為是內建物件的用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-240">In containment, the outer object behaves as a client of the inner object.</span></span> <span data-ttu-id="cc214-241">外部物件是內建物件的邏輯容器，當外部物件使用內建物件的服務時，外部物件會將執行委派給內建物件的介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-241">The outer object is a logical container for the inner object, and when the outer object uses the services of the inner object, the outer object delegates implementation to the inner object's interfaces.</span></span> <span data-ttu-id="cc214-242">這表示外部物件會根據內建物件的服務來執行。</span><span class="sxs-lookup"><span data-stu-id="cc214-242">This means that the outer object is implemented in terms of the inner object's services.</span></span> <span data-ttu-id="cc214-243">外部物件可能不支援與內建物件相同的介面，而且外部物件可能會使用內建物件的介面，以協助在外部物件上執行不同介面的元件。</span><span class="sxs-lookup"><span data-stu-id="cc214-243">The outer object may not support the same interfaces as the inner object, and the outer object may use an inner object's interface to help with implementing parts of a different interface on the outer object.</span></span>

<span data-ttu-id="cc214-244">在匯總中，外部物件會公開內建物件的介面，就如同它們是在外部物件上執行一樣。</span><span class="sxs-lookup"><span data-stu-id="cc214-244">In aggregation, the outer object exposes interfaces from the inner object as if they were implemented on the outer object.</span></span> <span data-ttu-id="cc214-245">當外部物件一律會將其中一個介面的每個呼叫委派給內建物件的相同介面時，這會很有用。</span><span class="sxs-lookup"><span data-stu-id="cc214-245">This is useful when the outer object would always delegate every call on one of its interfaces to the same interface of the inner object.</span></span> <span data-ttu-id="cc214-246">匯總是方便的，可讓外部物件避免額外的執行負擔。</span><span class="sxs-lookup"><span data-stu-id="cc214-246">Aggregation is a convenience that enables the outer object to avoid extra implementation overhead.</span></span>

<span data-ttu-id="cc214-247">如需詳細資訊，請參閱 [重複使用物件](reusing-objects.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-247">For more information, see [Reusing Objects](reusing-objects.md).</span></span>

## <a name="storage-and-stream-objects"></a><span data-ttu-id="cc214-248">儲存體和資料流程物件</span><span class="sxs-lookup"><span data-stu-id="cc214-248">Storage and Stream Objects</span></span>

<span data-ttu-id="cc214-249">COM 物件會使用 *結構化儲存區* 將狀態儲存至檔案，這是一種持續性儲存格式，可讓您使用檔案系統語義來流覽檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="cc214-249">COM objects save state to a file by using *structured storage*, which is a form of persistent storage that enables navigation of a file's contents by using file system semantics.</span></span> <span data-ttu-id="cc214-250">以這種方式來處理檔案的內容，可以在進程之間提供累加式存取、交易和共用等功能。</span><span class="sxs-lookup"><span data-stu-id="cc214-250">Treating a file's contents in this manner enables features such as incremental access, transactions, and sharing among processes.</span></span>

<span data-ttu-id="cc214-251">COM 持續性儲存體規格提供兩種類型的儲存體元素：儲存物件和資料流程物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-251">The COM persistent storage specification provides for two types of storage elements: storage objects and stream objects.</span></span> <span data-ttu-id="cc214-252">這些物件是由 COM 程式庫所執行，而且使用者應用程式很少會執行這些儲存元素。</span><span class="sxs-lookup"><span data-stu-id="cc214-252">These objects are implemented by the COM Library, and user applications rarely implement these storage elements.</span></span> <span data-ttu-id="cc214-253">儲存體物件會執行 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 介面，而資料流程物件則會執行 [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) 介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-253">Storage objects implement the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, and stream objects implement the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface.</span></span>

<span data-ttu-id="cc214-254">資料流程物件包含資料，而且在概念上類似于檔案系統中的單一檔案。</span><span class="sxs-lookup"><span data-stu-id="cc214-254">A stream object contains data and is conceptually similar to a single file in a file system.</span></span> <span data-ttu-id="cc214-255">每個串流都具有存取權限和單一搜尋指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-255">Each stream has access rights and a single seek pointer.</span></span> <span data-ttu-id="cc214-256">透過 [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) 介面，您可以讀取、寫入、搜尋和執行資料流程基礎資料的其他作業。</span><span class="sxs-lookup"><span data-stu-id="cc214-256">Through the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface, you can read, write, seek, and perform other operations on the stream's underlying data.</span></span> <span data-ttu-id="cc214-257">資料流程的命名方式是使用文字字串。</span><span class="sxs-lookup"><span data-stu-id="cc214-257">A stream is named by using a text string.</span></span> <span data-ttu-id="cc214-258">它可以包含任何內部結構，因為這是一般的位元組資料流程。</span><span class="sxs-lookup"><span data-stu-id="cc214-258">It can contain any internal structure, because it is a flat stream of bytes.</span></span> <span data-ttu-id="cc214-259">此外， **IStream** 介面中的函式類似于標準檔案處理型函式，例如 ANSI C 執行時間程式庫中的函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-259">In addition, the functions in the **IStream** interface are similar to standard file-handle based functions, such as those in the ANSI C run-time library.</span></span>

<span data-ttu-id="cc214-260">儲存物件在概念上類似于檔案系統中的目錄。</span><span class="sxs-lookup"><span data-stu-id="cc214-260">A storage object is conceptually similar to a directory in a file system.</span></span> <span data-ttu-id="cc214-261">每個儲存體可包含任意數目的子儲存體物件和任意數量的資料流程。</span><span class="sxs-lookup"><span data-stu-id="cc214-261">Each storage can contain any number of sub-storage objects and any number of streams.</span></span> <span data-ttu-id="cc214-262">每個儲存體都有自己的存取權限。</span><span class="sxs-lookup"><span data-stu-id="cc214-262">Each storage has its own access rights.</span></span> <span data-ttu-id="cc214-263">透過 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 介面，您可以執行像是列舉、移動、複製、重新命名、建立及刪除元素等作業。</span><span class="sxs-lookup"><span data-stu-id="cc214-263">Through the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, you can perform operations such as enumerating, moving, copying, renaming, creating, and deleting elements.</span></span> <span data-ttu-id="cc214-264">儲存物件不會儲存應用程式定義的資料，但會以隱含的方式儲存專案名稱， (儲存和它所包含的資料流程) 。</span><span class="sxs-lookup"><span data-stu-id="cc214-264">A storage object does not store application-defined data, but it stores implicitly the names of the elements (storages and streams) that it contains.</span></span>

<span data-ttu-id="cc214-265">當程式是根據主機平臺上的 COM 規格來執行時，可以在進程間共用儲存和資料流程物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-265">Storage and stream objects are sharable among processes when they are implemented according to the COM specification on a host platform.</span></span> <span data-ttu-id="cc214-266">這可讓執行同進程或跨進程的物件擁有相同的累加式存取權來存取其檔案儲存體。</span><span class="sxs-lookup"><span data-stu-id="cc214-266">This enables objects that are running in-process or out-of-process to have equal incremental access to their file storage.</span></span> <span data-ttu-id="cc214-267">由於 COM 會個別載入至每個進程，因此它會使用作業系統支援的共用記憶體機制，來傳達開啟專案的狀態及其處理常式之間的存取模式。</span><span class="sxs-lookup"><span data-stu-id="cc214-267">Because COM is loaded into each process separately, it uses operating-system supported shared memory mechanisms to communicate the state of opened elements and their access modes between processes.</span></span>

<span data-ttu-id="cc214-268">結構化檔案中的每個儲存和資料流程物件都有一個名稱來識別它。</span><span class="sxs-lookup"><span data-stu-id="cc214-268">Every storage and stream object in a structured file has a name to identify it.</span></span> <span data-ttu-id="cc214-269">名稱是遵循特定慣例的字串。</span><span class="sxs-lookup"><span data-stu-id="cc214-269">The name is a string that follows a particular convention.</span></span> <span data-ttu-id="cc214-270">如需詳細資訊，請參閱 [儲存物件命名慣例](/windows/desktop/Stg/storage-object-naming-conventions)。</span><span class="sxs-lookup"><span data-stu-id="cc214-270">For more information, see [Storage Object Naming Conventions](/windows/desktop/Stg/storage-object-naming-conventions).</span></span> <span data-ttu-id="cc214-271">名稱會傳遞至 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 函式，以指定要在儲存體中操作的元素。</span><span class="sxs-lookup"><span data-stu-id="cc214-271">The name is passed to [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) functions to specify which element in the storage to operate on.</span></span> <span data-ttu-id="cc214-272">根儲存物件的名稱與基礎檔案系統中的檔案名相同，而且這些名稱必須遵循檔案系統的慣例和限制。</span><span class="sxs-lookup"><span data-stu-id="cc214-272">Names of root storage objects are the same as file names in the underlying file system, and these names must follow the file system's conventions and restrictions.</span></span> <span data-ttu-id="cc214-273">傳遞給儲存相關函式的字串，這些函式會將名稱檔案傳遞至檔案系統，而不需要解讀或變更。</span><span class="sxs-lookup"><span data-stu-id="cc214-273">Strings passed to storage-related functions which name files are passed through to the file system without interpretation or changes.</span></span>

<span data-ttu-id="cc214-274">包含在儲存物件內的專案名稱，是由有問題的特定儲存物件的實作為管理。</span><span class="sxs-lookup"><span data-stu-id="cc214-274">Names of elements that are contained within storage objects are managed by the implementation of the particular storage object in question.</span></span> <span data-ttu-id="cc214-275">所有儲存體物件的執行都必須支援長度為32個字元的專案名稱，而某些執行可能會支援較長的名稱。</span><span class="sxs-lookup"><span data-stu-id="cc214-275">All implementations of storage objects must support element names that are 32 characters in length, and some implementations may support longer names.</span></span> <span data-ttu-id="cc214-276">名稱會儲存並保留大小寫，但會比較為不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="cc214-276">Names are stored with case preserved, but they are compared as case-insensitive.</span></span> <span data-ttu-id="cc214-277">定義儲存元素名稱的應用程式必須選擇可在任一情況下運作的名稱。</span><span class="sxs-lookup"><span data-stu-id="cc214-277">Applications that define storage element names must choose names that work in either situation.</span></span>

<span data-ttu-id="cc214-278">您可以使用 COM 所執行的函式和介面，來存取結構化儲存體檔案中的每個元素。</span><span class="sxs-lookup"><span data-stu-id="cc214-278">You access every element in a structured storage file by using functions and interfaces that are implemented by COM.</span></span> <span data-ttu-id="cc214-279">這表示其他應用程式可以流覽檔案，方法是以提供類似目錄服務的 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 介面函式進行流覽。</span><span class="sxs-lookup"><span data-stu-id="cc214-279">This means that other applications can browse the file by navigating with the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface functions that provide directory-like services.</span></span> <span data-ttu-id="cc214-280">此外，其他應用程式也可以使用檔案的資料，而不需要執行寫入檔案的應用程式。</span><span class="sxs-lookup"><span data-stu-id="cc214-280">Also, other applications can use the file's data, without having to run the application that wrote the file.</span></span> <span data-ttu-id="cc214-281">當 COM 應用程式存取另一個應用程式的結構化儲存體檔案時，會套用標準的 Windows 存取權限，而且應用程式必須有足夠的許可權。</span><span class="sxs-lookup"><span data-stu-id="cc214-281">When a COM application accesses the structured storage files of another application, standard Windows access rights apply, and the application must have sufficient privileges.</span></span>

<span data-ttu-id="cc214-282">COM 物件可以讀取和寫入持續性儲存區。</span><span class="sxs-lookup"><span data-stu-id="cc214-282">A COM object can read and write itself to persistent storage.</span></span> <span data-ttu-id="cc214-283">用戶端會根據作業的內容，查詢 COM 物件的其中一個持續性相關的介面。</span><span class="sxs-lookup"><span data-stu-id="cc214-283">A client queries for one of the persistence-related interfaces on the COM object, depending on the context of the operation.</span></span> <span data-ttu-id="cc214-284">COM 物件可以執行下列介面的任何組合：</span><span class="sxs-lookup"><span data-stu-id="cc214-284">COM objects can implement any combination of the following interfaces:</span></span>

-   <span data-ttu-id="cc214-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage)： COM 物件會讀取其持續性狀態，並將其寫入儲存物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): The COM object reads and writes its persistent state to a storage object.</span></span> <span data-ttu-id="cc214-286">用戶端會透過此介面提供具有 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 指標的物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-286">The client provides the object with an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) pointer through this interface.</span></span> <span data-ttu-id="cc214-287">這是唯一的持續性介面，其中包含累加式存取的語法。</span><span class="sxs-lookup"><span data-stu-id="cc214-287">This is the only persistence interface that includes semantics for incremental access.</span></span>
-   <span data-ttu-id="cc214-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream)： COM 物件會讀取其持續性狀態，並將其寫入資料流程物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): The COM object reads and writes its persistent state to a stream object.</span></span> <span data-ttu-id="cc214-289">用戶端會透過這個介面提供具有 [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) 指標的物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-289">The client provides the object with an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) pointer through this interface.</span></span>
-   <span data-ttu-id="cc214-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile)： COM 物件會將其持續性狀態直接讀取並寫入基礎系統上的檔案中。</span><span class="sxs-lookup"><span data-stu-id="cc214-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): The COM object reads and writes its persistent state directly to a file on the underlying system.</span></span> <span data-ttu-id="cc214-291">此介面不牽涉到 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 或 [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) ，除非基礎檔案是透過這些介面存取，但 **IPersistFile** 介面沒有適用于儲存體和資料流程的語法。</span><span class="sxs-lookup"><span data-stu-id="cc214-291">This interface does not involve [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) unless the underlying file is accessed through these interfaces, but the **IPersistFile** interface has no semantics for storages and streams.</span></span> <span data-ttu-id="cc214-292">用戶端會提供具有檔案名的物件，並呼叫 [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) 或 [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) 函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-292">The client provides the object with a file name and calls the [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) or [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) functions.</span></span>

## <a name="data-transfer"></a><span data-ttu-id="cc214-293">資料轉送</span><span class="sxs-lookup"><span data-stu-id="cc214-293">Data Transfer</span></span>

<span data-ttu-id="cc214-294">結構化儲存體提供 COM 物件與進程之間的資料交換基礎，名為「 *制式資料傳輸*」。</span><span class="sxs-lookup"><span data-stu-id="cc214-294">Structured storage provides the basis for data exchange between COM objects and processes, which is named *uniform data transfer*.</span></span> <span data-ttu-id="cc214-295">在 OLE 2 中執行 COM 之前，Windows 上的資料傳輸是由 *傳輸通訊協定*（例如剪貼簿和拖放通訊協定）所指定。</span><span class="sxs-lookup"><span data-stu-id="cc214-295">Before COM was implemented in OLE 2, data transfer on Windows was specified by *transfer protocols*, such as the clipboard and drag-drop protocols.</span></span> <span data-ttu-id="cc214-296">每個傳輸通訊協定都有自己的一組函式，這些函式會將通訊協定系結至查詢，而且需要特定程式碼來處理每個不同的通訊協定和交換程式。</span><span class="sxs-lookup"><span data-stu-id="cc214-296">Each transfer protocol had its own set of functions that bound the protocol to the query, and specific code was required to handle each different protocol and exchange procedure.</span></span> <span data-ttu-id="cc214-297">制式資料傳輸代表使用 [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) 介面的所有資料傳輸，可將一般資料交換作業與傳輸通訊協定分隔開來。</span><span class="sxs-lookup"><span data-stu-id="cc214-297">Uniform data transfer represents all data transfers by using the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface, which separates common data exchange operations from the transfer protocol.</span></span>

<span data-ttu-id="cc214-298">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)介面會針對資料、查詢和列舉，以及當物件中的資料變更時偵測到的通知，封裝標準的 get 和 set 作業。</span><span class="sxs-lookup"><span data-stu-id="cc214-298">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface encapsulates the standard get and set operations on data, queries and enumerations, and notifications that detect when data changes in an object.</span></span> <span data-ttu-id="cc214-299">制式資料傳輸可提供豐富的資料格式描述，以及使用不同的儲存體媒體進行資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="cc214-299">Uniform data transfer enables rich descriptions of data formats, as well as the use of different storage media for the data transfer.</span></span>

<span data-ttu-id="cc214-300">在統一的資料傳輸期間，所有通訊協定都會交換指向 [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="cc214-300">During uniform data transfer, all protocols exchange a pointer to an [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="cc214-301">伺服器是資料的來源，並會執行一個資料物件，此物件可在任何資料交換通訊協定中使用。</span><span class="sxs-lookup"><span data-stu-id="cc214-301">The server is the source of the data and implements one data object, which is usable in any data exchange protocol.</span></span> <span data-ttu-id="cc214-302">用戶端會在收到來自任何通訊協定的 **IDataObject** 指標時取用資料，並要求資料物件中的資料。</span><span class="sxs-lookup"><span data-stu-id="cc214-302">The client consumes the data and requests data from a data object when it receives an **IDataObject** pointer from any protocol.</span></span> <span data-ttu-id="cc214-303">指標交換之後，雙方都會透過 **IDataObject** 介面，以一致的方式處理資料交換。</span><span class="sxs-lookup"><span data-stu-id="cc214-303">After the pointer exchange has occurred, both sides handle data exchange in a uniform fashion, through the **IDataObject** interface.</span></span>

<span data-ttu-id="cc214-304">COM 會定義兩個資料結構，以啟用統一的資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="cc214-304">COM defines two data structures that enable uniform data transfer.</span></span> <span data-ttu-id="cc214-305">[**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構代表通用的剪貼簿格式，而 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構則代表傳送媒體作為記憶體控制碼。</span><span class="sxs-lookup"><span data-stu-id="cc214-305">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure represents a generalized clipboard format, and the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure represents the transfer medium as a memory handle.</span></span>

<span data-ttu-id="cc214-306">用戶端會建立 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構來指出它從資料來源要求的資料類型，而且資料來源會使用它來描述它所提供的格式。</span><span class="sxs-lookup"><span data-stu-id="cc214-306">The client creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to indicate the type of data that it requests from a data source, and it is used by the data source to describe what formats it provides.</span></span> <span data-ttu-id="cc214-307">用戶端會要求其 [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) 介面，以查詢資料來源的可用格式。</span><span class="sxs-lookup"><span data-stu-id="cc214-307">The client queries a data source for its available formats by requesting its [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="cc214-308">如需詳細資訊，請參閱 [FORMATETC 結構](the-formatetc-structure.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-308">For more information, see [The FORMATETC Structure](the-formatetc-structure.md).</span></span>

<span data-ttu-id="cc214-309">用戶端會建立 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構，並將它傳遞至「未處理 [**」方法，**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) 而資料物件會傳回所提供 **STGMEDIUM** 結構中的資料。</span><span class="sxs-lookup"><span data-stu-id="cc214-309">The client creates a [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure and passes it to the [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) method, and the data object returns the data in the provided **STGMEDIUM** structure.</span></span>

<span data-ttu-id="cc214-310">[**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構可讓用戶端和資料來源選擇最有效率的 exchange 媒體。</span><span class="sxs-lookup"><span data-stu-id="cc214-310">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure enables both clients and data sources to choose the most efficient exchange medium.</span></span> <span data-ttu-id="cc214-311">例如，如果要交換的資料很大，資料來源可以將磁片型媒體表示為其慣用格式，而不是主儲存體。</span><span class="sxs-lookup"><span data-stu-id="cc214-311">For example, if the data to be exchanged is very large, the data source can indicate a disk-based medium as its preferred format, instead of main memory.</span></span> <span data-ttu-id="cc214-312">這種彈性可提供有效率的資料交換，就像傳遞指標給 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 或 [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream)一樣快。</span><span class="sxs-lookup"><span data-stu-id="cc214-312">This flexibility enables efficient data exchanges that can be as fast as passing a pointer to an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span></span> <span data-ttu-id="cc214-313">如需詳細資訊，請參閱 [STGMEDIUM 結構](the-stgmedium-structure.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-313">For more information, see [The STGMEDIUM Structure](the-stgmedium-structure.md).</span></span>

<span data-ttu-id="cc214-314">資料來源的用戶端可能需要在資料變更時發出通知。</span><span class="sxs-lookup"><span data-stu-id="cc214-314">A client of a data source may require notification when the data changes.</span></span> <span data-ttu-id="cc214-315">COM 會使用實 [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink)介面的 *建議接收* 物件來處理資料變更通知。</span><span class="sxs-lookup"><span data-stu-id="cc214-315">COM handles data-change notifications by using an *advise sink* object, which implements the [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) interface.</span></span> <span data-ttu-id="cc214-316">建議接收物件和 **IAdviseSink** 介面是由用戶端所執行，該用戶端會將 **IAdviseSink** 指標傳遞至資料來源。</span><span class="sxs-lookup"><span data-stu-id="cc214-316">The advise sink object and the **IAdviseSink** interface are implemented by the client, which passes an **IAdviseSink** pointer to the data source.</span></span> <span data-ttu-id="cc214-317">當資料來源偵測到基礎資料變更時，它會呼叫 **IAdviseSink** 方法來通知用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-317">When the data source detects a change in the underlying data, it calls an **IAdviseSink** method to notify the client.</span></span> <span data-ttu-id="cc214-318">如需詳細資訊，請參閱 [資料通知](data-notification.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-318">For more information, see [Data Notification](data-notification.md).</span></span>

## <a name="remoting"></a><span data-ttu-id="cc214-319">遠端</span><span class="sxs-lookup"><span data-stu-id="cc214-319">Remoting</span></span>

<span data-ttu-id="cc214-320">COM 可啟用遠端和分散式運算。</span><span class="sxs-lookup"><span data-stu-id="cc214-320">COM enables remote and distributed computation.</span></span> <span data-ttu-id="cc214-321">*介面遠端* 功能可讓成員函式將介面指標傳回至不同進程或不同主機電腦上的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="cc214-321">*Interface remoting* enables a member function to return an interface pointer to a COM object that is in a different process or on a different host computer.</span></span> <span data-ttu-id="cc214-322">執行介面遠端的基礎結構對於用戶端和物件服務器都是透明的。</span><span class="sxs-lookup"><span data-stu-id="cc214-322">The infrastructure that performs the interface remoting is transparent to both the client and the object server.</span></span> <span data-ttu-id="cc214-323">用戶端和伺服器都不需要另一個部署詳細資料，也能透過遠端介面進行通訊。</span><span class="sxs-lookup"><span data-stu-id="cc214-323">Neither the client nor the server need one another's deployment details to communicate through a remoted interface.</span></span> <span data-ttu-id="cc214-324">用戶端會呼叫相同介面上的成員函式，以便與本機主機或遠端電腦上同進程、跨進程的 COM 物件進行通訊。</span><span class="sxs-lookup"><span data-stu-id="cc214-324">A client calls member functions on the same interface to communicate with a COM object that is in-process, out-of-process on the local host, or on a remote computer.</span></span> <span data-ttu-id="cc214-325">相同介面上的本機和遠端呼叫與用戶端不區分。</span><span class="sxs-lookup"><span data-stu-id="cc214-325">Local and remote calls on the same interface are indistinguishable to the client.</span></span>

<span data-ttu-id="cc214-326">若要與 COM 物件進行通訊，用戶端一律會呼叫同進程執行。</span><span class="sxs-lookup"><span data-stu-id="cc214-326">To communicate with a COM object, a client always calls an in-process implementation.</span></span> <span data-ttu-id="cc214-327">如果 COM 物件是同進程，則呼叫是 direct。</span><span class="sxs-lookup"><span data-stu-id="cc214-327">If the COM object is in-process, the call is direct.</span></span> <span data-ttu-id="cc214-328">如果 COM 物件是跨進程或遠端，COM 會提供 *proxy* 執行，使用遠端程序呼叫 (RPC) 通訊協定來轉送物件的呼叫。</span><span class="sxs-lookup"><span data-stu-id="cc214-328">If the COM object is out-of-process or remote, COM provides a *proxy* implementation that forwards the call to the object by using the Remote Procedure Call (RPC) protocol.</span></span>

<span data-ttu-id="cc214-329">COM 物件一律會透過同進程執行，從用戶端接收呼叫。</span><span class="sxs-lookup"><span data-stu-id="cc214-329">A COM object always receives calls from a client through an in-process implementation.</span></span> <span data-ttu-id="cc214-330">如果呼叫端在同進程中，則呼叫是 direct。</span><span class="sxs-lookup"><span data-stu-id="cc214-330">If the caller is in-process, the call is direct.</span></span> <span data-ttu-id="cc214-331">如果呼叫端在進程外或遠端，COM 會提供 *存根* 執行，以接收用戶端進程中 proxy 的遠端程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="cc214-331">If the caller is out-of-process or remote, COM provides a *stub* implementation that receives the remote procedure call from the proxy in the client process.</span></span>

<span data-ttu-id="cc214-332">*封送處理* 是封裝呼叫堆疊以從 proxy 傳輸到 stub 的程式。</span><span class="sxs-lookup"><span data-stu-id="cc214-332">*Marshaling* is the procedure for packaging the call stack for transmission from proxy to stub.</span></span> <span data-ttu-id="cc214-333">*封送* 是在接收端發生的解除封裝。</span><span class="sxs-lookup"><span data-stu-id="cc214-333">*Unmarshaling* is the unpackaging that occurs at the receiving end.</span></span> <span data-ttu-id="cc214-334">傳回值會從存根封送處理並取消封送處理至 proxy。</span><span class="sxs-lookup"><span data-stu-id="cc214-334">Return values are marshaled and unmarshaled from the stub to the proxy.</span></span> <span data-ttu-id="cc214-335">這種通訊也稱為透過 *網路* 傳送通話。</span><span class="sxs-lookup"><span data-stu-id="cc214-335">This kind of communication is also referred to as sending a call *over the wire*.</span></span>

<span data-ttu-id="cc214-336">每個不同的資料類型都有封送處理的規則。</span><span class="sxs-lookup"><span data-stu-id="cc214-336">Each different data type has rules for marshaling.</span></span> <span data-ttu-id="cc214-337">介面指標也有封送處理通訊協定，它封裝在 [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) 函式中。</span><span class="sxs-lookup"><span data-stu-id="cc214-337">Interface pointers also have a marshaling protocol, which is encapsulated in the [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) function.</span></span> <span data-ttu-id="cc214-338">在大部分的情況下， *標準介面封送處理*（由系統提供）已足夠，但 COM 物件可選擇性地執行 *自訂介面封送處理* ，以控制如何建立遠端物件 proxy。</span><span class="sxs-lookup"><span data-stu-id="cc214-338">In most cases, *standard interface marshaling*, which is provided by the system, is sufficient, but a COM object optionally may implement *custom interface marshaling* to control the creation of remote object proxies to itself.</span></span> <span data-ttu-id="cc214-339">如需詳細資訊，請參閱 [物件間通訊](inter-object-communication.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-339">For more information, see [Inter-Object Communication](inter-object-communication.md).</span></span>

## <a name="security"></a><span data-ttu-id="cc214-340">安全性</span><span class="sxs-lookup"><span data-stu-id="cc214-340">Security</span></span>

<span data-ttu-id="cc214-341">COM 提供兩種形式的應用程式安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-341">COM provides two forms of application security.</span></span> <span data-ttu-id="cc214-342">其中一個是 *啟用安全性*，可指定新物件的建立方式、用戶端連接至新的和現有物件的方式，以及某些公用服務（例如類別資料表和執行中的物件資料表）的安全方式。</span><span class="sxs-lookup"><span data-stu-id="cc214-342">One is *activation security*, which specifies how new objects are created, how clients connect to new and existing objects, and how certain public services, such as the Class Table and the Running Object Table are secured.</span></span> <span data-ttu-id="cc214-343">另一個是 *呼叫安全性*，它會指定在用戶端與 COM 物件之間建立的連線時，安全性的運作方式。</span><span class="sxs-lookup"><span data-stu-id="cc214-343">The other is *call security*, which specifies how security operates in an established connection between a client to a COM object.</span></span>

<span data-ttu-id="cc214-344">「服務控制管理員」會自動套用「啟用安全性」 (SCM) 。</span><span class="sxs-lookup"><span data-stu-id="cc214-344">Activation security is applied automatically by the Service Control Manager (SCM).</span></span> <span data-ttu-id="cc214-345">當 SCM 收到取得 COM 物件的要求時，它會根據儲存在登錄中的安全性資訊來檢查要求。</span><span class="sxs-lookup"><span data-stu-id="cc214-345">When the SCM receives a request to retrieve a COM object, it checks the request against security information that is stored in the registry.</span></span>

<span data-ttu-id="cc214-346">SCM 執行通常會提供登錄導向的設定，以管理部署的類別和主機上的特定使用者帳戶。</span><span class="sxs-lookup"><span data-stu-id="cc214-346">SCM implementations usually offer registry-driven configuration for administering deployed classes and for specific user accounts on the host.</span></span> <span data-ttu-id="cc214-347">如需詳細資訊，請參閱 [啟用安全性](activation-security.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-347">For more information, see [Activation Security](activation-security.md).</span></span>

<span data-ttu-id="cc214-348">呼叫安全性會自動套用，或由應用程式強制執行。</span><span class="sxs-lookup"><span data-stu-id="cc214-348">Call security is applied automatically or is enforced by the application.</span></span> <span data-ttu-id="cc214-349">如果應用程式提供設定資訊，COM 會執行必要的檢查以保護應用程式。</span><span class="sxs-lookup"><span data-stu-id="cc214-349">If the application provides setup information, COM performs the necessary checks to secure the application.</span></span>

<span data-ttu-id="cc214-350">自動機制會檢查進程的安全性，但不會檢查個別物件或方法的安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-350">The automatic mechanism checks security for the process, but not for individual objects or methods.</span></span> <span data-ttu-id="cc214-351">如果應用程式需要更精細的安全性，COM 會提供應用程式可使用的函式來執行自己的安全性檢查。</span><span class="sxs-lookup"><span data-stu-id="cc214-351">If an application requires more fine-grained security, COM provides functions that applications may use do their own security checking.</span></span>

<span data-ttu-id="cc214-352">自動和自訂機制可以一起使用，因此應用程式可能會要求 COM 執行自動安全性檢查，然後執行它自己的動作。</span><span class="sxs-lookup"><span data-stu-id="cc214-352">The automatic and custom mechanisms can be used together, so an application may ask COM to perform automatic security checking and then perform its own.</span></span>

<span data-ttu-id="cc214-353">COM 呼叫安全性服務分為下列類別：</span><span class="sxs-lookup"><span data-stu-id="cc214-353">COM call security services are divided into the following categories:</span></span>

-   <span data-ttu-id="cc214-354">用戶端和伺服器所呼叫的一般函式，可讓您初始化自動安全性機制，以及註冊自動驗證服務。</span><span class="sxs-lookup"><span data-stu-id="cc214-354">General functions that are called by both clients and servers, which enable the automatic security mechanism to be initialized and automatic authentication services to be registered.</span></span> <span data-ttu-id="cc214-355">一般呼叫安全性 Api 是 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) 和 [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) 函數。</span><span class="sxs-lookup"><span data-stu-id="cc214-355">The general call security APIs are the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) functions.</span></span>
-   <span data-ttu-id="cc214-356">用戶端 proxy 上的介面，可讓用戶端控制對個別介面之呼叫的安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-356">Interfaces on client proxies, which enable the client to control the security on calls to individual interfaces.</span></span> <span data-ttu-id="cc214-357">[**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity)介面和 [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket)、 [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)和 [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy)函數會在遠端物件上提供呼叫安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-357">The [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface and the [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), and [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) functions provide call security on a remote object.</span></span>
-   <span data-ttu-id="cc214-358">伺服器端函式和呼叫內容介面，可讓伺服器取得有關呼叫的安全性資訊，以及模擬呼叫者。</span><span class="sxs-lookup"><span data-stu-id="cc214-358">Server-side functions and call-context interfaces, which enable the server to retrieve security information about a call and to impersonate the caller.</span></span> <span data-ttu-id="cc214-359">[**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity)介面和 [**CoGetCallCoNtext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext)、 [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient)和 [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself)函式提供伺服器端呼叫安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-359">The [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface and the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient), and [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) functions provide server-side call security.</span></span>

<span data-ttu-id="cc214-360">通常，用戶端會查詢 COM 物件以取得 [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) 介面，這個介面是由遠端層在本機執行。</span><span class="sxs-lookup"><span data-stu-id="cc214-360">Often, the client queries the COM object for the [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface, which is implemented locally by the remoting layer.</span></span> <span data-ttu-id="cc214-361">用戶端會使用此介面來控制 COM 物件上個別介面 proxy 的安全性，然後再對其中一個介面進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="cc214-361">The client uses this interface to control the security of individual interface proxies on the COM object before making a call on one of the interfaces.</span></span>

<span data-ttu-id="cc214-362">當呼叫抵達伺服器時，伺服器可能會呼叫 [**CoGetCallCoNtext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) 函式來取出 [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) 介面，如此可讓伺服器檢查用戶端的驗證，並在必要時模擬用戶端。</span><span class="sxs-lookup"><span data-stu-id="cc214-362">When a call arrives at the server, the server may call the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) function to retrieve an [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface, which allows the server to check the client's authentication and to impersonate the client, if necessary.</span></span> <span data-ttu-id="cc214-363">**IServerSecurity** 物件在呼叫期間有效。</span><span class="sxs-lookup"><span data-stu-id="cc214-363">The **IServerSecurity** object is valid for the duration of the call.</span></span>

<span data-ttu-id="cc214-364">呼叫 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) 函式來初始化安全性層級，並將指定的值設定為安全性預設值。</span><span class="sxs-lookup"><span data-stu-id="cc214-364">Call the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) function to initialize the security layer and set the specified values as the security default.</span></span> <span data-ttu-id="cc214-365">如果處理常式未呼叫 **CoInitializeSecurity**，COM 會在第一次將介面封送處理或取消封送處理時自動呼叫它，以註冊系統預設安全性。</span><span class="sxs-lookup"><span data-stu-id="cc214-365">If a process does not call **CoInitializeSecurity**, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security.</span></span> <span data-ttu-id="cc214-366">**CoInitializeSecurity** 函數可讓用戶端建立進程的預設呼叫安全性，以避免在個別 proxy 上使用 [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) 。</span><span class="sxs-lookup"><span data-stu-id="cc214-366">The **CoInitializeSecurity** function allows the client to establish default call security for the process, which avoids the use of [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) on individual proxies.</span></span> <span data-ttu-id="cc214-367">**CoInitializeSecurity** 函式可讓伺服器為進程註冊自動驗證服務。</span><span class="sxs-lookup"><span data-stu-id="cc214-367">The **CoInitializeSecurity** function enables a server to register automatic authentication services for the process.</span></span> <span data-ttu-id="cc214-368">如需詳細資訊，請參閱 [使用 CoInitializeSecurity 設定 Process-Wide 安全性](setting-processwide-security-with-coinitializesecurity.md)。</span><span class="sxs-lookup"><span data-stu-id="cc214-368">For more information, see [Setting Process-Wide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="cc214-369">相關主題</span><span class="sxs-lookup"><span data-stu-id="cc214-369">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="cc214-370">COM 用戶端和伺服器</span><span class="sxs-lookup"><span data-stu-id="cc214-370">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="cc214-371">定義 COM 介面</span><span class="sxs-lookup"><span data-stu-id="cc214-371">Defining COM Interfaces</span></span>](defining-com-interfaces.md)
</dt> <dt>

[<span data-ttu-id="cc214-372">註冊 COM 應用程式</span><span class="sxs-lookup"><span data-stu-id="cc214-372">Registering COM Applications</span></span>](registering-com-applications.md)
</dt> <dt>

[<span data-ttu-id="cc214-373">COM 中的安全性</span><span class="sxs-lookup"><span data-stu-id="cc214-373">Security in COM</span></span>](security-in-com.md)
</dt> <dt>

[<span data-ttu-id="cc214-374">進程、執行緒和單元</span><span class="sxs-lookup"><span data-stu-id="cc214-374">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> </dl>

 

 
