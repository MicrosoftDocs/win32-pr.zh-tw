---
title: 視圖快取
description: 視圖快取
ms.assetid: d19c111c-1367-43a2-97a9-35dc0ff5dcc8
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 592c5bc2555e907cdc4e600465b807387c3a5548
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382926"
---
# <a name="view-caching"></a><span data-ttu-id="5d038-103">視圖快取</span><span class="sxs-lookup"><span data-stu-id="5d038-103">View Caching</span></span>

<span data-ttu-id="5d038-104">容器應用程式必須能夠取得物件的呈現方式，以便在檔開啟時顯示或列印該物件，但是物件的伺服器應用程式不在執行中，或未安裝在使用者的電腦上。</span><span class="sxs-lookup"><span data-stu-id="5d038-104">A container application must be able to obtain a presentation of an object for the purpose of displaying or printing it for users when the document is open but the object's server application is not running or is not installed on the user's machine.</span></span> <span data-ttu-id="5d038-105">不過，假設檔中的所有物件的伺服器都安裝在每個使用者的電腦上，而且隨時都可以視需要執行。</span><span class="sxs-lookup"><span data-stu-id="5d038-105">To assume, however, that the servers for all the objects that might conceivably be found in a document are installed on every user's machine and can always run on demand is unrealistic.</span></span> <span data-ttu-id="5d038-106">可以隨時使用的預設物件處理常式，會藉由在檔的儲存體中快取物件簡報並在任何平臺上操作這些簡報，來解決這個難題，而不管任何特定的容器安裝上可用性的物件服務器為何。</span><span class="sxs-lookup"><span data-stu-id="5d038-106">The default object handler, which is available at all times, solves this dilemma by caching object presentations in the document's storage and manipulating these presentations on any platform regardless of the availablility of the object server on any particular installation of the container.</span></span>

<span data-ttu-id="5d038-107">容器可以維護一或多個特定目標裝置的繪圖簡報，以及維護螢幕上物件所需的繪圖。</span><span class="sxs-lookup"><span data-stu-id="5d038-107">Containers can maintain drawing presentations for one or more specific target devices in addition to the one required to maintain the object on screen.</span></span> <span data-ttu-id="5d038-108">此外，如果您將物件從某個平臺移植到另一個平臺，OLE 會自動將物件的資料格式轉換為新平臺所支援的格式。</span><span class="sxs-lookup"><span data-stu-id="5d038-108">Moreover, if you port the object from one platform to another, OLE automatically converts the object's data formats to ones supported on the new platform.</span></span> <span data-ttu-id="5d038-109">例如，如果您將物件從 Windows 移至 Macintosh，OLE 會將其中繼檔簡報轉換成 PICT 格式。</span><span class="sxs-lookup"><span data-stu-id="5d038-109">For example, if you move an object from Windows to the Macintosh, OLE will convert its metafile presentations to PICT formats.</span></span>

<span data-ttu-id="5d038-110">為了將内嵌物件的精確表示呈現給使用者，物件的容器應用程式會使用物件處理常式起始對話方塊，要求資料和繪製指示。</span><span class="sxs-lookup"><span data-stu-id="5d038-110">In order to present an accurate representation of an embedded object to the user, the object's container application initiates a dialog with the object handler, requesting data and drawing instructions.</span></span> <span data-ttu-id="5d038-111">若要能夠滿足容器的要求，處理常式必須執行 [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)、 [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)和 [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) 介面。</span><span class="sxs-lookup"><span data-stu-id="5d038-111">To be able to fulfill the container's requests, the handler must implement the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject), [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2), and [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) interfaces.</span></span>

<span data-ttu-id="5d038-112">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) 可讓 OLE 容器應用程式取得資料，並將資料傳送至其內嵌或連結的物件。</span><span class="sxs-lookup"><span data-stu-id="5d038-112">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) enables an OLE container application to get data from and send data to its embedded or linked objects.</span></span> <span data-ttu-id="5d038-113">當物件中的資料變更時，此介面會提供方法讓物件將其新資料提供給其容器，並提供容器更新其物件複本中資料的方式。</span><span class="sxs-lookup"><span data-stu-id="5d038-113">When data changes in an object, this interface provides a way for the object to make its new data available to its container and provides the container with a way to update the data in its copy of the object.</span></span> <span data-ttu-id="5d038-114"> (如需資料傳輸的一般討論，請參閱第4章：資料傳輸 ) 。</span><span class="sxs-lookup"><span data-stu-id="5d038-114">(For a discussion of data transfer in general, see Chapter 4, Data Transfer.)</span></span>

<span data-ttu-id="5d038-115">[**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)介面與 [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)介面非常類似，不同之處在于它會要求物件在裝置內容（例如螢幕、印表機或中繼檔）上自行繪製，而不是將其資料移動或複製到記憶體或某些其他傳輸媒體。</span><span class="sxs-lookup"><span data-stu-id="5d038-115">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface is very much like the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface except that it asks an object to draw itself on a device context, such as a screen, printer, or metafile, rather than move or copy its data to memory or some other transfer medium.</span></span> <span data-ttu-id="5d038-116">介面的目的是要讓 OLE 容器取得其内嵌物件的替代圖解標記法，其資料已經有，藉此避免必須直接傳送相同資料物件之新實例的額外負荷，才能取得新的繪圖指令。</span><span class="sxs-lookup"><span data-stu-id="5d038-116">The purpose of the interface is to enable an OLE container to obtain alternative pictorial representations of its embedded objects, whose data it already has, thereby avoiding the overhead of having to transfer entirely new instances of the same data objects simply to obtain new drawing instructions.</span></span> <span data-ttu-id="5d038-117">相反地， **IViewObject2** 介面可讓容器藉由在容器所指定的裝置內容中繪製，來要求物件提供其本身的圖形標記法。</span><span class="sxs-lookup"><span data-stu-id="5d038-117">Instead, the **IViewObject2** interface enables the container to ask an object to provide a pictorial representation of itself by drawing on a device context specified by the container.</span></span>

<span data-ttu-id="5d038-118">當您呼叫 [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) 介面時，容器應用程式也可以指定物件在目標裝置上繪製本身，而不是實際呈現該物件的目標裝置。</span><span class="sxs-lookup"><span data-stu-id="5d038-118">When calling the [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface, a container application can also specify that the object draw itself on a target device different than the one on which it will actually be rendered.</span></span> <span data-ttu-id="5d038-119">這會視需要啟用容器，以產生單一物件的不同轉譯。</span><span class="sxs-lookup"><span data-stu-id="5d038-119">This enables the container, as needed, to generate different renderings from a single object.</span></span> <span data-ttu-id="5d038-120">例如，呼叫者可能會要求物件為印表機撰寫，即使產生的繪圖將會在螢幕上呈現也一樣。</span><span class="sxs-lookup"><span data-stu-id="5d038-120">For example, the caller could ask the object to compose itself for a printer even though the resulting drawing will be rendered on screen.</span></span> <span data-ttu-id="5d038-121">當然，結果就是物件的預覽列印。</span><span class="sxs-lookup"><span data-stu-id="5d038-121">The result, of course, would be a print-preview of the object.</span></span>

<span data-ttu-id="5d038-122">[**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)介面也提供可讓容器註冊 view 變更通知的方法。</span><span class="sxs-lookup"><span data-stu-id="5d038-122">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)interface also provides methods that enable containers to register for view-change notifications.</span></span> <span data-ttu-id="5d038-123">如同資料和 OLE 諮詢一樣，view 諮詢連接可讓容器以自己的便利性更新其物件的轉譯，而不是回應物件的呼叫。</span><span class="sxs-lookup"><span data-stu-id="5d038-123">As with data and OLE advisories, a view advisory connection enables a container to update its renderings of an object at its own convenience rather than in response to a call from the object.</span></span> <span data-ttu-id="5d038-124">例如，如果新版本的物件服務器應用程式提供相同資料的其他視圖，則物件的預設處理常式會呼叫每個容器的 [**IAdviseSink：： OnViewChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange) 實值，讓他們知道新的簡報可供使用。</span><span class="sxs-lookup"><span data-stu-id="5d038-124">For example, if a new version of an object's server application were to offer additional views of the same data, the object's default handler would call each container's implementation of [**IAdviseSink::OnViewChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange) to let them know that the new presentations were available.</span></span> <span data-ttu-id="5d038-125">只有在需要時，容器才會從建議接收取得此資訊。</span><span class="sxs-lookup"><span data-stu-id="5d038-125">The container would retrieve this information from the advise sink only when needed.</span></span>

<span data-ttu-id="5d038-126">由於 Windows 裝置內容只有在單一進程內才有意義，因此您無法跨進程界限傳遞 [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) 指標。</span><span class="sxs-lookup"><span data-stu-id="5d038-126">Because Windows device contexts have meaning only within a single process, you cannot pass [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) pointers across process boundaries.</span></span> <span data-ttu-id="5d038-127">如此一來，OLE 本機和遠端伺服器就不需要執行介面，即使有的話也不會正常運作。</span><span class="sxs-lookup"><span data-stu-id="5d038-127">As a result, OLE local and remote servers have no need whatsoever to implement the interface, which wouldn't work properly even if they did.</span></span> <span data-ttu-id="5d038-128">只有物件處理常式和同進程伺服器會執行 **IViewObject2** 介面。</span><span class="sxs-lookup"><span data-stu-id="5d038-128">Only object handlers and in-process servers implement the **IViewObject2** interface.</span></span> <span data-ttu-id="5d038-129">OLE 提供預設的實作為，只要藉由匯總 OLE 預設處理常式，您就可以在自己的 OLE 同進程伺服器和物件處理常式中使用。</span><span class="sxs-lookup"><span data-stu-id="5d038-129">OLE provides a default implementation, which you can use in your own OLE in-process servers and object handlers simply by aggregating the OLE default handler.</span></span> <span data-ttu-id="5d038-130">或者，您也可以撰寫自己的 **IViewObject2** 執行。</span><span class="sxs-lookup"><span data-stu-id="5d038-130">Or you can write your own implementation of **IViewObject2**.</span></span>

<span data-ttu-id="5d038-131">物件會實 [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) 介面，以便讓處理常式知道它應該快取的功能。</span><span class="sxs-lookup"><span data-stu-id="5d038-131">An object implements the [**IOleCache**](/windows/desktop/api/OleIdl/nn-oleidl-iolecache) interface in order to let the handler know what capabilities it should cache.</span></span> <span data-ttu-id="5d038-132">物件處理常式也擁有快取，並確保它會保持最新狀態。</span><span class="sxs-lookup"><span data-stu-id="5d038-132">The object handler also owns the cache and ensures it is kept up to date.</span></span> <span data-ttu-id="5d038-133">當内嵌物件進入「執行中」狀態時，處理常式會在伺服器物件上設定適當的諮詢連接，其本身可作為接收。</span><span class="sxs-lookup"><span data-stu-id="5d038-133">As the embedded object enters the running state, the handler sets up appropriate advisory connections on the server object, with itself acting as the sink.</span></span> <span data-ttu-id="5d038-134">[**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject)和 [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)介面的執行作業會在用戶端上快取的資料上運作。</span><span class="sxs-lookup"><span data-stu-id="5d038-134">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) and [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)interface implementations operate out of data cached on the client side.</span></span> <span data-ttu-id="5d038-135">處理常式的 **IViewObject2** 會負責決定要快取的資料格式，以便滿足用戶端繪製要求。</span><span class="sxs-lookup"><span data-stu-id="5d038-135">The handler's implementation of **IViewObject2** is responsible for determining what data formats to cache in order to satisfy client draw requests.</span></span> <span data-ttu-id="5d038-136">處理常式的 **IDataObject** 會負責取得不同格式的資料，以及在記憶體和内嵌物件的基礎 [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) 實例之間取得資料。</span><span class="sxs-lookup"><span data-stu-id="5d038-136">The handler's implementation of **IDataObject** is responsible for getting data in various formats, etc., between memory and the underlying [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) instance of the embedded object.</span></span> <span data-ttu-id="5d038-137">自訂處理常式可以藉由匯總預設處理常式來使用這些實值。</span><span class="sxs-lookup"><span data-stu-id="5d038-137">Custom handlers can use these implementations by aggregating on the default handler.</span></span>

> [!Note]  
> <span data-ttu-id="5d038-138">[**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2)介面是 [**IViewObject**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject)的簡單功能延伸模組，而且應該執行，而非後者現在已淘汰的介面。</span><span class="sxs-lookup"><span data-stu-id="5d038-138">The [**IViewObject2**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject2) interface is a simple functional extension of [**IViewObject**](/windows/desktop/api/OleIdl/nn-oleidl-iviewobject) and should be implemented instead of the latter interface, which is now obsolete.</span></span> <span data-ttu-id="5d038-139">除了提供 **IViewObject** 方法之外， **IViewObject2** 介面還提供一個額外的 [**GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-iviewobject2-getextent)成員，可讓容器應用程式從快取中取得物件展示的大小，而不需要先透過呼叫 [**IOleObject：： GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getextent)，將物件移到執行中狀態。</span><span class="sxs-lookup"><span data-stu-id="5d038-139">In addition to providing the **IViewObject** methods, the **IViewObject2** interface provides a single additional member, [**GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-iviewobject2-getextent), which enables a container application to get the size of an object's presentation from the cache without first having to move the object into the running state with a call to [**IOleObject::GetExtent**](/windows/desktop/api/OleIdl/nf-oleidl-ioleobject-getextent).</span></span>

 

## <a name="related-topics"></a><span data-ttu-id="5d038-140">相關主題</span><span class="sxs-lookup"><span data-stu-id="5d038-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="5d038-141">複合檔案</span><span class="sxs-lookup"><span data-stu-id="5d038-141">Compound Documents</span></span>](compound-documents.md)
</dt> </dl>

 

 