---
title: 製作和處理非同步呼叫
description: COM 物件可支援非同步呼叫。
ms.assetid: bf7f9f8e-66ce-41a4-854c-62dbe840a89e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 059f55cc64a70f130e7fb654426803edbe8b7209
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "106995154"
---
# <a name="making-and-processing-asynchronous-calls"></a><span data-ttu-id="14e74-103">製作和處理非同步呼叫</span><span class="sxs-lookup"><span data-stu-id="14e74-103">Making and Processing Asynchronous Calls</span></span>

<span data-ttu-id="14e74-104">COM 物件可支援非同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-104">COM objects can support asynchronous calling.</span></span> <span data-ttu-id="14e74-105">當用戶端進行非同步呼叫時，控制權會立即返回用戶端。</span><span class="sxs-lookup"><span data-stu-id="14e74-105">When a client makes an asynchronous call, control returns to the client immediately.</span></span> <span data-ttu-id="14e74-106">當伺服器處理呼叫時，用戶端可以自由執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="14e74-106">While the server processes the call, the client is free to do other work.</span></span> <span data-ttu-id="14e74-107">當用戶端無法在沒有呼叫結果的情況下繼續進行時，它可以在該時間取得呼叫的結果。</span><span class="sxs-lookup"><span data-stu-id="14e74-107">When the client can no longer proceed without the results of the call, it can get the results of the call at that time.</span></span>

<span data-ttu-id="14e74-108">例如，大型或複雜記錄集的要求可能相當耗時。</span><span class="sxs-lookup"><span data-stu-id="14e74-108">For example, a request for a large or complex recordset can be time-consuming.</span></span> <span data-ttu-id="14e74-109">用戶端可以透過非同步呼叫來要求記錄集，然後再執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="14e74-109">A client can request the recordset by an asynchronous call and then do other work.</span></span> <span data-ttu-id="14e74-110">當記錄集可供使用時，用戶端可以快速取得，而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="14e74-110">When the recordset is available, the client can obtain it quickly without blocking.</span></span>

<span data-ttu-id="14e74-111">用戶端不會直接在伺服器物件上進行非同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-111">Clients do not make asynchronous calls directly on the server object.</span></span> <span data-ttu-id="14e74-112">相反地，它們會取得呼叫物件，以在伺服器物件上執行同步介面的非同步版本。</span><span class="sxs-lookup"><span data-stu-id="14e74-112">Instead, they obtain a call object that implements an asynchronous version of a synchronous interface on the server object.</span></span> <span data-ttu-id="14e74-113">呼叫物件上的非同步介面具有形式為 Async *介面名稱* 的名稱。</span><span class="sxs-lookup"><span data-stu-id="14e74-113">The asynchronous interface on the call object has a name of the form Async *InterfaceName*.</span></span> <span data-ttu-id="14e74-114">例如，如果伺服器物件會執行名為 IMyInterface 的同步介面，則會有一個呼叫物件來執行名為 AsyncIMyInterface 的非同步介面。</span><span class="sxs-lookup"><span data-stu-id="14e74-114">For example, if a server object implements a synchronous interface named IMyInterface, there will be a call object that implements an asynchronous interface named AsyncIMyInterface.</span></span>

> [!Note]  
> <span data-ttu-id="14e74-115">不提供適用于 **idispatch** 的非同步支援，或繼承 **IDispatch** 的介面。</span><span class="sxs-lookup"><span data-stu-id="14e74-115">Asynchronous support is not available for **IDispatch** or for interfaces that inherit **IDispatch**.</span></span>

 

<span data-ttu-id="14e74-116">支援非同步呼叫的伺服器物件會執行 [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) 介面。</span><span class="sxs-lookup"><span data-stu-id="14e74-116">Server objects that support asynchronous calls implement the [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) interface.</span></span> <span data-ttu-id="14e74-117">這個介面會公開單一方法 [**CreateCall**](/windows/win32/api/objidlbase/nf-objidlbase-icallfactory-createcall)，它會建立指定之呼叫物件的實例。</span><span class="sxs-lookup"><span data-stu-id="14e74-117">This interface exposes a single method, [**CreateCall**](/windows/win32/api/objidlbase/nf-objidlbase-icallfactory-createcall), which creates an instance of a specified call object.</span></span> <span data-ttu-id="14e74-118">用戶端可以查詢 **ICallFactory** ，以判斷物件是否支援非同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-118">Clients can query for **ICallFactory** to determine whether an object supports asynchronous calling.</span></span>

<span data-ttu-id="14e74-119">針對同步介面上的每個方法，對應的非同步介面會執行兩個方法。</span><span class="sxs-lookup"><span data-stu-id="14e74-119">For each method on a synchronous interface, the corresponding asynchronous interface implements two methods.</span></span> <span data-ttu-id="14e74-120">這些方法會將開頭和結尾的前置詞附加 \_ \_ 至同步方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="14e74-120">These methods attach the prefixes Begin\_ and Finish\_ to the name of the synchronous method.</span></span> <span data-ttu-id="14e74-121">例如，如果名為 ISimpleStream 的介面有 Read 方法，AsyncISimpleStream 介面將會有開始 \_ 讀取和完成 \_ 讀取方法。</span><span class="sxs-lookup"><span data-stu-id="14e74-121">For example, if an interface named ISimpleStream has a Read method, the AsyncISimpleStream interface will have a Begin\_Read and a Finish\_Read method.</span></span> <span data-ttu-id="14e74-122">若要開始非同步呼叫，用戶端會呼叫 Begin \_ 方法。</span><span class="sxs-lookup"><span data-stu-id="14e74-122">To begin an asynchronous call, the client calls the Begin\_ method.</span></span>

<span data-ttu-id="14e74-123">當您執行伺服器物件時，您不需要為該物件所執行的每個介面提供呼叫物件。</span><span class="sxs-lookup"><span data-stu-id="14e74-123">When you implement a server object, you do not have to provide a call object for every interface the object implements.</span></span> <span data-ttu-id="14e74-124">如果伺服器物件會執行 [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) 介面並使用標準封送處理，即使伺服器端沒有呼叫物件，封送處理的用戶端仍然可以取得 proxy 呼叫物件。</span><span class="sxs-lookup"><span data-stu-id="14e74-124">If the server object implements the [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory) interface and uses standard marshaling, a marshaled client can always obtain a proxy call object, even if there is no call object on the server side.</span></span> <span data-ttu-id="14e74-125">此 proxy 會將 Begin 方法封送 \_ 處理為同步呼叫，伺服器將會同步處理呼叫，而用戶端可以藉由呼叫完成方法來取得 out 參數 \_ 。</span><span class="sxs-lookup"><span data-stu-id="14e74-125">This proxy will marshal the Begin\_ method as a synchronous call, the server will process the call synchronously, and the client can obtain the out parameters by calling the Finish\_ method.</span></span>

<span data-ttu-id="14e74-126">相反地，如果用戶端在伺服器端上有呼叫物件的介面上進行封送處理的同步呼叫，伺服器一律會以非同步方式處理呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-126">Conversely, if a client makes a marshaled synchronous call on an interface for which there is a call object on the server side, the server will always process the call asynchronously.</span></span> <span data-ttu-id="14e74-127">用戶端將不會察覺到這種行為，因為用戶端會收到相同的 out 參數和從同步方法收到的相同傳回值。</span><span class="sxs-lookup"><span data-stu-id="14e74-127">This behavior will not be apparent to the client, because the client will receive the same out parameters and the same return value it would have received from the synchronous method.</span></span>

<span data-ttu-id="14e74-128">無論是哪一種情況，用戶端與伺服器之間的互動都會被封送處理，就像呼叫是同步的一樣：同步和非同步 proxy 的輸出並不區分，如同對應的存根的輸出。</span><span class="sxs-lookup"><span data-stu-id="14e74-128">In either case, the interaction between client and server is marshaled as if the call were synchronous: The output of synchronous and asynchronous proxies is indistinguishable, as is the output of the corresponding stubs.</span></span> <span data-ttu-id="14e74-129">此行為可大幅簡化用戶端和伺服器的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="14e74-129">This behavior greatly simplifies the programming model both of clients and of servers.</span></span> <span data-ttu-id="14e74-130">如果伺服器物件會執行 [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory)，則已封送處理的用戶端不需要嘗試建立可能無法使用的呼叫物件，而是一律可使用 call 物件。</span><span class="sxs-lookup"><span data-stu-id="14e74-130">If a server object implements [**ICallFactory**](/windows/win32/api/objidlbase/nn-objidlbase-icallfactory), a marshaled client does not have to attempt to create a call object that may not be available — to the client, a call object is always available.</span></span>

<span data-ttu-id="14e74-131">當用戶端和伺服器位於相同的單元時，伺服器物件將會處理用戶端所進行的任何呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-131">When client and server are in the same apartment, the server object will process whichever call the client makes.</span></span> <span data-ttu-id="14e74-132">如果無法使用呼叫物件，用戶端必須明確取得同步介面並進行同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="14e74-132">If a call object is not available, the client must explicitly obtain the synchronous interface and make a synchronous call.</span></span>

<span data-ttu-id="14e74-133">如需詳細資訊，請參閱下列主題：</span><span class="sxs-lookup"><span data-stu-id="14e74-133">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="14e74-134">進行非同步呼叫</span><span class="sxs-lookup"><span data-stu-id="14e74-134">Making an Asynchronous Call</span></span>](making-an-asynchronous-call.md)
-   [<span data-ttu-id="14e74-135">取消非同步呼叫</span><span class="sxs-lookup"><span data-stu-id="14e74-135">Canceling an Asynchronous Call</span></span>](canceling-an-asynchronous-call.md)
-   [<span data-ttu-id="14e74-136">取消方法呼叫</span><span class="sxs-lookup"><span data-stu-id="14e74-136">Canceling Method Calls</span></span>](canceling-method-calls.md)
-   [<span data-ttu-id="14e74-137">呼叫同步處理</span><span class="sxs-lookup"><span data-stu-id="14e74-137">Call Synchronization</span></span>](call-synchronization.md)

 

 