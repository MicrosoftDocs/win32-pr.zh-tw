---
title: 正在執行參考計數
description: 正在執行參考計數
ms.assetid: d4fd98c9-afa4-4c5c-a3c9-44d34881cbdb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a0d4dfe2b0faf2fc6557d1b089e33ae6ce4b98cb
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "106996567"
---
# <a name="implementing-reference-counting"></a><span data-ttu-id="eca28-103">正在執行參考計數</span><span class="sxs-lookup"><span data-stu-id="eca28-103">Implementing Reference Counting</span></span>

<span data-ttu-id="eca28-104">參考計數需要在實作項類別的部分，以及使用該類別之物件的用戶端上進行工作。</span><span class="sxs-lookup"><span data-stu-id="eca28-104">Reference counting requires work on the part of both the implementor of a class and the clients who use objects of that class.</span></span> <span data-ttu-id="eca28-105">當您執行類別時，您必須將 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 和 [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 方法實作為 [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) 介面的一部分。</span><span class="sxs-lookup"><span data-stu-id="eca28-105">When you implement a class, you must implement the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods as part of the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="eca28-106">這兩種方法具有下列簡單的實作為：</span><span class="sxs-lookup"><span data-stu-id="eca28-106">These two methods have the following simple implementations:</span></span>

-   <span data-ttu-id="eca28-107">[**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 會遞增物件的內部參考計數。</span><span class="sxs-lookup"><span data-stu-id="eca28-107">[**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) increments the object's internal reference count.</span></span>
-   <span data-ttu-id="eca28-108">[**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 會先遞減物件的內部參考計數，然後檢查參考計數是否已下降到零。</span><span class="sxs-lookup"><span data-stu-id="eca28-108">[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) first decrements the object's internal reference count, and then it checks whether the reference count has fallen to zero.</span></span> <span data-ttu-id="eca28-109">如果有的話，這表示沒有人使用此物件，因此釋放函式會 **解除** 分配物件。</span><span class="sxs-lookup"><span data-stu-id="eca28-109">If it has, that means no one is using the object any longer, so the **Release** function deallocates the object.</span></span>

<span data-ttu-id="eca28-110">大部分物件的常見實作為方法之一，就是只執行這些方法的其中一項 (，以及在所有介面之間共用的 [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))) ，因此是套用至整個物件的參考計數。</span><span class="sxs-lookup"><span data-stu-id="eca28-110">A common implementation approach for most objects is to have only one implementation of these methods (along with [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))), which is shared between all interfaces, and therefore a reference count that applies to the entire object.</span></span> <span data-ttu-id="eca28-111">不過，從用戶端的觀點來看，參考計數是嚴格且清楚的每個介面指標的概念，因此，利用這項功能的物件可以根據目前現存的介面指標，動態地建立、終結、載入或卸載部分功能。</span><span class="sxs-lookup"><span data-stu-id="eca28-111">However, from a client's perspective, reference counting is strictly and clearly a per-interface-pointer notion, and therefore objects that take advantage of this capability by dynamically constructing, destroying, loading, or unloading portions of their functionality based on the currently extant interface pointers may be implemented.</span></span> <span data-ttu-id="eca28-112">這些堆疊稱為「卸載 *介面*」。</span><span class="sxs-lookup"><span data-stu-id="eca28-112">These are colloquially called *tear-off interfaces*.</span></span>

<span data-ttu-id="eca28-113">只要用戶端呼叫方法 (或 API 函式) ，例如會傳回新介面指標的 [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))，呼叫的方法就會負責透過傳回的指標遞增參考計數。</span><span class="sxs-lookup"><span data-stu-id="eca28-113">Whenever a client calls a method (or API function), such as [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), that returns a new interface pointer, the method being called is responsible for incrementing the reference count through the returned pointer.</span></span> <span data-ttu-id="eca28-114">例如，當用戶端第一次建立物件時，它會接收指向物件的介面指標，而從用戶端的觀點來看，它的參考計數是一個。</span><span class="sxs-lookup"><span data-stu-id="eca28-114">For example, when a client first creates an object, it receives an interface pointer to an object that, from the client's point of view, has a reference count of one.</span></span> <span data-ttu-id="eca28-115">如果用戶端接著在介面指標上呼叫 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) ，參考計數就會變成二。</span><span class="sxs-lookup"><span data-stu-id="eca28-115">If the client then calls [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the interface pointer, the reference count becomes two.</span></span> <span data-ttu-id="eca28-116">用戶端 [**必須呼叫介面**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 指標上的兩次，以卸載其對物件的所有參考。</span><span class="sxs-lookup"><span data-stu-id="eca28-116">The client must call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) twice on the interface pointer to drop all of its references to the object.</span></span>

<span data-ttu-id="eca28-117">例如，當用戶端在新介面或相同介面的第一個指標上呼叫 [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) 時，每個介面指標的參考計數會是嚴格的。</span><span class="sxs-lookup"><span data-stu-id="eca28-117">An example of how reference counts are strictly per-interface-pointer occurs when a client calls [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) on the first pointer for either a new interface or the same interface.</span></span> <span data-ttu-id="eca28-118">在上述任一情況下，用戶端都必須呼叫每個指標一次的 [**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 。</span><span class="sxs-lookup"><span data-stu-id="eca28-118">In either of these cases, the client is required to call [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) once for each pointer.</span></span> <span data-ttu-id="eca28-119">當系統要求相同的介面多次時，COM 不需要物件傳回相同的指標。</span><span class="sxs-lookup"><span data-stu-id="eca28-119">COM does not require that an object return the same pointer when asked for the same interface multiple times.</span></span> <span data-ttu-id="eca28-120"> (唯一的例外狀況是對 [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown)的查詢，該查詢會識別 COM 的物件。 ) 這可讓物件的執行有效率地管理資源。</span><span class="sxs-lookup"><span data-stu-id="eca28-120">(The only exception to this is a query to [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown), which identifies an object to COM.) This allows the object implementation to manage resources efficiently.</span></span>

<span data-ttu-id="eca28-121">執行緒安全也是執行 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 和 [**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)的重要問題。</span><span class="sxs-lookup"><span data-stu-id="eca28-121">Thread-safety is also an important issue in implementing [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="eca28-122">如需詳細資訊，請參閱 [進程、執行緒和單元](processes--threads--and-apartments.md)。</span><span class="sxs-lookup"><span data-stu-id="eca28-122">For more information, see [Processes, Threads, and Apartments](processes--threads--and-apartments.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="eca28-123">相關主題</span><span class="sxs-lookup"><span data-stu-id="eca28-123">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="eca28-124">透過參考計數來管理物件存留期</span><span class="sxs-lookup"><span data-stu-id="eca28-124">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 