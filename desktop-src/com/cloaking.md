---
title: " (COM) 的掩蓋"
description: 「掩蓋」是一種 COM 安全性功能，可決定用戶端在模擬期間要將哪些身分識別導向伺服器。
ms.assetid: 5b97d9d6-8fa9-4da2-8351-64772227d9a2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 588651cfa37def4e174ef0f2fdba9b79b0c60ca8
ms.sourcegitcommit: d39e82e232f6510f843fdb8d55d25b4e9e02e880
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/03/2021
ms.locfileid: "103853200"
---
# <a name="cloaking-com"></a><span data-ttu-id="d1027-103"> (COM) 的掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-103">Cloaking (COM)</span></span>

<span data-ttu-id="d1027-104">「掩蓋」是一種 COM 安全性功能，可決定用戶端在模擬期間要將哪些身分識別導向伺服器。</span><span class="sxs-lookup"><span data-stu-id="d1027-104">Cloaking is a COM security capability that determines what identity the client projects toward the server during impersonation.</span></span> <span data-ttu-id="d1027-105">當設定了遮罩時，轉送伺服器會遮罩自己的身分識別，並將用戶端的身分識別提供給它代表用戶端呼叫的伺服器。</span><span class="sxs-lookup"><span data-stu-id="d1027-105">When cloaking is set, the intermediate server masks its own identity and presents the client's identity to the server that it calls on the client's behalf.</span></span> <span data-ttu-id="d1027-106">就伺服器看到的用戶端身分識別是與 proxy 相關聯的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-106">Basically; the client identity that is seen by the server is the identity associated with the proxy.</span></span> <span data-ttu-id="d1027-107">Proxy 的身分識別取決於數個因素，其中一個是在任何)  (設定的遮蓋類型。</span><span class="sxs-lookup"><span data-stu-id="d1027-107">The proxy's identity is determined by several factors, one of which is the type of cloaking that is set (if any).</span></span> <span data-ttu-id="d1027-108">安全通道安全性提供者不支援掩蓋。</span><span class="sxs-lookup"><span data-stu-id="d1027-108">Cloaking is not supported by the Schannel security provider.</span></span>

<span data-ttu-id="d1027-109">下列主題提供有關掩蓋的詳細資訊：</span><span class="sxs-lookup"><span data-stu-id="d1027-109">The following topics provide more information about cloaking:</span></span>

-   [<span data-ttu-id="d1027-110">掩蓋類型</span><span class="sxs-lookup"><span data-stu-id="d1027-110">Types of Cloaking</span></span>](#types-of-cloaking)
-   [<span data-ttu-id="d1027-111">掩蓋如何影響用戶端身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-111">How Cloaking Affects Client Identity</span></span>](#how-cloaking-affects-client-identity)
-   [<span data-ttu-id="d1027-112">設定掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-112">Setting Cloaking</span></span>](#setting-cloaking)
-   [<span data-ttu-id="d1027-113">掩蓋和模擬層級</span><span class="sxs-lookup"><span data-stu-id="d1027-113">Cloaking and Impersonation Levels</span></span>](#cloaking-and-impersonation-levels)
-   [<span data-ttu-id="d1027-114">掩蓋案例</span><span class="sxs-lookup"><span data-stu-id="d1027-114">Cloaking Scenarios</span></span>](#cloaking-scenarios)
-   [<span data-ttu-id="d1027-115">相關主題</span><span class="sxs-lookup"><span data-stu-id="d1027-115">Related topics</span></span>](#related-topics)

## <a name="types-of-cloaking"></a><span data-ttu-id="d1027-116">掩蓋類型</span><span class="sxs-lookup"><span data-stu-id="d1027-116">Types of Cloaking</span></span>

<span data-ttu-id="d1027-117">有兩種類型的掩蓋： *靜態* 的掩蓋和 *動態* 掩蓋：</span><span class="sxs-lookup"><span data-stu-id="d1027-117">There are two types of cloaking: *static* cloaking and *dynamic* cloaking:</span></span>

-   <span data-ttu-id="d1027-118">利用靜態掩蓋 (EOAC \_ 靜態 \_ 的掩蓋) ，伺服器會從用戶端到伺服器的第一次呼叫中看到執行緒 token。</span><span class="sxs-lookup"><span data-stu-id="d1027-118">With static cloaking (EOAC\_STATIC\_CLOAKING), the server sees the thread token from the first call from a client to the server.</span></span> <span data-ttu-id="d1027-119">第一次呼叫時，如果先前已在呼叫 [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)期間設定 proxy 身分識別，則會使用該 proxy 身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-119">For the first call, if the proxy identity was previously set during a call to [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), that proxy identity is used.</span></span> <span data-ttu-id="d1027-120">不過，如果先前未設定 proxy 身分識別，則會使用執行緒 token。</span><span class="sxs-lookup"><span data-stu-id="d1027-120">However, if the proxy identity was not previously set, the thread token is used.</span></span> <span data-ttu-id="d1027-121">如果沒有任何執行緒 token 存在，則會使用進程權杖。</span><span class="sxs-lookup"><span data-stu-id="d1027-121">If no thread token is present, the process token is used.</span></span> <span data-ttu-id="d1027-122">針對所有未來的呼叫，會使用第一次呼叫所設定的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-122">For all future calls, the identity set on the first call is used.</span></span>
-   <span data-ttu-id="d1027-123">使用動態掩蓋 (EOAC \_ 動態 \_ 掩蓋) ，在每次呼叫目前的執行緒權杖時 (如果有線程 token) 用來判斷用戶端的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-123">With dynamic cloaking (EOAC\_DYNAMIC\_CLOAKING), on each call the current thread token (if there is a thread token) is used to determine the client's identity.</span></span> <span data-ttu-id="d1027-124">如果沒有線程 token，則會使用進程權杖。</span><span class="sxs-lookup"><span data-stu-id="d1027-124">If there is no thread token, the process token is used.</span></span> <span data-ttu-id="d1027-125">這表示在模擬期間代表用戶端呼叫的伺服器會看到發出呼叫的 COM 用戶端的身分識別，這通常是所需的行為。</span><span class="sxs-lookup"><span data-stu-id="d1027-125">This means that servers called on the client's behalf during impersonation see the identity of the COM client that originated the call, which is generally the desired behavior.</span></span> <span data-ttu-id="d1027-126"> (當然，為了讓模擬成功，用戶端必須透過設定適當的模擬層級，讓伺服器授權單位進行模擬。</span><span class="sxs-lookup"><span data-stu-id="d1027-126">(Of course, for impersonation to succeed, the client must have given the server authority to impersonate by setting an appropriate impersonation level.</span></span> <span data-ttu-id="d1027-127">如需詳細資訊，請參閱模擬 [層級](impersonation-levels.md)。 ) 這種類型的掩蓋很昂貴。</span><span class="sxs-lookup"><span data-stu-id="d1027-127">For more information, see [Impersonation Levels](impersonation-levels.md).) This type of cloaking is expensive.</span></span>

## <a name="how-cloaking-affects-client-identity"></a><span data-ttu-id="d1027-128">掩蓋如何影響用戶端身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-128">How Cloaking Affects Client Identity</span></span>

<span data-ttu-id="d1027-129">進行加密的呼叫，且伺服器要求用戶端輸入其身分識別時，通常會取得系結至 proxy 的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-129">When an encrypted call is made and the server asks the client for its identity, it usually gets the identity tied to the proxy.</span></span> <span data-ttu-id="d1027-130"> (有時驗證服務會從真實身分識別執行轉譯，但通常 proxy 身分識別會是伺服器所見的身分識別。 ) proxy 會根據設定的遮蓋類型和其他因素，向伺服器呈現身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-130">(Sometimes the authentication service performs a translation from the real identity, but generally the proxy identity is the identity the server sees.) The proxy presents an identity to the server that depends on the type of cloaking that is set and other factors.</span></span>

<span data-ttu-id="d1027-131">總而言之，用戶端的身分識別是設定掩蓋旗標的函式、進程權杖、存在或沒有線程 token 的功能，以及是否先前已設定 proxy 身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-131">To summarize, the identity of the client is a function of the cloaking flag set, the process token, the presence or absence of a thread token, and whether the proxy identity has been previously set.</span></span> <span data-ttu-id="d1027-132">下表顯示當這些因素有所差異時，所產生的 proxy 身分識別 (用戶端身分識別) 。</span><span class="sxs-lookup"><span data-stu-id="d1027-132">The following table shows the resulting proxy identity (client identity) when these factors vary.</span></span>



| <span data-ttu-id="d1027-133">遮蓋旗標</span><span class="sxs-lookup"><span data-stu-id="d1027-133">Cloaking Flags</span></span>                     | <span data-ttu-id="d1027-134">執行緒權杖存在</span><span class="sxs-lookup"><span data-stu-id="d1027-134">Thread Token Presence</span></span>  | <span data-ttu-id="d1027-135">先前設定的 Proxy 身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-135">Proxy Identity Previously Set</span></span> | <span data-ttu-id="d1027-136"> (用戶端身分識別) 的 Proxy 身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-136">Proxy Identity (Client Identity)</span></span>                    |
|------------------------------------|------------------------|-------------------------------|-----------------------------------------------------|
| <span data-ttu-id="d1027-137">未設定掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-137">Cloaking not set</span></span><br/>        | <span data-ttu-id="d1027-138">別在意</span><span class="sxs-lookup"><span data-stu-id="d1027-138">Don't care</span></span><br/>  | <span data-ttu-id="d1027-139">別在意</span><span class="sxs-lookup"><span data-stu-id="d1027-139">Don't care</span></span><br/>         | <span data-ttu-id="d1027-140">進程權杖或驗證身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-140">Process token or authentication identity</span></span><br/> |
| <span data-ttu-id="d1027-141">EOAC \_ 靜態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-141">EOAC\_STATIC\_CLOAKING</span></span><br/>  | <span data-ttu-id="d1027-142">存在</span><span class="sxs-lookup"><span data-stu-id="d1027-142">Present</span></span><br/>     | <span data-ttu-id="d1027-143">No</span><span class="sxs-lookup"><span data-stu-id="d1027-143">No</span></span><br/>                 | <span data-ttu-id="d1027-144">執行緒 token</span><span class="sxs-lookup"><span data-stu-id="d1027-144">Thread token</span></span><br/>                             |
| <span data-ttu-id="d1027-145">EOAC \_ 靜態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-145">EOAC\_STATIC\_CLOAKING</span></span><br/>  | <span data-ttu-id="d1027-146">存在</span><span class="sxs-lookup"><span data-stu-id="d1027-146">Present</span></span><br/>     | <span data-ttu-id="d1027-147">Yes</span><span class="sxs-lookup"><span data-stu-id="d1027-147">Yes</span></span><br/>                | <span data-ttu-id="d1027-148">目前的 proxy 身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-148">Current proxy identity</span></span><br/>                   |
| <span data-ttu-id="d1027-149">EOAC \_ 靜態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-149">EOAC\_STATIC\_CLOAKING</span></span><br/>  | <span data-ttu-id="d1027-150">不存在</span><span class="sxs-lookup"><span data-stu-id="d1027-150">Not present</span></span><br/> | <span data-ttu-id="d1027-151">No</span><span class="sxs-lookup"><span data-stu-id="d1027-151">No</span></span><br/>                 | <span data-ttu-id="d1027-152">進程 token</span><span class="sxs-lookup"><span data-stu-id="d1027-152">Process token</span></span><br/>                            |
| <span data-ttu-id="d1027-153">EOAC \_ 靜態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-153">EOAC\_STATIC\_CLOAKING</span></span><br/>  | <span data-ttu-id="d1027-154">不存在</span><span class="sxs-lookup"><span data-stu-id="d1027-154">Not present</span></span><br/> | <span data-ttu-id="d1027-155">Yes</span><span class="sxs-lookup"><span data-stu-id="d1027-155">Yes</span></span><br/>                | <span data-ttu-id="d1027-156">目前的 proxy 身分識別</span><span class="sxs-lookup"><span data-stu-id="d1027-156">Current proxy identity</span></span><br/>                   |
| <span data-ttu-id="d1027-157">EOAC \_ 動態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-157">EOAC\_DYNAMIC\_CLOAKING</span></span><br/> | <span data-ttu-id="d1027-158">存在</span><span class="sxs-lookup"><span data-stu-id="d1027-158">Present</span></span><br/>     | <span data-ttu-id="d1027-159">別在意</span><span class="sxs-lookup"><span data-stu-id="d1027-159">Don't care</span></span><br/>         | <span data-ttu-id="d1027-160">執行緒 token</span><span class="sxs-lookup"><span data-stu-id="d1027-160">Thread token</span></span><br/>                             |
| <span data-ttu-id="d1027-161">EOAC \_ 動態 \_ 掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-161">EOAC\_DYNAMIC\_CLOAKING</span></span><br/> | <span data-ttu-id="d1027-162">不存在</span><span class="sxs-lookup"><span data-stu-id="d1027-162">Not present</span></span><br/> | <span data-ttu-id="d1027-163">別在意</span><span class="sxs-lookup"><span data-stu-id="d1027-163">Don't care</span></span> <br/>        | <span data-ttu-id="d1027-164">進程 token</span><span class="sxs-lookup"><span data-stu-id="d1027-164">Process token</span></span><br/>                            |



 

<span data-ttu-id="d1027-165">下列流程圖說明如何在不同的情況下判斷 proxy 身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-165">The following flowchart illustrates how the proxy identity is determined in different situations.</span></span>

![顯示判斷 proxy 身分識別流程的圖表。](images/9e8409b7-8475-4824-bdff-cf6b09c139c5.png)

## <a name="setting-cloaking"></a><span data-ttu-id="d1027-167">設定掩蓋</span><span class="sxs-lookup"><span data-stu-id="d1027-167">Setting Cloaking</span></span>

<span data-ttu-id="d1027-168">在呼叫 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)時，會將掩蓋設定為功能旗標，以設定整個進程的遮蓋。</span><span class="sxs-lookup"><span data-stu-id="d1027-168">Cloaking is set as a capability flag in a call to [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), which sets cloaking for the entire process.</span></span> <span data-ttu-id="d1027-169">接著會設定「掩蓋」功能，直到用戶端透過呼叫 IClientSecurity：：[**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) (或 [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)) （可設定 proxy 的遮蓋）來變更它。</span><span class="sxs-lookup"><span data-stu-id="d1027-169">The cloaking capability is then set until the client changes it through a call to IClientSecurity::[**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) (or to [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)), which sets cloaking for the proxy.</span></span>

<span data-ttu-id="d1027-170">根據預設，不會設定掩飾。</span><span class="sxs-lookup"><span data-stu-id="d1027-170">By default, cloaking is not set.</span></span> <span data-ttu-id="d1027-171">若要進行設定，請將 EOAC \_ 靜態 \_ 掩蓋或 EOAC \_ 動態 \_ 掩蔽傳遞給 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)或 [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)中的 *pCapabilities* 參數。</span><span class="sxs-lookup"><span data-stu-id="d1027-171">To set it, pass EOAC\_STATIC\_CLOAKING or EOAC\_DYNAMIC\_CLOAKING to the *pCapabilities* parameter in [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) or [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket).</span></span>

<span data-ttu-id="d1027-172">使用 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity)啟用靜態掩蓋時，當您第一次在 proxy 上進行呼叫時，每個 proxy 都會挑選權杖 (執行緒或進程) 。</span><span class="sxs-lookup"><span data-stu-id="d1027-172">When static cloaking is enabled using [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), each proxy picks up a token (thread or process) the first time you make a call on the proxy.</span></span> <span data-ttu-id="d1027-173">使用 [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)啟用靜態掩蓋時，proxy 會在該時間挑選執行緒上的權杖。</span><span class="sxs-lookup"><span data-stu-id="d1027-173">When static cloaking is enabled using [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket), the proxy picks up the token on the thread at that time.</span></span> <span data-ttu-id="d1027-174">如果呼叫 **SetBlanket** 時沒有可用的執行緒 token，則會使用進程權杖作為 proxy 的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-174">If no thread token is available when **SetBlanket** is called, the process token is used for the proxy's identity.</span></span> <span data-ttu-id="d1027-175">基本上， **SetBlanket** 會修正 proxy 的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-175">Basically, **SetBlanket** fixes the identity of the proxy.</span></span>

<span data-ttu-id="d1027-176">使用動態掩蓋時，無論使用 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) 或使用 [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket)來設定動態擬呼，proxy 的身分識別都會以相同的方式來決定。</span><span class="sxs-lookup"><span data-stu-id="d1027-176">With dynamic cloaking, the proxy's identity is determined the same way regardless of whether dynamic cloaking is set using [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) or with [**SetBlanket**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket).</span></span> <span data-ttu-id="d1027-177">如果有的話，則會使用目前的執行緒權杖;否則，會使用進程權杖。</span><span class="sxs-lookup"><span data-stu-id="d1027-177">The current thread token is used if there is one; otherwise, the process token is used.</span></span>

<span data-ttu-id="d1027-178">如果透過呼叫 [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) 來設定整個程式的掩蓋，而您想要使用進程權杖進行呼叫，則在進行呼叫時不會模擬。</span><span class="sxs-lookup"><span data-stu-id="d1027-178">If cloaking is set for the entire process through a call to [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and you want to make calls with the process token, do not impersonate while making calls.</span></span>

## <a name="cloaking-and-impersonation-levels"></a><span data-ttu-id="d1027-179">掩蓋和模擬層級</span><span class="sxs-lookup"><span data-stu-id="d1027-179">Cloaking and Impersonation Levels</span></span>

<span data-ttu-id="d1027-180">如先前所述，「掩蔽」功能會判斷在模擬期間向伺服器呈現的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-180">As mentioned previously, the cloaking capability determines what identity is presented to a server during impersonation.</span></span> <span data-ttu-id="d1027-181">「掩蓋」提供一種方式，讓伺服器將本身以外的身分識別投射到另一部代表用戶端呼叫的伺服器。</span><span class="sxs-lookup"><span data-stu-id="d1027-181">Cloaking provides a way for a server to project an identity other than its own to another server it is calling on behalf of the client.</span></span> <span data-ttu-id="d1027-182">模擬等級表示用戶端對伺服器提供多少授權單位。</span><span class="sxs-lookup"><span data-stu-id="d1027-182">The impersonation level indicates how much authority the client has given the server.</span></span>

<span data-ttu-id="d1027-183">沒有掩蓋的模擬可正常運作，但可能不是最佳選擇，因為在某些情況下，最終伺服器必須知道初始呼叫端的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-183">Impersonation without cloaking works, but it may not be the best choice because, in some cases, the final server needs to know the identity of the initial caller.</span></span> <span data-ttu-id="d1027-184">因為很難確保只有經過授權的用戶端可以存取遠端電腦，所以無法在不使用掩蓋的情況下達成此目的。</span><span class="sxs-lookup"><span data-stu-id="d1027-184">This cannot be achieved without using cloaking because it is difficult to ensure that only authorized clients can access a remote computer.</span></span> <span data-ttu-id="d1027-185">使用模擬而不會有掩蓋時，呈現給下游伺服器的身分識別就是立即呼叫程式的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-185">When impersonation is used without cloaking, the identity presented to a downstream server is that of the immediate calling process.</span></span>

<span data-ttu-id="d1027-186">不過，在沒有模擬的情況下，掩蓋並不有用。</span><span class="sxs-lookup"><span data-stu-id="d1027-186">However, cloaking is not useful without impersonation.</span></span> <span data-ttu-id="d1027-187">只有當用戶端已設定模擬或委派的模擬等級時，才會有意義。</span><span class="sxs-lookup"><span data-stu-id="d1027-187">Cloaking makes sense only when the client has set an impersonation level of impersonate or delegate.</span></span> <span data-ttu-id="d1027-188">使用較低的模擬層級 (，伺服器無法進行隱匿的呼叫。 ) 是否成功，取決於跨越的電腦界限數目和模擬等級，這表示伺服器必須代表用戶端執行多少授權單位。</span><span class="sxs-lookup"><span data-stu-id="d1027-188">(With lower impersonation levels, the server cannot make cloaked calls.) Whether cloaking is successful depends on the number of computer boundaries crossed and on the impersonation level, which indicates how much authority the server has to act on behalf of the client.</span></span>

<span data-ttu-id="d1027-189">在某些情況下，當用戶端將模擬層級設定為 RPC \_ C \_ IMP \_ 層級模擬時，伺服器就可以設定掩蓋 \_ 。</span><span class="sxs-lookup"><span data-stu-id="d1027-189">In some situations, it makes sense for the server to set cloaking when the client sets the impersonation level to RPC\_C\_IMP\_LEVEL\_IMPERSONATE.</span></span> <span data-ttu-id="d1027-190">不過，某些限制是有效的。</span><span class="sxs-lookup"><span data-stu-id="d1027-190">However, certain limitations are in effect.</span></span> <span data-ttu-id="d1027-191">如果原始用戶端將模擬層級設定為「RPC \_ C \_ IMP \_ 層級模擬」 \_ ，則轉送伺服器 (作為相同電腦上的用戶端) 只可在一個電腦界限上遮蓋。</span><span class="sxs-lookup"><span data-stu-id="d1027-191">If the original client sets the impersonation level to RPC\_C\_IMP\_LEVEL\_IMPERSONATE, the intermediate server (acting as a client on the same computer) can cloak across only one computer boundary.</span></span> <span data-ttu-id="d1027-192">這是因為模擬層級的模擬權杖只能跨一個電腦界限傳遞。</span><span class="sxs-lookup"><span data-stu-id="d1027-192">This is because an impersonate-level impersonation token can be passed across only one computer boundary.</span></span> <span data-ttu-id="d1027-193">超過電腦界限後，就只能存取本機資源。</span><span class="sxs-lookup"><span data-stu-id="d1027-193">After the computer boundary has been crossed, only local resources can be accessed.</span></span> <span data-ttu-id="d1027-194">呈現給伺服器的身分識別取決於所設定的遮蓋類型。</span><span class="sxs-lookup"><span data-stu-id="d1027-194">The identity presented to the server depends on the type of cloaking that is set.</span></span> <span data-ttu-id="d1027-195">如果未設定任何掩蓋，則呈現給伺服器的身分識別將會是發出立即呼叫的程式。</span><span class="sxs-lookup"><span data-stu-id="d1027-195">If no cloaking is set, the identity presented to a server will be that of the process making the immediate call.</span></span>

<span data-ttu-id="d1027-196">若要掩蔽多部電腦界限，您必須同時指定適當的隱匿功能旗標和委派層級模擬。</span><span class="sxs-lookup"><span data-stu-id="d1027-196">To cloak over multiple computer boundaries, you must specify both an appropriate cloaking capability flag and delegate-level impersonation.</span></span> <span data-ttu-id="d1027-197">使用這種類型的模擬時，會將用戶端的本機和網路認證提供給伺服器，因此模擬權杖可以跨越任意數量的電腦界限。</span><span class="sxs-lookup"><span data-stu-id="d1027-197">With this type of impersonation, both the local and network credentials of the client are given to the server, so the impersonation token can cross any number of computer boundaries.</span></span> <span data-ttu-id="d1027-198">同樣地，向伺服器出示的身分識別取決於設定的遮蓋類型。</span><span class="sxs-lookup"><span data-stu-id="d1027-198">Again, the identity presented to the server depends on the type of cloaking that is set.</span></span> <span data-ttu-id="d1027-199">如果沒有設定委派層級模擬的掩蓋，則呈現給伺服器的身分識別就是發出呼叫的進程。</span><span class="sxs-lookup"><span data-stu-id="d1027-199">If no cloaking is set with delegate-level impersonation, the identity presented to a server is that of the process making the call.</span></span>

<span data-ttu-id="d1027-200">例如，假設處理 A 呼叫 B，而 B 呼叫 C. B 已設定了掩蓋，而 A 已將模擬層級設定為模擬。</span><span class="sxs-lookup"><span data-stu-id="d1027-200">For example, suppose Process A calls B, and B calls C. B has set cloaking and A has set the impersonation level to impersonate.</span></span> <span data-ttu-id="d1027-201">如果 A、B 和 C 是在同一部電腦上，則將模擬權杖從 A 傳遞到 B，然後將可運作。</span><span class="sxs-lookup"><span data-stu-id="d1027-201">If A, B, and C are on the same computer, passing the impersonation token from A to B and then to C will work.</span></span> <span data-ttu-id="d1027-202">但是，如果和 C 是在同一部電腦上，而 B 不是，則傳遞權杖將會在 A 和 B 之間運作，而不是從 B 到 C。從 B 到 C 的呼叫將會失敗，因為 B 在遮蓋時無法呼叫 C。</span><span class="sxs-lookup"><span data-stu-id="d1027-202">But if A and C are on the same computer, and B is not, passing the token will work between A and B, but not from B to C. The call from B to C will fail because B cannot call C while cloaking.</span></span> <span data-ttu-id="d1027-203">但是，如果將模擬層級設定為委派，則權杖可以從 B 傳遞到 C，而且呼叫可能會成功。</span><span class="sxs-lookup"><span data-stu-id="d1027-203">However, if A sets the impersonation level to delegate, the token can be passed from B to C and the call may succeed.</span></span>

## <a name="cloaking-scenarios"></a><span data-ttu-id="d1027-204">掩蓋案例</span><span class="sxs-lookup"><span data-stu-id="d1027-204">Cloaking Scenarios</span></span>

<span data-ttu-id="d1027-205">在下圖中，處理 A 呼叫 B，呼叫 C，呼叫 D，但未設定掩飾。</span><span class="sxs-lookup"><span data-stu-id="d1027-205">In the following illustration, Process A calls B, calls C, calls D when cloaking is not set.</span></span> <span data-ttu-id="d1027-206">因此，每個中繼程式都會看到呼叫它的進程的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-206">As a result, each intermediate process sees the identity of the process that called it.</span></span>

![顯示未設定遮蓋時之進程的圖表。](images/0d2eb6cf-97d6-4c4e-b97e-abad854b1120.png)

<span data-ttu-id="d1027-208">使用靜態掩蓋時，伺服器會看到從用戶端到伺服器的第一次呼叫期間所設定的 proxy 身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-208">With static cloaking, the server sees the proxy identity that was set during the first call from the client to the server.</span></span> <span data-ttu-id="d1027-209">下圖顯示從 B 到 C 呼叫期間設定的 proxy 身分識別範例。在後續的呼叫中，當 B 和 C 設定靜態的掩蓋時，進程 D 會看到 B 的身分識別。</span><span class="sxs-lookup"><span data-stu-id="d1027-209">The following figure shows an example of the proxy identity being set during a call from B to C. On a subsequent call, Process D sees B's identity when static cloaking is set by B and C.</span></span>

![顯示靜態掩蓋進程的圖表。](images/520938e0-c4a6-4ac1-937d-02baf2007a27.png)

<span data-ttu-id="d1027-211">使用動態掩蓋時，在模擬期間呼叫端的身分識別是以目前的執行緒權杖為基礎（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="d1027-211">With dynamic cloaking, the identity of the caller during impersonation is based on the current thread token, if there is one.</span></span> <span data-ttu-id="d1027-212">下圖顯示 B 和 C 設定動態遮蓋的情況，而 D 則會看見的身分識別，儘管先前的呼叫是從 B 到 C。</span><span class="sxs-lookup"><span data-stu-id="d1027-212">The following illustration shows the situation where B and C set dynamic cloaking and D sees the identity of A, despite an earlier call from B to C.</span></span>

![顯示動態掩蓋流程的圖表。](images/d0848465-82f3-4d5a-851e-566d7800ada0.png)

## <a name="related-topics"></a><span data-ttu-id="d1027-214">相關主題</span><span class="sxs-lookup"><span data-stu-id="d1027-214">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d1027-215">委派和模擬</span><span class="sxs-lookup"><span data-stu-id="d1027-215">Delegation and Impersonation</span></span>](delegation-and-impersonation.md)
</dt> </dl>

 

