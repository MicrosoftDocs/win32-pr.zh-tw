---
title: COM 類別物件和 Clsid
description: COM 伺服器會實作為 COM 類別。
ms.assetid: 0073acdf-38a8-4f1a-aa26-379456a95fca
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1bbfde2f379c4c7589db4cde283c8c67d720b21d
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "106969120"
---
# <a name="com-class-objects-and-clsids"></a><span data-ttu-id="4191d-103">COM 類別物件和 Clsid</span><span class="sxs-lookup"><span data-stu-id="4191d-103">COM Class Objects and CLSIDs</span></span>

<span data-ttu-id="4191d-104">COM 伺服器會實作為 COM 類別。</span><span class="sxs-lookup"><span data-stu-id="4191d-104">A COM server is implemented as a COM class.</span></span> <span data-ttu-id="4191d-105">*COM 類別* 是在每次與指定物件互動時，執行程式碼中的一組介面。</span><span class="sxs-lookup"><span data-stu-id="4191d-105">A *COM class* is an implementation of a group of interfaces in code executed whenever you interact with a given object.</span></span> <span data-ttu-id="4191d-106">C + + 類別和 COM 類別之間有一個重要的差異：在 c + + 中，類別是型別，而 COM 類別只是物件的定義，而且沒有任何型別，不過 c + + 程式設計人員可以使用 c + + 類別來執行它。</span><span class="sxs-lookup"><span data-stu-id="4191d-106">There is an important distinction between a C++ class and a COM class: In C++, a class is a type, while a COM class is simply a definition of the object and carries no type, although a C++ programmer might implement it by using a C++ class.</span></span> <span data-ttu-id="4191d-107">COM 的設計目的是要讓不同的應用程式使用類別，包括不知道該特定類別是否存在而撰寫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4191d-107">COM is designed to allow a class to be used by different applications, including applications written without knowledge of that particular class's existence.</span></span> <span data-ttu-id="4191d-108">因此，指定物件類型的類別程式碼存在於動態連結程式庫 (DLL) 或其他可執行檔應用程式 (EXE) 中。</span><span class="sxs-lookup"><span data-stu-id="4191d-108">Therefore, class code for a given type of object exists either in a dynamic linked library (DLL) or in another executable application (EXE).</span></span>

<span data-ttu-id="4191d-109">每個 COM 類別都是由 *CLSID*（伺服器必須註冊的唯一128位 GUID）所識別。</span><span class="sxs-lookup"><span data-stu-id="4191d-109">Each COM class is identified by a *CLSID*, a unique 128-bit GUID, which the server must register.</span></span> <span data-ttu-id="4191d-110">COM 會在用戶端要求時使用此 CLSID，將特定資料與包含可執行類別之程式碼的 DLL 或 EXE 產生關聯，進而建立物件的實例。</span><span class="sxs-lookup"><span data-stu-id="4191d-110">COM uses this CLSID, at the request of a client, to associate specific data with the DLL or EXE containing the code that implements the class, thus creating an instance of the object.</span></span>

<span data-ttu-id="4191d-111">針對相同電腦上的用戶端和伺服器，伺服器的 CLSID 是用戶端的所有需求。</span><span class="sxs-lookup"><span data-stu-id="4191d-111">For clients and servers on the same computer, the CLSID of the server is all the client ever needs.</span></span> <span data-ttu-id="4191d-112">在每部電腦上，COM 會維護一個資料庫 (它會在安裝于系統上的伺服器之所有 Clsid 的所有 Clsid) 使用 Microsoft Windows 和 Macintosh 平臺上的系統登錄。</span><span class="sxs-lookup"><span data-stu-id="4191d-112">On each computer, COM maintains a database (it makes use of the system registry on Microsoft Windows and Macintosh platforms) of all the CLSIDs for the servers installed on the system.</span></span> <span data-ttu-id="4191d-113">這是每個 CLSID 和 DLL 或 EXE （裝載該 CLSID 的程式碼）的位置之間的對應。</span><span class="sxs-lookup"><span data-stu-id="4191d-113">This is a mapping between each CLSID and the location of the DLL or EXE that houses the code for that CLSID.</span></span> <span data-ttu-id="4191d-114">當用戶端想要建立 COM 類別的實例並使用其服務時，COM 會參考此資料庫，因此用戶端永遠不需要知道程式碼在電腦上的絕對位置。</span><span class="sxs-lookup"><span data-stu-id="4191d-114">COM consults this database whenever a client wants to create an instance of a COM class and use its services, so the client never needs to know the absolute location of the code on the computer.</span></span>

<span data-ttu-id="4191d-115">若為分散式系統，COM 會提供登錄專案，讓遠端伺服器自行註冊以供用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="4191d-115">For distributed systems, COM provides registry entries that allow a remote server to register itself for use by a client.</span></span> <span data-ttu-id="4191d-116">雖然應用程式只需要知道伺服器的 CLSID，因為它們可以依賴登錄找出伺服器，但是 COM 可讓用戶端覆寫登錄專案並指定伺服器位置，以充分利用網路。</span><span class="sxs-lookup"><span data-stu-id="4191d-116">While applications need know only a server's CLSID, because they can rely on the registry to locate the server, COM allows clients to override registry entries and to specify server locations, to take full advantage of the network.</span></span> <span data-ttu-id="4191d-117"> (參閱 [尋找遠端物件](locating-a-remote-object.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="4191d-117">(See [Locating a Remote Object](locating-a-remote-object.md).)</span></span>

<span data-ttu-id="4191d-118">建立類別實例的基本方法是透過 COM *類別物件*。</span><span class="sxs-lookup"><span data-stu-id="4191d-118">The basic way to create an instance of a class is through a COM *class object*.</span></span> <span data-ttu-id="4191d-119">這只是一個中繼物件，可支援建立指定類別之新實例的通用功能。</span><span class="sxs-lookup"><span data-stu-id="4191d-119">This is simply an intermediate object that supports functions common to creating new instances of a given class.</span></span> <span data-ttu-id="4191d-120">大部分用來從 CLSID 建立物件的類別物件都支援 [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) 介面，也就是包含重要 [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) 方法的介面。</span><span class="sxs-lookup"><span data-stu-id="4191d-120">Most class objects used to create objects from a CLSID support the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface, an interface that includes the important [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) method.</span></span> <span data-ttu-id="4191d-121">您可以針對每個您提供要具現化的物件類別，執行 **IClassFactory** 介面。</span><span class="sxs-lookup"><span data-stu-id="4191d-121">You implement an **IClassFactory** interface for each class of object that you offer to be instantiated.</span></span> <span data-ttu-id="4191d-122"> (如需有關如何執行 **IClassFactory** 的詳細資訊，請參閱實 [IClassFactory](implementing-iclassfactory.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="4191d-122">(For more information about implementing **IClassFactory**, see [Implementing IClassFactory](implementing-iclassfactory.md).)</span></span>

> [!Note]  
> <span data-ttu-id="4191d-123">支援某些其他自訂類別 factory 介面的伺服器，並不需要特別支援 [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) 。</span><span class="sxs-lookup"><span data-stu-id="4191d-123">Servers that support some other custom class factory interface are not required to support [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) specifically.</span></span> <span data-ttu-id="4191d-124">不過，呼叫 [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) 以外的啟用函式 (例如 [**CoCreateInstanceEx**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex)) 需要伺服器支援 **IClassFactory**。</span><span class="sxs-lookup"><span data-stu-id="4191d-124">However, calls to activation functions other than [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) (such as [**CoCreateInstanceEx**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstanceex)) require that the server support **IClassFactory**.</span></span>

 

<span data-ttu-id="4191d-125">當用戶端想要建立伺服器物件的實例時，它會在 [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject)的呼叫中使用所需的物件 CLSID。</span><span class="sxs-lookup"><span data-stu-id="4191d-125">When a client wants to create an instance of the server's object, it uses the desired object's CLSID in a call to [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject).</span></span> <span data-ttu-id="4191d-126"> (此呼叫可以是直接或隱含的，透過其中一個物件建立協助程式函式。 ) 此函式會尋找與 CLSID 相關聯的程式碼，並建立類別物件，並提供所要求介面的指標。</span><span class="sxs-lookup"><span data-stu-id="4191d-126">(This call can be either direct or implicit, through one of the object creation helper functions.) This function locates the code associated with the CLSID, and creates a class object, and supplies a pointer to the interface requested.</span></span> <span data-ttu-id="4191d-127"> (**CoGetClassObject** 會採用指定用戶端所需介面指標的 *riid* 參數。 ) </span><span class="sxs-lookup"><span data-stu-id="4191d-127">(**CoGetClassObject** takes a *riid* param that specifies the client's desired interface pointer.)</span></span>

> [!Note]  
> <span data-ttu-id="4191d-128">COM 只有幾個函式，許多其他函式都已建立。</span><span class="sxs-lookup"><span data-stu-id="4191d-128">COM has just a few functions upon which many of the others are built.</span></span> <span data-ttu-id="4191d-129">其中最重要的可能是 [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject)，其基礎是所有實例建立功能。</span><span class="sxs-lookup"><span data-stu-id="4191d-129">The most important of these is probably [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject), which underlies all of the instance creation functions.</span></span>

 

<span data-ttu-id="4191d-130">使用這個指標，呼叫端就可以建立物件的實例，並取得物件上所要求介面的指標。</span><span class="sxs-lookup"><span data-stu-id="4191d-130">With this pointer, the caller can create an instance of the object and retrieve a pointer to a requested interface on the object.</span></span> <span data-ttu-id="4191d-131">這通常是初始化介面，用來啟始物件 (將它置於執行中狀態) ，讓用戶端可以使用它想要的物件來執行任何工作。</span><span class="sxs-lookup"><span data-stu-id="4191d-131">This is usually an initialization interface, used to activate the object (put it in the running state) so that the client can do whatever work with the object that it wants to.</span></span> <span data-ttu-id="4191d-132">使用 COM 的基本函數時，用戶端也必須小心釋放所有物件指標。</span><span class="sxs-lookup"><span data-stu-id="4191d-132">Using COM's basic functions, the client must also take care to release all object pointers.</span></span>

<span data-ttu-id="4191d-133">啟用物件實例的另一個機制是透過類別標記。</span><span class="sxs-lookup"><span data-stu-id="4191d-133">Another mechanism for activating object instances is through the class moniker.</span></span> <span data-ttu-id="4191d-134">類別標記系結至其所建立之類別的類別物件。</span><span class="sxs-lookup"><span data-stu-id="4191d-134">Class monikers bind to the class object of the class for which they are created.</span></span> <span data-ttu-id="4191d-135">如需詳細資訊，請參閱 [類別的名字](class-monikers.md)。</span><span class="sxs-lookup"><span data-stu-id="4191d-135">For more information, see [Class Monikers](class-monikers.md).</span></span>

<span data-ttu-id="4191d-136">COM 提供數個協助程式函數，可減少建立物件實例的工作。</span><span class="sxs-lookup"><span data-stu-id="4191d-136">COM provides several helper functions that reduce the work of creating object instances.</span></span> <span data-ttu-id="4191d-137">這些會在 [實例建立](instance-creation-helper-functions.md)協助程式函式中描述。</span><span class="sxs-lookup"><span data-stu-id="4191d-137">These are described in [Instance Creation Helper Functions](instance-creation-helper-functions.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="4191d-138">相關主題</span><span class="sxs-lookup"><span data-stu-id="4191d-138">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4191d-139">透過類別物件建立物件</span><span class="sxs-lookup"><span data-stu-id="4191d-139">Creating an Object Through a Class Object</span></span>](creating-an-object-through-a-class-object.md)
</dt> </dl>

 

 