---
title: Inter-Object 通訊
description: COM 的設計目的是為了讓用戶端能夠以透明的方式與物件進行通訊，而不論這些物件是在相同的進程、同一部電腦或不同的電腦上執行。
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104093344"
---
# <a name="inter-object-communication"></a><span data-ttu-id="3a9ad-103">Inter-Object 通訊</span><span class="sxs-lookup"><span data-stu-id="3a9ad-103">Inter-Object Communication</span></span>

<span data-ttu-id="3a9ad-104">COM 的設計目的是為了讓用戶端能夠以透明的方式與物件進行通訊，無論這些物件是在相同的進程、同一部電腦或不同的電腦上 runningâ。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-104">COM is designed to allow clients to communicate transparently with objects, regardless of where those objects are runningâ€”in the same process, on the same computer, or on a different computer.</span></span> <span data-ttu-id="3a9ad-105">這會針對所有類型的物件，以及物件用戶端和物件服務器，提供單一程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-105">This provides a single programming model for all types of objects, and for both object clients and object servers.</span></span>

<span data-ttu-id="3a9ad-106">從用戶端的觀點來看，所有物件都是透過介面指標來存取。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-106">From a client's point of view, all objects are accessed through interface pointers.</span></span> <span data-ttu-id="3a9ad-107">指標必須為同進程。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-107">A pointer must be in-process.</span></span> <span data-ttu-id="3a9ad-108">事實上，任何對介面函式的呼叫一律會先到達某個進程內程式碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-108">In fact, any call to an interface function always reaches some piece of in-process code first.</span></span> <span data-ttu-id="3a9ad-109">如果物件是同進程，則呼叫會直接抵達它，而不會有中間的系統基礎結構程式碼。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-109">If the object is in-process, the call reaches it directly, with no intervening system-infrastructure code.</span></span> <span data-ttu-id="3a9ad-110">如果物件是跨進程，則呼叫會先達到 COM 或物件所提供的「proxy」物件 (如果實作項希望) 。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-110">If the object is out-of-process, the call first reaches what is called a "proxy" object provided either by COM or by the object (if the implementor wishes).</span></span> <span data-ttu-id="3a9ad-111">Proxy 封裝呼叫參數 (包括) 的任何介面指標，以及產生適當的遠端程序呼叫， (或在自訂產生的 proxy) 到其他進程或物件執行所在的另一部電腦時的其他通訊機制。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-111">The proxy packages call parameters (including any interface pointers) and generate the appropriate remote procedure call (or other communication mechanism in the case of custom generated proxies) to the other process or the other computer where the object implementation is located.</span></span> <span data-ttu-id="3a9ad-112">封裝指標以便跨進程界限傳輸的程式稱為 *封送* 處理。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-112">This process of packaging pointers for transmission across process boundaries is called *marshaling*.</span></span>

<span data-ttu-id="3a9ad-113">從伺服器的觀點來看，對物件介面函式的所有呼叫都是透過該介面的指標來進行。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-113">From a server's point of view, all calls to an object's interface functions are made through a pointer to that interface.</span></span> <span data-ttu-id="3a9ad-114">同樣地，指標只會在單一進程中包含內容，而呼叫端一律必須是同進程程式碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-114">Again, a pointer has context only in a single process, and the caller must always be some piece of in-process code.</span></span> <span data-ttu-id="3a9ad-115">如果物件是同進程，呼叫端就是用戶端本身。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-115">If the object is in-process, the caller is the client itself.</span></span> <span data-ttu-id="3a9ad-116">否則，呼叫端是由 COM 或物件本身提供的「存根」物件。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-116">Otherwise, the caller is a "stub" object provided either by COM or by the object itself.</span></span> <span data-ttu-id="3a9ad-117">當自訂產生的 proxy 從用戶端進程中的 "proxy") 、拆收參數，並在伺服器物件上呼叫適當的介面時，存根會接收遠端程序呼叫 (或其他通訊機制。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-117">The stub receives the remote procedure call (or other communication mechanism in the case of custom generated proxies) from the "proxy" in the client process, unmarshals the parameters, and calls the appropriate interface on the server object.</span></span> <span data-ttu-id="3a9ad-118">從用戶端和伺服器的觀點來看，它們一律會直接與其他的同進程程式碼進行通訊。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-118">From the points of view of both clients and servers, they always communicate directly with some other in-process code.</span></span>

<span data-ttu-id="3a9ad-119">COM 提供封送處理的執行，稱為 *標準封送處理*。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-119">COM provides an implementation of marshaling, referred to as *standard marshaling*.</span></span> <span data-ttu-id="3a9ad-120">這項處理非常適合大部分的物件，並大幅減少程式設計的需求，讓封送處理常式的效果更有效率。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-120">This implementation works very well for most objects and greatly reduces programming requirements, making the marshaling process effectively transparent.</span></span>

<span data-ttu-id="3a9ad-121">不過，在某些情況下，從 COM 的進程透明度的實來看，就能清楚地分隔介面。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-121">The clear separation of interface from implementation of COM's process transparency can, however, get in the way in some situations.</span></span> <span data-ttu-id="3a9ad-122">從用戶端的觀點來看，從用戶端的角度來看的介面設計，有時可能會導致設計決策與跨網路有效率地執行該介面。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-122">The design of an interface that focuses on its function from the client's point of view can sometimes lead to design decisions that conflict with efficient implementation of that interface across a network.</span></span> <span data-ttu-id="3a9ad-123">在這種情況下，您需要的是單純的進程透明度，但「處理透明度」，除非您需要在意。」</span><span class="sxs-lookup"><span data-stu-id="3a9ad-123">In cases like this, what is needed is not pure process transparency but "process transparency, unless you need to care."</span></span> <span data-ttu-id="3a9ad-124">COM 會提供這項功能，方法是允許物件實作項支援 *自訂封送處理* (也稱為 [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) 封送處理) 。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-124">COM provides this capability by allowing an object implementor to support *custom marshaling* (also called [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) marshaling).</span></span> <span data-ttu-id="3a9ad-125">事實上，標準封送處理是自訂封送處理的實例;它是物件不需要自訂封送處理時所使用的預設實值。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-125">Standard marshaling is, in fact, an instance of custom marshaling; it is the default implementation used when an object does not require custom marshaling.</span></span>

<span data-ttu-id="3a9ad-126">您可以執行自訂封送處理，以允許物件從網路使用不同的動作，而不是在本機存取的情況下使用，而且完全不會對用戶端進行透明處理。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-126">You can implement custom marshaling to allow an object to take different actions when used from across a network than it takes under local access and it is completely transparent to the client.</span></span> <span data-ttu-id="3a9ad-127">此架構可讓您設計用戶端/物件介面，而不需要考慮網路效能問題，之後也可以解決網路效能問題，而不會中斷所建立的設計。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-127">This architecture makes it possible to design client/object interfaces without regard to network performance issues and then later to address network performance issues without disrupting the established design.</span></span>

<span data-ttu-id="3a9ad-128">COM 不會指定元件的結構化方式;它會指定其互動方式。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-128">COM does not specify how components are structured; it specifies how they interact.</span></span> <span data-ttu-id="3a9ad-129">COM 會將元件內部結構的考慮留給程式設計語言和開發環境。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-129">COM leaves the concern about the internal structure of a component to programming languages and development environments.</span></span> <span data-ttu-id="3a9ad-130">相反地，程式設計環境沒有在立即應用程式之外使用物件的標準。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-130">Conversely, programming environments have no set standards for working with objects outside of the immediate application.</span></span> <span data-ttu-id="3a9ad-131">例如，Microsoft Visual C++ 很適合用來操作應用程式內的物件，但不支援在應用程式外部使用物件。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-131">Microsoft Visual C++, for example, works extremely well for manipulating objects inside an application but has no support for working with objects outside the application.</span></span> <span data-ttu-id="3a9ad-132">一般而言，所有其他程式設計語言在這方面都一樣。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-132">Generally, all other programming languages are the same in this regard.</span></span> <span data-ttu-id="3a9ad-133">因此，為了提供完備的互通性（COM），透過與語言無關的介面，會在程式設計語言離開的地方繼續進行。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-133">Therefore, to provide networkwide interoperability, COM, through language-independent interfaces, picks up where programming languages leave off.</span></span>

<span data-ttu-id="3a9ad-134">Vtbl 結構的雙重間接取值表示函式指標資料表中的指標不需要直接指向真正物件中的實際執行。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-134">The double indirection of the vtbl structure means that the pointers in the table of function pointers do not need to point directly to the real implementation in the real object.</span></span> <span data-ttu-id="3a9ad-135">這是進程透明度的核心。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-135">This is the heart of process transparency.</span></span>

<span data-ttu-id="3a9ad-136">如果是直接載入至用戶端進程的同進程伺服器，則資料表中的函式指標會直接指向實際的實作為。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-136">For in-process servers, where the object is loaded directly into the client process, the function pointers in the table point directly to the actual implementation.</span></span> <span data-ttu-id="3a9ad-137">在此情況下，從用戶端到介面方法的函式呼叫，會直接將執行控制傳送至方法。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-137">In this case, a function call from the client to an interface method directly transfers execution control to the method.</span></span> <span data-ttu-id="3a9ad-138">不過，這種情況無法用於本機、讓遠端、物件，因為進程間無法共用記憶體指標。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-138">However, this cannot work for local, let alone remote, objects because pointers to memory cannot be shared between processes.</span></span> <span data-ttu-id="3a9ad-139">然而，用戶端必須能夠呼叫介面方法，就像是呼叫實際的實值一樣。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-139">Nevertheless, the client must be able to call interface methods as if it were calling the actual implementation.</span></span> <span data-ttu-id="3a9ad-140">因此，用戶端會藉由進行呼叫，以一致的方式將控制權傳輸至某些物件中的方法。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-140">Thus, the client uniformly transfers control to a method in some object by making the call.</span></span>

<span data-ttu-id="3a9ad-141">用戶端一律會呼叫某些同進程物件中的介面方法。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-141">A client always calls interface methods in some in-process object.</span></span> <span data-ttu-id="3a9ad-142">如果實際的物件是本機或遠端，則會對 proxy 物件進行呼叫，然後對實際物件進行遠端程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-142">If the actual object is local or remote, the call is made to a proxy object, which then makes a remote procedure call to the actual object.</span></span>

<span data-ttu-id="3a9ad-143">那麼實際執行的是什麼方法？</span><span class="sxs-lookup"><span data-stu-id="3a9ad-143">So what method is actually executed?</span></span> <span data-ttu-id="3a9ad-144">答案是只要呼叫跨進程介面，每個介面方法都是由 proxy 物件所執行。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-144">The answer is that whenever there is a call to an out-of-process interface, each interface method is implemented by a proxy object.</span></span> <span data-ttu-id="3a9ad-145">Proxy 物件一律是代表所呼叫物件的同進程物件。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-145">The proxy object is always an in-process object that acts on behalf of the object being called.</span></span> <span data-ttu-id="3a9ad-146">這個 proxy 物件知道實際的物件是在本機或遠端伺服器上執行。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-146">This proxy object knows that the actual object is running in a local or remote server.</span></span>

<span data-ttu-id="3a9ad-147">Proxy 物件會封裝某些資料封包中的函式參數，並產生本機或遠端物件的 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-147">The proxy object packages up the function parameters in some data packets and generates an RPC call to the local or remote object.</span></span> <span data-ttu-id="3a9ad-148">在本機或遠端電腦上，伺服器進程中的存根物件會挑選該封包，解壓縮參數並對方法的實際執行進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-148">That packet is picked up by a stub object in the server's process on the local or a remote computer, which unpacks the parameters and makes the call to the real implementation of the method.</span></span> <span data-ttu-id="3a9ad-149">當該函式傳回時，存根會封裝任何 out 參數和傳回值，並將其傳回至 proxy，解壓縮它們並將它們傳回給原始用戶端。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-149">When that function returns, the stub packages up any out-parameters and the return value and sends it back to the proxy, which unpacks them and returns them to the original client.</span></span>

<span data-ttu-id="3a9ad-150">因此，用戶端和伺服器一律會彼此通訊，就好像所有專案都在同進程中一樣。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-150">Thus, client and server always talk to each other as if everything was in-process.</span></span> <span data-ttu-id="3a9ad-151">所有來自用戶端的呼叫，以及伺服器的所有呼叫，在某個時間點都是同進程。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-151">All calls from the client and all calls to the server are, at some point, in-process.</span></span> <span data-ttu-id="3a9ad-152">但因為 vtbl 結構允許某些代理程式（例如 COM）攔截所有函式呼叫，並從函式傳回所有的，所以該代理程式可以視需要將這些呼叫重新導向至 RPC 呼叫。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-152">But because the vtbl structure allows some agent, like COM, to intercept all function calls and all returns from functions, that agent can redirect those calls to an RPC call as necessary.</span></span> <span data-ttu-id="3a9ad-153">雖然同進程呼叫比跨進程呼叫更快，但處理常式差異對用戶端和伺服器而言完全是透明的。</span><span class="sxs-lookup"><span data-stu-id="3a9ad-153">Although in-process calls are faster than out-of-process calls, the process differences are completely transparent to the client and server.</span></span>

<span data-ttu-id="3a9ad-154">如需詳細資訊，請參閱下列主題：</span><span class="sxs-lookup"><span data-stu-id="3a9ad-154">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="3a9ad-155">封送處理詳細資料</span><span class="sxs-lookup"><span data-stu-id="3a9ad-155">Marshaling Details</span></span>](marshaling-details.md)
-   [<span data-ttu-id="3a9ad-156">Proxy</span><span class="sxs-lookup"><span data-stu-id="3a9ad-156">Proxy</span></span>](proxy.md)
-   [<span data-ttu-id="3a9ad-157">存根</span><span class="sxs-lookup"><span data-stu-id="3a9ad-157">Stub</span></span>](stub.md)
-   [<span data-ttu-id="3a9ad-158">通道</span><span class="sxs-lookup"><span data-stu-id="3a9ad-158">Channel</span></span>](channel.md)
-   [<span data-ttu-id="3a9ad-159">Microsoft RPC</span><span class="sxs-lookup"><span data-stu-id="3a9ad-159">Microsoft RPC</span></span>](microsoft-rpc.md)

## <a name="related-topics"></a><span data-ttu-id="3a9ad-160">相關主題</span><span class="sxs-lookup"><span data-stu-id="3a9ad-160">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3a9ad-161">COM 用戶端和伺服器</span><span class="sxs-lookup"><span data-stu-id="3a9ad-161">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="3a9ad-162">介面封送處理</span><span class="sxs-lookup"><span data-stu-id="3a9ad-162">Interface Marshaling</span></span>](interface-marshaling.md)
</dt> </dl>

 

 