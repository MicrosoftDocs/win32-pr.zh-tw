---
title: Inter-Object 通訊
description: COM 的設計目的是為了讓用戶端能夠以透明的方式與物件進行通訊，而不論這些物件是在相同的進程、同一部電腦或不同的電腦上執行。
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9356ba2bcb9dd3a6a56ac16c354f3abcb752d717
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104093344"
---
# <a name="inter-object-communication"></a>Inter-Object 通訊

COM 的設計目的是為了讓用戶端能夠以透明的方式與物件進行通訊，無論這些物件是在相同的進程、同一部電腦或不同的電腦上 runningâ。 這會針對所有類型的物件，以及物件用戶端和物件服務器，提供單一程式設計模型。

從用戶端的觀點來看，所有物件都是透過介面指標來存取。 指標必須為同進程。 事實上，任何對介面函式的呼叫一律會先到達某個進程內程式碼的一部分。 如果物件是同進程，則呼叫會直接抵達它，而不會有中間的系統基礎結構程式碼。 如果物件是跨進程，則呼叫會先達到 COM 或物件所提供的「proxy」物件 (如果實作項希望) 。 Proxy 封裝呼叫參數 (包括) 的任何介面指標，以及產生適當的遠端程序呼叫， (或在自訂產生的 proxy) 到其他進程或物件執行所在的另一部電腦時的其他通訊機制。 封裝指標以便跨進程界限傳輸的程式稱為 *封送* 處理。

從伺服器的觀點來看，對物件介面函式的所有呼叫都是透過該介面的指標來進行。 同樣地，指標只會在單一進程中包含內容，而呼叫端一律必須是同進程程式碼的一部分。 如果物件是同進程，呼叫端就是用戶端本身。 否則，呼叫端是由 COM 或物件本身提供的「存根」物件。 當自訂產生的 proxy 從用戶端進程中的 "proxy") 、拆收參數，並在伺服器物件上呼叫適當的介面時，存根會接收遠端程序呼叫 (或其他通訊機制。 從用戶端和伺服器的觀點來看，它們一律會直接與其他的同進程程式碼進行通訊。

COM 提供封送處理的執行，稱為 *標準封送處理*。 這項處理非常適合大部分的物件，並大幅減少程式設計的需求，讓封送處理常式的效果更有效率。

不過，在某些情況下，從 COM 的進程透明度的實來看，就能清楚地分隔介面。 從用戶端的觀點來看，從用戶端的角度來看的介面設計，有時可能會導致設計決策與跨網路有效率地執行該介面。 在這種情況下，您需要的是單純的進程透明度，但「處理透明度」，除非您需要在意。」 COM 會提供這項功能，方法是允許物件實作項支援 *自訂封送處理* (也稱為 [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) 封送處理) 。 事實上，標準封送處理是自訂封送處理的實例;它是物件不需要自訂封送處理時所使用的預設實值。

您可以執行自訂封送處理，以允許物件從網路使用不同的動作，而不是在本機存取的情況下使用，而且完全不會對用戶端進行透明處理。 此架構可讓您設計用戶端/物件介面，而不需要考慮網路效能問題，之後也可以解決網路效能問題，而不會中斷所建立的設計。

COM 不會指定元件的結構化方式;它會指定其互動方式。 COM 會將元件內部結構的考慮留給程式設計語言和開發環境。 相反地，程式設計環境沒有在立即應用程式之外使用物件的標準。 例如，Microsoft Visual C++ 很適合用來操作應用程式內的物件，但不支援在應用程式外部使用物件。 一般而言，所有其他程式設計語言在這方面都一樣。 因此，為了提供完備的互通性（COM），透過與語言無關的介面，會在程式設計語言離開的地方繼續進行。

Vtbl 結構的雙重間接取值表示函式指標資料表中的指標不需要直接指向真正物件中的實際執行。 這是進程透明度的核心。

如果是直接載入至用戶端進程的同進程伺服器，則資料表中的函式指標會直接指向實際的實作為。 在此情況下，從用戶端到介面方法的函式呼叫，會直接將執行控制傳送至方法。 不過，這種情況無法用於本機、讓遠端、物件，因為進程間無法共用記憶體指標。 然而，用戶端必須能夠呼叫介面方法，就像是呼叫實際的實值一樣。 因此，用戶端會藉由進行呼叫，以一致的方式將控制權傳輸至某些物件中的方法。

用戶端一律會呼叫某些同進程物件中的介面方法。 如果實際的物件是本機或遠端，則會對 proxy 物件進行呼叫，然後對實際物件進行遠端程序呼叫。

那麼實際執行的是什麼方法？ 答案是只要呼叫跨進程介面，每個介面方法都是由 proxy 物件所執行。 Proxy 物件一律是代表所呼叫物件的同進程物件。 這個 proxy 物件知道實際的物件是在本機或遠端伺服器上執行。

Proxy 物件會封裝某些資料封包中的函式參數，並產生本機或遠端物件的 RPC 呼叫。 在本機或遠端電腦上，伺服器進程中的存根物件會挑選該封包，解壓縮參數並對方法的實際執行進行呼叫。 當該函式傳回時，存根會封裝任何 out 參數和傳回值，並將其傳回至 proxy，解壓縮它們並將它們傳回給原始用戶端。

因此，用戶端和伺服器一律會彼此通訊，就好像所有專案都在同進程中一樣。 所有來自用戶端的呼叫，以及伺服器的所有呼叫，在某個時間點都是同進程。 但因為 vtbl 結構允許某些代理程式（例如 COM）攔截所有函式呼叫，並從函式傳回所有的，所以該代理程式可以視需要將這些呼叫重新導向至 RPC 呼叫。 雖然同進程呼叫比跨進程呼叫更快，但處理常式差異對用戶端和伺服器而言完全是透明的。

如需詳細資訊，請參閱下列主題：

-   [封送處理詳細資料](marshaling-details.md)
-   [Proxy](proxy.md)
-   [存根](stub.md)
-   [通道](channel.md)
-   [Microsoft RPC](microsoft-rpc.md)

## <a name="related-topics"></a>相關主題

<dl> <dt>

[COM 用戶端和伺服器](com-clients-and-servers.md)
</dt> <dt>

[介面封送處理](interface-marshaling.md)
</dt> </dl>

 

 