---
title: 管理參考計數的規則
description: 使用參考計數來管理物件的存留期，可讓多個用戶端取得和釋放單一物件的存取權，而不需要在管理物件的存留期時彼此協調。
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382922"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="12390-103">管理參考計數的規則</span><span class="sxs-lookup"><span data-stu-id="12390-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="12390-104">使用參考計數來管理物件的存留期，可讓多個用戶端取得和釋放單一物件的存取權，而不需要在管理物件的存留期時彼此協調。</span><span class="sxs-lookup"><span data-stu-id="12390-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="12390-105">只要用戶端物件符合特定的使用規則，物件實際上就會提供這項管理。</span><span class="sxs-lookup"><span data-stu-id="12390-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="12390-106">這些規則會指定如何管理物件間的參考。</span><span class="sxs-lookup"><span data-stu-id="12390-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="12390-107"> (COM 不會指定物件的內部執行，不過這些規則是物件內原則的合理起點。 ) </span><span class="sxs-lookup"><span data-stu-id="12390-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="12390-108">就概念而言，介面指標可視為位於指標變數內，這些變數包含所有保留介面指標的內部計算狀態。</span><span class="sxs-lookup"><span data-stu-id="12390-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="12390-109">這會包含記憶體位置、內部處理器暫存器中的變數，以及程式設計人員產生和編譯器產生的變數。</span><span class="sxs-lookup"><span data-stu-id="12390-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="12390-110">指派給指標變數或將其初始化，需要建立已存在之指標的新複本。</span><span class="sxs-lookup"><span data-stu-id="12390-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="12390-111">其中某個變數中有一個指標複本 (指派/初始化) 中所使用的值，現在有兩個。</span><span class="sxs-lookup"><span data-stu-id="12390-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="12390-112">指標變數的指派會終結目前變數中的指標複製，如同變數本身的終結。</span><span class="sxs-lookup"><span data-stu-id="12390-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="12390-113"> (也就是已終結變數的範圍，例如堆疊框架。 ) </span><span class="sxs-lookup"><span data-stu-id="12390-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="12390-114">從 COM 用戶端的觀點來看，一律會針對每個介面進行參考計數。</span><span class="sxs-lookup"><span data-stu-id="12390-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="12390-115">用戶端絕對不應假設物件對所有介面都使用相同的計數器。</span><span class="sxs-lookup"><span data-stu-id="12390-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="12390-116">預設的情況是必須針對每個介面指標的新複本呼叫 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) ，而且必須針對介面指標的每個終結來呼叫 [**版本**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) ，除非下列規則允許的情況：</span><span class="sxs-lookup"><span data-stu-id="12390-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="12390-117">**函數的 out 參數。**</span><span class="sxs-lookup"><span data-stu-id="12390-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="12390-118">呼叫端必須在參數上呼叫 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) ，因為當 out 值儲存在其上方時，將會在執行程式碼中釋放 (的 [**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) 呼叫。</span><span class="sxs-lookup"><span data-stu-id="12390-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="12390-119">**提取全域變數。**</span><span class="sxs-lookup"><span data-stu-id="12390-119">**Fetching a global variable.**</span></span> <span data-ttu-id="12390-120">從全域變數中現有的指標複本建立介面指標的本機複本時，您必須在本機複本上呼叫 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) ，因為當本機複本仍然有效時，另一個函數可能會損毀全域變數中的複本。</span><span class="sxs-lookup"><span data-stu-id="12390-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="12390-121">**新的指標，合成「超薄空氣」。**</span><span class="sxs-lookup"><span data-stu-id="12390-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="12390-122">使用特殊內部知識會合成介面指標的函式，而不是從其他來源取得介面指標，必須一開始就在新合成的指標上呼叫 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 。</span><span class="sxs-lookup"><span data-stu-id="12390-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="12390-123">這類常式的重要範例包括實例建立常式、 [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q))的執行等等。</span><span class="sxs-lookup"><span data-stu-id="12390-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="12390-124">**正在抓取內部儲存指標的複本。**</span><span class="sxs-lookup"><span data-stu-id="12390-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="12390-125">當函式抓取由呼叫的物件在內部儲存的指標複本時，該物件的程式碼必須在函式傳回之前呼叫指標上的 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 。</span><span class="sxs-lookup"><span data-stu-id="12390-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="12390-126">一旦已抓取指標，原始物件就沒有其他方法可判斷其存留期與內部儲存之指標複本的相關程度。</span><span class="sxs-lookup"><span data-stu-id="12390-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="12390-127">預設情況的唯一例外狀況是，管理程式碼必須知道物件的兩個或多個複本之存留期的關聯性，並藉由允許其參考計數移至零來確定物件未終結。</span><span class="sxs-lookup"><span data-stu-id="12390-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="12390-128">通常有兩種情況，如下所示：</span><span class="sxs-lookup"><span data-stu-id="12390-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="12390-129">當指標的其中一個複本已存在，且後續建立第二個複本，然後在第一個複本仍然存在時終結，則可以省略第二個複本的 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 和 [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)呼叫。</span><span class="sxs-lookup"><span data-stu-id="12390-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="12390-130">當有一份指標存在並建立第二個複本，然後在第二個複本上被終結時，就會省略第二個複本的 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)呼叫，並在第二個複本 [**釋放**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 。</span><span class="sxs-lookup"><span data-stu-id="12390-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="12390-131">以下是這些情況的特定範例，前兩個特別常見：</span><span class="sxs-lookup"><span data-stu-id="12390-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="12390-132">**函數中的參數。**</span><span class="sxs-lookup"><span data-stu-id="12390-132">**In parameters to functions.**</span></span> <span data-ttu-id="12390-133">當做參數傳遞至函式之介面指標的複本存留期，會以用來初始化值之指標的形式進行嵌套，因此，不需要在參數上有個別的參考計數。</span><span class="sxs-lookup"><span data-stu-id="12390-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="12390-134">**函數中的 Out 參數，包括傳回值。**</span><span class="sxs-lookup"><span data-stu-id="12390-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="12390-135">若要設定 out 參數，函式必須有介面指標的穩定複本。</span><span class="sxs-lookup"><span data-stu-id="12390-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="12390-136">傳回時，呼叫端會負責釋放指標。</span><span class="sxs-lookup"><span data-stu-id="12390-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="12390-137">因此，out 參數不需要個別的參考計數。</span><span class="sxs-lookup"><span data-stu-id="12390-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="12390-138">**區域變數。**</span><span class="sxs-lookup"><span data-stu-id="12390-138">**Local variables.**</span></span> <span data-ttu-id="12390-139">方法執行可控制堆疊框架上所配置之每個指標變數的存留期，並且可以用來判斷如何省略多餘的 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) / [**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)組。</span><span class="sxs-lookup"><span data-stu-id="12390-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="12390-140">**Backpointers.**</span><span class="sxs-lookup"><span data-stu-id="12390-140">**Backpointers.**</span></span> <span data-ttu-id="12390-141">某些資料結構包含兩個物件，每個物件都有指向另一個的指標。</span><span class="sxs-lookup"><span data-stu-id="12390-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="12390-142">如果已知第一個物件的存留期包含第二個物件的存留期，則在第一個物件的第二個物件指標上不需要有參考計數。</span><span class="sxs-lookup"><span data-stu-id="12390-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="12390-143">通常，避免這個迴圈對於維護適當的解除配置行為相當重要。</span><span class="sxs-lookup"><span data-stu-id="12390-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="12390-144">不過，微調指標應謹慎使用，因為處理遠端處理的作業系統部分無法得知此關聯性。</span><span class="sxs-lookup"><span data-stu-id="12390-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="12390-145">因此，在幾乎所有情況下，讓 backpointer 看到第一個指標的第二個 "friend" 物件 (因此避免迴圈) 是慣用的解決方案。</span><span class="sxs-lookup"><span data-stu-id="12390-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="12390-146">例如，COM 的可連線物件架構會使用這種方法。</span><span class="sxs-lookup"><span data-stu-id="12390-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="12390-147">當您在執行或使用參考計數的物件時，套用 *人工參考計數* 可能會很有用，這可保證處理函式期間的物件穩定性。</span><span class="sxs-lookup"><span data-stu-id="12390-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="12390-148">在執行介面的方法時，您可能會呼叫有機會將您的參考計數遞減至物件的函式，而導致物件過早釋放和執行失敗。</span><span class="sxs-lookup"><span data-stu-id="12390-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="12390-149">若要避免這種情況，最好的方法是在方法執行的開頭插入 [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 的呼叫，並將它與在方法傳回之前的 [**版本**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 呼叫配對。</span><span class="sxs-lookup"><span data-stu-id="12390-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="12390-150">在某些情況下， [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 和 [**發行**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 的傳回值可能不穩定，因此不應該依賴;它們只能用於偵測或診斷用途。</span><span class="sxs-lookup"><span data-stu-id="12390-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="12390-151">相關主題</span><span class="sxs-lookup"><span data-stu-id="12390-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="12390-152">透過參考計數來管理物件存留期</span><span class="sxs-lookup"><span data-stu-id="12390-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 