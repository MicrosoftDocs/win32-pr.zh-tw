---
title: 介面和介面的實現
description: COM 會在介面定義和其實作為之間進行基本的區別。
ms.assetid: f50b3e8f-bf87-4525-b47b-96e75b3a05b9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: db8df92ac8b851925d82a4b03505fa4c5ab3dc39
ms.sourcegitcommit: 80d74c0bf4fc402865a1ad223480abe1ce4d1115
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/12/2020
ms.locfileid: "104023145"
---
# <a name="interfaces-and-interface-implementations"></a>介面和介面的實現

COM 會在介面定義和其實作為之間進行基本的區別。

*介面* 實際上是由一組相關的函式原型所組成的合約，其使用方式是已定義的，但其執行不是。 這些函數原型相當於 c + + 程式設計中的純虛擬基類。 介面定義會指定介面的成員函式，稱為 *方法*、其傳回類型、參數的數目和類型，以及它們必須做的動作。 沒有與介面相關聯的執行。

*介面實* 作為程式設計師提供的程式碼，用來執行介面定義中指定的動作。 程式設計人員可以在以物件為基礎的應用程式中使用的許多介面，都包含在 COM 程式庫中。 不過，程式設計人員可以自由地忽略這些實作為並撰寫自己的。 當建立物件的實例時，介面的執行會與物件產生關聯，而該執行會提供物件所提供的服務。

例如，名為 IStack 的假設介面可能會定義兩個方法，名為 Push 和 Pop，指定連續呼叫 Pop 方法會以反向順序傳回先前傳遞給 Push 方法的值。 此介面定義不會指定如何在程式碼中執行函數。 在執行介面時，程式設計人員可能會將堆疊實作為陣列，並以存取該陣列的方式來執行 Push 和 Pop 方法，而另一位程式設計人員可能會使用連結的清單，並據此執行方法。 無論推送和 Pop 方法的特定執行方式為何，IStack 介面指標的記憶體內標記法，以及用戶端所使用的，都完全由介面定義來決定。

簡單物件只支援單一介面。 更複雜的物件（例如内嵌物件）通常支援數個介面。 用戶端只能透過其中一個介面的指標存取 COM 物件，而後者可讓用戶端呼叫任何組成該介面的方法。 這些方法會決定用戶端如何使用物件的資料。

介面會定義物件與其用戶端之間的合約。 合約會指定必須與每個介面相關聯的方法，以及每個方法的行為在輸入和輸出方面必須有何關聯性。 合約通常不會定義如何在介面中執行方法。 合約的另一個重要層面是，如果物件支援介面，則必須以某種方式支援該介面的所有方法。 並非所有方法都必須執行某些動作。 如果物件不支援方法所隱含的函式，則其實作為簡單的傳回，或可能會傳回有意義的錯誤訊息，但這些方法必須存在。

## <a name="related-topics"></a>相關主題

<dl> <dt>

[COM 物件和介面](com-objects-and-interfaces.md)
</dt> </dl>

 

 




