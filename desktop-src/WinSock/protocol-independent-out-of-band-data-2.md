---
description: 資料流程通訊端抽象包括頻外 (OOB) 資料的概念。
ms.assetid: 1a517885-2688-421f-9389-2d329e5c3d56
title: Protocol-Independent 頻外資料
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a929f4273d9cc9f268a296b711649406622ca9b4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104318364"
---
# <a name="protocol-independent-out-of-band-data"></a><span data-ttu-id="8eed8-103">Protocol-Independent 頻外資料</span><span class="sxs-lookup"><span data-stu-id="8eed8-103">Protocol-Independent Out-of-Band Data</span></span>

<span data-ttu-id="8eed8-104">資料流程通訊端抽象包括頻外 (OOB) 資料的概念。</span><span class="sxs-lookup"><span data-stu-id="8eed8-104">The stream socket abstraction includes the notion of out of band (OOB) data.</span></span> <span data-ttu-id="8eed8-105">許多通訊協定允許某些內送資料的部分以某種方式標示為特殊，而這些特殊資料區塊可以傳遞給使用者，而不是正常的順序。</span><span class="sxs-lookup"><span data-stu-id="8eed8-105">Many protocols allow portions of incoming data to be marked as special in some way, and these special data blocks can be delivered to the user out of the normal sequence.</span></span> <span data-ttu-id="8eed8-106">範例包括在 x.500 和其他 OSI 通訊協定中的快速資料，以及 BSD UNIX 使用 TCP 的緊急資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-106">Examples include expedited data in X.25 and other OSI protocols, and urgent data in BSD UNIX's use of TCP.</span></span> <span data-ttu-id="8eed8-107">下一節會以與通訊協定無關的方式來說明 OOB 資料處理。</span><span class="sxs-lookup"><span data-stu-id="8eed8-107">The following section describes OOB data handling in a protocol-independent manner.</span></span> <span data-ttu-id="8eed8-108">使用 TCP 緊急資料實行的 OOB 資料討論，會遵循與通訊協定無關的說明。</span><span class="sxs-lookup"><span data-stu-id="8eed8-108">A discussion of OOB data implemented using TCP urgent data follows the protocol-independent explanation.</span></span> <span data-ttu-id="8eed8-109">在每個討論中，使用 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 也意指 [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom)、 [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv)和 [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom)，而 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) 的參考也適用于 [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect)。</span><span class="sxs-lookup"><span data-stu-id="8eed8-109">In each discussion, the use of [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) also implies [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom), [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv), and [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom), and references to [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) also apply to [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect).</span></span>

## <a name="protocol-independent-oob-data"></a><span data-ttu-id="8eed8-110">通訊協定獨立的 OOB 資料</span><span class="sxs-lookup"><span data-stu-id="8eed8-110">Protocol Independent OOB Data</span></span>

<span data-ttu-id="8eed8-111">OOB 資料是與每一對連接的串流通訊端相關聯的邏輯獨立傳輸通道。</span><span class="sxs-lookup"><span data-stu-id="8eed8-111">OOB data is a logically independent transmission channel associated with each pair of connected stream sockets.</span></span> <span data-ttu-id="8eed8-112">OOB 資料可能會與一般資料分開傳遞給使用者。</span><span class="sxs-lookup"><span data-stu-id="8eed8-112">OOB data may be delivered to the user independently of normal data.</span></span> <span data-ttu-id="8eed8-113">此抽象概念會定義 OOB 資料設施一次至少必須支援至少一個 OOB 資料區塊的可靠傳遞。</span><span class="sxs-lookup"><span data-stu-id="8eed8-113">The abstraction defines that the OOB data facilities must support the reliable delivery of at least one OOB data block at a time.</span></span> <span data-ttu-id="8eed8-114">此資料區塊可以包含至少一個位元組的資料，而且至少有一個 OOB 資料區塊可以在任何時間都擱置傳遞給使用者。</span><span class="sxs-lookup"><span data-stu-id="8eed8-114">This data block can contain at least one byte of data, and at least one OOB data block can be pending delivery to the user at any one time.</span></span> <span data-ttu-id="8eed8-115">針對支援頻外信號的通訊協定 (例如 TCP，其中緊急資料是以一般資料) 順序傳遞，系統通常會從一般資料流程中取出 OOB 資料，並將其個別儲存 (在標準資料流程) 中留出間距。</span><span class="sxs-lookup"><span data-stu-id="8eed8-115">For communications protocols that support in-band signaling (such as TCP, where the urgent data is delivered in sequence with the normal data), the system normally extracts the OOB data from the normal data stream and stores it separately (leaving a gap in the normal data stream).</span></span> <span data-ttu-id="8eed8-116">這可讓使用者依序接收 OOB 資料並依序接收該資料，而不需要緩衝所有的中間資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-116">This allows users to choose between receiving the OOB data in order and receiving it out of sequence without having to buffer all the intervening data.</span></span> <span data-ttu-id="8eed8-117">您可以查看頻外 (OOB) 資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-117">It is possible to peek at out-of-band (OOB) data.</span></span>

<span data-ttu-id="8eed8-118">使用者可以使用 [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) 或 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 函數搭配 **SIOCATMARK** IOCTL 來判斷是否有任何 OOB 資料正在等候讀取。</span><span class="sxs-lookup"><span data-stu-id="8eed8-118">A user can determine if any OOB data is waiting to be read using the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) or [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function with the **SIOCATMARK** IOCTL.</span></span> <span data-ttu-id="8eed8-119">若為通訊協定，則一般資料流程內 OOB 資料區塊位置的概念有意義，例如 TCP，Windows 通訊端服務提供者會維護概念性標記，指出一般資料流程內 OOB 資料最後一個位元組的位置。</span><span class="sxs-lookup"><span data-stu-id="8eed8-119">For protocols where the concept of the position of the OOB data block within the normal data stream is meaningful, such as TCP, a Windows Sockets service provider maintains a conceptual marker indicating the position of the last byte of OOB data within the normal data stream.</span></span> <span data-ttu-id="8eed8-120">這不是執行支援 **SIOCATMARK** 之 **ioctlsocket** 或 **WSAIoctl** 函數的必要項。</span><span class="sxs-lookup"><span data-stu-id="8eed8-120">This is not necessary for the implementation of the **ioctlsocket** or **WSAIoctl** functions that support **SIOCATMARK**.</span></span> <span data-ttu-id="8eed8-121">需要的是 OOB 資料的存在或不存在。</span><span class="sxs-lookup"><span data-stu-id="8eed8-121">The presence or absence of OOB data is all is required.</span></span>

<span data-ttu-id="8eed8-122">針對一般資料流程中 OOB 資料區塊位置的概念有意義的通訊協定，應用程式可能會以內嵌方式處理頻外資料，作為一般資料流程的一部分。</span><span class="sxs-lookup"><span data-stu-id="8eed8-122">For protocols where the concept of the position of the OOB data block within the normal data stream is meaningful, an application might process out-of-band data inline, as part of the normal data stream.</span></span> <span data-ttu-id="8eed8-123">這是藉由設定 socket 選項讓 \_ OOBINLINE 與 [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) 函式來達成。</span><span class="sxs-lookup"><span data-stu-id="8eed8-123">This is achieved by setting the socket option SO\_OOBINLINE with the [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) function.</span></span> <span data-ttu-id="8eed8-124">對於 OOB 資料區塊真正獨立于一般資料流程的其他通訊協定，嘗試設定 \_ OOBINLINE 會導致錯誤。</span><span class="sxs-lookup"><span data-stu-id="8eed8-124">For other protocols where the OOB data blocks are truly independent of the normal data stream, attempting to set SO\_OOBINLINE results in an error.</span></span> <span data-ttu-id="8eed8-125">應用程式可以使用 [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) 或 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 函式搭配 **SIOCATMARK** IOCTL，判斷是否有任何未讀取的 OOB 資料在標記前面。</span><span class="sxs-lookup"><span data-stu-id="8eed8-125">An application can use the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) or [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function with the **SIOCATMARK** IOCTL to determine whether there is any unread OOB data preceding the mark.</span></span> <span data-ttu-id="8eed8-126">例如，它可以使用這項資訊，藉由確保在適當的情況下捨棄資料流程中標示的所有資料，來重新同步處理其對等。</span><span class="sxs-lookup"><span data-stu-id="8eed8-126">For example, it can use this information to resynchronize with its peer by ensuring that all data up to the mark in the data stream is discarded when appropriate.</span></span>

<span data-ttu-id="8eed8-127">停用 \_ OOBINLINE 之後 (預設設定) ：</span><span class="sxs-lookup"><span data-stu-id="8eed8-127">With SO\_OOBINLINE disabled (the default setting):</span></span>

-   <span data-ttu-id="8eed8-128">\_如果應用程式已使用 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect)註冊通知，Windows 通訊端就會通知應用程式 fd OOB 事件， \_ 就像使用 FD READ 來通知一般資料存在一樣。</span><span class="sxs-lookup"><span data-stu-id="8eed8-128">Windows Sockets notifies an application of an FD\_OOB event, if the application registered for notification with [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect), in exactly the same way FD\_READ is used to notify of the presence of normal data.</span></span> <span data-ttu-id="8eed8-129">亦即， \_ 當 oob 資料到達時，會在沒有先前排入佇列的 oob 資料的情況下公佈 FD oob。</span><span class="sxs-lookup"><span data-stu-id="8eed8-129">That is, FD\_OOB is posted when OOB data arrives with no OOB data previously queued.</span></span> <span data-ttu-id="8eed8-130">\_當使用 MSG oob 旗標讀取資料時，也會公佈 FD oob， \_ 而某些 OOB 資料在讀取作業傳回之後仍會排入佇列。</span><span class="sxs-lookup"><span data-stu-id="8eed8-130">The FD\_OOB is also posted when data is read using the MSG\_OOB flag while some OOB data remains queued after the read operation has returned.</span></span> <span data-ttu-id="8eed8-131">FD \_ 讀取訊息不會針對 OOB 資料張貼。</span><span class="sxs-lookup"><span data-stu-id="8eed8-131">FD\_READ messages are not posted for OOB data.</span></span>
-   <span data-ttu-id="8eed8-132">如果 OOB 資料在通訊端上排入佇列，Windows 通訊端會從 [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) 傳回，並設定適當的 *exceptfds* 通訊端。</span><span class="sxs-lookup"><span data-stu-id="8eed8-132">Windows Sockets returns from [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) with the appropriate *exceptfds* socket set if OOB data is queued on the socket.</span></span>
-   <span data-ttu-id="8eed8-133">應用程式可以在任何時間使用訊息 OOB 呼叫 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) ， \_ 以讀取緊急資料區塊。</span><span class="sxs-lookup"><span data-stu-id="8eed8-133">The application can call [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) with MSG\_OOB to read the urgent data block at any time.</span></span> <span data-ttu-id="8eed8-134">OOB 資料的區塊會跳至佇列。</span><span class="sxs-lookup"><span data-stu-id="8eed8-134">The block of OOB data jumps the queue.</span></span>
-   <span data-ttu-id="8eed8-135">應用程式可以在沒有訊息 OOB 的情況下呼叫 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) ， \_ 以讀取正常資料流程。</span><span class="sxs-lookup"><span data-stu-id="8eed8-135">The application can call [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) without MSG\_OOB to read the normal data stream.</span></span> <span data-ttu-id="8eed8-136">OOB 資料區塊不會出現在具有一般資料的資料流程中。</span><span class="sxs-lookup"><span data-stu-id="8eed8-136">The OOB data block does not appear in the data stream with normal data.</span></span> <span data-ttu-id="8eed8-137">如果在任何 **接收** 呼叫之後仍保留 OOB 資料，Windows 通訊端會在 \_ 使用 [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select)時，使用 FD OOB 或 with *exceptfds* 來通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="8eed8-137">If OOB data remains after any call to **recv**, Windows Sockets notifies the application with FD\_OOB or with *exceptfds* when using [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select).</span></span>
-   <span data-ttu-id="8eed8-138">針對 OOB 資料在標準資料流程中具有位置的通訊協定，單一 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 作業不會跨越該位置。</span><span class="sxs-lookup"><span data-stu-id="8eed8-138">For protocols where the OOB data has a position within the normal data stream, a single [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) operation does not span that position.</span></span> <span data-ttu-id="8eed8-139">其中一個 **接收** 會傳回標記之前的一般資料，而第二次 **接收** 則需要在標記之後開始讀取資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-139">One **recv** returns the normal data before the mark, and a second **recv** is required to begin reading data after the mark.</span></span>

<span data-ttu-id="8eed8-140">\_啟用 OOBINLINE 之後：</span><span class="sxs-lookup"><span data-stu-id="8eed8-140">With SO\_OOBINLINE enabled:</span></span>

-   <span data-ttu-id="8eed8-141">\_未針對 oob 資料張貼 FD oob 訊息。</span><span class="sxs-lookup"><span data-stu-id="8eed8-141">FD\_OOB messages are not posted for OOB data.</span></span> <span data-ttu-id="8eed8-142">[**選取**](/windows/desktop/api/Winsock2/nf-winsock2-select)和 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect)函式的用途會將 OOB 資料視為正常，並藉由在 *readfds* 中設定通訊端，或分別傳送 FD \_ 讀取訊息來表示。</span><span class="sxs-lookup"><span data-stu-id="8eed8-142">OOB data is treated as normal for the purpose of the [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) functions, and indicated by setting the socket in *readfds* or by sending an FD\_READ message respectively.</span></span>
-   <span data-ttu-id="8eed8-143">應用程式無法呼叫[](/windows/desktop/api/winsock/nf-winsock-recv)具有 \_ 設定為讀取 oob 資料區塊之 MSG oob 旗標的接收。</span><span class="sxs-lookup"><span data-stu-id="8eed8-143">The application cannot call [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) with the MSG\_OOB flag set to read the OOB data block.</span></span> <span data-ttu-id="8eed8-144">傳回錯誤碼 WSAEINVAL。</span><span class="sxs-lookup"><span data-stu-id="8eed8-144">The error code WSAEINVAL is returned.</span></span>
-   <span data-ttu-id="8eed8-145">應用程式可以呼叫未設定 MSG OOB 旗標的 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) \_ 。</span><span class="sxs-lookup"><span data-stu-id="8eed8-145">The application can call [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) without the MSG\_OOB flag set.</span></span> <span data-ttu-id="8eed8-146">任何 OOB 資料在一般資料流程內都會以正確的順序傳遞。</span><span class="sxs-lookup"><span data-stu-id="8eed8-146">Any OOB data is delivered in its correct order within the normal data stream.</span></span> <span data-ttu-id="8eed8-147">OOB 資料永遠不會與一般資料混合。</span><span class="sxs-lookup"><span data-stu-id="8eed8-147">OOB data is never mixed with normal data.</span></span> <span data-ttu-id="8eed8-148">必須有三個讀取要求，才能取得過去的 OOB 資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-148">There must be three read requests to get past the OOB data.</span></span> <span data-ttu-id="8eed8-149">第一個會傳回 OOB 資料區塊之前的一般資料，第二個會傳回 OOB 資料，而第三個會傳回 oob 資料之後的一般資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-149">The first returns the normal data prior to the OOB data block, the second returns the OOB data, the third returns the normal data following the OOB data.</span></span> <span data-ttu-id="8eed8-150">換句話說，會保留 OOB 資料區塊界限。</span><span class="sxs-lookup"><span data-stu-id="8eed8-150">In other words, the OOB data block boundaries are preserved.</span></span>

<span data-ttu-id="8eed8-151">當 OOBINLINE 為 off 時， [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) 常式特別適合用來處理頻外資料存在的通知 \_ 。</span><span class="sxs-lookup"><span data-stu-id="8eed8-151">The [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) routine is particularly well suited to handling notification of the presence of out-of-band-data when SO\_OOBINLINE is off.</span></span>

## <a name="oob-data-in-tcp"></a><span data-ttu-id="8eed8-152">TCP 中的 OOB 資料</span><span class="sxs-lookup"><span data-stu-id="8eed8-152">OOB Data in TCP</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8eed8-153">以下討論使用 TCP 緊急資料執行的頻外資料 (OOB) ，會遵循 Berkeley software 散發套件中所使用的模型。</span><span class="sxs-lookup"><span data-stu-id="8eed8-153">The following discussion of out-of-band data (OOB), implemented using TCP urgent data, follows the model used in the Berkeley software distribution.</span></span> <span data-ttu-id="8eed8-154">使用者和實施者應該注意：</span><span class="sxs-lookup"><span data-stu-id="8eed8-154">Users and implementers should be aware that:</span></span>

 

-   <span data-ttu-id="8eed8-155">[RFC 793](https://www.ietf.org/rfc/rfc793.txt) (有兩個衝突的解釋，) 引進了概念。</span><span class="sxs-lookup"><span data-stu-id="8eed8-155">There are, at present, two conflicting interpretations of [RFC 793](https://www.ietf.org/rfc/rfc793.txt) (where the concept is introduced).</span></span>
-   <span data-ttu-id="8eed8-156">Berkeley Software 散發 (BSD) 中的 OOB 資料執行不符合 [RFC 1122](https://www.ietf.org/rfc/rfc1122.txt)中指定的主機需求。</span><span class="sxs-lookup"><span data-stu-id="8eed8-156">The implementation of OOB data in the Berkeley Software Distribution (BSD) does not conform to the Host Requirements specified in [RFC 1122](https://www.ietf.org/rfc/rfc1122.txt).</span></span>

    <span data-ttu-id="8eed8-157">具體而言，BSD 中的 TCP 緊急指標會指向緊急資料位元組之後的位元組，而 RFC 相容的 TCP 緊急指標則會指向緊急資料位元組。</span><span class="sxs-lookup"><span data-stu-id="8eed8-157">Specifically, the TCP urgent pointer in BSD points to the byte after the urgent data byte, and an RFC-compliant TCP urgent pointer points to the urgent data byte.</span></span> <span data-ttu-id="8eed8-158">因此，如果應用程式將來自 BSD 相容的執行的緊急資料傳送至與 RFC 1122 相容的執行，則接收者會讀取錯誤的緊急資料位元組 (它會讀取位於資料流程中正確位元組後面的位元組，以作為緊急資料位元組) 。</span><span class="sxs-lookup"><span data-stu-id="8eed8-158">As a result, if an application sends urgent data from a BSD-compatible implementation to an implementation compatible with RFC 1122, the receiver reads the wrong urgent data byte (it reads the byte located after the correct byte in the data stream as the urgent data byte).</span></span>

    <span data-ttu-id="8eed8-159">為了將互通性問題降到最低，建議應用程式寫入器不要使用 OOB 資料，除非這是與現有服務互通的必要項。</span><span class="sxs-lookup"><span data-stu-id="8eed8-159">To minimize interoperability problems, applications writers are advised not to use OOB data unless this is required to interoperate with an existing service.</span></span> <span data-ttu-id="8eed8-160">Windows 通訊端供應商的呼籲是要記錄其產品所實行的 OOB 語義 (BSD 或 RFC 1122) 。</span><span class="sxs-lookup"><span data-stu-id="8eed8-160">Windows Sockets suppliers are urged to document the OOB semantics (BSD or RFC 1122) that their product implements.</span></span>

<span data-ttu-id="8eed8-161">具有 URG (for 緊急) 旗標集合的 TCP 區段抵達，表示 TCP 資料流程內有單一位元組的 OOB 資料存在。</span><span class="sxs-lookup"><span data-stu-id="8eed8-161">The arrival of a TCP segment with the URG (for urgent) flag set indicates the existence of a single byte of OOB data within the TCP data stream.</span></span> <span data-ttu-id="8eed8-162">OOB 資料區塊的大小為一個位元組。</span><span class="sxs-lookup"><span data-stu-id="8eed8-162">The OOB data block is one byte in size.</span></span> <span data-ttu-id="8eed8-163">緊急指標是 TCP 標頭中目前序號的正數位移，表示 OOB 資料區塊 (不明確的位置，如先前) 所述。</span><span class="sxs-lookup"><span data-stu-id="8eed8-163">The urgent pointer is a positive offset from the current sequence number in the TCP header that indicates the location of the OOB data block (ambiguously, as noted in the preceding).</span></span> <span data-ttu-id="8eed8-164">因此，它可能會指向尚未收到的資料。</span><span class="sxs-lookup"><span data-stu-id="8eed8-164">It might, therefore, point to data that has not yet been received.</span></span>

<span data-ttu-id="8eed8-165">如果已 \_ 停用 OOBINLINE， (預設) 當 TCP 區段包含緊急指標所指向的位元組時，就會從資料流程中移除 OOB 資料區塊 (一個位元組) ，然後緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="8eed8-165">If SO\_OOBINLINE is disabled (the default) when the TCP segment containing the byte pointed to by the urgent pointer arrives, the OOB data block (one byte) is removed from the data stream and buffered.</span></span> <span data-ttu-id="8eed8-166">如果後續的 TCP 區段以緊急旗標設定 (，並) 新的緊急指標，則目前排入佇列的 OOB 位元組可能會遺失，因為新的 OOB 資料 (區塊會將它取代為 Berkeley 軟體散發) 中發生的情況。</span><span class="sxs-lookup"><span data-stu-id="8eed8-166">If a subsequent TCP segment arrives with the urgent flag set (and a new urgent pointer), the OOB byte currently queued can be lost as it is replaced by the new OOB data block (as occurs in Berkeley Software Distribution).</span></span> <span data-ttu-id="8eed8-167">但是，它永遠不會在資料流程中取代。</span><span class="sxs-lookup"><span data-stu-id="8eed8-167">It is never replaced in the data stream, however.</span></span>

<span data-ttu-id="8eed8-168">在 \_ 啟用 OOBINLINE 的情況下，緊急資料仍會保留在資料流程中。</span><span class="sxs-lookup"><span data-stu-id="8eed8-168">With SO\_OOBINLINE enabled, the urgent data remains in the data stream.</span></span> <span data-ttu-id="8eed8-169">因此，當新的 TCP 區段抵達包含緊急資料時，不會遺失 OOB 資料區塊。</span><span class="sxs-lookup"><span data-stu-id="8eed8-169">As a result, the OOB data block is never lost when a new TCP segment arrives containing urgent data.</span></span> <span data-ttu-id="8eed8-170">現有的 OOB 資料標記會更新為新的位置。</span><span class="sxs-lookup"><span data-stu-id="8eed8-170">The existing OOB data mark is updated to the new position.</span></span>

> [!Note]  
> <span data-ttu-id="8eed8-171">\_設定好 OOBINLINE 通訊端選項時，SIOCATMARK 的 IOCTL 一律會傳回 **TRUE**，而且 OOB 資料會以一般資料的形式傳回給使用者。</span><span class="sxs-lookup"><span data-stu-id="8eed8-171">When the SO\_OOBINLINE socket option is set, the SIOCATMARK IOCTL always returns **TRUE**, and OOB data is returned to the user as normal data.</span></span>

 

 

 



