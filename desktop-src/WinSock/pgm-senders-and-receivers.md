---
description: 建立 PGM 會話類似于與 TCP 會話相關聯的連接建立常式。
ms.assetid: 777e0106-0314-4ec8-b064-88ceb694614b
title: PGM 寄件者和接收者
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e300a0c9de199e1f836e71407caf6487812cf7b4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104511408"
---
# <a name="pgm-senders-and-receivers"></a><span data-ttu-id="c52c3-103">PGM 寄件者和接收者</span><span class="sxs-lookup"><span data-stu-id="c52c3-103">PGM Senders and Receivers</span></span>

<span data-ttu-id="c52c3-104">建立 PGM 會話類似于與 TCP 會話相關聯的連接建立常式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-104">Establishing a PGM session is similar to the connection establishment routine associated with a TCP session.</span></span> <span data-ttu-id="c52c3-105">不過，TCP 會話的重大起飛是反轉用戶端和伺服器的語義; (PGM 傳送者的伺服器) 連線到多播群組，而 (PGM 接收器的用戶端) 等待接受連線。</span><span class="sxs-lookup"><span data-stu-id="c52c3-105">The significant departure from a TCP session, however, is that the client and server semantics are reversed; the server (the PGM sender) connects to a multicast group, while the client (the PGM receiver) waits to accept a connection.</span></span> <span data-ttu-id="c52c3-106">下列段落詳細說明建立 PGM 傳送者和 PGM 接收器所需的程式設計步驟。</span><span class="sxs-lookup"><span data-stu-id="c52c3-106">The following paragraphs detail programmatic steps necessary for creating a PGM sender and a PGM receiver.</span></span> <span data-ttu-id="c52c3-107">此頁面也會說明適用于 PGM 會話的可用資料模式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-107">This page also describes the available data modes for PGM sessions.</span></span>

## <a name="pgm-sender"></a><span data-ttu-id="c52c3-108">PGM 寄件者</span><span class="sxs-lookup"><span data-stu-id="c52c3-108">PGM Sender</span></span>

<span data-ttu-id="c52c3-109">**若要建立 PGM 寄件者，請執行下列步驟**</span><span class="sxs-lookup"><span data-stu-id="c52c3-109">**To create a PGM sender, perform the following steps**</span></span>

1.  <span data-ttu-id="c52c3-110">建立 PGM 通訊端。</span><span class="sxs-lookup"><span data-stu-id="c52c3-110">Create a PGM socket.</span></span>
2.  <span data-ttu-id="c52c3-111">[](/windows/desktop/api/winsock/nf-winsock-bind)系結通訊端至 INADDR \_ ANY。</span><span class="sxs-lookup"><span data-stu-id="c52c3-111">[**bind**](/windows/desktop/api/winsock/nf-winsock-bind) the socket to INADDR\_ANY.</span></span>
3.  <span data-ttu-id="c52c3-112">[**連接**](/windows/desktop/api/Winsock2/nf-winsock2-connect) 到多播群組傳輸位址。</span><span class="sxs-lookup"><span data-stu-id="c52c3-112">[**connect**](/windows/desktop/api/Winsock2/nf-winsock2-connect) to the multicast group transmission address.</span></span>

<span data-ttu-id="c52c3-113">任何用戶端都不會執行正式的會話信號交換。</span><span class="sxs-lookup"><span data-stu-id="c52c3-113">No formal session handshaking is performed with any clients.</span></span> <span data-ttu-id="c52c3-114">連接程式類似于 UDP [**連接**](/windows/desktop/api/Winsock2/nf-winsock2-connect)，因為它會將端點位址 (多播群組) 與通訊端關聯。</span><span class="sxs-lookup"><span data-stu-id="c52c3-114">The connection process is similar to a UDP [**connect**](/windows/desktop/api/Winsock2/nf-winsock2-connect), in that it associates an endpoint address (the multicast group) with the socket.</span></span> <span data-ttu-id="c52c3-115">完成之後，資料可能會在通訊端上傳送。</span><span class="sxs-lookup"><span data-stu-id="c52c3-115">Once completed, data may be sent on the socket.</span></span>

<span data-ttu-id="c52c3-116">當傳送者建立 PGM 通訊端並將它連接到多播位址時，會建立一個 PGM 會話。</span><span class="sxs-lookup"><span data-stu-id="c52c3-116">When a sender creates a PGM socket and connects it to a multicast address, a PGM session is created.</span></span> <span data-ttu-id="c52c3-117">可靠的多播會話是由全域唯一識別碼 (GUID) 和來源埠的組合所定義。</span><span class="sxs-lookup"><span data-stu-id="c52c3-117">A reliable multicast session is defined by a combination of the globally unique identifier (GUID) and the source port.</span></span> <span data-ttu-id="c52c3-118">GUID 是由傳輸所產生。</span><span class="sxs-lookup"><span data-stu-id="c52c3-118">The GUID is generated by the transport.</span></span> <span data-ttu-id="c52c3-119">SSource 埠是由傳輸指定，不會提供使用來源埠的控制權。</span><span class="sxs-lookup"><span data-stu-id="c52c3-119">The sSource port is specified by the transport, and no control is provided over which source port is used.</span></span>

> [!Note]  
> <span data-ttu-id="c52c3-120">不允許接收傳送者通訊端上的資料，並產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c52c3-120">Receiving data on a sender socket is not allowed, and results in an error.</span></span>

 

<span data-ttu-id="c52c3-121">下列程式碼片段說明如何設定 PGM 寄件者：</span><span class="sxs-lookup"><span data-stu-id="c52c3-121">The following code snippet illustrates setting up a PGM sender:</span></span>


```C++

SOCKET        s;
SOCKADDR_IN   salocal, sasession;
int           dwSessionPort;

s = socket (AF_INET, SOCK_RDM, IPPROTO_RM);

salocal.sin_family = AF_INET;
salocal.sin_port   = htons (0);    // Port is ignored here
salocal.sin_addr.s_addr = htonl (INADDR_ANY);

bind (s, (SOCKADDR *)&salocal, sizeof(salocal));

//
// Set all relevant sender socket options here
//

//
// Now, connect <entity type="hellip"/>
// Setting the connection port (dwSessionPort) has relevance, and
// can be used to multiplex multiple sessions to the same
// multicast group address over different ports
//
dwSessionPort = 0;
sasession.sin_family = AF_INET;
sasession.sin_port   = htons (dwSessionPort);
sasession.sin_addr.s_addr = inet_addr ("234.5.6.7");

connect (s, (SOCKADDR *)&sasession, sizeof(sasession));

//
// We're now ready to send data!
//



```



## <a name="pgm-receiver"></a><span data-ttu-id="c52c3-122">PGM 接收器</span><span class="sxs-lookup"><span data-stu-id="c52c3-122">PGM Receiver</span></span>

<span data-ttu-id="c52c3-123">**若要建立 PGM 接收器，請執行下列步驟**</span><span class="sxs-lookup"><span data-stu-id="c52c3-123">**To create a PGM receiver, perform the following steps**</span></span>

1.  <span data-ttu-id="c52c3-124">建立 PGM 通訊端。</span><span class="sxs-lookup"><span data-stu-id="c52c3-124">Create a PGM socket.</span></span>
2.  <span data-ttu-id="c52c3-125">[**將套**](/windows/desktop/api/winsock/nf-winsock-bind) 接字系結至傳送者正在傳輸的多播群組位址。</span><span class="sxs-lookup"><span data-stu-id="c52c3-125">[**bind**](/windows/desktop/api/winsock/nf-winsock-bind) the socket to the multicast group address on which the sender is transmitting.</span></span>
3.  <span data-ttu-id="c52c3-126">呼叫通訊端上的 [**接聽**](/windows/desktop/api/Winsock2/nf-winsock2-listen) 函式，將通訊端置於接聽模式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-126">Call the [**listen**](/windows/desktop/api/Winsock2/nf-winsock2-listen) function on the socket to put the socket in listening mode.</span></span> <span data-ttu-id="c52c3-127">當在指定的多播群組位址和埠上偵測到 PGM 會話時，就會傳回接聽函式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-127">The listen function returns when a PGM session is detected on the specified multicast group address and port.</span></span>
4.  <span data-ttu-id="c52c3-128">呼叫 [**accept**](/windows/desktop/api/Winsock2/nf-winsock2-accept) 函數，以取得對應至會話的新通訊端控制碼。</span><span class="sxs-lookup"><span data-stu-id="c52c3-128">Call the [**accept**](/windows/desktop/api/Winsock2/nf-winsock2-accept) function to obtain a new socket handle corresponding to the session.</span></span>

<span data-ttu-id="c52c3-129">只有原始的 PGM 資料 (ODATA) 會觸發新的會話的接受。</span><span class="sxs-lookup"><span data-stu-id="c52c3-129">Only original PGM data (ODATA) triggers the acceptance of a new session.</span></span> <span data-ttu-id="c52c3-130">因此，傳輸可能會接收到其他的 PGM 流量 (例如 SPM 或 .RDATA 封包) ，但不會導致 [**接聽**](/windows/desktop/api/Winsock2/nf-winsock2-listen) 函數傳回。</span><span class="sxs-lookup"><span data-stu-id="c52c3-130">As such, other PGM traffic (such as SPM or RDATA packets) may be received by the transport, but do not result in the [**listen**](/windows/desktop/api/Winsock2/nf-winsock2-listen) function returning.</span></span>

<span data-ttu-id="c52c3-131">一旦接受會話之後，就會使用傳回的通訊端控制碼來接收資料。</span><span class="sxs-lookup"><span data-stu-id="c52c3-131">Once a session is accepted, the returned socket handle is used for receiving data.</span></span>

> [!Note]  
> <span data-ttu-id="c52c3-132">不允許在接收通訊端上傳送資料，而且會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c52c3-132">Sending data on a receive socket is not allowed, and results in an error.</span></span>

 

<span data-ttu-id="c52c3-133">下列程式碼片段說明如何設定 PGM 接收器：</span><span class="sxs-lookup"><span data-stu-id="c52c3-133">The following code snippet illustrates setting up a PGM receiver:</span></span>


```C++

SOCKET        s,
              sclient;
SOCKADDR_IN   salocal,
              sasession;
int           sasessionsz, dwSessionPort;

s = socket (AF_INET, SOCK_RDM, IPPROTO_RM);

//
// The bind port (dwSessionPort) specified should match that
// which the sender specified in the connect call
//
dwSessionPort = 0;
salocal.sin_family = AF_INET;
salocal.sin_port   = htons (dwSessionPort);    
salocal.sin_addr.s_addr = inet_addr ("234.5.6.7");

bind (s, (SOCKADDR *)&salocal, sizeof(salocal));

//
// Set all relevant receiver socket options here
//

listen (s, 10);

sasessionsz = sizeof(sasession);
sclient = accept (s, (SOCKADDR *)&sasession, &sasessionsz);

//
// accept will return the client socket and we are now ready
// to receive data on the new socket!
//



```



## <a name="data-modes"></a><span data-ttu-id="c52c3-134">資料模式</span><span class="sxs-lookup"><span data-stu-id="c52c3-134">Data Modes</span></span>

<span data-ttu-id="c52c3-135">PGM 會話有兩種資料模式選項：訊息模式和資料流程模式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-135">PGM sessions have two options for data modes: message mode and stream mode.</span></span>

<span data-ttu-id="c52c3-136">訊息模式適用于需要傳送離散訊息的應用程式，而且是由 SOCK RDM 的通訊端類型所指定 \_ 。</span><span class="sxs-lookup"><span data-stu-id="c52c3-136">Message mode is appropriate for applications that need to send discrete messages, and is specified by a socket type of SOCK\_RDM.</span></span> <span data-ttu-id="c52c3-137">資料流程模式適用于需要將串流資料傳送給接收者的應用程式，例如影片或語音應用程式，且是由 SOCK 資料流程的通訊端類型所指定 \_ 。</span><span class="sxs-lookup"><span data-stu-id="c52c3-137">Stream mode is appropriate for applications that need to send streaming data to receivers, such as video or voice applications, and is specified by a socket type of SOCK\_STREAM.</span></span> <span data-ttu-id="c52c3-138">此模式的選擇會影響 Winsock 處理資料的方式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-138">The choice of mode effects how Winsock processes data.</span></span>

<span data-ttu-id="c52c3-139">請考慮下列範例：訊息模式的 PGM 傳送者會對 [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) 函式進行三次呼叫，每個呼叫都有100位元組的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="c52c3-139">Consider the following example: A message mode PGM sender makes three calls to the [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) function, each with a 100-byte buffer.</span></span> <span data-ttu-id="c52c3-140">這項作業會以三個離散的 PGM 封包的形式出現在網路上。</span><span class="sxs-lookup"><span data-stu-id="c52c3-140">This operation appears on the wire as three discrete PGM packets.</span></span> <span data-ttu-id="c52c3-141">在接收者端， [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) 函式的每個呼叫只會傳回100個位元組，即使有提供較大的接收緩衝區也是如此。</span><span class="sxs-lookup"><span data-stu-id="c52c3-141">On the receiver side, each call to the [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) function returns only 100 bytes, even if a larger receive buffer is provided.</span></span> <span data-ttu-id="c52c3-142">相反地，使用串流模式的 PGM 傳送者，這些 3 100 位元組傳輸可能會結合到網路上的三個實體封包中 (或合併至接收器端) 上的一個資料 blob。</span><span class="sxs-lookup"><span data-stu-id="c52c3-142">In contrast, with a stream mode PGM sender those three 100 byte transmissions could be coalesced into less than three physical packets on the wire (or coalesced into one blob of data on the receiver side).</span></span> <span data-ttu-id="c52c3-143">如此一來，當接收者呼叫其中一個 Windows 通訊端接收函式時，由 PGM 傳輸接收的任何數量的資料都可能會傳回給應用程式，而不需考慮實際傳輸或接收資料的方式。</span><span class="sxs-lookup"><span data-stu-id="c52c3-143">As such, when the receiver calls one of the Windows Sockets receive functions, any amount of data that has been received by the PGM transport may be returned to the application without regard to how the data was physically transmitted or received.</span></span>

 

 



