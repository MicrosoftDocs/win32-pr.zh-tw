---
description: 雖然這項機制足以滿足簡單的應用程式，但它無法支援更高階應用程式的複雜訊息分派需求，例如使用多重文件介面 (MDI) 模型。
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: 封鎖攔截
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "107001336"
---
# <a name="blocking-hook"></a><span data-ttu-id="0340a-103">封鎖攔截</span><span class="sxs-lookup"><span data-stu-id="0340a-103">Blocking Hook</span></span>

<span data-ttu-id="0340a-104">雖然這項機制足以滿足簡單的應用程式，但它無法支援更高階應用程式的複雜訊息分派需求，例如使用多重文件介面 (MDI) 模型。</span><span class="sxs-lookup"><span data-stu-id="0340a-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="0340a-105">針對這類應用程式，應用程式可能會安裝執行緒特定的封鎖攔截器。</span><span class="sxs-lookup"><span data-stu-id="0340a-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="0340a-106">這會由服務提供者呼叫，而不是先前所述的預設封鎖掛勾。</span><span class="sxs-lookup"><span data-stu-id="0340a-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="0340a-107">服務提供者必須藉 \_ 由呼叫 [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback)，從 Ws232.dll 取出每個執行緒的指標。</span><span class="sxs-lookup"><span data-stu-id="0340a-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="0340a-108">如果應用程式沒有自行安裝封鎖攔截，則會傳回預設封鎖攔截函式的指標。</span><span class="sxs-lookup"><span data-stu-id="0340a-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="0340a-109">Windows 通訊端服務提供者無法假設應用程式提供的封鎖攔截器，可讓訊息處理繼續進行，因為預設封鎖攔截器會執行此操作。</span><span class="sxs-lookup"><span data-stu-id="0340a-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="0340a-110">某些應用程式在封鎖作業未完成時，無法容忍可重新進入訊息的可能性。</span><span class="sxs-lookup"><span data-stu-id="0340a-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="0340a-111">這類應用程式封鎖攔截函式只會傳回 **FALSE**。</span><span class="sxs-lookup"><span data-stu-id="0340a-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="0340a-112">如果服務提供者相依于其內部作業的訊息，它可能會在執行應用程式的封鎖攔截器之前執行 **PeekMessage** (hMyWnd ... ) ，讓它可以取得自己的訊息，而不會影響系統的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="0340a-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="0340a-113">Windows 的先占式多執行緒版本未安裝預設封鎖攔截。</span><span class="sxs-lookup"><span data-stu-id="0340a-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="0340a-114">這是因為如果單一應用程式正在等待作業完成 (而不是呼叫 **PeekMessage** 或 **GetMessage** ，而導致應用程式在 nonpreemptive Windows) 中產生處理器，則不會封鎖其他進程。</span><span class="sxs-lookup"><span data-stu-id="0340a-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="0340a-115">當服務提供者呼叫 [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) 時，將會傳回 null 指標，表示提供者是使用原生作業系統封鎖函式。</span><span class="sxs-lookup"><span data-stu-id="0340a-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="0340a-116">不過，為了維持回溯相容性，應用程式提供的封鎖攔截仍可以在 Windows 中以個別執行緒的形式安裝。</span><span class="sxs-lookup"><span data-stu-id="0340a-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="0340a-117">只有在下列所有條件都成立時，Winsock 服務提供者才會呼叫封鎖攔截：常式是定義為可以封鎖的常式、指定的通訊端是封鎖通訊端，而且無法立即完成要求。</span><span class="sxs-lookup"><span data-stu-id="0340a-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="0340a-118">如果只使用非封鎖通訊端和 [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) ，而不是使用 [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) ，則永遠不會呼叫封鎖掛勾。</span><span class="sxs-lookup"><span data-stu-id="0340a-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="0340a-119">如果在 pseudoblocking 期間用來封鎖執行緒，則會收到執行緒的 Windows 訊息，而執行緒會嘗試發出另一個 Winsock 呼叫的風險。</span><span class="sxs-lookup"><span data-stu-id="0340a-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="0340a-120">由於安全地管理此狀況的困難，因此 Windows 通訊端1.1 規格不允許這種行為。</span><span class="sxs-lookup"><span data-stu-id="0340a-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="0340a-121">不允許指定的執行緒進行多個嵌套的 Winsock 函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="0340a-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="0340a-122">特定執行緒只允許一個未處理的函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="0340a-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="0340a-123">任何嵌套的 Winsock 函式呼叫都會失敗，並出現錯誤 WSAEINPROGRESS。</span><span class="sxs-lookup"><span data-stu-id="0340a-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="0340a-124">請注意，這項限制適用于封鎖和非封鎖作業，但僅適用于 Windows 通訊端1.1 環境。</span><span class="sxs-lookup"><span data-stu-id="0340a-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="0340a-125">這項規則有一些例外狀況，包括兩個可讓應用程式判斷 pseudoblocking 作業是否正在進行的函式，以及是否要在需要時取消這類作業。</span><span class="sxs-lookup"><span data-stu-id="0340a-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="0340a-126">以下將說明這些情況。</span><span class="sxs-lookup"><span data-stu-id="0340a-126">These are described in the following.</span></span>

 

 

 
