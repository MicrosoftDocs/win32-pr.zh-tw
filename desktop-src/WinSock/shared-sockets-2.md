---
description: 引進 WSADuplicateSocket 函式，以啟用跨進程的通訊端共用。
ms.assetid: f7cf40e9-f3a6-4b62-8a78-df25464e2365
title: 共用通訊端
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fb6753b01f6389254756254d2ebe196af8e2a8a3
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103943829"
---
# <a name="shared-sockets"></a><span data-ttu-id="22d70-103">共用通訊端</span><span class="sxs-lookup"><span data-stu-id="22d70-103">Shared Sockets</span></span>

<span data-ttu-id="22d70-104">引進 [**WSADuplicateSocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsaduplicatesocketa) 函式，以啟用跨進程的通訊端共用。</span><span class="sxs-lookup"><span data-stu-id="22d70-104">The [**WSADuplicateSocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsaduplicatesocketa) function is introduced to enable socket sharing across processes.</span></span> <span data-ttu-id="22d70-105">來源進程會呼叫 **WSADuplicateSocket** 來取得目標處理序識別碼的特殊 [**WSAPROTOCOL \_ 資訊**](/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa) 結構。</span><span class="sxs-lookup"><span data-stu-id="22d70-105">A source process calls **WSADuplicateSocket** to obtain a special [**WSAPROTOCOL\_INFO**](/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa) structure for a target process identifier.</span></span> <span data-ttu-id="22d70-106">它會使用一些處理序間通訊 (IPC) 機制，將此結構的內容傳遞至目標進程。</span><span class="sxs-lookup"><span data-stu-id="22d70-106">It uses some interprocess communications (IPC) mechanism to pass the contents of this structure to a target process.</span></span> <span data-ttu-id="22d70-107">然後，目標進程會在 [**WSPSocket**](/windows/desktop/api/Ws2spi/nc-ws2spi-lpwspsocket)的呼叫中使用 **WSAPROTOCOL \_ 資訊** 結構。</span><span class="sxs-lookup"><span data-stu-id="22d70-107">The target process then uses the **WSAPROTOCOL\_INFO** structure in a call to [**WSPSocket**](/windows/desktop/api/Ws2spi/nc-ws2spi-lpwspsocket).</span></span> <span data-ttu-id="22d70-108">這個函式所傳回的通訊端描述項會是基礎通訊端的額外通訊端描述元，因此會變成共用。</span><span class="sxs-lookup"><span data-stu-id="22d70-108">The socket descriptor returned by this function will be an additional socket descriptor to an underlying socket which thus becomes shared.</span></span> <span data-ttu-id="22d70-109">可以在指定進程的執行緒之間共用通訊端，而不使用 **WSADuplicateSocket** 函式，因為通訊端描述項在進程的所有線程中都是有效的。</span><span class="sxs-lookup"><span data-stu-id="22d70-109">Sockets can be shared among threads in a given process without using the **WSADuplicateSocket** function because a socket descriptor is valid in all threads of a process.</span></span>

<span data-ttu-id="22d70-110">參考共用通訊端的兩個 (或多個) 描述項，可以獨立于 i/o 的考慮使用。</span><span class="sxs-lookup"><span data-stu-id="22d70-110">The two (or more) descriptors that reference a shared socket can be used independently as far as I/O is concerned.</span></span> <span data-ttu-id="22d70-111">不過，Winsock 介面不會執行任何類型的存取控制，因此進程必須協調共用通訊端上的任何作業。</span><span class="sxs-lookup"><span data-stu-id="22d70-111">However, the Winsock interface does not implement any type of access control, so the processes must coordinate any operations on a shared socket.</span></span> <span data-ttu-id="22d70-112">共用通訊端的常見範例是使用一個進程來建立通訊端並建立連線。</span><span class="sxs-lookup"><span data-stu-id="22d70-112">A typical example of sharing sockets is to use one process for creating sockets and establishing connections.</span></span> <span data-ttu-id="22d70-113">然後，此程式會將通訊端交給其他負責資訊交換的進程。</span><span class="sxs-lookup"><span data-stu-id="22d70-113">This process then hands off sockets to other processes that are responsible for information exchange.</span></span>

<span data-ttu-id="22d70-114">[**WSADuplicateSocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsaduplicatesocketa)函式會建立通訊端描述項，而不是基礎通訊端。</span><span class="sxs-lookup"><span data-stu-id="22d70-114">The [**WSADuplicateSocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsaduplicatesocketa) function creates socket descriptors and not the underlying socket.</span></span> <span data-ttu-id="22d70-115">如此一來，與通訊端相關聯的所有狀態都會保留在所有描述項的共通範圍內。</span><span class="sxs-lookup"><span data-stu-id="22d70-115">As a result, all the states associated with a socket are held in common across all the descriptors.</span></span> <span data-ttu-id="22d70-116">例如，使用一個描述項執行的 [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) 作業，之後會使用來自任何或所有描述項的 [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt) 來顯示。</span><span class="sxs-lookup"><span data-stu-id="22d70-116">For example, a [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) operation performed using one descriptor is subsequently visible using a [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt) from any or all descriptors.</span></span> <span data-ttu-id="22d70-117">進程可以在重複的通訊端上呼叫 [**導致 closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) ，而描述項將會解除配置。</span><span class="sxs-lookup"><span data-stu-id="22d70-117">A process can call [**closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) on a duplicated socket and the descriptor will become deallocated.</span></span> <span data-ttu-id="22d70-118">不過，基礎通訊端會保持開啟，直到以最後剩下的描述項呼叫 **導致 closesocket** 為止。</span><span class="sxs-lookup"><span data-stu-id="22d70-118">The underlying socket, however, remains open until **closesocket** is called with the last remaining descriptor.</span></span>

<span data-ttu-id="22d70-119">共用通訊端上的通知受限於 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) 和 [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) 函式的一般條件約束。</span><span class="sxs-lookup"><span data-stu-id="22d70-119">Notification on shared sockets is subject to the usual constraints of the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) functions.</span></span> <span data-ttu-id="22d70-120">使用任何共用描述項來發出上述其中一項呼叫，就會取消通訊端先前的任何事件註冊，無論使用哪一個描述項進行註冊。</span><span class="sxs-lookup"><span data-stu-id="22d70-120">Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration.</span></span> <span data-ttu-id="22d70-121">例如，可能無法讓進程收到「接收 FD \_ 讀取事件」和「進程 B 接收 fd」 \_ 寫入事件。</span><span class="sxs-lookup"><span data-stu-id="22d70-121">Thus, for example, it would not be possible to have process A receive FD\_READ events and process B receive FD\_WRITE events.</span></span> <span data-ttu-id="22d70-122">在需要這類緊密協調的情況下，建議開發人員使用執行緒，而不是個別的進程。</span><span class="sxs-lookup"><span data-stu-id="22d70-122">For situations when such tight coordination is required, it is suggested that developers use threads instead of separate processes.</span></span>

 

 
