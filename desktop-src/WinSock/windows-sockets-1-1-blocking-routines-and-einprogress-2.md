---
description: 將應用程式從 Berkeley 通訊端環境移植到 Windows 環境的其中一個主要問題，就是封鎖;也就是說，叫用不會傳回的函式，直到相關聯的作業完成為止。
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Windows 通訊端1.1 封鎖常式和 EINPROGRESS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106987423"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="b85d4-103">Windows 通訊端1.1 封鎖常式和 EINPROGRESS</span><span class="sxs-lookup"><span data-stu-id="b85d4-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="b85d4-104">將應用程式從 Berkeley 通訊端環境移植到 Windows 環境的其中一個主要問題，就是封鎖;也就是說，叫用不會傳回的函式，直到相關聯的作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="b85d4-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="b85d4-105">當作業需要很長的時間才能完成時，會發生問題：例如，可能會封鎖的 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 函式，直到從對等系統收到資料為止。</span><span class="sxs-lookup"><span data-stu-id="b85d4-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="b85d4-106">Berkeley 通訊端模型內的預設行為是讓通訊端在封鎖模式下運作，除非程式設計師明確要求將作業視為非封鎖。</span><span class="sxs-lookup"><span data-stu-id="b85d4-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="b85d4-107">Windows 通訊端1.1 環境無法採用先占式排程。</span><span class="sxs-lookup"><span data-stu-id="b85d4-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="b85d4-108">因此，強烈建議程式設計人員盡可能使用非封鎖 (非同步) 作業（如果 Windows 通訊端1.1）。</span><span class="sxs-lookup"><span data-stu-id="b85d4-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="b85d4-109">因為這不一定是可行的，所以提供了以下所述的虛擬封鎖功能。</span><span class="sxs-lookup"><span data-stu-id="b85d4-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="b85d4-110">Windows 通訊端2只會在已建立的32位作業系統上執行，而鎖死不是問題。</span><span class="sxs-lookup"><span data-stu-id="b85d4-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="b85d4-111">Windows 通訊端2中不需要 Windows 通訊端1.1 所建議的程式設計作法。</span><span class="sxs-lookup"><span data-stu-id="b85d4-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="b85d4-112">即使是在封鎖通訊端上，某些函式（例如 [**bind**](/windows/desktop/api/winsock/nf-winsock-bind)、 [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)和 [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) ）會立即完成。</span><span class="sxs-lookup"><span data-stu-id="b85d4-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="b85d4-113">這些函數的封鎖和非封鎖作業之間沒有任何差異。</span><span class="sxs-lookup"><span data-stu-id="b85d4-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="b85d4-114">其他作業（例如，「 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv)」）可以立即完成或需要任意時間才能完成，視不同的傳輸條件而定。</span><span class="sxs-lookup"><span data-stu-id="b85d4-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="b85d4-115">套用至封鎖通訊端時，這些作業稱為封鎖作業。</span><span class="sxs-lookup"><span data-stu-id="b85d4-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="b85d4-116">下列函數可以封鎖：</span><span class="sxs-lookup"><span data-stu-id="b85d4-116">The following functions can block:</span></span>

-   [<span data-ttu-id="b85d4-117">**recv**</span><span class="sxs-lookup"><span data-stu-id="b85d4-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="b85d4-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="b85d4-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="b85d4-119">**發送**</span><span class="sxs-lookup"><span data-stu-id="b85d4-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="b85d4-120">**sendto**</span><span class="sxs-lookup"><span data-stu-id="b85d4-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="b85d4-121">使用16位 Windows 通訊端1.1 時，虛擬封鎖會處理無法立即完成的封鎖作業，如下所示。</span><span class="sxs-lookup"><span data-stu-id="b85d4-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="b85d4-122">服務提供者會起始作業，然後進入迴圈來分派任何 Windows 訊息 (將處理器產生到另一個執行緒（如有必要）) ，然後檢查 Windows 通訊端函式是否完成。</span><span class="sxs-lookup"><span data-stu-id="b85d4-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="b85d4-123">如果函式已完成，或已叫用 [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) ，封鎖函式就會完成，並產生適當的結果。</span><span class="sxs-lookup"><span data-stu-id="b85d4-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="b85d4-124">服務提供者必須允許安裝不會處理訊息的封鎖攔截函式，以避免在封鎖作業未完成的情況下重新執行訊息的可能性。</span><span class="sxs-lookup"><span data-stu-id="b85d4-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="b85d4-125">最簡單的這類封鎖攔截函數會傳回 **FALSE**。</span><span class="sxs-lookup"><span data-stu-id="b85d4-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="b85d4-126">如果 Windows 通訊端 DLL 相依于內部作業的訊息，它可以在執行應用程式封鎖攔截之前執行 **PeekMessage** (**hMyWnd**) ...，讓它可以取得其訊息，而不會影響系統的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="b85d4-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="b85d4-127">在16位 Windows 通訊端1.1 環境中，如果收到封鎖作業正在進行之進程的 Windows 訊息，應用程式會有可能嘗試發出另一個 Windows 通訊端呼叫的風險。</span><span class="sxs-lookup"><span data-stu-id="b85d4-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="b85d4-128">由於難以安全地管理此狀況，因此 Windows 通訊端1.1 不支援這類應用程式行為。</span><span class="sxs-lookup"><span data-stu-id="b85d4-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="b85d4-129">不允許應用程式進行一個以上的嵌套 Windows 通訊端函數呼叫。</span><span class="sxs-lookup"><span data-stu-id="b85d4-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="b85d4-130">特定工作只允許一個未處理的函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="b85d4-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="b85d4-131">唯一的例外是為了協助程式設計人員在這種情況下所提供的兩個函數： [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) 和 [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall)。</span><span class="sxs-lookup"><span data-stu-id="b85d4-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="b85d4-132">您可以隨時呼叫 [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) 函數，以判斷封鎖的 Windows 通訊端1.1 呼叫是否正在進行中。</span><span class="sxs-lookup"><span data-stu-id="b85d4-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="b85d4-133">同樣地，您可以隨時呼叫 [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) 函式來取消進行中的封鎖呼叫。</span><span class="sxs-lookup"><span data-stu-id="b85d4-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="b85d4-134">任何其他 Windows 通訊端功能的嵌套都會失敗，並出現錯誤 WSAEINPROGRESS。</span><span class="sxs-lookup"><span data-stu-id="b85d4-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="b85d4-135">請強調，這項限制適用于封鎖和非封鎖作業。</span><span class="sxs-lookup"><span data-stu-id="b85d4-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="b85d4-136">針對在呼叫 [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup)時協商2.0 版或更高版本的 Windows 通訊端2應用程式，作業的嵌套沒有任何限制。</span><span class="sxs-lookup"><span data-stu-id="b85d4-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="b85d4-137">在罕見的情況下，作業可能會變成嵌套，例如在 [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) 條件式接受回呼期間，或服務提供者輪流叫用 Windows 通訊端2函式時。</span><span class="sxs-lookup"><span data-stu-id="b85d4-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="b85d4-138">雖然這項機制足以滿足簡單的應用程式，但它無法支援更高階應用程式的複雜訊息分派需求 (例如，使用 MDI 模型) 。</span><span class="sxs-lookup"><span data-stu-id="b85d4-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="b85d4-139">針對這類應用程式，Windows 通訊端 API 包含函式 [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook)，可讓應用程式指定可呼叫的特殊常式，而不是上述討論中所述的預設訊息分派常式。</span><span class="sxs-lookup"><span data-stu-id="b85d4-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="b85d4-140">只有在下列所有條件都成立時，Windows 通訊端提供者才會呼叫封鎖攔截：</span><span class="sxs-lookup"><span data-stu-id="b85d4-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="b85d4-141">常式是定義為可以封鎖的常式。</span><span class="sxs-lookup"><span data-stu-id="b85d4-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="b85d4-142">指定的通訊端是封鎖的通訊端。</span><span class="sxs-lookup"><span data-stu-id="b85d4-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="b85d4-143">無法立即完成要求。</span><span class="sxs-lookup"><span data-stu-id="b85d4-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="b85d4-144">通訊端預設會設定為封鎖，但使用 **FIONBIO** IOCTL 或 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect)函數的 [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket)函數可以將通訊端設定為非封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="b85d4-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="b85d4-145">封鎖攔截程式永遠不會被呼叫，且如果應用程式遵循下列指導方針，應用程式就不需要擔心封鎖攔截的重新進入問題：</span><span class="sxs-lookup"><span data-stu-id="b85d4-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="b85d4-146">它只會使用非封鎖通訊端。</span><span class="sxs-lookup"><span data-stu-id="b85d4-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="b85d4-147">它會使用 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) 和/或 **WSAAsyncGetXByY** 常式，而不是 [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) 和 **getXbyY** 常式。</span><span class="sxs-lookup"><span data-stu-id="b85d4-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="b85d4-148">如果 Windows 通訊端1.1 應用程式叫用的非同步或非封鎖作業會取得記憶體物件的指標 (緩衝區或全域變數（例如) 作為引數），則應用程式必須負責確保該物件可供整個作業中的 Windows 通訊端使用。</span><span class="sxs-lookup"><span data-stu-id="b85d4-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="b85d4-149">應用程式不能叫用任何可能影響對應的 Windows 函式，或處理所涉及記憶體的可行性。</span><span class="sxs-lookup"><span data-stu-id="b85d4-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



