---
description: Windows 通訊端2支援重迭的 i/o，而且所有的傳輸提供者都支援這項功能。
ms.assetid: b36ab606-df1a-4254-b048-6d47eb366275
title: 重迭的 i/o 和事件物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ed034f06243959d94a1ada7eaa71e33c84cd35ee
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106974034"
---
# <a name="overlapped-io-and-event-objects"></a><span data-ttu-id="81ccc-103">重迭的 i/o 和事件物件</span><span class="sxs-lookup"><span data-stu-id="81ccc-103">Overlapped I/O and Event Objects</span></span>

<span data-ttu-id="81ccc-104">Windows 通訊端2支援重迭的 i/o，而且所有的傳輸提供者都支援這項功能。</span><span class="sxs-lookup"><span data-stu-id="81ccc-104">Windows Sockets 2 supports overlapped I/O and all transport providers support this capability.</span></span> <span data-ttu-id="81ccc-105">重迭的 i/o 會遵循在 Windows 中建立的模型，並可在使用 [**通訊端**](/windows/desktop/api/Winsock2/nf-winsock2-socket)函數建立的通訊端上執行，或在使用 [**WSASocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsasocketa)函式建立的通訊端上，使用 *dwFlags* 參數中所設定的 **WSA \_ 旗 \_** 標重迭旗標</span><span class="sxs-lookup"><span data-stu-id="81ccc-105">Overlapped I/O follows the model established in Windows and can be performed on sockets created with the [**socket**](/windows/desktop/api/Winsock2/nf-winsock2-socket) function or sockets created with the [**WSASocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsasocketa) function with the **WSA\_FLAG\_OVERLAPPED** flag set in the *dwFlags* parameter.</span></span>

> [!Note]  
> <span data-ttu-id="81ccc-106">使用重迭的屬性建立通訊端，並不會影響通訊端目前是否處於封鎖或非封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="81ccc-106">Creating a socket with the overlapped attribute has no impact on whether a socket is currently in blocking or nonblocking mode.</span></span> <span data-ttu-id="81ccc-107">使用重迭屬性建立的通訊端可以用來執行重迭的 i/o，這樣做並不會變更通訊端的封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="81ccc-107">Sockets created with the overlapped attribute can be used to perform overlapped I/O—doing so does not change the blocking mode of a socket.</span></span> <span data-ttu-id="81ccc-108">由於重迭的 i/o 作業不會封鎖，因此通訊端的封鎖模式與這些作業無關。</span><span class="sxs-lookup"><span data-stu-id="81ccc-108">Since overlapped I/O operations do not block, the blocking mode of a socket is irrelevant for these operations.</span></span>

 

<span data-ttu-id="81ccc-109">針對接收，應用程式會使用 [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) 或 [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom) 函數來提供要接收資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="81ccc-109">For receiving, applications use the [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) or [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom) functions to supply buffers into which data is to be received.</span></span> <span data-ttu-id="81ccc-110">如果有一或多個緩衝區在網路收到資料的時間之前張貼，則在使用者的緩衝區抵達時，該資料就會立即放在使用者的緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="81ccc-110">If one or more buffers are posted prior to the time when data has been received by the network, that data could be placed in the user's buffers immediately as it arrives.</span></span> <span data-ttu-id="81ccc-111">因此，它可以避免叫用 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 或 [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom) 函式時所發生的複製作業。</span><span class="sxs-lookup"><span data-stu-id="81ccc-111">Thus, it can avoid the copy operation that would otherwise occur at the time the [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) or [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom) function is invoked.</span></span> <span data-ttu-id="81ccc-112">如果在張貼接收緩衝區時資料已存在，則會立即複製到使用者的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="81ccc-112">If data is already present when receive buffers are posted, it is copied immediately into the user's buffers.</span></span>

<span data-ttu-id="81ccc-113">當應用程式未張貼任何接收緩衝區時，如果資料到達，則網路會將設定為熟悉的操作操作樣式。</span><span class="sxs-lookup"><span data-stu-id="81ccc-113">If data arrives when no receive buffers have been posted by the application, the network resorts to the familiar synchronous style of operation.</span></span> <span data-ttu-id="81ccc-114">也就是說，傳入的資料會在內部緩衝處理，直到應用程式發出接收呼叫，因而提供可複製資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="81ccc-114">That is, the incoming data is buffered internally until the application issues a receive call and thereby supplies a buffer into which the data can be copied.</span></span> <span data-ttu-id="81ccc-115">當應用程式使用 [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) 將接收緩衝區的大小設定為零時，就會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="81ccc-115">An exception to this is when the application uses [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) to set the size of the receive buffer to zero.</span></span> <span data-ttu-id="81ccc-116">在此情況下，可靠的通訊協定只允許在應用程式緩衝區張貼時接收資料，而且不可靠的通訊協定上的資料將會遺失。</span><span class="sxs-lookup"><span data-stu-id="81ccc-116">In this instance, reliable protocols would only allow data to be received when application buffers had been posted and data on unreliable protocols would be lost.</span></span>

<span data-ttu-id="81ccc-117">在傳送端，應用程式會使用 [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) 或 [**WSASendTo**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto) 來提供已填滿緩衝區的指標，然後在網路取用緩衝區的內容之前，以任何方式同意不要擾亂緩衝區。</span><span class="sxs-lookup"><span data-stu-id="81ccc-117">On the sending side, applications use [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) or [**WSASendTo**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto) to supply pointers to filled buffers and then agree not to disturb the buffers in any way until the network has consumed the buffer's contents.</span></span>

<span data-ttu-id="81ccc-118">重迭的傳送和接收呼叫會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="81ccc-118">Overlapped send and receive calls return immediately.</span></span> <span data-ttu-id="81ccc-119">傳回值為零表示 i/o 作業已立即完成，而且對應的完成指示已發生。</span><span class="sxs-lookup"><span data-stu-id="81ccc-119">A return value of zero indicates that the I/O operation was completed immediately and that the corresponding completion indication already occurred.</span></span> <span data-ttu-id="81ccc-120">也就是說，相關聯的事件物件已收到信號，或完成常式已排入佇列，並且將在呼叫執行緒進入可提供警示等候狀態時執行。</span><span class="sxs-lookup"><span data-stu-id="81ccc-120">That is, the associated event object has been signaled, or a completion routine has been queued and will be executed when the calling thread gets into the alertable wait state.</span></span>

<span data-ttu-id="81ccc-121">通訊端錯誤的傳回值 \_ 加上 [WSA \_ IO \_ 暫](windows-sockets-error-codes-2.md) 止的錯誤碼，表示已成功起始重迭的作業，而且當取用傳送緩衝區或接收作業完成時，將會提供後續的指示。</span><span class="sxs-lookup"><span data-stu-id="81ccc-121">A return value of SOCKET\_ERROR coupled with an error code of [WSA\_IO\_PENDING](windows-sockets-error-codes-2.md) indicates that the overlapped operation has been successfully initiated and that a subsequent indication will be provided when send buffers have been consumed or when a receive operation has been completed.</span></span> <span data-ttu-id="81ccc-122">不過，對於位元組資料流程樣式的通訊端，無論緩衝區是否已滿，就會在每次傳入的資料用盡時進行。</span><span class="sxs-lookup"><span data-stu-id="81ccc-122">However, for sockets that are byte-stream style, the completion indication occurs whenever the incoming data is exhausted, regardless of whether the buffers are full.</span></span> <span data-ttu-id="81ccc-123">任何其他錯誤碼都會指出重迭的作業未成功啟動，而且即將出現任何完成指示。</span><span class="sxs-lookup"><span data-stu-id="81ccc-123">Any other error code indicates that the overlapped operation was not successfully initiated and that no completion indication will be forthcoming.</span></span>

<span data-ttu-id="81ccc-124">傳送和接收作業可以重迭。</span><span class="sxs-lookup"><span data-stu-id="81ccc-124">Both send and receive operations can be overlapped.</span></span> <span data-ttu-id="81ccc-125">您可以叫用接收函式數次，以張貼接收緩衝區以準備傳入資料，而且可以叫用傳送函式數次，以將多個緩衝區排入佇列以傳送。</span><span class="sxs-lookup"><span data-stu-id="81ccc-125">The receive functions can be invoked several times to post receive buffers in preparation for incoming data, and the send functions can be invoked several times to queue multiple buffers to send.</span></span> <span data-ttu-id="81ccc-126">雖然應用程式可以依賴一連串的重迭傳送緩衝區（依提供的順序傳送），但對應的完成指示可能會以不同的順序進行。</span><span class="sxs-lookup"><span data-stu-id="81ccc-126">While the application can rely upon a series of overlapped send buffers being sent in the order supplied, the corresponding completion indications might occur in a different order.</span></span> <span data-ttu-id="81ccc-127">同樣地，在接收端，緩衝區可以依提供的順序填滿，但完成指示可能會以不同順序發生。</span><span class="sxs-lookup"><span data-stu-id="81ccc-127">Likewise, on the receiving side, buffers can be filled in the order they are supplied, but the completion indications might occur in a different order.</span></span>

<span data-ttu-id="81ccc-128">在許多情況下，使用 [**AcceptEx**](/windows/win32/api/mswsock/nf-mswsock-acceptex)、 [**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex)、 [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend)、 [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv)、 [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile)和類似函數的 Winsock 重迭作業都可以取消。</span><span class="sxs-lookup"><span data-stu-id="81ccc-128">In many cases, Winsock overlapped operations using [**AcceptEx**](/windows/win32/api/mswsock/nf-mswsock-acceptex), [**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex), [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend), [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv), [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile), and similar functions are cancelable.</span></span> <span data-ttu-id="81ccc-129">不過，若要繼續使用已取消未完成作業的通訊端，行為是未定義的。</span><span class="sxs-lookup"><span data-stu-id="81ccc-129">However, behavior is undefined for the continued use of a socket that has canceled outstanding operations.</span></span> <span data-ttu-id="81ccc-130">取消重迭的作業之後，應呼叫 [**導致 closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) 函數。</span><span class="sxs-lookup"><span data-stu-id="81ccc-130">The [**closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) function should be called after canceling an overlapped operation.</span></span> <span data-ttu-id="81ccc-131">因此，為了獲得最佳結果，您應該呼叫 **導致 closesocket** 函式來關閉通常會停止所有暫止作業的通訊端，而不是直接取消 i/o。</span><span class="sxs-lookup"><span data-stu-id="81ccc-131">Therefore, for best results, instead of canceling the I/O directly, the **closesocket** function should be called to close the socket which will eventually discontinue all pending operations.</span></span>

<span data-ttu-id="81ccc-132">重迭 i/o 的延遲完成功能也適用于 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl)，這是 [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket)的增強版本。</span><span class="sxs-lookup"><span data-stu-id="81ccc-132">The deferred completion feature of overlapped I/O is also available for [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl), which is an enhanced version of [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket).</span></span>

 

 
