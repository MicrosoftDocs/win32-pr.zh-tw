---
description: Windows 通訊端 (Winsock) 通訊端 IOCTLs 的流覽主題。
ms.assetid: 6a63c2c9-4e09-4a62-b39f-3ccb26287da8
title: Winsock IOCTLs (Winsock2.h)
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: eadf4a0e2799d6123bf81069fe65ea16313af444
ms.sourcegitcommit: f848119a8faa29b27585f4df53f6e50ee9666684
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/27/2021
ms.locfileid: "110550253"
---
# <a name="winsock-ioctls"></a><span data-ttu-id="56874-103">Winsock IOCTLs</span><span class="sxs-lookup"><span data-stu-id="56874-103">Winsock IOCTLs</span></span>

<span data-ttu-id="56874-104">本節描述 Winsock 通訊端輸入/輸出控制項 (IOCTLs) 適用于各種不同版本的 Windows 作業系統。</span><span class="sxs-lookup"><span data-stu-id="56874-104">This section describes Winsock Socket input/output controls (IOCTLs) for various editions of Windows operating systems.</span></span> <span data-ttu-id="56874-105">使用 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 或 [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) 函數來發出 Winsock IOCTL，以控制通訊端、傳輸通訊協定或通訊子系統的模式。</span><span class="sxs-lookup"><span data-stu-id="56874-105">Use the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) or [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) function to issue a Winsock IOCTL to control the mode of a socket, the transport protocol, or the communications subsystem.</span></span>

<span data-ttu-id="56874-106">有些 Winsock IOCTLs 需要比此資料表可以傳達的更多說明;這類選項包含其他主題的連結。</span><span class="sxs-lookup"><span data-stu-id="56874-106">Some Winsock IOCTLs require more explanation than this table can convey; such options contain links to additional topics.</span></span>

<span data-ttu-id="56874-107">您可以採用編碼配置來保留目前定義的 [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) 操作碼，同時提供便利的方式來分割 opcode 識別碼空間，因為 *dwIoControlCode* 參數現在是32位實體。</span><span class="sxs-lookup"><span data-stu-id="56874-107">It is possible to adopt an encoding scheme that preserves the currently defined [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) opcodes while providing a convenient way to partition the opcode identifier space in as much as the *dwIoControlCode* parameter is now a 32-bit entity.</span></span> <span data-ttu-id="56874-108">*DwIoControlCode* 參數的建立目的，是要在加入新的控制程式代碼時，允許通訊協定和廠商獨立性，同時保留與 Windows 通訊端1.1 和 Unix 控制程式代碼的回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="56874-108">The *dwIoControlCode* parameter is built to allow for protocol and vendor independence when adding new control codes while retaining backward compatibility with the Windows Sockets 1.1 and Unix control codes.</span></span> <span data-ttu-id="56874-109">*DwIoControlCode* 參數的格式如下。</span><span class="sxs-lookup"><span data-stu-id="56874-109">The *dwIoControlCode* parameter has the following form.</span></span>

| <span data-ttu-id="56874-110">I</span><span class="sxs-lookup"><span data-stu-id="56874-110">I</span></span>  | <span data-ttu-id="56874-111">O</span><span class="sxs-lookup"><span data-stu-id="56874-111">O</span></span>  | <span data-ttu-id="56874-112">V</span><span class="sxs-lookup"><span data-stu-id="56874-112">V</span></span>  | <span data-ttu-id="56874-113">T</span><span class="sxs-lookup"><span data-stu-id="56874-113">T</span></span>  | <span data-ttu-id="56874-114">廠商/位址系列</span><span class="sxs-lookup"><span data-stu-id="56874-114">Vendor/address family</span></span> | <span data-ttu-id="56874-115">程式碼</span><span class="sxs-lookup"><span data-stu-id="56874-115">Code</span></span>                   |
|-|-|-|-|-|-|
| <span data-ttu-id="56874-116">3</span><span class="sxs-lookup"><span data-stu-id="56874-116">3</span></span>  | <span data-ttu-id="56874-117">3</span><span class="sxs-lookup"><span data-stu-id="56874-117">3</span></span>  | <span data-ttu-id="56874-118">2</span><span class="sxs-lookup"><span data-stu-id="56874-118">2</span></span>  | <span data-ttu-id="56874-119">2 2</span><span class="sxs-lookup"><span data-stu-id="56874-119">2 2</span></span> | <span data-ttu-id="56874-120">2 2 2 2 2 2 2 1 1 1 1</span><span class="sxs-lookup"><span data-stu-id="56874-120">2 2 2 2 2 2 2 1 1 1 1</span></span> | <span data-ttu-id="56874-121">1 1 1 1 1 1</span><span class="sxs-lookup"><span data-stu-id="56874-121">1 1 1 1 1 1</span></span>              |
| <span data-ttu-id="56874-122">1</span><span class="sxs-lookup"><span data-stu-id="56874-122">1</span></span>  | <span data-ttu-id="56874-123">0</span><span class="sxs-lookup"><span data-stu-id="56874-123">0</span></span>  | <span data-ttu-id="56874-124">9</span><span class="sxs-lookup"><span data-stu-id="56874-124">9</span></span>  | <span data-ttu-id="56874-125">8 7</span><span class="sxs-lookup"><span data-stu-id="56874-125">8 7</span></span> | <span data-ttu-id="56874-126">6 5 4 3 2 1 0 9 8 7 6</span><span class="sxs-lookup"><span data-stu-id="56874-126">6 5 4 3 2 1 0 9 8 7 6</span></span> | <span data-ttu-id="56874-127">5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</span><span class="sxs-lookup"><span data-stu-id="56874-127">5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</span></span> |

> [!Note] 
> <span data-ttu-id="56874-128">在資料表中顯示的 *dwIoControlCode* 參數中的位，必須從上到下依資料行以垂直方式讀取。</span><span class="sxs-lookup"><span data-stu-id="56874-128">The bits in *dwIoControlCode* parameter displayed in the table must be read vertically from top to bottom by column.</span></span> <span data-ttu-id="56874-129">因此最左邊的位是 bit 31，下個位是 bit 30，最右邊位則是 bit 0。</span><span class="sxs-lookup"><span data-stu-id="56874-129">So the left-most bit is bit 31, the next bit is bit 30, and the right-most bit is bit 0.</span></span>

<span data-ttu-id="56874-130">如果輸入緩衝區對程式碼而言是有效的，則會設定 I，如同 **IOC_IN** 一樣。</span><span class="sxs-lookup"><span data-stu-id="56874-130">I is set if the input buffer is valid for the code, as with **IOC_IN**.</span></span>

<span data-ttu-id="56874-131">如果輸出緩衝區對程式碼而言是有效的，則會設定 O，如同 **IOC_OUT** 一樣。</span><span class="sxs-lookup"><span data-stu-id="56874-131">O is set if the output buffer is valid for the code, as with **IOC_OUT**.</span></span> <span data-ttu-id="56874-132">使用輸入和輸出緩衝區的控制代碼都設定了 I 和 O。</span><span class="sxs-lookup"><span data-stu-id="56874-132">Control codes using both input and output buffers set both I and O.</span></span>

<span data-ttu-id="56874-133">如果程式碼沒有參數，則設定 V，如同 **IOC_VOID** 一樣。</span><span class="sxs-lookup"><span data-stu-id="56874-133">V is set if there are no parameters for the code, as with **IOC_VOID**.</span></span>

<span data-ttu-id="56874-134">T 是定義 IOCTL 類型的2位數量。</span><span class="sxs-lookup"><span data-stu-id="56874-134">T is a 2-bit quantity that defines the type of the IOCTL.</span></span> <span data-ttu-id="56874-135">系統會定義下列值：</span><span class="sxs-lookup"><span data-stu-id="56874-135">The following values are defined:</span></span>

<span data-ttu-id="56874-136">0： IOCTL 是標準的 Unix IOCTL 程式碼，如同 **FIONREAD** 和 **FIONBIO**。</span><span class="sxs-lookup"><span data-stu-id="56874-136">0 The IOCTL is a standard Unix IOCTL code, as with **FIONREAD** and **FIONBIO**.</span></span>

<span data-ttu-id="56874-137">1： IOCTL 是一般的 Windows 通訊端 2 IOCTL 程式碼。</span><span class="sxs-lookup"><span data-stu-id="56874-137">1 The IOCTL is a generic Windows Sockets 2 IOCTL code.</span></span> <span data-ttu-id="56874-138">針對 Windows 通訊端2定義的新 IOCTL 程式碼將會有 T = = 1。</span><span class="sxs-lookup"><span data-stu-id="56874-138">New IOCTL codes defined for Windows Sockets 2 will have T == 1.</span></span>

<span data-ttu-id="56874-139">2： IOCTL 只適用于特定的位址系列。</span><span class="sxs-lookup"><span data-stu-id="56874-139">2 The IOCTL applies only to a specific address family.</span></span>

<span data-ttu-id="56874-140">3： IOCTL 只適用于特定廠商的提供者，如同 **IOC_VENDOR** 一樣。</span><span class="sxs-lookup"><span data-stu-id="56874-140">3 The IOCTL applies only to a specific vendor's provider, as with **IOC_VENDOR**.</span></span> <span data-ttu-id="56874-141">此類型可讓公司將出現在 **廠商/位址系列** 參數中的廠商編號指派給公司。</span><span class="sxs-lookup"><span data-stu-id="56874-141">This type allows companies to be assigned a vendor number that appears in the **Vendor/Address family** parameter.</span></span> <span data-ttu-id="56874-142">然後，廠商可以定義該廠商專屬的新 IOCTLs，而不需要向 clearinghouse 註冊 IOCTL，進而提供廠商的彈性和隱私權。</span><span class="sxs-lookup"><span data-stu-id="56874-142">Then, the vendor can define new IOCTLs specific to that vendor without having to register the IOCTL with a clearinghouse, thereby providing vendor flexibility and privacy.</span></span>

<span data-ttu-id="56874-143">**廠商/位址系列** 11位的數量，定義擁有程式碼的廠商 (如果 T = = 3) 或包含程式碼套用的位址系列 (if T = = 2) 。</span><span class="sxs-lookup"><span data-stu-id="56874-143">**Vendor/Address family** An 11-bit quantity that defines the vendor who owns the code (if T == 3) or that contains the address family to which the code applies (if T == 2).</span></span> <span data-ttu-id="56874-144">如果這是 Unix IOCTL 程式碼 (T = = 0) 則此參數的值與 Unix 上的程式碼相同。</span><span class="sxs-lookup"><span data-stu-id="56874-144">If this is a Unix IOCTL code (T == 0) then this parameter has the same value as the code on Unix.</span></span> <span data-ttu-id="56874-145">如果這是泛型 Windows 通訊端 2 IOCTL (T = = 1) 則此參數可以用來做為程式碼參數的副檔名，以提供額外的程式碼值。</span><span class="sxs-lookup"><span data-stu-id="56874-145">If this is a generic Windows Sockets 2 IOCTL (T == 1) then this parameter can be used as an extension of the code parameter to provide additional code values.</span></span>

<span data-ttu-id="56874-146">程式 **代碼** 16位的數量，其中包含作業的特定 IOCTL 程式碼。</span><span class="sxs-lookup"><span data-stu-id="56874-146">**Code** The 16-bit quantity that contains the specific IOCTL code for the operation.</span></span>

## <a name="unix-ioctl-codes"></a><span data-ttu-id="56874-147">Unix IOCTL 代碼</span><span class="sxs-lookup"><span data-stu-id="56874-147">Unix IOCTL codes</span></span>

<span data-ttu-id="56874-148">支援) 的下列 Unix IOCTL 代碼 (命令。</span><span class="sxs-lookup"><span data-stu-id="56874-148">The following Unix IOCTL codes (commands) are supported.</span></span>

### <a name="fionbio"></a><span data-ttu-id="56874-149">FIONBIO</span><span class="sxs-lookup"><span data-stu-id="56874-149">FIONBIO</span></span>

<span data-ttu-id="56874-150">啟用或停用通訊端 *s* 上的非封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="56874-150">Enable or disable non-blocking mode on socket *s*.</span></span> <span data-ttu-id="56874-151">*LpvInBuffer* 參數指向不 **帶正負** 號的 long (QoS) ，如果要啟用非封鎖模式則為非零，如果要停用，則為零。</span><span class="sxs-lookup"><span data-stu-id="56874-151">The *lpvInBuffer* parameter points at an **unsigned long** (QoS), which is nonzero if non-blocking mode is to be enabled and zero if it is to be disabled.</span></span> <span data-ttu-id="56874-152">建立通訊端時，它會在封鎖模式下運作 (也就是) 停用非封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="56874-152">When a socket is created, it operates in blocking mode (that is, non-blocking mode is disabled).</span></span> <span data-ttu-id="56874-153">這與 BSD 通訊端一致。</span><span class="sxs-lookup"><span data-stu-id="56874-153">This is consistent with BSD sockets.</span></span>

<span data-ttu-id="56874-154">[**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect)或 [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect)常式會自動將通訊端設定為非封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="56874-154">The [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) or [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) routine automatically sets a socket to non-blocking mode.</span></span> <span data-ttu-id="56874-155">如果已在通訊端上發出 **WSAAsyncSelect** 或 **WSAEventSelect** ，則嘗試使用 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 將通訊端設定回封鎖模式將會失敗，並出現 WSAEINVAL。</span><span class="sxs-lookup"><span data-stu-id="56874-155">If **WSAAsyncSelect** or **WSAEventSelect** has been issued on a socket, then any attempt to use [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) to set the socket back to blocking mode will fail with WSAEINVAL.</span></span> <span data-ttu-id="56874-156">若要將通訊端設定回封鎖模式，應用程式必須先使用等於零的 *lEvent* 參數呼叫 **WSAAsyncSelect** 來停用 **WSAAsyncSelect** ，或呼叫 **WSAEventSelect** ，並將 *lNetworkEvents* 參數等於零，以停用 **WSAEventSelect** 。</span><span class="sxs-lookup"><span data-stu-id="56874-156">To set the socket back to blocking mode, an application must first disable **WSAAsyncSelect** by calling **WSAAsyncSelect** with the *lEvent* parameter equal to zero, or disable **WSAEventSelect** by calling **WSAEventSelect** with the *lNetworkEvents* parameter equal to zero.</span></span>

### <a name="fionread"></a><span data-ttu-id="56874-157">FIONREAD</span><span class="sxs-lookup"><span data-stu-id="56874-157">FIONREAD</span></span>

<span data-ttu-id="56874-158">判斷可 *從通訊端* 以不可部分完成的方式讀取的資料量。</span><span class="sxs-lookup"><span data-stu-id="56874-158">Determine the amount of data that can be read atomically from socket *s*.</span></span> <span data-ttu-id="56874-159">*LpvOutBuffer* 參數指向 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl)儲存結果的不 **帶正負** 號的 long。</span><span class="sxs-lookup"><span data-stu-id="56874-159">The *lpvOutBuffer* parameter points at an **unsigned long** in which [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) stores the result.</span></span>

<span data-ttu-id="56874-160">如果傳入 *s* 參數的通訊端是資料流程導向 (例如，輸入 SOCK \_ Stream) ， **FIONREAD** 會傳回可在單一接收作業中讀取的資料總量; 這通常與套 (接字上佇列的資料總量相同，因為資料流程是位元組導向的，這並不保證) 。</span><span class="sxs-lookup"><span data-stu-id="56874-160">If the socket passed in the *s* parameter is stream oriented (for example, type SOCK\_STREAM), **FIONREAD** returns the total amount of data that can be read in a single receive operation; this is normally the same as the total amount of data queued on the socket (since a data stream is byte-oriented, this is not guaranteed).</span></span>

<span data-ttu-id="56874-161">如果傳入 *s* 參數的通訊端是訊息導向 (例如，輸入 SOCK \_ DGRAM) ， **FIONREAD** 會傳回可讀取的位元組總數，而不是第一個資料包 (訊息) 在通訊端上排入佇列的大小。</span><span class="sxs-lookup"><span data-stu-id="56874-161">If the socket passed in the *s* parameter is message oriented (for example, type SOCK\_DGRAM), **FIONREAD** returns the reports the total number of bytes available to read, not the size of the first datagram (message) queued on the socket.</span></span>

### <a name="siocatmark"></a><span data-ttu-id="56874-162">SIOCATMARK</span><span class="sxs-lookup"><span data-stu-id="56874-162">SIOCATMARK</span></span>

<span data-ttu-id="56874-163">判斷是否已讀取所有 OOB 資料。</span><span class="sxs-lookup"><span data-stu-id="56874-163">Determine whether or not all OOB data has been read.</span></span> <span data-ttu-id="56874-164">這僅適用于資料流程樣式 (的通訊端，例如，輸入 SOCK \_ stream) ，其已設定為以內嵌方式接收任何 OOB 資料 (因此 \_ OOBINLINE) 。</span><span class="sxs-lookup"><span data-stu-id="56874-164">This applies only to a socket of stream-style (for example, type SOCK\_STREAM) that has been configured for inline reception of any OOB data (SO\_OOBINLINE).</span></span> <span data-ttu-id="56874-165">如果沒有任何 OOB 資料正在等候讀取，則作業會傳回 TRUE。</span><span class="sxs-lookup"><span data-stu-id="56874-165">If no OOB data is waiting to be read, the operation returns TRUE.</span></span> <span data-ttu-id="56874-166">否則，它會傳回 **FALSE**，而且在通訊端上執行的下一個接收作業會取出標記前面的部分或全部資料;應用程式應該使用 **SIOCATMARK** 作業來判斷是否有任何保留。</span><span class="sxs-lookup"><span data-stu-id="56874-166">Otherwise, it returns **FALSE**, and the next receive operation performed on the socket will retrieve some or all of the data preceding the mark; the application should use the **SIOCATMARK** operation to determine whether any remains.</span></span> <span data-ttu-id="56874-167">如果緊急 (的頻外) 資料中有任何一般資料，則會依序接收。</span><span class="sxs-lookup"><span data-stu-id="56874-167">If there is any normal data preceding the urgent (out of band) data, it will be received in order.</span></span> <span data-ttu-id="56874-168"> (請注意，在相同的呼叫中，[**接收**](/windows/desktop/api/winsock/nf-winsock-recv)作業永遠不會混用 OOB 和一般資料。在 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl)儲存結果的布林值上，) *lpvOutBuffer* 點。</span><span class="sxs-lookup"><span data-stu-id="56874-168">(Note that [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) operations will never mix OOB and normal data in the same call.) *lpvOutBuffer* points at a BOOL in which [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) stores the result.</span></span>

## <a name="windows-sockets-2-commands"></a><span data-ttu-id="56874-169">Windows 通訊端2命令</span><span class="sxs-lookup"><span data-stu-id="56874-169">Windows Sockets 2 commands</span></span>

<span data-ttu-id="56874-170">支援下列 Windows 通訊端2命令。</span><span class="sxs-lookup"><span data-stu-id="56874-170">The following Windows Sockets 2 commands are supported.</span></span>

### <a name="sio_acquire_port_reservation-opcode-setting-i-t3"></a><span data-ttu-id="56874-171">SIO_ACQUIRE_PORT_RESER加值稅ION (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-171">SIO_ACQUIRE_PORT_RESERVATION (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-172">要求 TCP 或 UDP 埠區塊的執行時間保留。</span><span class="sxs-lookup"><span data-stu-id="56874-172">Request a runtime reservation for a block of TCP or UDP ports.</span></span> <span data-ttu-id="56874-173">針對執行時間埠保留，埠集區會要求從其通訊端已授與保留的進程取用保留。</span><span class="sxs-lookup"><span data-stu-id="56874-173">For runtime port reservations, the port pool requires that reservations be consumed from the process on whose socket the reservation was granted.</span></span> <span data-ttu-id="56874-174">執行時間埠保留最後只會在呼叫 [**SIO \_ 取得 \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) IOCTL 的通訊端存留期內。</span><span class="sxs-lookup"><span data-stu-id="56874-174">Runtime port reservations last only as long as the lifetime of the socket on which the [**SIO\_ACQUIRE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) IOCTL was called.</span></span> <span data-ttu-id="56874-175">相反地，使用 [**CreatePersistentTcpPortReservation**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation) 或 [**CreatePersistentUdpPortReservation**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation) 函式所建立的持續性埠保留，可供任何程式使用，以取得持續保留。</span><span class="sxs-lookup"><span data-stu-id="56874-175">In contrast, persistent port reservations created using the [**CreatePersistentTcpPortReservation**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation) or [**CreatePersistentUdpPortReservation**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation) function may be consumed by any process with the ability to obtain persistent reservations.</span></span>

<span data-ttu-id="56874-176">如需詳細資訊，請參閱 [**SIO \_ 取得 \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-176">For more detailed information, see the [**SIO\_ACQUIRE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-177">[**SIO \_Windows \_ \_**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) Vista 和更新版本的作業系統支援取得埠保留。</span><span class="sxs-lookup"><span data-stu-id="56874-177">[**SIO\_ACQUIRE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) is supported on Windows Vista and later versions of the operating system.</span></span>

### <a name="sio_address_list_change-opcode-setting-v-t1"></a><span data-ttu-id="56874-178">SIO \_ 位址 \_ 清單 \_ 變更 (操作碼設定： V，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-178">SIO\_ADDRESS\_LIST\_CHANGE (opcode setting: V, T==1)</span></span>

<span data-ttu-id="56874-179">接收應用程式可以系結之通訊端通訊協定系列的本機傳輸地址清單中的變更通知。</span><span class="sxs-lookup"><span data-stu-id="56874-179">To receive notification of changes in the list of local transport addresses of the socket's protocol family to which the application can bind.</span></span> <span data-ttu-id="56874-180">這項 IOCTL 完成時，將不會提供任何輸出資訊;完成隻會指出可用的本機地址清單已變更，且應該透過 **SIO \_ 位址 \_ 清單 \_ 查詢** 重新查詢。</span><span class="sxs-lookup"><span data-stu-id="56874-180">No output information will be provided upon completion of this IOCTL; the completion merely indicates that list of available local address has changed and should be queried again through **SIO\_ADDRESS\_LIST\_QUERY**.</span></span>

<span data-ttu-id="56874-181">雖然並非) 必要，但應用程式會使用重迭的 i/o 來 **SIO \_ 位址 \_ 清單 \_ 變更** 要求，以通知變更，但這是假設的 (。</span><span class="sxs-lookup"><span data-stu-id="56874-181">It is assumed (although not required) that the application uses overlapped I/O to be notified of change by completion of **SIO\_ADDRESS\_LIST\_CHANGE** request.</span></span> <span data-ttu-id="56874-182">或者，如果 **SIO \_ 位址 \_ 清單 \_ 變更** IOCTL 是在非封鎖通訊端上發出的，且沒有重迭的參數 (*lpOverlapped* /  *lpCompletionRoutine* 會設定為 **Null**) ，它會立即完成，並出現錯誤 [WSAEWOULDBLOCK](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-182">Alternatively, if the **SIO\_ADDRESS\_LIST\_CHANGE** IOCTL is issued on a non-blocking socket and without overlapped parameters (*lpOverlapped*/ *lpCompletionRoutine* are set to **NULL**), it will complete immediately with error [WSAEWOULDBLOCK](windows-sockets-error-codes-2.md).</span></span> <span data-ttu-id="56874-183">然後，應用程式可以透過呼叫 [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) 或 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) ，以在 \_ \_ \_ 網路事件位元遮罩中設定的 FD 地址清單變更位來等候地址清單變更事件。</span><span class="sxs-lookup"><span data-stu-id="56874-183">The application can then wait for address list change events through a call to [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) or [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) with FD\_ADDRESS\_LIST\_CHANGE bit set in the network event bitmask.</span></span>

### <a name="sio_address_list_query-opcode-setting-o-t1"></a><span data-ttu-id="56874-184">SIO \_ 位址 \_ 清單 \_ 查詢 (操作碼設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-184">SIO\_ADDRESS\_LIST\_QUERY (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-185">取得應用程式可系結之通訊端通訊協定系列的本機傳輸地址清單。</span><span class="sxs-lookup"><span data-stu-id="56874-185">Obtains a list of local transport addresses of the socket's protocol family to which the application can bind.</span></span> <span data-ttu-id="56874-186">地址清單會根據地址系列而有所不同，而某些位址會從清單中排除。</span><span class="sxs-lookup"><span data-stu-id="56874-186">The list of addresses varies based on address family and some addresses are excluded from the list.</span></span>

> [!Note] 
> <span data-ttu-id="56874-187">在 Windows 隨插即用環境中，可以動態新增和移除位址。</span><span class="sxs-lookup"><span data-stu-id="56874-187">In Windows Plug-n-Play environments, addresses can be added and removed dynamically.</span></span> <span data-ttu-id="56874-188">因此，應用程式無法依賴 **SIO \_ 位址 \_ 清單 \_ 查詢** 所傳回的資訊來持續存在。</span><span class="sxs-lookup"><span data-stu-id="56874-188">Therefore, applications cannot rely on the information returned by **SIO\_ADDRESS\_LIST\_QUERY** to be persistent.</span></span> <span data-ttu-id="56874-189">應用程式可以透過 **SIO \_ 位址 \_ 清單 \_ 變更** IOCTL 來登入位址變更通知，以透過重迭的 I/o 或 FD \_ 通訊 \_ 清單 \_ 變更事件提供通知。</span><span class="sxs-lookup"><span data-stu-id="56874-189">Applications may register for address change notifications through the **SIO\_ADDRESS\_LIST\_CHANGE** IOCTL which provides for notification through either overlapped I/O or FD\_ADDRESS\_LIST\_CHANGE event.</span></span> <span data-ttu-id="56874-190">下列動作順序可以用來保證應用程式一律具有目前的通訊清單資訊：</span><span class="sxs-lookup"><span data-stu-id="56874-190">The following sequence of actions can be used to guarantee that the application always has current address list information:</span></span>

-  <span data-ttu-id="56874-191">問題 **SIO \_ 位址 \_ 清單 \_ 變更** IOCTL</span><span class="sxs-lookup"><span data-stu-id="56874-191">Issue **SIO\_ADDRESS\_LIST\_CHANGE** IOCTL</span></span>
-  <span data-ttu-id="56874-192">問題 **SIO \_ 位址 \_ 清單 \_ 查詢** IOCTL</span><span class="sxs-lookup"><span data-stu-id="56874-192">Issue **SIO\_ADDRESS\_LIST\_QUERY** IOCTL</span></span>
-  <span data-ttu-id="56874-193">每當 **SIO \_ 位址 \_ 清單 \_ 變更** IOCTL 通知應用程式地址清單變更時 (透過重迭的 I/o 或) 的 FD \_ 通訊 \_ 清單 \_ 變更事件，就應該重複執行整個動作順序。</span><span class="sxs-lookup"><span data-stu-id="56874-193">Whenever **SIO\_ADDRESS\_LIST\_CHANGE** IOCTL notifies the application of address list change (either through overlapped I/O or by signaling FD\_ADDRESS\_LIST\_CHANGE event), the whole sequence of actions should be repeated.</span></span>

<span data-ttu-id="56874-194">如需詳細資訊，請參閱 [**SIO \_ 位址 \_ 清單 \_ 查詢**](/previous-versions/windows/desktop/legacy/dd877219(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-194">For more detailed information, see the [**SIO\_ADDRESS\_LIST\_QUERY**](/previous-versions/windows/desktop/legacy/dd877219(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-195">**SIO \_Windows 2000 和更新版本支援位址 \_ 清單 \_ 查詢** 。</span><span class="sxs-lookup"><span data-stu-id="56874-195">**SIO\_ADDRESS\_LIST\_QUERY** is supported on Windows 2000 and later.</span></span>

### <a name="sio_apply_transport_setting-opcode-setting-i-t3"></a><span data-ttu-id="56874-196">SIO \_ 套用 \_ 傳輸 \_ 設定 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-196">SIO\_APPLY\_TRANSPORT\_SETTING (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-197">將傳輸設定套用至通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-197">Applies a transport setting to a socket.</span></span> <span data-ttu-id="56874-198">正在套用的傳輸設定是以 *lpvInBuffer* 參數中傳遞的 [**傳輸 \_ 設定 \_ 識別碼**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id)為基礎。</span><span class="sxs-lookup"><span data-stu-id="56874-198">The transport setting being applied is based on the [**TRANSPORT\_SETTING\_ID**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) passed in the *lpvInBuffer* parameter.</span></span>

<span data-ttu-id="56874-199">目前唯一定義的傳輸設定是用於 TCP 通訊端上的 **即時 \_ \_ 通知 \_ 功能** 功能。</span><span class="sxs-lookup"><span data-stu-id="56874-199">The only transport setting currently defines is for the **REAL\_TIME\_NOTIFICATION\_CAPABILITY** capability on a TCP socket.</span></span>

<span data-ttu-id="56874-200">如果傳遞的 [**傳輸 \_ 設定 \_ 識別碼**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id)具有設定為 **即時 \_ \_ 通知 \_ 功能** 的 **Guid** 成員，則這項要求會要求套用與 [**ControlChannelTrigger**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger)搭配使用的 TCP 通訊端的即時通知設定，以在 Windows 市集中應用程式接收背景網路通知。</span><span class="sxs-lookup"><span data-stu-id="56874-200">If the [**TRANSPORT\_SETTING\_ID**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) passed has the **Guid** member set to **REAL\_TIME\_NOTIFICATION\_CAPABILITY**, then this is a request to apply real time notification settings for the TCP socket used with the [**ControlChannelTrigger**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger) to receive background network notifications in a Windows Store app.</span></span>

<span data-ttu-id="56874-201">如需詳細資訊，請參閱 [**SIO \_ 套用 \_ 傳輸 \_ 設定**](/previous-versions/windows/desktop/legacy/jj553481(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-201">For more detailed information, see the [**SIO\_APPLY\_TRANSPORT\_SETTING**](/previous-versions/windows/desktop/legacy/jj553481(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-202">**SIO \_Windows 8 \_ \_** 、Windows Server 2012 及更新版本都支援 [套用傳輸] 設定。</span><span class="sxs-lookup"><span data-stu-id="56874-202">**SIO\_APPLY\_TRANSPORT\_SETTING** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_associate_handle-opcode-setting-i-t1"></a><span data-ttu-id="56874-203">SIO \_ 建立 \_ 控制碼 (opcode 設定的關聯： I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-203">SIO\_ASSOCIATE\_HANDLE (opcode setting: I, T==1)</span></span>

<span data-ttu-id="56874-204">使這個通訊端與隨附介面的指定控制碼產生關聯。</span><span class="sxs-lookup"><span data-stu-id="56874-204">Associate this socket with the specified handle of a companion interface.</span></span> <span data-ttu-id="56874-205">輸入緩衝區包含對應至隨附介面之資訊清單常數的整數值 (例如，第 \_ NETDEV 和第 \_ 一個 TAPI。 ) ，後面接著一個值，也就是指定之附屬介面的控制碼，以及任何其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="56874-205">The input buffer contains the integer value corresponding to the manifest constant for the companion interface (for example, TH\_NETDEV and TH\_TAPI.), followed by a value that is a handle of the specified companion interface, along with any other required information.</span></span> <span data-ttu-id="56874-206">請參閱 [Winsock 附件](winsock-annexes.md) 中的適當區段，以取得特定隨附介面特定的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="56874-206">Refer to the appropriate section in [Winsock Annexes](winsock-annexes.md) for details specific to a particular companion interface.</span></span> <span data-ttu-id="56874-207">總大小會反映在輸入緩衝區長度中。</span><span class="sxs-lookup"><span data-stu-id="56874-207">The total size is reflected in the input buffer length.</span></span> <span data-ttu-id="56874-208">不需要輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-208">No output buffer is required.</span></span> <span data-ttu-id="56874-209">針對不支援這個 IOCTL 的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-209">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support this IOCTL.</span></span> <span data-ttu-id="56874-210">您可以使用 **SIO \_ 轉譯 \_ 控制碼** 來抓取這個 IOCTL 相關聯的控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-210">The handle associated by this IOCTL can be retrieved using **SIO\_TRANSLATE\_HANDLE**.</span></span>

<span data-ttu-id="56874-211">您可以使用隨附的介面，例如，如果特定提供者提供 (1) 通訊端行為的大量額外控制項，以及 (2) 控制項是提供者特定的，足以讓它們不會對應至現有的 Windows 通訊端函式，或未來可能會定義的控制項。</span><span class="sxs-lookup"><span data-stu-id="56874-211">A companion interface might be used, for example, if a particular provider provides (1) a great deal of additional controls over the behavior of a socket and (2) the controls are provider-specific enough that they do not map to existing Windows Socket functions or ones likely to be defined in the future.</span></span> <span data-ttu-id="56874-212">建議您) 使用元件物件模型 (COM，而不使用這個 IOCTL 來探索和追蹤通訊端可能支援的其他介面。</span><span class="sxs-lookup"><span data-stu-id="56874-212">It is recommend that the Component Object Model (COM) be used instead of this IOCTL to discover and track other interfaces that might be supported by a socket.</span></span> <span data-ttu-id="56874-213">這個 IOCTL 存在於與 COM 無法使用或無法用於其他原因的系統 (反向) 相容性。</span><span class="sxs-lookup"><span data-stu-id="56874-213">This IOCTL is present for (reverse) compatibility with systems where COM is not available or cannot be used for some other reason.</span></span>

### <a name="sio_associate_port_reservation-opcode-setting-i-t3"></a><span data-ttu-id="56874-214">SIO \_ 將 \_ 埠 \_ 保留關聯 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-214">SIO\_ASSOCIATE\_PORT\_RESERVATION (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-215">針對埠保留權杖所識別的 TCP 或 UDP 埠區塊，將通訊端與持續或執行時間保留建立關聯。</span><span class="sxs-lookup"><span data-stu-id="56874-215">Associate a socket with a persistent or runtime reservation for a block of TCP or UDP ports identified by the port reservation token.</span></span> <span data-ttu-id="56874-216">SIO 在系結器之前，必須先發出 [**\_ \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) 的 IOCTL。</span><span class="sxs-lookup"><span data-stu-id="56874-216">The [**SIO\_ASSOCIATE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) IOCTL must be issued before the socket is bound.</span></span> <span data-ttu-id="56874-217">當通訊端系結時，會從指定權杖所識別的埠保留中選取指派給它的通訊埠。</span><span class="sxs-lookup"><span data-stu-id="56874-217">If and when the socket is bound, the port assigned to it will be selected from the port reservation identified by the given token.</span></span> <span data-ttu-id="56874-218">如果指定的保留中沒有任何可用的埠，系 [**結函數呼叫**](/windows/desktop/api/winsock/nf-winsock-bind) 將會失敗。</span><span class="sxs-lookup"><span data-stu-id="56874-218">If no ports are available from the specified reservation, the [**bind**](/windows/desktop/api/winsock/nf-winsock-bind) function call will fail.</span></span>

<span data-ttu-id="56874-219">如需詳細資訊，請參閱 [**SIO \_ 關聯 \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-219">For more detailed information, see the [**SIO\_ASSOCIATE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-220">[**SIO \_Windows \_ \_**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) Vista 和更新版本的作業系統支援埠保留的關聯。</span><span class="sxs-lookup"><span data-stu-id="56874-220">[**SIO\_ASSOCIATE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) is supported on Windows Vista and later versions of the operating system.</span></span>

### <a name="sio_base_handle-opcode-setting-o-t1"></a><span data-ttu-id="56874-221">SIO \_ 基底 \_ 控制碼 (操作碼設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-221">SIO\_BASE\_HANDLE (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-222">抓取給定通訊端的基底服務提供者控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-222">Retrieves the base service provider handle for a given socket.</span></span> <span data-ttu-id="56874-223">傳回的值是 **通訊端**。</span><span class="sxs-lookup"><span data-stu-id="56874-223">The returned value is a **SOCKET**.</span></span>

<span data-ttu-id="56874-224">多層式服務提供者永遠不會攔截這個 IOCTL，因為傳回值必須是基底服務提供者的通訊端控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-224">A layered service provider would never intercept this IOCTL since the return value must be the socket handle from the base service provider.</span></span>

<span data-ttu-id="56874-225">如果輸出緩衝區不夠大，以致于通訊端控制碼 (*cbOutBuffer* 小於 **通訊端** 的大小) 或 *lpvOutBuffer* 參數為 **Null** 指標，則會傳回 **通訊端 \_ 錯誤** ，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEFAULT](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-225">If the output buffer is not large enough for a socket handle (the *cbOutBuffer* is less than the size of a **SOCKET**) or the *lpvOutBuffer* parameter is a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEFAULT](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-226">**SIO \_基底 \_ 控制碼** 定義于 *Mswsock .h* 標頭檔中，並在 Windows Vista 和更新版本上支援。</span><span class="sxs-lookup"><span data-stu-id="56874-226">**SIO\_BASE\_HANDLE** is defined in the *Mswsock.h* header file and supported on Windows Vista and later.</span></span>

### <a name="sio_bsp_handle-opcode-setting-o-t1"></a><span data-ttu-id="56874-227">SIO \_ BSP \_ 控制碼 (opcode 設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-227">SIO\_BSP\_HANDLE (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-228">抓取 [**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) 函式所使用之通訊端的基底服務提供者控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-228">Retrieves the base service provider handle for a socket used by the [**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) function.</span></span> <span data-ttu-id="56874-229">傳回的值是 **通訊端**。</span><span class="sxs-lookup"><span data-stu-id="56874-229">The returned value is a **SOCKET**.</span></span>

<span data-ttu-id="56874-230">這個 Ioctl 是由多層式服務提供者所使用，以確保提供者攔截 [**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) 函數。</span><span class="sxs-lookup"><span data-stu-id="56874-230">This Ioctl is used by a layered service provider to ensure the provider intercept the [**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) function.</span></span>

<span data-ttu-id="56874-231">如果輸出緩衝區不夠大，以致于通訊端控制碼 (*cbOutBuffer* 小於 **通訊端** 的大小) 或 *lpvOutBuffer* 參數為 **Null** 指標，則會傳回 **通訊端 \_ 錯誤** ，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEFAULT](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-231">If the output buffer is not large enough for a socket handle (the *cbOutBuffer* is less than the size of a **SOCKET**) or the *lpvOutBuffer* parameter is a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEFAULT](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-232">**SIO \_BSP \_ 控制碼** 定義于 *Mswsock .h* 標頭檔中，並在 Windows Vista 和更新版本上支援。</span><span class="sxs-lookup"><span data-stu-id="56874-232">**SIO\_BSP\_HANDLE** is defined in the *Mswsock.h* header file and supported on Windows Vista and later.</span></span>

### <a name="sio_bsp_handle_select-opcode-setting-o-t1"></a><span data-ttu-id="56874-233">SIO \_ BSP \_ 控制碼 \_ SELECT (Opcode 設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-233">SIO\_BSP\_HANDLE\_SELECT (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-234">抓取 [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) 函數所用之通訊端的基底服務提供者控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-234">Retrieves the base service provider handle for a socket used by the [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) function.</span></span> <span data-ttu-id="56874-235">傳回的值是 **通訊端**。</span><span class="sxs-lookup"><span data-stu-id="56874-235">The returned value is a **SOCKET**.</span></span>

<span data-ttu-id="56874-236">多層式服務提供者會使用這個 Ioctl，以確保提供者攔截 [**選取**](/windows/desktop/api/Winsock2/nf-winsock2-select) 的函式。</span><span class="sxs-lookup"><span data-stu-id="56874-236">This Ioctl is used by a layered service provider to ensure the provider intercept the [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) function.</span></span>

<span data-ttu-id="56874-237">如果輸出緩衝區不夠大，以致于通訊端控制碼 (*cbOutBuffer* 小於 **通訊端** 的大小) 或 *lpvOutBuffer* 參數為 **Null** 指標，則會傳回 **通訊端 \_ 錯誤** ，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEFAULT](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-237">If the output buffer is not large enough for a socket handle (the *cbOutBuffer* is less than the size of a **SOCKET**) or the *lpvOutBuffer* parameter is a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEFAULT](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-238">**SIO \_BSP \_ 控制碼 \_ SELECT** 是定義于 *Mswsock .h* 標頭檔中，並在 Windows Vista 和更新版本上支援。</span><span class="sxs-lookup"><span data-stu-id="56874-238">**SIO\_BSP\_HANDLE\_SELECT** is defined in the *Mswsock.h* header file and supported on Windows Vista and later.</span></span>

### <a name="sio_bsp_handle_poll-opcode-setting-o-t1"></a><span data-ttu-id="56874-239">SIO \_ BSP \_ 控制碼 \_ 輪詢 (操作碼設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-239">SIO\_BSP\_HANDLE\_POLL (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-240">抓取 [**WSAPoll**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) 函式所使用之通訊端的基底服務提供者控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-240">Retrieves the base service provider handle for a socket used by the [**WSAPoll**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) function.</span></span> <span data-ttu-id="56874-241">*LpOverlapped* 參數必須是 **Null** 指標。</span><span class="sxs-lookup"><span data-stu-id="56874-241">The *lpOverlapped* parameter must be a **NULL** pointer.</span></span> <span data-ttu-id="56874-242">傳回的值是 **通訊端**。</span><span class="sxs-lookup"><span data-stu-id="56874-242">The returned value is a **SOCKET**.</span></span>

<span data-ttu-id="56874-243">這個 Ioctl 是由多層式服務提供者所使用，以確保提供者攔截 [**WSAPoll**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) 函數。</span><span class="sxs-lookup"><span data-stu-id="56874-243">This Ioctl is used by a layered service provider to ensure the provider intercept the [**WSAPoll**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) function.</span></span>

<span data-ttu-id="56874-244">如果輸出緩衝區不夠大，以致于通訊端控制碼 (*cbOutBuffer* 小於 **通訊端**) 的大小，則 *lpvOutBuffer* 參數為 **null** 指標，或 *lpOverlapped* 參數不是 **null** 指標，則會傳回此 IOCTL 的結果 **， \_ 而** [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEFAULT](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-244">If the output buffer is not large enough for a socket handle (the *cbOutBuffer* is less than the size of a **SOCKET**), the *lpvOutBuffer* parameter is a **NULL** pointer, or the *lpOverlapped* parameter is not a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEFAULT](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-245">**SIO \_BSP \_ 控制碼 \_ 輪詢** 是定義于 *Mswsock .h* 標頭檔中，並在 Windows Vista 和更新版本上支援。</span><span class="sxs-lookup"><span data-stu-id="56874-245">**SIO\_BSP\_HANDLE\_POLL** is defined in the *Mswsock.h* header file and supported on Windows Vista and later.</span></span>

### <a name="sio_chk_qos-opcode-setting-i-o-t3"></a><span data-ttu-id="56874-246">SIO \_ .Chk \_ QOS (opcode 設定： I、O、T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-246">SIO\_CHK\_QOS (opcode setting: I, O, T==3)</span></span>

<span data-ttu-id="56874-247">捕獲 QoS 流量特性的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="56874-247">Retrieves information about QoS traffic characteristics.</span></span> <span data-ttu-id="56874-248">在 flow 設定和收到 RESV 訊息之間傳送系統的過渡階段期間 (查看「 [Rsvp 服務」如何](/previous-versions/windows/desktop/qos/how-the-rsvp-service-invokes-tc) 叫用 TC，以取得過渡階段) 的詳細資訊。與「回復」流程相關聯的流量會根據「服務類型」（ ([最大努力](/previous-versions/windows/desktop/qos/best-effort)、 [受控制的負載](/previous-versions/windows/desktop/qos/controlled-load)或 [保證](/previous-versions/windows/desktop/qos/guaranteed)) ）成形。</span><span class="sxs-lookup"><span data-stu-id="56874-248">During the transitional phase on the sending system between flow setup and the receipt of a RESV message (see [How the RSVP Service Invokes TC](/previous-versions/windows/desktop/qos/how-the-rsvp-service-invokes-tc) for more information on the transitional phase), traffic associated with an RSVP flow is shaped based on service type ([BEST EFFORT](/previous-versions/windows/desktop/qos/best-effort), [CONTROLLED LOAD](/previous-versions/windows/desktop/qos/controlled-load), or [GUARANTEED](/previous-versions/windows/desktop/qos/guaranteed)).</span></span> <span data-ttu-id="56874-249">如需詳細資訊，請參閱 Platform SDK 的「[服務品質](/previous-versions/windows/desktop/qos/qos-start-page)」一節中的「[使用 SIO \_ .chk \_ QOS](/previous-versions/windows/desktop/qos/using-sio-chk-qos) 」。</span><span class="sxs-lookup"><span data-stu-id="56874-249">For more information, see [Using SIO\_CHK\_QOS](/previous-versions/windows/desktop/qos/using-sio-chk-qos) in the [Quality of Service](/previous-versions/windows/desktop/qos/qos-start-page) section of the Platform SDK.</span></span>

### <a name="sio_cpu_affinity-opcode-setting-i-t3"></a><span data-ttu-id="56874-250">SIO_CPU_AFFINITY (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-250">SIO_CPU_AFFINITY (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-251">啟用埠共用和接收指示平行處理。</span><span class="sxs-lookup"><span data-stu-id="56874-251">Enables port sharing and receive indication parallelization.</span></span> <span data-ttu-id="56874-252">當您的應用程式使用此通訊端選項來建立通訊端與不同處理器之間的關聯，然後將通訊端系結至相同的位址時，將會根據接收端調整 (RSS) 雜湊，將接收指示分散到通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-252">When your application uses this socket option to associate sockets to different processors, and then binds the sockets to the same address, receive indications will be distributed across the sockets based on Receive Side Scaling (RSS) hash.</span></span> <span data-ttu-id="56874-253">RSS 設定不會變更，因此任何指定的流程 (本機端點、遠端端點配對) 一律會在相同的處理器上指出。</span><span class="sxs-lookup"><span data-stu-id="56874-253">The RSS settings don't change, so any given flow (local endpoint, remote endpoint pair) will always be indicated on the same processor.</span></span> <span data-ttu-id="56874-254">如此一來，所有屬於指定流程的封包都會顯示在相同的通訊端中。</span><span class="sxs-lookup"><span data-stu-id="56874-254">As a result, all packets belonging to a given flow will be indicated to the same socket.</span></span> <span data-ttu-id="56874-255">這個 IOCTL 必須在系結之前呼叫，否則將會傳回 WSAEINVAL。</span><span class="sxs-lookup"><span data-stu-id="56874-255">This IOCTL must be called prior to bind, otherwise WSAEINVAL will be returned.</span></span> <span data-ttu-id="56874-256">輸入緩衝區是以 USHORT 類型 (0 為基礎) 的處理器索引。</span><span class="sxs-lookup"><span data-stu-id="56874-256">The input buffer is a processor index (0-based) of type USHORT.</span></span> <span data-ttu-id="56874-257">IOCTL 與 SO_REUSEADDR 和 SO_REUSE_MULTICASTPORT 不相容。</span><span class="sxs-lookup"><span data-stu-id="56874-257">The IOCTL is incompatible with SO_REUSEADDR and SO_REUSE_MULTICASTPORT.</span></span> <span data-ttu-id="56874-258">僅支援 UDP 通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-258">Only supported for UDP sockets.</span></span>

> [!NOTE]
> <span data-ttu-id="56874-259">如果您將目標設為版本 10.0.19041.0 (Windows 10，版本 2004) Windows SDK，請使用此值， `0x98000015` 而不是名稱 **SIO_CPU_AFFINITY**。</span><span class="sxs-lookup"><span data-stu-id="56874-259">If you're targeting version 10.0.19041.0 (Windows 10, version 2004) of the Windows SDK, then use the value `0x98000015` instead of the name **SIO_CPU_AFFINITY**.</span></span>

### <a name="sio_enable_circular_queueing-opcode-setting-v-t1"></a><span data-ttu-id="56874-260">SIO \_ 啟用 \_ 迴圈 \_ 佇列 (Opcode 設定： V，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-260">SIO\_ENABLE\_CIRCULAR\_QUEUEING (opcode setting: V, T==1)</span></span>

<span data-ttu-id="56874-261">向基礎訊息導向服務提供者指出，新抵達的訊息絕對不應該卸載，因為緩衝區佇列溢位。</span><span class="sxs-lookup"><span data-stu-id="56874-261">Indicates to the underlying message-oriented service provider that a newly arrived message should never be dropped because of a buffer queue overflow.</span></span> <span data-ttu-id="56874-262">相反地，應該消除佇列中最舊的訊息，以便容納新抵達的訊息。</span><span class="sxs-lookup"><span data-stu-id="56874-262">Instead, the oldest message in the queue should be eliminated in order to accommodate the newly arrived message.</span></span> <span data-ttu-id="56874-263">不需要輸入和輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-263">No input and output buffers are required.</span></span> <span data-ttu-id="56874-264">請注意，這個 IOCTL 只適用于與不可靠的訊息導向通訊協定相關聯的通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-264">Note that this IOCTL is only valid for sockets associated with unreliable, message-oriented protocols.</span></span> <span data-ttu-id="56874-265">針對不支援這個 IOCTL 的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-265">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support this IOCTL.</span></span>

### <a name="sio_find_route-opcode-setting-o-t1"></a><span data-ttu-id="56874-266">SIO \_ FIND \_ ROUTE (opcode 設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-266">SIO\_FIND\_ROUTE (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-267">發出時，此 IOCTL 會要求探索在輸入緩衝區中指定為 [**sockaddr**](sockaddr-2.md) 之遠端位址的路由。</span><span class="sxs-lookup"><span data-stu-id="56874-267">When issued, this IOCTL requests that the route to the remote address specified as a [**sockaddr**](sockaddr-2.md) in the input buffer be discovered.</span></span> <span data-ttu-id="56874-268">如果位址已存在於本機快取中，則其專案會失效。</span><span class="sxs-lookup"><span data-stu-id="56874-268">If the address already exists in the local cache, its entry is invalidated.</span></span> <span data-ttu-id="56874-269">在 Novell 的 IPX 案例中，此呼叫會起始 IPX GetLocalTarget (GLT) ，以查詢網路中的指定遠端位址。</span><span class="sxs-lookup"><span data-stu-id="56874-269">In the case of Novell's IPX, this call initiates an IPX GetLocalTarget (GLT), which queries the network for the given remote address.</span></span>

### <a name="sio_flush-opcode-setting-v-t1"></a><span data-ttu-id="56874-270">SIO \_ FLUSH (opcode 設定： V，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-270">SIO\_FLUSH (opcode setting: V, T==1)</span></span>

<span data-ttu-id="56874-271">捨棄與此通訊端關聯之傳送佇列的目前內容。</span><span class="sxs-lookup"><span data-stu-id="56874-271">Discards current contents of the sending queue associated with this socket.</span></span> <span data-ttu-id="56874-272">不需要輸入和輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-272">No input and output buffers are required.</span></span> <span data-ttu-id="56874-273">針對不支援這個 IOCTL 的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-273">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support this IOCTL.</span></span>

### <a name="sio_get_broadcast_address-opcode-setting-o-t1"></a><span data-ttu-id="56874-274">SIO \_ 取得 \_ 廣播 \_ 位址 (Opcode 設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-274">SIO\_GET\_BROADCAST\_ADDRESS (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-275">這個 IOCTL 會使用 [sockaddr](sockaddr-2.md)結構來填滿輸出緩衝區，其中包含適用于 [**sendto**](/windows/desktop/api/winsock/nf-winsock-sendto)WSASendTo 的適當廣播位址 /  [\*\*\*\*](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto)。</span><span class="sxs-lookup"><span data-stu-id="56874-275">This IOCTL fills the output buffer with a [sockaddr](sockaddr-2.md) structure containing a suitable broadcast address for use with [**sendto**](/windows/desktop/api/winsock/nf-winsock-sendto)/ [**WSASendTo**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto).</span></span> <span data-ttu-id="56874-276">IPv6 通訊端不支援這個 IOCTL，並傳回 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-276">This IOCTL is not supported for IPv6 sockets and returns the [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code.</span></span>

### <a name="sio_get_extension_function_pointer-opcode-setting-o-i-t1"></a><span data-ttu-id="56874-277">SIO \_ 取得延伸模組函式 \_ \_ \_ 指標 (操作碼設定： O，I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-277">SIO\_GET\_EXTENSION\_FUNCTION\_POINTER (opcode setting: O, I, T==1)</span></span>

<span data-ttu-id="56874-278">取得相關聯服務提供者所支援之指定擴充功能的指標。</span><span class="sxs-lookup"><span data-stu-id="56874-278">Retrieve a pointer to the specified extension function supported by the associated service provider.</span></span> <span data-ttu-id="56874-279">輸入緩衝區包含 (**GUID**) 的全域唯一識別碼，其值可識別有問題的擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-279">The input buffer contains a globally unique identifier (**GUID**) whose value identifies the extension function in question.</span></span> <span data-ttu-id="56874-280">要在輸出緩衝區中傳回所需函式的指標。</span><span class="sxs-lookup"><span data-stu-id="56874-280">The pointer to the desired function is returned in the output buffer.</span></span> <span data-ttu-id="56874-281">延伸模組函式識別碼是由服務提供者廠商所建立，而且應該包含在描述擴充功能功能和語義的廠商檔中。</span><span class="sxs-lookup"><span data-stu-id="56874-281">Extension function identifiers are established by service provider vendors and should be included in vendor documentation that describes extension function capabilities and semantics.</span></span>

<span data-ttu-id="56874-282">Windows TCP/IP 服務提供者所支援的擴充功能 GUID 值是定義在 *Mswsock .h* 標頭檔中。</span><span class="sxs-lookup"><span data-stu-id="56874-282">The GUID values for extension functions supported by the Windows TCP/IP service provider are defined in the *Mswsock.h* header file.</span></span> <span data-ttu-id="56874-283">這些 Guid 可能的值如下所示：</span><span class="sxs-lookup"><span data-stu-id="56874-283">The possible value for these GUIDs are as follows:</span></span>

| <span data-ttu-id="56874-284">詞彙</span><span class="sxs-lookup"><span data-stu-id="56874-284">Term</span></span>                                                                                                                | <span data-ttu-id="56874-285">描述</span><span class="sxs-lookup"><span data-stu-id="56874-285">Description</span></span>                                                                               |
|-|-|
| <span data-ttu-id="56874-286"><span id="WSAID_ACCEPTEX"></span><span id="wsaid_acceptex"></span>WSAID \_ ACCEPTEX</span><span class="sxs-lookup"><span data-stu-id="56874-286"><span id="WSAID_ACCEPTEX"></span><span id="wsaid_acceptex"></span>WSAID\_ACCEPTEX</span></span><br/>                                     | <span data-ttu-id="56874-287">[**AcceptEx**](/windows/win32/api/mswsock/nf-mswsock-acceptex)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-287">The [**AcceptEx**](/windows/win32/api/mswsock/nf-mswsock-acceptex) extension function.</span></span><br/>                         |
| <span data-ttu-id="56874-288"><span id="WSAID_CONNECTEX"></span><span id="wsaid_connectex"></span>WSAID \_ CONNECTEX</span><span class="sxs-lookup"><span data-stu-id="56874-288"><span id="WSAID_CONNECTEX"></span><span id="wsaid_connectex"></span>WSAID\_CONNECTEX</span></span><br/>                                  | <span data-ttu-id="56874-289">[**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-289">The [**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex) extension function.</span></span> <br/>                      |
| <span data-ttu-id="56874-290"><span id="WSAID_DISCONNECTEX"></span><span id="wsaid_disconnectex"></span>WSAID \_ DISCONNECTEX</span><span class="sxs-lookup"><span data-stu-id="56874-290"><span id="WSAID_DISCONNECTEX"></span><span id="wsaid_disconnectex"></span>WSAID\_DISCONNECTEX</span></span><br/>                         | <span data-ttu-id="56874-291">[**DisconnectEx**](/previous-versions/windows/desktop/legacy/ms737757(v=vs.85))擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-291">The [**DisconnectEx**](/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)) extension function.</span></span> <br/>                |
| <span data-ttu-id="56874-292"><span id="WSAID_GETACCEPTEXSOCKADDRS"></span><span id="wsaid_getacceptexsockaddrs"></span>WSAID \_ GETACCEPTEXSOCKADDRS</span><span class="sxs-lookup"><span data-stu-id="56874-292"><span id="WSAID_GETACCEPTEXSOCKADDRS"></span><span id="wsaid_getacceptexsockaddrs"></span>WSAID\_GETACCEPTEXSOCKADDRS</span></span><br/> | <span data-ttu-id="56874-293">[**GetAcceptExSockaddrs**](/windows/win32/api/mswsock/nf-mswsock-getacceptexsockaddrs)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-293">The [**GetAcceptExSockaddrs**](/windows/win32/api/mswsock/nf-mswsock-getacceptexsockaddrs) extension function.</span></span><br/> |
| <span data-ttu-id="56874-294"><span id="WSAID_TRANSMITFILE"></span><span id="wsaid_transmitfile"></span>WSAID \_ TRANSMITFILE</span><span class="sxs-lookup"><span data-stu-id="56874-294"><span id="WSAID_TRANSMITFILE"></span><span id="wsaid_transmitfile"></span>WSAID\_TRANSMITFILE</span></span><br/>                         | <span data-ttu-id="56874-295">[**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-295">The [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile) extension function.</span></span><br/>                 |
| <span data-ttu-id="56874-296"><span id="WSAID_TRANSMITPACKETS"></span><span id="wsaid_transmitpackets"></span>WSAID \_ TRANSMITPACKETS</span><span class="sxs-lookup"><span data-stu-id="56874-296"><span id="WSAID_TRANSMITPACKETS"></span><span id="wsaid_transmitpackets"></span>WSAID\_TRANSMITPACKETS</span></span><br/>                | <span data-ttu-id="56874-297">[**TransmitPackets**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_transmitpackets)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-297">The [**TransmitPackets**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_transmitpackets) extension function.</span></span> <br/>          |
| <span data-ttu-id="56874-298"><span id="WSAID_WSARECVMSG"></span><span id="wsaid_wsarecvmsg"></span>WSAID \_ WSARECVMSG</span><span class="sxs-lookup"><span data-stu-id="56874-298"><span id="WSAID_WSARECVMSG"></span><span id="wsaid_wsarecvmsg"></span>WSAID\_WSARECVMSG</span></span><br/>                               | <span data-ttu-id="56874-299">[**LPFN_WSARECVMSG (WSARECVMSG)**](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-299">The [**LPFN_WSARECVMSG (WSARecvMsg)**](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg) extension function.</span></span><br/>                     |
| <span data-ttu-id="56874-300"><span id="WSAID_WSASENDMSG"></span><span id="wsaid_wsasendmsg"></span>WSAID \_ WSASENDMSG</span><span class="sxs-lookup"><span data-stu-id="56874-300"><span id="WSAID_WSASENDMSG"></span><span id="wsaid_wsasendmsg"></span>WSAID\_WSASENDMSG</span></span><br/>                               | <span data-ttu-id="56874-301">[**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)擴充功能。</span><span class="sxs-lookup"><span data-stu-id="56874-301">The [**WSASendMsg**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) extension function.</span></span> <br/>                      |

### <a name="sio_get_group_qos-opcode-setting-o-i-t1"></a><span data-ttu-id="56874-302">SIO \_ 取得 \_ 群組 \_ QOS (操作碼設定： O，I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-302">SIO\_GET\_GROUP\_QOS (opcode setting: O, I, T==1)</span></span>

<span data-ttu-id="56874-303">保留供未來使用通訊端使用。</span><span class="sxs-lookup"><span data-stu-id="56874-303">Reserved for future use with sockets.</span></span>

<span data-ttu-id="56874-304">取得與此通訊端所屬之通訊端群組相關聯的 [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) 結構。</span><span class="sxs-lookup"><span data-stu-id="56874-304">Retrieve the [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) structure associated with the socket group to which this socket belongs.</span></span> <span data-ttu-id="56874-305">輸入緩衝區是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="56874-305">The input buffer is optional.</span></span> <span data-ttu-id="56874-306">某些通訊協定 (例如，「RSVP) 允許輸入緩衝區用來限定服務要求的品質。</span><span class="sxs-lookup"><span data-stu-id="56874-306">Some protocols (for example, RSVP) allow the input buffer to be used to qualify a quality of service request.</span></span> <span data-ttu-id="56874-307">**QOS** 結構將會複製到輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-307">The **QOS** structure will be copied into the output buffer.</span></span> <span data-ttu-id="56874-308">如果這個通訊端不屬於適當的通訊端群組，則傳回的 **QOS** 結構的 **SendingFlowspec** 和 **ReceivingFlowspec** 成員會設定為 **Null**。</span><span class="sxs-lookup"><span data-stu-id="56874-308">If this socket does not belong to an appropriate socket group, the **SendingFlowspec** and **ReceivingFlowspec** members of the returned **QOS** structure are set to **NULL**.</span></span> <span data-ttu-id="56874-309">針對不支援服務品質的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-309">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support quality of service.</span></span>

### <a name="sio_get_interface_list-opcode-setting-o-t0"></a><span data-ttu-id="56874-310">SIO \_ GET \_ INTERFACE \_ LIST (Opcode 設定： O，T = = 0) </span><span class="sxs-lookup"><span data-stu-id="56874-310">SIO\_GET\_INTERFACE\_LIST (opcode setting: O, T==0)</span></span>

<span data-ttu-id="56874-311">傳回已設定的 IP 介面及其參數的清單，做為 [**介面 \_ 資訊**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info) 結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="56874-311">Returns a list of configured IP interfaces and their parameters as an array of [**INTERFACE\_INFO**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info) structures.</span></span>

> [!Note]  
> <span data-ttu-id="56874-312">對 Windows 通訊端2相容的 TCP/IP 服務提供者，此命令的支援是必要的。</span><span class="sxs-lookup"><span data-stu-id="56874-312">Support of this command is mandatory for Windows Sockets 2-compliant TCP/IP service providers.</span></span>

<span data-ttu-id="56874-313">*LpvOutBuffer* 參數會指向緩衝區，以將介面的相關資訊儲存為介面上單播 IP 位址的 [**介面 \_ 資訊**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info)結構陣列。</span><span class="sxs-lookup"><span data-stu-id="56874-313">The *lpvOutBuffer* parameter points to the buffer in which to store the information about interfaces as an array of [**INTERFACE\_INFO**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info) structures for unicast IP addresses on the interfaces.</span></span> <span data-ttu-id="56874-314">*CbOutBuffer* 參數會指定輸出緩衝區的長度。</span><span class="sxs-lookup"><span data-stu-id="56874-314">The *cbOutBuffer* parameter specifies the length of the output buffer.</span></span> <span data-ttu-id="56874-315">在 *lpvOutBuffer* 參數所指向的緩衝區中傳回的結構數目 (傳回的介面數目) 可以根據 *lpcbBytesReturned* 參數中所傳回之輸出緩衝區的實際長度來決定。</span><span class="sxs-lookup"><span data-stu-id="56874-315">The number of interfaces returned (number of structures returned in the buffer pointed to by *lpvOutBuffer* parameter) can be determined based on the actual length of the output buffer returned in *lpcbBytesReturned* parameter.</span></span>

<span data-ttu-id="56874-316">如果使用 **SIO \_ GET \_ INTERFACE \_ LIST** 呼叫 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl)函式，而通訊端 *s* 參數的層級成員未定義為 **IPPROTO \_ IP**，則會傳回 **WSAEINVAL** 。</span><span class="sxs-lookup"><span data-stu-id="56874-316">If the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function is called with **SIO\_GET\_INTERFACE\_LIST** and the level member of the socket *s* parameter is not defined as **IPPROTO\_IP**, **WSAEINVAL** is returned.</span></span> <span data-ttu-id="56874-317">如果指定輸出緩衝區長度的 *cbOutBuffer* 參數太小，則呼叫 **WSAIoctl** 函式的 **SIO \_ GET \_ INTERFACE \_ list** 會傳回 **WSAEFAULT** ，以取得已設定的介面清單。</span><span class="sxs-lookup"><span data-stu-id="56874-317">A call to the **WSAIoctl** function with **SIO\_GET\_INTERFACE\_LIST** returns **WSAEFAULT** if the *cbOutBuffer* parameter that specifies the length of the output buffer is too small ro receive the list of configured interfaces.</span></span>

<span data-ttu-id="56874-318">**SIO \_GET \_ INTERFACE \_ LIST** 在 Windows Me/98 和 Windows NT 4.0 加裝 SP4 和更新版本支援。</span><span class="sxs-lookup"><span data-stu-id="56874-318">**SIO\_GET\_INTERFACE\_LIST** is supported on Windows Me/98 and Windows NT 4.0 with SP4 and later.</span></span>

### <a name="sio_get_interface_list_ex-opcode-setting-o-t0"></a><span data-ttu-id="56874-319">SIO \_ 取得 \_ 介面 \_ 清單， \_ 例如 (操作碼設定： O、T = = 0) </span><span class="sxs-lookup"><span data-stu-id="56874-319">SIO\_GET\_INTERFACE\_LIST\_EX (opcode setting: O, T==0)</span></span>

<span data-ttu-id="56874-320">保留供未來使用通訊端使用。</span><span class="sxs-lookup"><span data-stu-id="56874-320">Reserved for future use with sockets.</span></span>

<span data-ttu-id="56874-321">傳回已設定的 IP 介面及其參數的清單，做為 [**介面 \_ 資訊 \_ EX**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex) 結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="56874-321">Returns a list of configured IP interfaces and their parameters as an array of [**INTERFACE\_INFO\_EX**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex) structures.</span></span>

<span data-ttu-id="56874-322">*LpvOutBuffer* 參數會指向緩衝區，以將介面的相關資訊儲存為介面上單播 IP 位址 [**的 \_ 介面 \_ 資訊**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex)的陣列。</span><span class="sxs-lookup"><span data-stu-id="56874-322">The *lpvOutBuffer* parameter points to the buffer in which to store the information about interfaces as an array of [**INTERFACE\_INFO\_EX**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex) structures for unicast IP addresses on the interface.</span></span> <span data-ttu-id="56874-323">*CbOutBuffer* 參數會指定輸出緩衝區的長度。</span><span class="sxs-lookup"><span data-stu-id="56874-323">The *cbOutBuffer* parameter specifies the length of the output buffer.</span></span> <span data-ttu-id="56874-324">傳回的介面數目 (在 *lpvOutBuffer* 中傳回的結構數目) 可根據 *lpcbBytesReturned* 參數中所傳回之輸出緩衝區的實際長度來決定。</span><span class="sxs-lookup"><span data-stu-id="56874-324">The number of interfaces returned (number of structures returned in *lpvOutBuffer*) can be determined based on the actual length of the output buffer returned in *lpcbBytesReturned* parameter.</span></span>

<span data-ttu-id="56874-325">**SIO \_Windows 上目前不支援取得 \_ 介面 \_ 清單 \_ EX** 。</span><span class="sxs-lookup"><span data-stu-id="56874-325">**SIO\_GET\_INTERFACE\_LIST\_EX** is not currently supported on Windows.</span></span>

### <a name="sio_get_qos-opcode-setting-o-t1"></a><span data-ttu-id="56874-326">SIO \_ 取得 \_ QOS (操作碼設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-326">SIO\_GET\_QOS (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-327">保留供未來使用通訊端使用。</span><span class="sxs-lookup"><span data-stu-id="56874-327">Reserved for future use with sockets.</span></span> <span data-ttu-id="56874-328">取出與通訊端相關聯的 [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) 結構。</span><span class="sxs-lookup"><span data-stu-id="56874-328">Retrieve the [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) structure associated with the socket.</span></span> <span data-ttu-id="56874-329">輸入緩衝區是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="56874-329">The input buffer is optional.</span></span> <span data-ttu-id="56874-330">某些通訊協定 (例如，「RSVP) 允許輸入緩衝區用來限定服務要求的品質。</span><span class="sxs-lookup"><span data-stu-id="56874-330">Some protocols (for example, RSVP) allow the input buffer to be used to qualify a quality of service request.</span></span> <span data-ttu-id="56874-331">**QOS** 結構將會複製到輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-331">The **QOS** structure will be copied into the output buffer.</span></span> <span data-ttu-id="56874-332">輸出緩衝區的大小必須夠大，才能包含完整的 **QOS** 結構。</span><span class="sxs-lookup"><span data-stu-id="56874-332">The output buffer must be sized large enough to be able to contain the full **QOS** structure.</span></span> <span data-ttu-id="56874-333">針對不支援服務品質的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-333">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support quality of service.</span></span>

<span data-ttu-id="56874-334">傳送者可能不會呼叫 **SIO \_ 取得 \_ QOS** ，直到通訊端連線為止。</span><span class="sxs-lookup"><span data-stu-id="56874-334">A sender may not call **SIO\_GET\_QOS** until the socket is connected.</span></span>

<span data-ttu-id="56874-335">接收者可能會在系結時呼叫 **SIO \_ 取得 \_ QOS** 。</span><span class="sxs-lookup"><span data-stu-id="56874-335">A receiver may call **SIO\_GET\_QOS** as soon as it is bound.</span></span>

### <a name="sio_get_tx_timestamp"></a><span data-ttu-id="56874-336">SIO_GET_TX_TIMESTAMP</span><span class="sxs-lookup"><span data-stu-id="56874-336">SIO_GET_TX_TIMESTAMP</span></span>

<span data-ttu-id="56874-337">通訊端 IOCTL 可用來取得傳輸 (TX) 封包的時間戳記。</span><span class="sxs-lookup"><span data-stu-id="56874-337">A socket IOCTL used to get timestamps for transmitted (TX) packets.</span></span> <span data-ttu-id="56874-338">只對資料包通訊端有效。</span><span class="sxs-lookup"><span data-stu-id="56874-338">Valid only for datagram sockets.</span></span>

<span data-ttu-id="56874-339">**SIO_GET_TX_TIMESTAMP** 控制程式代碼會從通訊端的傳輸時間戳記佇列中移除傳輸時間戳記。</span><span class="sxs-lookup"><span data-stu-id="56874-339">The **SIO_GET_TX_TIMESTAMP** control code removes a transmit timestamp from a socket's transmit timestamp queue.</span></span> <span data-ttu-id="56874-340">請先使用 [**SIO_TIMESTAMPING**](#sio_timestamping) 通訊端 IOCTL 來啟用時間戳記接收。</span><span class="sxs-lookup"><span data-stu-id="56874-340">Enable timestamp reception first by using the [**SIO_TIMESTAMPING**](#sio_timestamping) socket IOCTL.</span></span> <span data-ttu-id="56874-341">然後藉由使用下列參數呼叫 [**WSAIoctl**](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) (或 [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85))) 函式，依識別碼取出 tx 時間戳記。</span><span class="sxs-lookup"><span data-stu-id="56874-341">Then retrieve tx timestamps by ID by calling the [**WSAIoctl**](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) (or [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85))) function with the following parameters.</span></span>

<span data-ttu-id="56874-342">針對 **SIO_GET_TX_TIMESTAMP**，輸入是 **UINT32** 時間戳記識別碼，輸出則是 **UINT64** 時間戳記值。</span><span class="sxs-lookup"><span data-stu-id="56874-342">For **SIO_GET_TX_TIMESTAMP**, the input is a **UINT32** timestamp ID, and the output is a **UINT64** timestamp value.</span></span> <span data-ttu-id="56874-343">成功時，可以使用 tx 時間戳記，並傳回。</span><span class="sxs-lookup"><span data-stu-id="56874-343">On success, the tx timestamp is available, and is returned.</span></span> <span data-ttu-id="56874-344">如果沒有可用的傳輸時間戳記，則 [**WSAGetLastError**](/windows/win32/api/winsock/nf-winsock-wsagetlasterror) 會傳回 **WSAEWOULDBLOCK**。</span><span class="sxs-lookup"><span data-stu-id="56874-344">If no transmit timestamps are available, then [**WSAGetLastError**](/windows/win32/api/winsock/nf-winsock-wsagetlasterror) returns **WSAEWOULDBLOCK**.</span></span>

> [!NOTE]
> <span data-ttu-id="56874-345">透過 **UDP_SEND_MSG_SIZE** 進行結合的傳送時，不支援 TX 時間戳記。</span><span class="sxs-lookup"><span data-stu-id="56874-345">TX timestamps are not supported when doing a coalesced send via **UDP_SEND_MSG_SIZE**.</span></span>

<span data-ttu-id="56874-346">另請參閱 [Winsock 時間戳記](/windows/win32/winsock/winsock-timestamping)。</span><span class="sxs-lookup"><span data-stu-id="56874-346">Also see [Winsock timestamping](/windows/win32/winsock/winsock-timestamping).</span></span>

### <a name="sio_ideal_send_backlog_change-opcode-setting-v-t0"></a><span data-ttu-id="56874-347">SIO \_ 理想的 \_ 傳送待處理專案 \_ \_ 變更 (操作碼設定： V，T = = 0) </span><span class="sxs-lookup"><span data-stu-id="56874-347">SIO\_IDEAL\_SEND\_BACKLOG\_CHANGE (opcode setting: V, T==0)</span></span>

<span data-ttu-id="56874-348">當理想的傳送待處理專案 (ISB) 值變更基礎連接時通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="56874-348">Notifies an application when the ideal send backlog (ISB) value changes for the underlying connection.</span></span>

<span data-ttu-id="56874-349">使用 Windows sockets 透過 TCP 連線傳送資料時，請務必保留足夠的資料量， (傳送但尚未認可到 TCP 中的) ，以達到最高的輸送量。</span><span class="sxs-lookup"><span data-stu-id="56874-349">When sending data over a TCP connection using Windows sockets, it is important to keep a sufficient amount of data outstanding (sent but not acknowledged yet) in TCP in order to achieve the highest throughput.</span></span> <span data-ttu-id="56874-350">若要達到 TCP 連接的最佳輸送量，最理想的資料量值就稱為「理想的傳送待處理專案」 (ISB) 大小。</span><span class="sxs-lookup"><span data-stu-id="56874-350">The ideal value for the amount of data outstanding to achieve the best throughput for the TCP connection is called the ideal send backlog (ISB) size.</span></span> <span data-ttu-id="56874-351">ISB 值是 TCP 連線之頻寬延遲乘積的函式，而接收者的通告接收視窗 (以及網路) 中的擁塞量部分。</span><span class="sxs-lookup"><span data-stu-id="56874-351">The ISB value is a function of the bandwidth-delay product of the TCP connection and the receiver's advertised receive window (and partly the amount of congestion in the network).</span></span>

<span data-ttu-id="56874-352">您可以從 Windows Server 2008、Windows Vista SP1 和更新版本的作業系統中的 TCP 通訊協定，取得每個連接的 ISB 值。</span><span class="sxs-lookup"><span data-stu-id="56874-352">The ISB value per connection is available from the TCP protocol implementation in Windows Server 2008, Windows Vista with SP1, and later versions of the operating system.</span></span> <span data-ttu-id="56874-353">**SIO \_ 理想的 \_ 傳送 \_ 待 \_** 處理專案變更 IOCTL 可供應用程式使用，以在 ISB 值針對連接動態變更時取得通知。</span><span class="sxs-lookup"><span data-stu-id="56874-353">The **SIO\_IDEAL\_SEND\_BACKLOG\_CHANGE** IOCTL can be used by an application to get notification when the ISB value changes dynamically for a connection.</span></span>

<span data-ttu-id="56874-354">如需詳細資訊，請參閱 [**SIO \_ 理想的 \_ 傳送 \_ 待 \_**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) 處理專案變更參考。</span><span class="sxs-lookup"><span data-stu-id="56874-354">For more detailed information, see the [**SIO\_IDEAL\_SEND\_BACKLOG\_CHANGE**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-355">[**SIO \_Windows \_ Server \_ \_**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) 2008、windows Vista SP1 和更新版本的作業系統都支援理想的傳送待處理專案變更。</span><span class="sxs-lookup"><span data-stu-id="56874-355">[**SIO\_IDEAL\_SEND\_BACKLOG\_CHANGE**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) is supported on Windows Server 2008, Windows Vista with SP1, and later versions of the operating system.</span></span>

### <a name="sio_ideal_send_backlog_query-opcode-setting-o-t0"></a><span data-ttu-id="56874-356">SIO \_ 理想 \_ 的傳送待處理專案 \_ （BACKLOG） \_ 查詢 (操作碼設定： O，T = = 0) </span><span class="sxs-lookup"><span data-stu-id="56874-356">SIO\_IDEAL\_SEND\_BACKLOG\_QUERY (opcode setting: O, T==0)</span></span>

<span data-ttu-id="56874-357">抓取基礎連接 (ISB) 值的理想傳送待辦專案。</span><span class="sxs-lookup"><span data-stu-id="56874-357">Retrieves the ideal send backlog (ISB) value for the underlying connection.</span></span>

<span data-ttu-id="56874-358">使用 Windows sockets 透過 TCP 連線傳送資料時，請務必保留足夠的資料量， (傳送但尚未認可到 TCP 中的) ，以達到最高的輸送量。</span><span class="sxs-lookup"><span data-stu-id="56874-358">When sending data over a TCP connection using Windows sockets, it is important to keep a sufficient amount of data outstanding (sent but not acknowledged yet) in TCP in order to achieve the highest throughput.</span></span> <span data-ttu-id="56874-359">若要達到 TCP 連接的最佳輸送量，最理想的資料量值就稱為「理想的傳送待處理專案」 (ISB) 大小。</span><span class="sxs-lookup"><span data-stu-id="56874-359">The ideal value for the amount of data outstanding to achieve the best throughput for the TCP connection is called the ideal send backlog (ISB) size.</span></span> <span data-ttu-id="56874-360">ISB 值是 TCP 連線之頻寬延遲乘積的函式，而接收者的通告接收視窗 (以及網路) 中的擁塞量部分。</span><span class="sxs-lookup"><span data-stu-id="56874-360">The ISB value is a function of the bandwidth-delay product of the TCP connection and the receiver's advertised receive window (and partly the amount of congestion in the network).</span></span>

<span data-ttu-id="56874-361">您可以從 Windows Server 2008 和更新版本中的 TCP 通訊協定，取得每個連接的 ISB 值。</span><span class="sxs-lookup"><span data-stu-id="56874-361">The ISB value per connection is available from the TCP protocol implementation in Windows Server 2008 and later.</span></span> <span data-ttu-id="56874-362">**SIO \_ 理想的 \_ 傳送待處理專案 \_ （BACKLOG） \_ 查詢** IOCTL 可以由應用程式用來查詢連接的 ISB 值。</span><span class="sxs-lookup"><span data-stu-id="56874-362">The **SIO\_IDEAL\_SEND\_BACKLOG\_QUERY** IOCTL can be used by an application to query the ISB value for a connection.</span></span>

<span data-ttu-id="56874-363">如需詳細資訊，請參閱 [**SIO \_ 理想的 \_ 傳送 \_ 待 \_**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) 處理專案查詢參考。</span><span class="sxs-lookup"><span data-stu-id="56874-363">For more detailed information, see the [**SIO\_IDEAL\_SEND\_BACKLOG\_QUERY**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-364">[**SIO \_Windows \_ Server \_ \_**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) 2008、windows Vista SP1 和更新版本的作業系統都支援理想的傳送待處理專案查詢。</span><span class="sxs-lookup"><span data-stu-id="56874-364">[**SIO\_IDEAL\_SEND\_BACKLOG\_QUERY**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) is supported on Windows Server 2008, Windows Vista with SP1, and later versions of the operating system.</span></span>

### <a name="sio_keepalive_vals-opcode-setting-i-t3"></a><span data-ttu-id="56874-365">SIO \_ KEEPALIVE \_ VALS (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-365">SIO\_KEEPALIVE\_VALS (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-366">啟用或停用 TCP **keep-alive** 選項的每一連接設定，以指定 tcp keep-alive timeout 和 interval。</span><span class="sxs-lookup"><span data-stu-id="56874-366">Enables or disables the per-connection setting of the TCP **keep-alive** option which specifies the TCP keep-alive timeout and interval.</span></span> <span data-ttu-id="56874-367">如需保持連線選項的詳細資訊，請參閱4.2.3.6 中的「 *網際網路主機需求* 」一節：在 [IETF 網站](https://www.ietf.org/rfc/rfc1122.txt)提供的 RFC 1122 中所指定的通訊層。</span><span class="sxs-lookup"><span data-stu-id="56874-367">For more information on the keep-alive option, see section 4.2.3.6 on the *Requirements for Internet Hosts—Communication Layers* specified in RFC 1122 available at the [IETF website](https://www.ietf.org/rfc/rfc1122.txt).</span></span> <span data-ttu-id="56874-368"> (此資源可能僅提供英文版。 ) </span><span class="sxs-lookup"><span data-stu-id="56874-368">(This resource may only be available in English.)</span></span>

<span data-ttu-id="56874-369">**SIO \_KEEPALIVE \_ VALS** 可用來啟用或停用 keep-alive 探查，並設定 keep-alive timeout 和 interval。</span><span class="sxs-lookup"><span data-stu-id="56874-369">**SIO\_KEEPALIVE\_VALS** can be used to enable or disable keep-alive probes and set the keep-alive timeout and interval.</span></span> <span data-ttu-id="56874-370">Keep-alive timeout 會以毫秒為單位來指定在第一個 keep-alive 封包傳送之前沒有任何活動的超時時間。</span><span class="sxs-lookup"><span data-stu-id="56874-370">The keep-alive timeout specifies the timeout, in milliseconds, with no activity until the first keep-alive packet is sent.</span></span> <span data-ttu-id="56874-371">Keep-alive 間隔會指定如果沒有收到任何通知，在連續的 keep-alive 封包傳送時的間隔（以毫秒為單位）。</span><span class="sxs-lookup"><span data-stu-id="56874-371">The keep-alive interval specifies the interval, in milliseconds, between when successive keep-alive packets are sent if no acknowledgement is received.</span></span>

<span data-ttu-id="56874-372">「 [**使用 \_ 中存留」選項（**](so-keepalive.md) 也就是其中一個「 [SOL \_ 通訊端通訊端」選項](sol-socket-socket-options.md)）也可用來啟用或停用連線上的 TCP keep-alive，以及查詢此選項的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="56874-372">The [**SO\_KEEPALIVE**](so-keepalive.md) option, which is one of the [SOL\_SOCKET Socket Options](sol-socket-socket-options.md), can also be used to enable or disable the TCP keep-alive on a connection, as well as query the current state of this option.</span></span> <span data-ttu-id="56874-373">若要查詢是否在通訊端上啟用 TCP keep-alive，可以使用「使用 **\_ KEEPALIVE** 」選項來呼叫 [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)函數。</span><span class="sxs-lookup"><span data-stu-id="56874-373">To query whether TCP keep-alive is enabled on a socket, the [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt) function can be called with the **SO\_KEEPALIVE** option.</span></span> <span data-ttu-id="56874-374">若要啟用或停用 TCP 保持連線，您可以使用 [使用 [**\_ KEEPALIVE**](so-keepalive.md) ] 選項來呼叫 [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt)函數。</span><span class="sxs-lookup"><span data-stu-id="56874-374">To enable or disable TCP keep-alive, the [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) function can be called with the [**SO\_KEEPALIVE**](so-keepalive.md) option.</span></span> <span data-ttu-id="56874-375">如果啟用 TCP keep-alive，則會將預設 TCP 設定用於保持連線的超時時間和 **間隔，除非 \_** 使用 **SIO \_ KEEPALIVE \_ VALS** 變更這些值。</span><span class="sxs-lookup"><span data-stu-id="56874-375">If TCP keep-alive is enabled with **SO\_KEEPALIVE**, then the default TCP settings are used for keep-alive timeout and interval unless these values have been changed using **SIO\_KEEPALIVE\_VALS**.</span></span>

<span data-ttu-id="56874-376">如需詳細資訊，請參閱 [**SIO \_ KEEPALIVE \_ VALS**](/previous-versions/windows/desktop/legacy/dd877220(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-376">For more detailed information, see the [**SIO\_KEEPALIVE\_VALS**](/previous-versions/windows/desktop/legacy/dd877220(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-377">**SIO \_Windows \_** 2000 和更新版本支援 KEEPALIVE VALS。</span><span class="sxs-lookup"><span data-stu-id="56874-377">**SIO\_KEEPALIVE\_VALS** is supported on Windows 2000 and later.</span></span>

### <a name="sio_loopback_fast_path-opcode-setting-i-t3"></a><span data-ttu-id="56874-378">SIO \_ 回送 \_ 快速 \_ 路徑 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-378">SIO\_LOOPBACK\_FAST\_PATH (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-379">在回送介面上設定 TCP 通訊端，以降低延遲和加快作業的速度。</span><span class="sxs-lookup"><span data-stu-id="56874-379">Configures a TCP socket for lower latency and faster operations on the loopback interface.</span></span> <span data-ttu-id="56874-380">此 IOCTL 要求 TCP/IP 堆疊針對此通訊端上的回送作業使用特殊的快速路徑。</span><span class="sxs-lookup"><span data-stu-id="56874-380">This IOCTL requests that the TCP/IP stack uses a special fast path for loopback operations on this socket.</span></span> <span data-ttu-id="56874-381">[**SIO \_ 回送 \_ 快速 \_ 路徑**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85))IOCTL 只能用於 TCP 通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-381">The [**SIO\_LOOPBACK\_FAST\_PATH**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85)) IOCTL can be used only with TCP sockets.</span></span> <span data-ttu-id="56874-382">這個 IOCTL 必須用於回送會話的兩端。</span><span class="sxs-lookup"><span data-stu-id="56874-382">This IOCTL must be used on both sides of the loopback session.</span></span> <span data-ttu-id="56874-383">您可以使用 IPv4 或 IPv6 回送介面，來支援 TCP 回送快速路徑。</span><span class="sxs-lookup"><span data-stu-id="56874-383">The TCP loopback fast path is supported using either the IPv4 or IPv6 loopback interface.</span></span> <span data-ttu-id="56874-384">預設會停用 **SIO \_ 回送 \_ 快速 \_ 路徑** 。</span><span class="sxs-lookup"><span data-stu-id="56874-384">By default, **SIO\_LOOPBACK\_FAST\_PATH** is disabled.</span></span>

<span data-ttu-id="56874-385">如需詳細資訊，請參閱 [**SIO \_ 回送 \_ 快速 \_ 路徑**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-385">For more detailed information, see the [**SIO\_LOOPBACK\_FAST\_PATH**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-386">**SIO \_Windows 8 \_ \_** 、Windows Server 2012 及更新版本都支援回送快速路徑。</span><span class="sxs-lookup"><span data-stu-id="56874-386">**SIO\_LOOPBACK\_FAST\_PATH** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_multipoint_loopback-opcode-setting-v-t1"></a><span data-ttu-id="56874-387">SIO \_ MULTIPOINT \_ 回送 (操作碼設定： V，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-387">SIO\_MULTIPOINT\_LOOPBACK (opcode setting: V, T==1)</span></span>

<span data-ttu-id="56874-388">控制應用程式在本機電腦上傳送的資料 (不一定是在多播會話中的相同通訊端) ，將會由聯結至回送介面上多播目的地群組的通訊端接收。</span><span class="sxs-lookup"><span data-stu-id="56874-388">Controls whether data sent by an application on the local computer (not necessarily by the same socket) in a multicast session will be received by a socket joined to the multicast destination group on the loopback interface.</span></span> <span data-ttu-id="56874-389">**TRUE** 值會導致本機電腦上的應用程式傳送的多播資料，傳遞給回送介面上的接聽通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-389">A value of **TRUE** causes multicast data sent by an application on the local computer to be delivered to a listening socket on the loopback interface.</span></span> <span data-ttu-id="56874-390">值為 **FALSE** 可防止本機電腦上的應用程式傳送的多播資料，將其傳遞至回送介面上的接聽通訊端。</span><span class="sxs-lookup"><span data-stu-id="56874-390">A value of **FALSE** prevents multicast data sent by an application on the local computer from being delivered to a listening socket on the loopback interface.</span></span> <span data-ttu-id="56874-391">預設會啟用 **SIO \_ MULTIPOINT \_ 回送** 。</span><span class="sxs-lookup"><span data-stu-id="56874-391">By default, **SIO\_MULTIPOINT\_LOOPBACK** is enabled.</span></span>

### <a name="sio_multicast_scope-opcode-setting-i-t1"></a><span data-ttu-id="56874-392">SIO \_ 多播 \_ 範圍 (操作碼設定： I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-392">SIO\_MULTICAST\_SCOPE (opcode setting: I, T==1)</span></span>

<span data-ttu-id="56874-393">指定將進行多播傳輸的範圍。</span><span class="sxs-lookup"><span data-stu-id="56874-393">Specifies the scope over which multicast transmissions will occur.</span></span> <span data-ttu-id="56874-394">範圍定義為要涵蓋的路由網路區段數目。</span><span class="sxs-lookup"><span data-stu-id="56874-394">Scope is defined as the number of routed network segments to be covered.</span></span> <span data-ttu-id="56874-395">範圍為零會指出多播傳輸不會放置在網路上，但是可以跨本機主機內的通訊端簡易性。</span><span class="sxs-lookup"><span data-stu-id="56874-395">A scope of zero would indicate that the multicast transmission would not be placed on the wire but could be disseminated across sockets within the local host.</span></span> <span data-ttu-id="56874-396">一個範圍值 (預設) 表示傳輸將放置在網路上，但不會跨越任何路由器。</span><span class="sxs-lookup"><span data-stu-id="56874-396">A scope value of one (the default) indicates that the transmission will be placed on the wire, but will not cross any routers.</span></span> <span data-ttu-id="56874-397">較高範圍的值會決定可跨越的路由器數目。</span><span class="sxs-lookup"><span data-stu-id="56874-397">Higher scope values determine the number of routers that can be crossed.</span></span> <span data-ttu-id="56874-398">請注意，這會對應至 IP 多播中的存留時間 (TTL) 參數。</span><span class="sxs-lookup"><span data-stu-id="56874-398">Note that this corresponds to the time-to-live (TTL) parameter in IP multicasting.</span></span> <span data-ttu-id="56874-399">範圍預設為1。</span><span class="sxs-lookup"><span data-stu-id="56874-399">By default, scope is 1.</span></span>

### <a name="sio_query_rss_processor_info-opcode-setting-o-t1"></a><span data-ttu-id="56874-400">SIO \_ 查詢 \_ RSS \_ 處理器 \_ 資訊 (操作碼設定： O，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-400">SIO\_QUERY\_RSS\_PROCESSOR\_INFO (opcode setting: O, T==1)</span></span>

<span data-ttu-id="56874-401">查詢通訊端與 RSS 處理器核心和 NUMA 節點之間的關聯。</span><span class="sxs-lookup"><span data-stu-id="56874-401">Queries the association between a socket and an RSS processor core and NUMA node.</span></span>

<span data-ttu-id="56874-402">[**SIO \_ 查詢 \_ RSS \_ 處理器 \_ 資訊**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85))IOCTL 會傳回 [**通訊端 \_ 處理器 \_ 親和性**](/windows/desktop/api/Ws2def/ns-ws2def-socket_processor_affinity)結構，其中包含 [**處理器 \_ 編號**](/windows/win32/api/winnt/ns-winnt-processor_number)和 NUMA 節點識別碼。</span><span class="sxs-lookup"><span data-stu-id="56874-402">The [**SIO\_QUERY\_RSS\_PROCESSOR\_INFO**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85)) IOCTL returns a [**SOCKET\_PROCESSOR\_AFFINITY**](/windows/desktop/api/Ws2def/ns-ws2def-socket_processor_affinity) structure that contains the [**PROCESSOR\_NUMBER**](/windows/win32/api/winnt/ns-winnt-processor_number) and the NUMA node ID.</span></span> <span data-ttu-id="56874-403">傳回的 **處理器 \_ 編號** 結構包含群組中的群組編號和相對處理器號碼。</span><span class="sxs-lookup"><span data-stu-id="56874-403">The returned **PROCESSOR\_NUMBER** structure contains a group number and relative processor number within the group.</span></span>

<span data-ttu-id="56874-404">如需詳細資訊，請參閱 [**SIO \_ 查詢 \_ RSS \_ 處理器 \_ 資訊**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-404">For more detailed information, see the [**SIO\_QUERY\_RSS\_PROCESSOR\_INFO**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-405">**SIO \_Windows 8、Windows Server 2012 及更新版本都支援查詢 \_ RSS \_ 處理器 \_ 資訊** 。</span><span class="sxs-lookup"><span data-stu-id="56874-405">**SIO\_QUERY\_RSS\_PROCESSOR\_INFO** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_query_rss_scalability_info-opcode-setting-o-t3"></a><span data-ttu-id="56874-406">SIO \_ 查詢 \_ RSS 擴充 \_ 性 \_ 資訊 (操作碼設定： O，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-406">SIO\_QUERY\_RSS\_SCALABILITY\_INFO (opcode setting: O, T==3)</span></span>

<span data-ttu-id="56874-407">查詢會卸載用於接收端調整 (RSS) 功能的介面。</span><span class="sxs-lookup"><span data-stu-id="56874-407">Queries offload interfaces for receive-side scaling (RSS) capability.</span></span> <span data-ttu-id="56874-408">針對 **SIO \_ 查詢 \_ RSS 擴充 \_ 性 \_ 資訊** 所傳回的引數結構，是在 *Mstcpip .h* 標頭檔中定義的 **RSS 擴充 \_ 性 \_ 資訊** 結構中指定。</span><span class="sxs-lookup"><span data-stu-id="56874-408">The argument structure returned for **SIO\_QUERY\_RSS\_SCALABILITY\_INFO** is specified in the **RSS\_SCALABILITY\_INFO** structure defined in the *Mstcpip.h* header file.</span></span> <span data-ttu-id="56874-409">此結構的定義如下：</span><span class="sxs-lookup"><span data-stu-id="56874-409">This structure is defined as follows:</span></span>

```cpp
// Scalability info for the transport
typedef struct _RSS_SCALABILITY_INFO {
   BOOLEAN RssEnabled;
} RSS_SCALABILITY_INFO, *PRSS_SCALABILITY_INFO;
```

<span data-ttu-id="56874-410">在 **RssEnabled** 成員中傳回的值會指出是否已在至少一個介面上啟用 RSS。</span><span class="sxs-lookup"><span data-stu-id="56874-410">The value returned in the **RssEnabled** member indicates if RSS is enabled on at least one interface.</span></span>

<span data-ttu-id="56874-411">如果輸出緩衝區不夠大，無法滿足 Rss 的 **擴充 \_ 性 \_ 資訊** 結構 (*cbOutBuffer* 小於 **rss 擴充 \_ 性 \_ 資訊** 的大小) 或 *lpvOutBuffer* 參數為 **Null** 指標，則會傳回 **通訊端 \_ 錯誤** ，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEINVAL](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-411">If the output buffer is not large enough for the **RSS\_SCALABILITY\_INFO** structure (the *cbOutBuffer* is less than the size of a **RSS\_SCALABILITY\_INFO**) or the *lpvOutBuffer* parameter is a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEINVAL](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-412">在多個 Cpu 位於單一系統內的高速網路中，會禁止網路通訊協定堆疊在多 CPU 系統上適當調整的能力，因為 NDIS 5.1 和較早版本的架構會限制只接收單一 CPU 的通訊協定處理。</span><span class="sxs-lookup"><span data-stu-id="56874-412">In high-speed networking where multiple CPUs reside within a single system, the ability of the networking protocol stack to scale well on a multi-CPU system is inhibited because the architecture of NDIS 5.1 and earlier versions limits receive protocol processing to a single CPU.</span></span> <span data-ttu-id="56874-413">接收端調整 (RSS) 可讓網路介面卡的網路負載跨多個 Cpu 進行平衡，藉此解決此問題。</span><span class="sxs-lookup"><span data-stu-id="56874-413">Receive-side scaling (RSS) resolves this issue by allowing the network load from a network adapter to be balanced across multiple CPUs.</span></span>

<span data-ttu-id="56874-414">**SIO \_Windows Vista 和更新版本支援查詢 \_ RSS 擴充 \_ 性 \_ 資訊** 。</span><span class="sxs-lookup"><span data-stu-id="56874-414">**SIO\_QUERY\_RSS\_SCALABILITY\_INFO** is supported on Windows Vista and later.</span></span>

### <a name="sio_query_transport_setting-opcode-setting-i-t3"></a><span data-ttu-id="56874-415">SIO \_ 查詢 \_ 傳輸 \_ 設定 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-415">SIO\_QUERY\_TRANSPORT\_SETTING (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-416">查詢通訊端上的傳輸設定。</span><span class="sxs-lookup"><span data-stu-id="56874-416">Queries the transport settings on a socket.</span></span> <span data-ttu-id="56874-417">正在查詢的傳輸設定是以 *lpvInBuffer* 參數中傳遞的 [**傳輸 \_ 設定 \_ 識別碼**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id)為基礎。</span><span class="sxs-lookup"><span data-stu-id="56874-417">The transport setting being queried is based on the [**TRANSPORT\_SETTING\_ID**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) passed in the *lpvInBuffer* parameter.</span></span>

<span data-ttu-id="56874-418">目前唯一定義的傳輸設定是用於 TCP 通訊端上的 **即時 \_ \_ 通知 \_ 功能** 功能。</span><span class="sxs-lookup"><span data-stu-id="56874-418">The only transport setting currently defines is for the **REAL\_TIME\_NOTIFICATION\_CAPABILITY** capability on a TCP socket.</span></span>

<span data-ttu-id="56874-419">如果 [**傳輸 \_ 設定 \_ 識別碼**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) 的 **Guid** 成員設為 **即時 \_ \_ 通知 \_ 功能**，則需要查詢與 [**ControlChannelTrigger**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger) 搭配使用之 TCP 通訊端的即時通知設定，以在 Windows Store 應用程式中接收背景網路通知。</span><span class="sxs-lookup"><span data-stu-id="56874-419">If the [**TRANSPORT\_SETTING\_ID**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) has the **Guid** member set to **REAL\_TIME\_NOTIFICATION\_CAPABILITY**, then this is a request to query the real time notification settings for the TCP socket used with the [**ControlChannelTrigger**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger) to receive background network notifications in a Windows Store app.</span></span> <span data-ttu-id="56874-420">如果 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 或 [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) 呼叫成功，這個 IOCTL 會以目前的狀態傳回 [**即時 \_ \_ 通知 \_ 設定 \_ 輸出**](/windows/desktop/api/Mstcpip/ns-mstcpip-real_time_notification_setting_input) 結構。</span><span class="sxs-lookup"><span data-stu-id="56874-420">If the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) or [**WSPIoctl**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) call is successful, this IOCTL returns a [**REAL\_TIME\_NOTIFICATION\_SETTING\_OUTPUT**](/windows/desktop/api/Mstcpip/ns-mstcpip-real_time_notification_setting_input) structure with the current status.</span></span>

<span data-ttu-id="56874-421">如需詳細資訊，請參閱 [**SIO \_ 查詢 \_ 傳輸 \_ 設定**](/previous-versions/windows/desktop/legacy/jj553483(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-421">For more detailed information, see the [**SIO\_QUERY\_TRANSPORT\_SETTING**](/previous-versions/windows/desktop/legacy/jj553483(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-422">**SIO \_Windows 8 \_ \_** 、Windows Server 2012 及更新版本都支援查詢傳輸設定。</span><span class="sxs-lookup"><span data-stu-id="56874-422">**SIO\_QUERY\_TRANSPORT\_SETTING** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_query_wfp_ale_endpoint_handle-opcode-setting-o-t3"></a><span data-ttu-id="56874-423">SIO \_ QUERY \_ WFP \_ ALE \_ 端點 \_ 控制碼 (操作碼設定： O，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-423">SIO\_QUERY\_WFP\_ALE\_ENDPOINT\_HANDLE (opcode setting: O, T==3)</span></span>

<span data-ttu-id="56874-424">查詢應用層強制 (ALE) 端點控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-424">Queries the Application Layer Enforcement (ALE) endpoint handle.</span></span>

<span data-ttu-id="56874-425"> (WFP 的 Windows 篩選平台) 支援網路流量檢查和修改。</span><span class="sxs-lookup"><span data-stu-id="56874-425">The Windows Filtering Platform (WFP) supports network traffic inspection and modification.</span></span> <span data-ttu-id="56874-426">在 Windows Vista 上，WFP 著重于主機電腦是通訊端點的案例。</span><span class="sxs-lookup"><span data-stu-id="56874-426">On Windows Vista, WFP focuses on scenarios where the host machine is the communication endpoint.</span></span> <span data-ttu-id="56874-427">不過，在 Windows Server 2008 上，有邊緣防火牆的執行，想要利用 WFP 平臺來檢查和 proxy 傳遞流量。</span><span class="sxs-lookup"><span data-stu-id="56874-427">On Windows Server 2008 , however, there are edge firewall implementations which would like to leverage the WFP platform to inspect and proxy pass-through traffic.</span></span> <span data-ttu-id="56874-428">Internet Security and 加速 (ISA) server 是這類邊緣裝置的範例。</span><span class="sxs-lookup"><span data-stu-id="56874-428">The Internet Security and Acceleration (ISA) server is an example of such an edge device.</span></span>

<span data-ttu-id="56874-429">有些防火牆案例可能需要能夠將輸入封包插入與現有端點相關聯的傳送路徑。</span><span class="sxs-lookup"><span data-stu-id="56874-429">There are some firewall scenarios that may require the ability to inject an inbound packet into the send path associated with an existing endpoint.</span></span> <span data-ttu-id="56874-430">需要有一種機制來探索與目的地端點相關聯的傳輸層端點控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-430">There needs to be a mechanism to discover the transport layer endpoint handle associated with the destination endpoint.</span></span> <span data-ttu-id="56874-431">建立端點的應用程式擁有這些傳輸層端點。</span><span class="sxs-lookup"><span data-stu-id="56874-431">The application that created the endpoint owns these transport layer endpoints.</span></span> <span data-ttu-id="56874-432">這個 IOCTL 可用來提供通訊端控制碼給傳輸層端點控制碼對應。</span><span class="sxs-lookup"><span data-stu-id="56874-432">This IOCTL is used to provide socket handle to transport layer endpoint handle mapping.</span></span>

<span data-ttu-id="56874-433">如果輸出緩衝區不夠大，以致于端點控制碼 (*cbOutBuffer* 小於 **UINT64**) 的大小，或 *lpvOutBuffer* 參數為 **Null** 指標，則會傳回 **通訊端 \_ 錯誤** ，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEINVAL](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-433">If the output buffer is not large enough for the endpoint handle (the *cbOutBuffer* is less than the size of a **UINT64**) or the *lpvOutBuffer* parameter is a **NULL** pointer, **SOCKET\_ERROR** is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEINVAL](windows-sockets-error-codes-2.md).</span></span>

<span data-ttu-id="56874-434">**SIO \_Windows Vista 和更新版本支援查詢 \_ WFP \_ ALE \_ 端點 \_ 控制碼** 。</span><span class="sxs-lookup"><span data-stu-id="56874-434">**SIO\_QUERY\_WFP\_ALE\_ENDPOINT\_HANDLE** is supported on Windows Vista and later.</span></span>

### <a name="sio_query_wfp_connection_redirect_context-opcode-setting-i-t3"></a><span data-ttu-id="56874-435">SIO \_ QUERY \_ WFP \_ 連接重新 \_ 導向 \_ 內容 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-435">SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_CONTEXT (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-436">查詢重新導向內容，以取得 Windows 篩選平台 (WFP) 重新導向服務所使用的重新導向記錄。</span><span class="sxs-lookup"><span data-stu-id="56874-436">Queries the redirect context for a redirect record used by a Windows Filtering Platform (WFP) redirect service.</span></span>

<span data-ttu-id="56874-437">[**SIO \_ QUERY \_ WFP 連接重新 \_ \_ 導向 \_ 內容**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85))IOCTL 可用來在重新導向的通訊端連線上提供代理的連接追蹤。</span><span class="sxs-lookup"><span data-stu-id="56874-437">The [**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_CONTEXT**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85)) IOCTL is used to provide proxied connection tracking on redirected socket connections.</span></span> <span data-ttu-id="56874-438">這種 WFP 功能可從連接的初始重新導向到目的地的最終連接，來協助追蹤重新導向記錄。</span><span class="sxs-lookup"><span data-stu-id="56874-438">This WFP feature facilitates tracking of redirection records from the initial redirect of a connection to the final connection to the destination.</span></span>

<span data-ttu-id="56874-439">如需詳細資訊，請參閱 [**SIO \_ QUERY \_ WFP \_ 連接重新 \_ 導向 \_ 內容**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-439">For more detailed information, see the [**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_CONTEXT**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-440">**SIO \_Windows 8、Windows Server 2012 及更新版本都支援查詢 \_ WFP \_ 連接重新 \_ 導向 \_ 內容** 。</span><span class="sxs-lookup"><span data-stu-id="56874-440">**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_CONTEXT** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_query_wfp_connection_redirect_records-opcode-setting-i-t3"></a><span data-ttu-id="56874-441">SIO \_ 查詢 \_ WFP \_ 連接重新 \_ 導向 \_ 記錄 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-441">SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_RECORDS (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-442">查詢已接受 TCP/IP 連接的重新導向記錄，以供 Windows 篩選平台 (WFP) 重新導向服務使用。</span><span class="sxs-lookup"><span data-stu-id="56874-442">Queries the redirect record for the accepted TCP/IP connection for use by a Windows Filtering Platform (WFP) redirect service.</span></span>

<span data-ttu-id="56874-443">[**SIO \_ QUERY \_ WFP 連接重新 \_ \_ 導向 \_ 記錄**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85))IOCTL 可用來在重新導向的通訊端連線上提供代理的連接追蹤。</span><span class="sxs-lookup"><span data-stu-id="56874-443">The [**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_RECORDS**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85)) IOCTL is used to provide proxied connection tracking on redirected socket connections.</span></span> <span data-ttu-id="56874-444">這種 WFP 功能可從連接的初始重新導向到目的地的最終連接，來協助追蹤重新導向記錄。</span><span class="sxs-lookup"><span data-stu-id="56874-444">This WFP feature facilitates tracking of redirection records from the initial redirect of a connection to the final connection to the destination.</span></span>

<span data-ttu-id="56874-445">如需詳細資訊，請參閱 [**SIO \_ QUERY \_ WFP \_ 連接重新 \_ 導向 \_ 記錄**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-445">For more detailed information, see the [**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_RECORDS**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-446">**SIO \_Windows 8、Windows Server 2012 及更新版本都支援查詢 \_ WFP \_ 連接重新 \_ 導向 \_ 記錄** 。</span><span class="sxs-lookup"><span data-stu-id="56874-446">**SIO\_QUERY\_WFP\_CONNECTION\_REDIRECT\_RECORDS** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_rcvall-opcode-setting-i-t3"></a><span data-ttu-id="56874-447">SIO \_ RCVALL (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-447">SIO\_RCVALL (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-448">可讓通訊端接收傳遞 throuigh 網路介面的所有 IPv4 或 IPv6 封包。</span><span class="sxs-lookup"><span data-stu-id="56874-448">Enables a socket to receive all IPv4 or IPv6 packets passing throuigh a network interface.</span></span> <span data-ttu-id="56874-449">傳遞至 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 函式的通訊端控制碼必須是下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="56874-449">The socket handle passed to the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function must be one of the following:</span></span>

-   <span data-ttu-id="56874-450">以位址系列設定為 AF \_ INET、通訊端類型設定為 SOCK \_ RAW，以及將通訊協定設定為 IPPROTO IP 所建立的 IPv4 通訊端 \_ 。</span><span class="sxs-lookup"><span data-stu-id="56874-450">An IPv4 socket that was created with the address family set to AF\_INET, the socket type set to SOCK\_RAW, and the protocol set to IPPROTO\_IP.</span></span>
-   <span data-ttu-id="56874-451">以位址系列設定為 AF \_ INET6、通訊端類型設定為 SOCK \_ RAW，以及將通訊協定設定為 IPPROTO IPv6 所建立的 IPv6 通訊端 \_ 。</span><span class="sxs-lookup"><span data-stu-id="56874-451">An IPv6 socket that was created with the address family set to AF\_INET6, the socket type set to SOCK\_RAW, and the protocol set to IPPROTO\_IPV6.</span></span>

<span data-ttu-id="56874-452">通訊端也必須系結至明確的本機 IPv4 或 IPv6 介面，這表示您無法系結至 **INADDR \_ any** 或 **in6addr \_ any**。</span><span class="sxs-lookup"><span data-stu-id="56874-452">The socket also must be bound to an explicit local IPv4 or IPv6 interface, which means that you cannot bind to **INADDR\_ANY** or **in6addr\_any**.</span></span>

<span data-ttu-id="56874-453">在 Windows Server 2008 及更早版本中， [**SIO \_ RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) IOCTL 設定不會捕捉從網路介面送出的本機封包。</span><span class="sxs-lookup"><span data-stu-id="56874-453">On Windows Server 2008 and earlier, the [**SIO\_RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) IOCTL setting would not capture local packets sent out of a network interface.</span></span> <span data-ttu-id="56874-454">這包含在另一個介面上收到的封包，並將針對 **SIO \_ RCVALL** IOCTL 指定的網路介面轉送出去。</span><span class="sxs-lookup"><span data-stu-id="56874-454">This included packets received on another interface and forwarded out the network interface specified for the **SIO\_RCVALL** IOCTL.</span></span>

<span data-ttu-id="56874-455">在 Windows 7 和 Windows Server 2008 R2 上，這項變更已變更，因此也會捕捉從網路介面送出的本機封包。</span><span class="sxs-lookup"><span data-stu-id="56874-455">On Windows 7 and Windows Server 2008 R2 , this was changed so that local packets sent out of a network interface are also captured.</span></span> <span data-ttu-id="56874-456">這包括在另一個介面上收到的封包，然後使用 [**SIO \_ RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) IOCTL 轉送系結至通訊端的網路介面。</span><span class="sxs-lookup"><span data-stu-id="56874-456">This includes packets received on another interface and then forwarded out the network interface bound to the socket with [**SIO\_RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) IOCTL.</span></span>

<span data-ttu-id="56874-457">設定這個 IOCTL 需要本機電腦的系統管理員許可權。</span><span class="sxs-lookup"><span data-stu-id="56874-457">Setting this IOCTL requires Administrator privilege on the local computer.</span></span>

<span data-ttu-id="56874-458">這項功能有時稱為混合模式。</span><span class="sxs-lookup"><span data-stu-id="56874-458">This feature is sometimes referred to as promiscuous mode.</span></span>

<span data-ttu-id="56874-459">**SIO \_ RCVALL** IOCTL 選項的可能值是在 *Mstcpip. .h* 標頭檔中定義的 **RCVALL \_ 值** 列舉中指定。</span><span class="sxs-lookup"><span data-stu-id="56874-459">The possible values for the **SIO\_RCVALL** IOCTL option are specified in the **RCVALL\_VALUE** enumeration defined in the *Mstcpip.h* header file.</span></span> <span data-ttu-id="56874-460">SIO RCVALL 的可能值如下 \_ ：</span><span class="sxs-lookup"><span data-stu-id="56874-460">The possible values for SIO\_RCVALL are as follows:</span></span>

| <span data-ttu-id="56874-461">詞彙</span><span class="sxs-lookup"><span data-stu-id="56874-461">Term</span></span>                                                                                                                 | <span data-ttu-id="56874-462">描述</span><span class="sxs-lookup"><span data-stu-id="56874-462">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-|-|
| <span data-ttu-id="56874-463"><span id="RCVALL_OFF"></span><span id="rcvall_off"></span>RCVALL \_ 關閉</span><span class="sxs-lookup"><span data-stu-id="56874-463"><span id="RCVALL_OFF"></span><span id="rcvall_off"></span>RCVALL\_OFF</span></span><br/>                                     | <span data-ttu-id="56874-464">停用此選項，讓通訊端不會接收網路上的所有 IPv4 或 IPv6 封包。</span><span class="sxs-lookup"><span data-stu-id="56874-464">Disable this option so a socket does not receive all IPv4 or IPv6 packets on the network.</span></span> <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="56874-465"><span id="RCVALL_ON"></span><span id="rcvall_on"></span>RCVALL \_ 于</span><span class="sxs-lookup"><span data-stu-id="56874-465"><span id="RCVALL_ON"></span><span id="rcvall_on"></span>RCVALL\_ON</span></span><br/>                                        | <span data-ttu-id="56874-466">啟用此選項，讓通訊端接收網路上的所有 IPv4 或 IPv6 封包。</span><span class="sxs-lookup"><span data-stu-id="56874-466">Enable this option so a socket receives all IPv4 or IPv6 packets on the network.</span></span> <span data-ttu-id="56874-467">如果 NIC 支援混合模式，此選項會在網路介面卡上啟用混合模式 (NIC) 。</span><span class="sxs-lookup"><span data-stu-id="56874-467">This option enables promiscuous mode on the network interface card (NIC), if the NIC supports promiscuous mode.</span></span> <span data-ttu-id="56874-468">在網路中樞的 LAN 區段上，支援混合模式的 NIC 會在 LAN 上捕捉所有 IPv4 或 IPv6 流量，包括相同 LAN 區段上其他電腦之間的流量。</span><span class="sxs-lookup"><span data-stu-id="56874-468">On a LAN segment with a network hub, a NIC that supports promiscuous mode will capture all IPv4 or IPv6 traffic on the LAN, including traffic between other computers on the same LAN segment.</span></span> <span data-ttu-id="56874-469">所有 (IPv4 或 IPv6 的已捕捉封包，視通訊端) 將會傳遞至原始通訊端而定。</span><span class="sxs-lookup"><span data-stu-id="56874-469">All of the captured packets (IPv4 or IPv6, depending on the socket) will be delivered to the raw socket.</span></span> <br/> <span data-ttu-id="56874-470">此選項不會將其他封包捕獲 (ARP、IPX 和 NetBEUI 封包，例如介面上的) 。</span><span class="sxs-lookup"><span data-stu-id="56874-470">This option will not capture other packets (ARP, IPX, and NetBEUI packets, for example) on the interface.</span></span><br/> <span data-ttu-id="56874-471">Netmon 針對網路介面使用相同的模式，但不會使用此選項來捕捉流量。</span><span class="sxs-lookup"><span data-stu-id="56874-471">Netmon uses the same mode for the network interface, but does not use this option to capture traffic.</span></span><br/> |
| <span data-ttu-id="56874-472"><span id="RCVALL_SOCKETLEVELONLY"></span><span id="rcvall_socketlevelonly"></span>RCVALL \_ SOCKETLEVELONLY</span><span class="sxs-lookup"><span data-stu-id="56874-472"><span id="RCVALL_SOCKETLEVELONLY"></span><span id="rcvall_socketlevelonly"></span>RCVALL\_SOCKETLEVELONLY</span></span><br/> | <span data-ttu-id="56874-473">這項功能目前未執行，因此設定此選項不會有任何影響。</span><span class="sxs-lookup"><span data-stu-id="56874-473">This feature is not currently implemented, so setting this option does not have any affect.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <span data-ttu-id="56874-474"><span id="RCVALL_IPLEVEL"></span><span id="rcvall_iplevel"></span>RCVALL \_ IPLEVEL</span><span class="sxs-lookup"><span data-stu-id="56874-474"><span id="RCVALL_IPLEVEL"></span><span id="rcvall_iplevel"></span>RCVALL\_IPLEVEL</span></span><br/>                         | <span data-ttu-id="56874-475">啟用此選項，讓 IPv4 或 IPv6 通訊端接收網路上 IP 層級的所有封包。</span><span class="sxs-lookup"><span data-stu-id="56874-475">Enable this option so an IPv4 or IPv6 socket receives all packets at the IP level on the network.</span></span> <span data-ttu-id="56874-476">此選項不會在網路介面卡上啟用混合模式。</span><span class="sxs-lookup"><span data-stu-id="56874-476">This option does not enable promiscuous mode on the network interface card.</span></span> <span data-ttu-id="56874-477">此選項只會影響在 IP 層級的封包處理。</span><span class="sxs-lookup"><span data-stu-id="56874-477">This option only affects packet processing at the IP level.</span></span> <span data-ttu-id="56874-478">NIC 仍只接收導向至其設定之單播和多播位址的封包。</span><span class="sxs-lookup"><span data-stu-id="56874-478">The NIC still receives only packets directed to its configured unicast and multicast addresses.</span></span> <span data-ttu-id="56874-479">不過，啟用此選項的通訊端不只會接收導向至特定 IP 位址的封包，而是會接收 NIC 接收的所有 IPv4 或 IPv6 封包。</span><span class="sxs-lookup"><span data-stu-id="56874-479">However, a socket with this option enabled will receive not only packets directed to specific IP addresses, but will receive all the IPv4 or IPv6 packets the NIC receives.</span></span><br/> <span data-ttu-id="56874-480">此選項不會將其他封包捕捉 (ARP、IPX 和 NetBEUI 封包，例如在介面上收到) 。</span><span class="sxs-lookup"><span data-stu-id="56874-480">This option will not capture other packets (ARP, IPX, and NetBEUI packets, for example) received on the interface.</span></span><br/>                                                                                             |



 

<span data-ttu-id="56874-481">如需詳細資訊，請參閱 [**SIO \_ RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-481">For more detailed information, see the [**SIO\_RCVALL**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-482">**SIO \_** Windows 2000 和更新版本支援 RCVALL。</span><span class="sxs-lookup"><span data-stu-id="56874-482">**SIO\_RCVALL** is supported on Windows 2000 and later.</span></span>

### <a name="sio_rcvall_igmpmcast-opcode-setting-i-t3"></a><span data-ttu-id="56874-483">SIO \_ RCVALL \_ IGMPMCAST (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-483">SIO\_RCVALL\_IGMPMCAST (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-484">可讓通訊端接收網路上的所有 IGMP 多播 IP 流量，而不會接收其他多播 IP 流量。</span><span class="sxs-lookup"><span data-stu-id="56874-484">Enables a socket to receive all IGMP multicast IP traffic on the network, without receiving other multicast IP traffic.</span></span> <span data-ttu-id="56874-485">傳遞至 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 函式的通訊端控制碼必須為 AF \_ INET 位址系列、SOCK \_ 原始通訊端類型和 IPPROTO \_ IGMP 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="56874-485">The socket handle passed to the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function must be of AF\_INET address family, SOCK\_RAW socket type, and IPPROTO\_IGMP protocol.</span></span> <span data-ttu-id="56874-486">通訊端也必須系結至明確的本機介面，這表示您無法系結至 INADDR \_ ANY。</span><span class="sxs-lookup"><span data-stu-id="56874-486">The socket also must be bound to an explicit local interface, which means that you cannot bind to INADDR\_ANY.</span></span>

<span data-ttu-id="56874-487">系結通訊端並設定 IOCTL 之後，對 [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) 或 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 函式的呼叫會傳回透過指定介面傳遞的多播 IP 資料包。</span><span class="sxs-lookup"><span data-stu-id="56874-487">Once the socket is bound and the IOCTL set, calls to the [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) or [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) functions return multicast IP datagrams passing through the given interface.</span></span> <span data-ttu-id="56874-488">請注意，您必須提供夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-488">Note that you must supply a sufficiently large buffer.</span></span> <span data-ttu-id="56874-489">設定這個 IOCTL 需要本機電腦的系統管理員許可權。</span><span class="sxs-lookup"><span data-stu-id="56874-489">Setting this IOCTL requires Administrator privilege on the local computer.</span></span>

<span data-ttu-id="56874-490">**SIO \_Windows \_** 2000 和更新版本支援 RCVALL IGMPMCAST。</span><span class="sxs-lookup"><span data-stu-id="56874-490">**SIO\_RCVALL\_IGMPMCAST** is supported on Windows 2000 and later.</span></span>

### <a name="sio_rcvall_mcast-opcode-setting-i-t3"></a><span data-ttu-id="56874-491">SIO \_ RCVALL \_ MCAST (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-491">SIO\_RCVALL\_MCAST (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-492">可讓通訊端接收網路上的所有多播 IP 流量 (也就是說，以224.0.0.0 到239.255.255.255 為範圍的 IP 位址為目標的所有 IP 封包) 。</span><span class="sxs-lookup"><span data-stu-id="56874-492">Enables a socket to receive all multicast IP traffic on the network (that is, all IP packets destined for IP addresses in the range of 224.0.0.0 to 239.255.255.255).</span></span> <span data-ttu-id="56874-493">傳遞至 [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) 函式的通訊端控制碼必須為 AF \_ INET 位址系列、SOCK \_ 原始通訊端類型和 IPPROTO \_ UDP 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="56874-493">The socket handle passed to the [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) function must be of AF\_INET address family, SOCK\_RAW socket type, and IPPROTO\_UDP protocol.</span></span> <span data-ttu-id="56874-494">通訊端也必須系結至明確的本機介面，這表示您無法系結至 INADDR \_ ANY。</span><span class="sxs-lookup"><span data-stu-id="56874-494">The socket also must bind to an explicit local interface, which means that you cannot bind to INADDR\_ANY.</span></span> <span data-ttu-id="56874-495">通訊端應系結至埠零。</span><span class="sxs-lookup"><span data-stu-id="56874-495">The socket should bind to port zero.</span></span>

<span data-ttu-id="56874-496">系結通訊端並設定 IOCTL 之後，對 [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) 或 [**接收**](/windows/desktop/api/winsock/nf-winsock-recv) 函式的呼叫會傳回透過指定介面傳遞的多播 IP 資料包。</span><span class="sxs-lookup"><span data-stu-id="56874-496">Once the socket is bound and the IOCTL set, calls to the [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) or [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) functions return multicast IP datagrams passing through the given interface.</span></span> <span data-ttu-id="56874-497">請注意，您必須提供夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="56874-497">Note that you must supply a sufficiently large buffer.</span></span> <span data-ttu-id="56874-498">設定這個 IOCTL 需要本機電腦的系統管理員許可權。</span><span class="sxs-lookup"><span data-stu-id="56874-498">Setting this IOCTL requires Administrator privilege on the local computer.</span></span>

<span data-ttu-id="56874-499">**SIO \_Windows \_** 2000 和更新版本支援 RCVALL MCAST。</span><span class="sxs-lookup"><span data-stu-id="56874-499">**SIO\_RCVALL\_MCAST** is supported on Windows 2000 and later.</span></span>

### <a name="sio_release_port_reservation-opcode-setting-i-t3"></a><span data-ttu-id="56874-500">SIO \_ 版本 \_ 埠 \_ 保留 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-500">SIO\_RELEASE\_PORT\_RESERVATION (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-501">針對 TCP 或 UDP 埠的區塊釋放執行時間保留。</span><span class="sxs-lookup"><span data-stu-id="56874-501">Releases a runtime reservation for a block of TCP or UDP ports.</span></span> <span data-ttu-id="56874-502">您必須使用 [**SIO \_ 取得 \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) IOCTL，從發行程式取得要發行的執行時間保留。</span><span class="sxs-lookup"><span data-stu-id="56874-502">The runtime reservation to be released must have been obtained from the issuing process using the [**SIO\_ACQUIRE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) IOCTL.</span></span>

<span data-ttu-id="56874-503">如需詳細資訊，請參閱 [**SIO \_ 版本 \_ 埠 \_ 保留**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-503">For more detailed information, see the [**SIO\_RELEASE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-504">[**SIO \_Windows \_ \_**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) Vista 和更新版本的作業系統支援發行埠保留。</span><span class="sxs-lookup"><span data-stu-id="56874-504">[**SIO\_RELEASE\_PORT\_RESERVATION**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) is supported on Windows Vista and later versions of the operating system.</span></span>

### <a name="sio_routing_interface_change-opcode-setting-i-t1"></a><span data-ttu-id="56874-505">SIO \_ 路由 \_ 介面 \_ 變更 (操作碼設定： I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-505">SIO\_ROUTING\_INTERFACE\_CHANGE (opcode setting: I, T==1)</span></span>

<span data-ttu-id="56874-506">若要接收路由介面變更的通知，而這些變更應該用來到達輸入緩衝區中的遠端位址 (指定為 [**sockaddr**](sockaddr-2.md) 結構) 。</span><span class="sxs-lookup"><span data-stu-id="56874-506">To receive notification of a routing interface change that should be used to reach the remote address in the input buffer (specified as a [**sockaddr**](sockaddr-2.md) structure).</span></span> <span data-ttu-id="56874-507">這項 IOCTL 完成時，將不會提供新路由介面上的輸出資訊;完成隻會指出給定目的地的路由介面已經變更，應該使用 **SIO \_ 路由 \_ 介面 \_ 查詢** IOCTL 來查詢。</span><span class="sxs-lookup"><span data-stu-id="56874-507">No output information on the new routing interface will be provided upon completion of this IOCTL; the completion merely indicates that the routing interface for a given destination has changed and should be queried using the **SIO\_ROUTING\_INTERFACE\_QUERY** IOCTL.</span></span>

<span data-ttu-id="56874-508">雖然並非必要，但應用程式會使用重迭的 i/o 來通知路由介面變更，以及完成 **SIO \_ 路由 \_ 介面 \_ 變更** 要求。</span><span class="sxs-lookup"><span data-stu-id="56874-508">It is assumed, although not required, that the application uses overlapped I/O to be notified of the routing interface change through completion of **SIO\_ROUTING\_INTERFACE\_CHANGE** request.</span></span> <span data-ttu-id="56874-509">或者，如果 **SIO \_ 路由 \_ 介面 \_ 變更** IOCTL 是在 *LpOverlapped* 和 *lpCompletionRoutine* 參數設定為 **Null**) 的非封鎖通訊端上發出的，則它會立即完成傳回並 [WSAEWOULDBLOCK](windows-sockets-error-codes-2.md) 為錯誤，然後應用程式可以透過呼叫 [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) 或 [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) ，以在 \_ \_ \_ 網路事件位元遮罩中設定的 FD 路由介面變更位來等候路由變更事件。</span><span class="sxs-lookup"><span data-stu-id="56874-509">Alternatively, if the **SIO\_ROUTING\_INTERFACE\_CHANGE** IOCTL is issued on a non-blocking socket with the *lpOverlapped* and *lpCompletionRoutine* parameters set to **NULL**), it will complete immediately returning and [WSAEWOULDBLOCK](windows-sockets-error-codes-2.md) as an error, and the application can then wait for routing change events through call to [**WSAEventSelect**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) or [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) with FD\_ROUTING\_INTERFACE\_CHANGE bit set in the network event bitmask.</span></span>

<span data-ttu-id="56874-510">在大部分的情況下，這是因為路由資訊會保持穩定，因此需要應用程式保留多個未處理的 IOCTLs 來取得有關它感興趣的所有目的地的通知，以及讓服務提供者追蹤這些通知要求，將會使用大量系統資源。</span><span class="sxs-lookup"><span data-stu-id="56874-510">It is recognized that routing information remains stable in most cases so that requiring the application to keep multiple outstanding IOCTLs to get notifications about all destinations that it is interested in as well as having the service provider keep track of these notification requests will use a significant amount system resources.</span></span> <span data-ttu-id="56874-511">您可以藉由擴充輸入參數的意義，並放寬服務提供者需求，來避免這種情況，如下所示：</span><span class="sxs-lookup"><span data-stu-id="56874-511">This situation can be avoided by extending the meaning of the input parameters and relaxing the service provider requirements as follows:</span></span>

-   <span data-ttu-id="56874-512">當要求系結至任何可用的位址) 以要求任何路由變更的通知時，應用程式可以指定通訊協定系列特定的萬用字元位址 (與系 [**結呼叫中所使用的相同**](/windows/desktop/api/winsock/nf-winsock-bind) 。</span><span class="sxs-lookup"><span data-stu-id="56874-512">The application can specify a protocol family specific wildcard address (same as one used in [**bind**](/windows/desktop/api/winsock/nf-winsock-bind) call when requesting to bind to any available address) to request notifications of any routing changes.</span></span> <span data-ttu-id="56874-513">如此一來，應用程式就只會針對它所擁有的所有通訊端和目的地，保留一個未完成的 **SIO \_ 路由 \_ 介面 \_ 變更** ，然後使用 **SIO \_ 路由 \_ 介面 \_ 查詢** 來取得實際的路由資訊。</span><span class="sxs-lookup"><span data-stu-id="56874-513">This allows the application to keep only one outstanding **SIO\_ROUTING\_INTERFACE\_CHANGE** for all the sockets and destinations it has and then use **SIO\_ROUTING\_INTERFACE\_QUERY** to get the actual routing information.</span></span>
-   <span data-ttu-id="56874-514">服務提供者可以選擇忽略 **SIO \_ 路由 \_ 介面 \_ 變更** 之輸入緩衝區中的應用程式所指定的資訊 (就像應用程式指定了萬用字元位址) ，並在發生任何路由資訊變更時完成 **SIO \_ 路由 \_ 介面 \_** 變更 IOCTL 或信號 FD \_ 路由 \_ 介面 \_ 變更事件， (不只是輸入緩衝區) 中指定之目的地的路由。</span><span class="sxs-lookup"><span data-stu-id="56874-514">A service provider has the option to ignore the information specified by the application in the input buffer of the **SIO\_ROUTING\_INTERFACE\_CHANGE** (as though the application specified a wildcard address) and complete the **SIO\_ROUTING\_INTERFACE\_CHANGE** IOCTL or signal FD\_ROUTING\_INTERFACE\_CHANGE event in the event of any routing information change (not just the route to the destination specified in the input buffer).</span></span>

### <a name="sio_routing_interface_query-opcode-setting-i-o-t1"></a><span data-ttu-id="56874-515">SIO \_ 路由 \_ 介面 \_ 查詢 (操作碼設定： I、O、T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-515">SIO\_ROUTING\_INTERFACE\_QUERY (opcode setting: I, O, T==1)</span></span>

<span data-ttu-id="56874-516">若要取得本機介面的位址 (以 [**sockaddr**](sockaddr-2.md) 結構表示，) 應該用來傳送至輸入緩衝區中指定的遠端位址， (為 **sockaddr**) 。</span><span class="sxs-lookup"><span data-stu-id="56874-516">To obtain the address of the local interface (represented as [**sockaddr**](sockaddr-2.md) structure) which should be used to send to the remote address specified in the input buffer (as **sockaddr**).</span></span> <span data-ttu-id="56874-517">您可以在輸入緩衝區中提交遠端多播位址，以取得適用于多播傳輸的慣用介面位址。</span><span class="sxs-lookup"><span data-stu-id="56874-517">Remote multicast addresses may be submitted in the input buffer to get the address of the preferred interface for multicast transmission.</span></span> <span data-ttu-id="56874-518">在任何情況下，應用程式可能會在後續 bind () 要求中使用傳回的介面位址。</span><span class="sxs-lookup"><span data-stu-id="56874-518">In any case, the interface address returned may be used by the application in a subsequent bind() request.</span></span>

<span data-ttu-id="56874-519">請注意，路由可能會變更。</span><span class="sxs-lookup"><span data-stu-id="56874-519">Note that routes are subject to change.</span></span> <span data-ttu-id="56874-520">因此，應用程式無法依賴 **SIO \_ 路由 \_ 介面 \_ 查詢** 所傳回的資訊持續存在。</span><span class="sxs-lookup"><span data-stu-id="56874-520">Therefore, applications cannot rely on the information returned by **SIO\_ROUTING\_INTERFACE\_QUERY** to be persistent.</span></span> <span data-ttu-id="56874-521">應用程式可以透過 **SIO \_ 路由 \_ 介面 \_ 變更** IOCTL 來註冊路由變更通知，以透過重迭的 I/o 或 FD \_ 路由 \_ 介面變更事件提供通知 \_ 。</span><span class="sxs-lookup"><span data-stu-id="56874-521">Applications may register for routing change notifications through the **SIO\_ROUTING\_INTERFACE\_CHANGE** IOCTL which provides for notification through either overlapped I/O or a FD\_ROUTING\_INTERFACE\_CHANGE event.</span></span> <span data-ttu-id="56874-522">下列一系列的動作可以用來保證應用程式一律具有指定目的地的目前路由介面資訊：</span><span class="sxs-lookup"><span data-stu-id="56874-522">The following sequence of actions can be used to guarantee that the application always has current routing interface information for a given destination:</span></span>

-   <span data-ttu-id="56874-523">發出 **SIO \_ 路由 \_ 介面 \_ 變更** IOCTL 的問題</span><span class="sxs-lookup"><span data-stu-id="56874-523">Issue **SIO\_ROUTING\_INTERFACE\_CHANGE** IOCTL</span></span>
-   <span data-ttu-id="56874-524">發出 **SIO \_ 路由 \_ 介面 \_ 查詢** IOCTL 的問題</span><span class="sxs-lookup"><span data-stu-id="56874-524">Issue **SIO\_ROUTING\_INTERFACE\_QUERY** IOCTL</span></span>
-   <span data-ttu-id="56874-525">每當 **SIO \_ 路由 \_ 介面 \_ 變更** IOCTL 通知應用程式傳送變更時 (透過重迭的 i/o，或藉由發出 \_) 的 FD 路由 \_ 介面 \_ 變更事件，就應該重複執行整個動作順序。</span><span class="sxs-lookup"><span data-stu-id="56874-525">Whenever **SIO\_ROUTING\_INTERFACE\_CHANGE** IOCTL notifies the application of routing change (either through overlapped I/O or by signaling FD\_ROUTING\_INTERFACE\_CHANGE event), the whole sequence of actions should be repeated.</span></span>

<span data-ttu-id="56874-526">如果輸出緩衝區不夠大，無法包含介面位址， \_ 則會傳回通訊端錯誤，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會傳回 [WSAEFAULT](windows-sockets-error-codes-2.md)。</span><span class="sxs-lookup"><span data-stu-id="56874-526">If the output buffer is not large enough to contain the interface address, SOCKET\_ERROR is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAEFAULT](windows-sockets-error-codes-2.md).</span></span> <span data-ttu-id="56874-527">在此情況下， *lpcbBytesReturned* 會傳回所需的輸出緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="56874-527">The required size of the output buffer will be returned in *lpcbBytesReturned* in this case.</span></span> <span data-ttu-id="56874-528">請注意，如果 *lpvInBuffer*、 *lpvOutBuffer* 或 *lpcbBytesReturned* 參數未完全包含在使用者位址空間的有效部分中，也會傳回 WSAEFAULT 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-528">Note the WSAEFAULT error code is also returned if the *lpvInBuffer*, *lpvOutBuffer*, or *lpcbBytesReturned* parameter is not totally contained in a valid part of the user address space.</span></span>

<span data-ttu-id="56874-529">如果無法透過任何可用的介面到達輸入緩衝區中指定的目的地位址， \_ 則會傳回通訊端錯誤，因為這個 IOCTL 的結果和 [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) 會在所有網路連線都遺失時傳回 [WSAENETUNREACH](windows-sockets-error-codes-2.md) ，甚至是 [WSAENETDOWN](windows-sockets-error-codes-2.md) 。</span><span class="sxs-lookup"><span data-stu-id="56874-529">If the destination address specified in the input buffer cannot be reached through any of the available interfaces, SOCKET\_ERROR is returned as the result of this IOCTL and [**WSAGetLastError**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) returns [WSAENETUNREACH](windows-sockets-error-codes-2.md) or even [WSAENETDOWN](windows-sockets-error-codes-2.md) if all of the network connectivity is lost.</span></span>

### <a name="sio_set_compatibility_mode-opcode-setting-i-t3"></a><span data-ttu-id="56874-530">SIO \_ 設定 \_ 相容性 \_ 模式 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-530">SIO\_SET\_COMPATIBILITY\_MODE (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-531">要求網路堆疊應該如何處理特定行為，而這種行為的預設處理方式可能會在 Windows 版本之間不同。</span><span class="sxs-lookup"><span data-stu-id="56874-531">Requests how the networking stack should handle certain behaviors for which the default way of handling the behavior may differ across Windows versions.</span></span> <span data-ttu-id="56874-532">**SIO \_ 集 \_ 相容性 \_ 模式** 的引數結構是在 *Mswsockdef .H* 標頭檔中定義的 **WSA \_ 相容性 \_ 模式** 結構中指定。</span><span class="sxs-lookup"><span data-stu-id="56874-532">The argument structure for **SIO\_SET\_COMPATIBILITY\_MODE** is specified in the **WSA\_COMPATIBILITY\_MODE** structure defined in the *Mswsockdef.h* header file.</span></span> <span data-ttu-id="56874-533">此結構的定義如下：</span><span class="sxs-lookup"><span data-stu-id="56874-533">This structure is defined as follows:</span></span>

```cpp
/* Argument structure for SIO_SET_COMPATIBILITY_MODE */
typedef struct _WSA_COMPATIBILITY_MODE {
    WSA_COMPATIBILITY_BEHAVIOR_ID BehaviorId;
    ULONG TargetOsVersion;
} WSA_COMPATIBILITY_MODE, *PWSA_COMPATIBILITY_MODE;
```

<span data-ttu-id="56874-534">**BehaviorId** 成員中指定的值會指出所要求的行為。</span><span class="sxs-lookup"><span data-stu-id="56874-534">The value specified in the **BehaviorId** member indicates the behavior requested.</span></span> <span data-ttu-id="56874-535">**TargetOsVersion** 成員中指定的值會指出所要求的行為的 Windows 版本。</span><span class="sxs-lookup"><span data-stu-id="56874-535">The value specified in the **TargetOsVersion** member indicates the Windows version that is being requested for the behavior.</span></span>

<span data-ttu-id="56874-536">**BehaviorId** 成員可以是 *Mswsockdef .h* 標頭檔中所定義之 **WSA \_ 相容性 \_ 行為 \_ 識別碼** 列舉類型的其中一個值。</span><span class="sxs-lookup"><span data-stu-id="56874-536">The **BehaviorId** member can be one of the values from the **WSA\_COMPATIBILITY\_BEHAVIOR\_ID** enumeration type defined in the *Mswsockdef.h* header file.</span></span> <span data-ttu-id="56874-537">**BehaviorId** 成員的可能值如下所示。</span><span class="sxs-lookup"><span data-stu-id="56874-537">The possible values for the **BehaviorId** member are as follows.</span></span>

| <span data-ttu-id="56874-538">詞彙</span><span class="sxs-lookup"><span data-stu-id="56874-538">Term</span></span>                                                                                                                                                                             | <span data-ttu-id="56874-539">描述</span><span class="sxs-lookup"><span data-stu-id="56874-539">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-|-|
| <span data-ttu-id="56874-540"><span id="WsaBehaviorAll"></span><span id="wsabehaviorall"></span><span id="WSABEHAVIORALL"></span>WsaBehaviorAll</span><span class="sxs-lookup"><span data-stu-id="56874-540"><span id="WsaBehaviorAll"></span><span id="wsabehaviorall"></span><span id="WSABEHAVIORALL"></span>WsaBehaviorAll</span></span><br/>                                                     | <span data-ttu-id="56874-541">這相當於要求針對 **WSA \_ 相容性 \_ 行為 \_ 識別碼** 定義的所有可能相容行為。</span><span class="sxs-lookup"><span data-stu-id="56874-541">This is equivalent to requesting all of the possible compatible behaviors defined for **WSA\_COMPATIBILITY\_BEHAVIOR\_ID**.</span></span><br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="56874-542"><span id="WsaBehaviorReceiveBuffering"></span><span id="wsabehaviorreceivebuffering"></span><span id="WSABEHAVIORRECEIVEBUFFERING"></span>WsaBehaviorReceiveBuffering</span><span class="sxs-lookup"><span data-stu-id="56874-542"><span id="WsaBehaviorReceiveBuffering"></span><span id="wsabehaviorreceivebuffering"></span><span id="WSABEHAVIORRECEIVEBUFFERING"></span>WsaBehaviorReceiveBuffering</span></span><br/> | <span data-ttu-id="56874-543">當 **TargetOsVersion** 成員設定為 Windows Vista 或更新版本的值時，即使在建立 tcp 連線之後，也允許使用 **SO \_ RCVBUF** 通訊端選項減少此通訊端上的 TCP 接收緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="56874-543">When the **TargetOsVersion** member is set to a value for Windows Vista or later, reductions to the TCP receive buffer size on this socket using the **SO\_RCVBUF** socket option are allowed even after a TCP connection has been establishment.</span></span> <br/> <span data-ttu-id="56874-544">當 **TargetOsVersion** 成員設定為早于 Windows Vista 的值時，在連線建立之後，就不允許使用 **\_ RCVBUF** 通訊端選項來降低此通訊端上的 TCP 接收緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="56874-544">When the **TargetOsVersion** member is set to a value earlier than Windows Vista, reductions to the TCP receive buffer size on this socket using the **SO\_RCVBUF** socket option are not allowed after connection establishment.</span></span> <br/>                                                                                                                                                                                  |
| <span data-ttu-id="56874-545"><span id="WsaBehaviorAutoTuning"></span><span id="wsabehaviorautotuning"></span><span id="WSABEHAVIORAUTOTUNING"></span>WsaBehaviorAutoTuning</span><span class="sxs-lookup"><span data-stu-id="56874-545"><span id="WsaBehaviorAutoTuning"></span><span id="wsabehaviorautotuning"></span><span id="WSABEHAVIORAUTOTUNING"></span>WsaBehaviorAutoTuning</span></span><br/>                         | <span data-ttu-id="56874-546">當 **TargetOsVersion** 成員設定為 Windows Vista 或更新版本的值時，會啟用 [接收視窗自動調整]，並將 [TCP 視窗縮放比例] 從預設值8縮減為2。</span><span class="sxs-lookup"><span data-stu-id="56874-546">When the **TargetOsVersion** member is set to a value for Windows Vista or later, receive window auto-tuning is enabled and the TCP window scale factor is reduced to 2 from the default value of 8.</span></span><br/> <span data-ttu-id="56874-547">當 **TargetOsVersion** 設定為 Windows Vista 之前的值時，會停用 [接收視窗自動調整]。</span><span class="sxs-lookup"><span data-stu-id="56874-547">When the **TargetOsVersion** is set to a value earlier than Windows Vista, receive window auto-tuning is disabled.</span></span> <span data-ttu-id="56874-548">[TCP 視窗調整] 選項也會停用，而 [最大值] 接收視窗大小則限制為65535個位元組。</span><span class="sxs-lookup"><span data-stu-id="56874-548">The TCP window scaling option is also disabled and the maximum true receive window size is limited to 65,535 bytes.</span></span> <span data-ttu-id="56874-549">即使在此通訊端上呼叫 **\_ RCVBUF** 通訊端選項，在建立連接之前指定大於65535個位元組的值，也無法在連接上協商 TCP 視窗調整選項。</span><span class="sxs-lookup"><span data-stu-id="56874-549">The TCP window scaling option can't be negotiated on the connection even if the **SO\_RCVBUF** socket option was called on this socket specifying a value greater than 65,535 bytes before the connection was established.</span></span><br/> |



 

<span data-ttu-id="56874-550">如需詳細資訊，請參閱 [**SIO \_ SET \_ 相容性 \_ 模式**](/previous-versions/windows/desktop/legacy/cc136103(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-550">For more detailed information, see the [**SIO\_SET\_COMPATIBILITY\_MODE**](/previous-versions/windows/desktop/legacy/cc136103(v=vs.85)) reference.</span></span>

<span data-ttu-id="56874-551">**SIO \_Windows Vista 和更新版本支援設定 \_ 相容性 \_ 模式** 。</span><span class="sxs-lookup"><span data-stu-id="56874-551">**SIO\_SET\_COMPATIBILITY\_MODE** is supported on Windows Vista and later.</span></span>

### <a name="sio_set_group_qos-opcode-setting-i-t1"></a><span data-ttu-id="56874-552">SIO \_ 設定 \_ 群組 \_ QOS (操作碼設定： I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-552">SIO\_SET\_GROUP\_QOS (opcode setting: I, T==1)</span></span>

<span data-ttu-id="56874-553">保留的。</span><span class="sxs-lookup"><span data-stu-id="56874-553">Reserved.</span></span>

### <a name="sio_set_priority_hint-opcode-setting-i-t3"></a><span data-ttu-id="56874-554">SIO_SET_PRIORITY_HINT (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-554">SIO_SET_PRIORITY_HINT (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-555">提供提示給基礎傳輸通訊協定，以將此通訊端上的流量視為特定優先權。</span><span class="sxs-lookup"><span data-stu-id="56874-555">Provides a hint to the underlying transport protocol to treat the traffic on this socket with a specific priority.</span></span> <span data-ttu-id="56874-556">*LpvInBuffer* 必須指向類型 **PRIORITY_HINT** 的變數，並將 *cbInBuffer* 設定為 sizeof (PRIORITY_HINT) 。</span><span class="sxs-lookup"><span data-stu-id="56874-556">The *lpvInBuffer* must point to a variable of type **PRIORITY_HINT** with *cbInBuffer* set to sizeof(PRIORITY_HINT).</span></span> <span data-ttu-id="56874-557">*LpvOutBuffer* 和 *cbOutBuffer* 參數必須分別為 **Null** 和0。</span><span class="sxs-lookup"><span data-stu-id="56874-557">The *lpvOutBuffer* and *cbOutBuffer* parameters must be **NULL** and 0, respectively.</span></span> <span data-ttu-id="56874-558">Microsoft Windows TCP 執行支援此 IOCTL，從 Windows 10 版本 1809 (10.0;組建 17763) 和更新版本，如下所示：當要求的優先權值設定為 **IoPriorityHintVeryLow** 時，TCP 會使用 LEDBAT 演算法的修改版本， (在 RFC 6817) 中定義，以控制通訊端上的輸出流量速率。</span><span class="sxs-lookup"><span data-stu-id="56874-558">The Microsoft Windows TCP implementation supports this IOCTL starting with Windows 10, version 1809 (10.0; Build 17763) and later as follows: when the requested priority value is set to **IoPriorityHintVeryLow**, TCP uses a modified version of the LEDBAT algorithm (defined in RFC 6817) for controlling the outbound traffic rate on the socket.</span></span> <span data-ttu-id="56874-559">輸入流量不會受到這個 IOCTL 的影響。</span><span class="sxs-lookup"><span data-stu-id="56874-559">The inbound traffic is not affected by this IOCTL.</span></span> <span data-ttu-id="56874-560">LEDBAT 是一種清除程式演算法，其目標是要讓延遲降至最低，並防止對一般優先順序流量造成任何不利的影響，方法是在有正常優先順序的流量時，繼續進行。</span><span class="sxs-lookup"><span data-stu-id="56874-560">LEDBAT is a scavenger algorithm, and its goal is to keep latency low and prevent any adverse effect on normal-priority traffic by getting out of the way when normal-priority traffic is present.</span></span>

<span data-ttu-id="56874-561">另請參閱 [RFC 6817](https://tools.ietf.org/html/rfc6817)。</span><span class="sxs-lookup"><span data-stu-id="56874-561">Also see [RFC 6817](https://tools.ietf.org/html/rfc6817).</span></span>

<span data-ttu-id="56874-562">**SIO_SET_PRIORITY_HINT** 支援 Windows 10 版本 1809 (10.0;組建 17763) 和更新版本。</span><span class="sxs-lookup"><span data-stu-id="56874-562">**SIO_SET_PRIORITY_HINT** is supported on Windows 10, version 1809 (10.0; Build 17763) and later.</span></span>

### <a name="sio_set_qos-opcode-setting-i-t1"></a><span data-ttu-id="56874-563">SIO \_ 將 \_ QOS (opcode 設定： I，T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-563">SIO\_SET\_QOS (opcode setting: I, T==1)</span></span>

<span data-ttu-id="56874-564">將指定的 [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) 結構與通訊端建立關聯。</span><span class="sxs-lookup"><span data-stu-id="56874-564">Associate the specified [**QOS**](/windows/win32/api/winsock2/ns-winsock2-qos) structure with the socket.</span></span> <span data-ttu-id="56874-565">不需要輸出緩衝區，系統會從輸入緩衝區取得 **QOS** 結構。</span><span class="sxs-lookup"><span data-stu-id="56874-565">No output buffer is required, the **QOS** structure will be obtained from the input buffer.</span></span> <span data-ttu-id="56874-566">針對不支援服務品質的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-566">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support quality of service.</span></span>

### <a name="sio_tcp_initial_rto-opcode-setting-i-t3"></a><span data-ttu-id="56874-567">SIO_TCP_INITIAL_RTO (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-567">SIO_TCP_INITIAL_RTO (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-568">藉由設定初始重新傳輸超時 (RTO) 參數，來控制 TCP 通訊端的初始 (SYN/SYN + ACK) 重新傳輸特性。</span><span class="sxs-lookup"><span data-stu-id="56874-568">Controls the initial (SYN / SYN+ACK) retransmission characteristics of a TCP socket by configuring initial retransmission timeout (RTO) parameters.</span></span> <span data-ttu-id="56874-569">設定參數是在 [**TCP \_ 初始 \_ RTO \_ 參數**](/windows/desktop/api/mswsock/ns-mswsock-transmit_file_buffers) 結構中指定的。</span><span class="sxs-lookup"><span data-stu-id="56874-569">The configuration parameters are specified in a [**TCP\_INITIAL\_RTO\_PARAMETERS**](/windows/desktop/api/mswsock/ns-mswsock-transmit_file_buffers) structure.</span></span>

<span data-ttu-id="56874-570">如需詳細資訊，請參閱 [**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-570">For more detailed information, see the [**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) reference.</span></span> <span data-ttu-id="56874-571">Windows 8、Windows Server 2012 及更新版本都支援 [**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) 。</span><span class="sxs-lookup"><span data-stu-id="56874-571">[**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_timestamping"></a><span data-ttu-id="56874-572">SIO_TIMESTAMPING</span><span class="sxs-lookup"><span data-stu-id="56874-572">SIO_TIMESTAMPING</span></span>

<span data-ttu-id="56874-573">用來設定接收通訊端傳輸/接收時間戳記的通訊端 IOCTL。</span><span class="sxs-lookup"><span data-stu-id="56874-573">A socket IOCTL used to configure reception of socket transmit/receive timestamps.</span></span> <span data-ttu-id="56874-574">只對資料包通訊端有效。</span><span class="sxs-lookup"><span data-stu-id="56874-574">Valid only for datagram sockets.</span></span> <span data-ttu-id="56874-575">**SIO_TIMESTAMPING** 的輸入類型是 [**TIMESTAMPING_CONFIG**](/windows/win32/api/mstcpip/ns-mstcpip-timestamping_config)結構。</span><span class="sxs-lookup"><span data-stu-id="56874-575">The input type for **SIO_TIMESTAMPING** is the [**TIMESTAMPING_CONFIG**](/windows/win32/api/mstcpip/ns-mstcpip-timestamping_config) structure.</span></span>

<span data-ttu-id="56874-576">另請參閱 [Winsock 時間戳記](/windows/win32/winsock/winsock-timestamping)。</span><span class="sxs-lookup"><span data-stu-id="56874-576">Also see [Winsock timestamping](/windows/win32/winsock/winsock-timestamping).</span></span>

### <a name="sio_translate_handle-opcode-setting-i-o-t1"></a><span data-ttu-id="56874-577">SIO \_ 轉譯 \_ 控制碼 (opcode 設定： I、O、T = = 1) </span><span class="sxs-lookup"><span data-stu-id="56874-577">SIO\_TRANSLATE\_HANDLE (opcode setting: I, O, T==1)</span></span>

<span data-ttu-id="56874-578">若要取得通訊端 *s* 的對應控制碼，該控制碼在隨附介面的內容中有效 (例如，第 \_ NETDEV 和第一次 \_ TAPI) 。</span><span class="sxs-lookup"><span data-stu-id="56874-578">To obtain a corresponding handle for socket *s* that is valid in the context of a companion interface (for example, TH\_NETDEV and TH\_TAPI).</span></span> <span data-ttu-id="56874-579">在輸入緩衝區中指定了識別隨附介面的資訊清單常數，以及任何其他需要的參數。</span><span class="sxs-lookup"><span data-stu-id="56874-579">A manifest constant identifying the companion interface along with any other needed parameters are specified in the input buffer.</span></span> <span data-ttu-id="56874-580">當此函式完成時，將會在輸出緩衝區中提供對應的控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-580">The corresponding handle will be available in the output buffer upon completion of this function.</span></span> <span data-ttu-id="56874-581">請參閱 [Winsock 附件](winsock-annexes.md) 中的適當區段，以取得特定隨附介面特定的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="56874-581">Refer to the appropriate section in [Winsock Annexes](winsock-annexes.md) for details specific to a particular companion interface.</span></span> <span data-ttu-id="56874-582">針對指定的隨附介面不支援這個 IOCTL 的服務提供者，會指出 [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) 錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="56874-582">The [WSAENOPROTOOPT](windows-sockets-error-codes-2.md) error code is indicated for service providers that do not support this IOCTL for the specified companion interface.</span></span> <span data-ttu-id="56874-583">這個 IOCTL 會使用 **SIO \_ 轉譯 \_ 控制碼** 來抓取相關聯的控制碼。</span><span class="sxs-lookup"><span data-stu-id="56874-583">This IOCTL retrieves the handle associated using **SIO\_TRANSLATE\_HANDLE**.</span></span>

<span data-ttu-id="56874-584">建議您) 使用元件物件模型 (COM，而不使用這個 IOCTL 來探索和追蹤通訊端可能支援的其他介面。</span><span class="sxs-lookup"><span data-stu-id="56874-584">It is recommend that the Component Object Model (COM) be used instead of this IOCTL to discover and track other interfaces that might be supported by a socket.</span></span> <span data-ttu-id="56874-585">這個 IOCTL 存在的目的是為了讓 COM 無法使用或無法用於其他原因的系統回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="56874-585">This IOCTL is present for backward compatibility with systems where COM is not available or cannot be used for some other reason.</span></span>

### <a name="sio_udp_connreset-opcode-setting-i-t3"></a><span data-ttu-id="56874-586">SIO \_ UDP \_ CONNRESET (opcode 設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-586">SIO\_UDP\_CONNRESET (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-587">**WINDOWS XP：** 控制是否報告 UDP 埠 \_ 無法連線的訊息。</span><span class="sxs-lookup"><span data-stu-id="56874-587">**Windows XP:** Controls whether UDP PORT\_UNREACHABLE messages are reported.</span></span> <span data-ttu-id="56874-588">設定為 **TRUE** 以啟用報告功能。</span><span class="sxs-lookup"><span data-stu-id="56874-588">Set to **TRUE** to enable reporting.</span></span> <span data-ttu-id="56874-589">設定為 **FALSE** 會停用報告。</span><span class="sxs-lookup"><span data-stu-id="56874-589">Set to **FALSE** to disable reporting.</span></span>

### <a name="sio_set_wfp_connection_redirect_records-opcode-setting-i-t3"></a><span data-ttu-id="56874-590">SIO \_ 設定 \_ WFP \_ 連接重新 \_ 導向 \_ 記錄 (操作碼設定： I，T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-590">SIO\_SET\_WFP\_CONNECTION\_REDIRECT\_RECORDS (opcode setting: I, T==3)</span></span>

<span data-ttu-id="56874-591">將重新導向記錄設定為新的 TCP 通訊端，用來連接到最終目的地，以供 Windows 篩選平台 (WFP) 重新導向服務使用。</span><span class="sxs-lookup"><span data-stu-id="56874-591">Sets the redirect record to the new TCP socket used for connecting to the final destination for use by a Windows Filtering Platform (WFP) redirect service.</span></span>

<span data-ttu-id="56874-592">在重新導向的通訊端連線上，會使用 [**SIO \_ SET \_ WFP \_ 連接重新 \_ 導向 \_ 記錄**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) IOCTL 作為 proxy 連接追蹤的一部分。</span><span class="sxs-lookup"><span data-stu-id="56874-592">The [**SIO\_SET\_WFP\_CONNECTION\_REDIRECT\_RECORDS**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) IOCTL is used as part of proxied connection tracking on redirected socket connections.</span></span> <span data-ttu-id="56874-593">這種 WFP 功能可從連接的初始重新導向到目的地的最終連接，來協助追蹤重新導向記錄。</span><span class="sxs-lookup"><span data-stu-id="56874-593">This WFP feature facilitates tracking of redirection records from the initial redirect of a connection to the final connection to the destination.</span></span>

<span data-ttu-id="56874-594">如需詳細資訊，請參閱 [**SIO \_ SET \_ WFP \_ 連接重新 \_ 導向 \_ 記錄**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) 參考。</span><span class="sxs-lookup"><span data-stu-id="56874-594">For more detailed information, see the [**SIO\_SET\_WFP\_CONNECTION\_REDIRECT\_RECORDS**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) reference.</span></span> <span data-ttu-id="56874-595">**SIO \_Windows 8、Windows Server 2012 及更新版本都支援設定 \_ WFP \_ 連接重新 \_ 導向 \_ 記錄** 。</span><span class="sxs-lookup"><span data-stu-id="56874-595">**SIO\_SET\_WFP\_CONNECTION\_REDIRECT\_RECORDS** is supported on Windows 8, Windows Server 2012, and later.</span></span>

### <a name="sio_tcp_info-opcode-setting-i-o-t3"></a><span data-ttu-id="56874-596">SIO \_ TCP \_ 資訊 (操作碼設定： I、O、T = = 3) </span><span class="sxs-lookup"><span data-stu-id="56874-596">SIO\_TCP\_INFO (opcode setting: I, O, T==3)</span></span>

<span data-ttu-id="56874-597">抓取通訊端的 TCP 統計資料。</span><span class="sxs-lookup"><span data-stu-id="56874-597">Retrieves the TCP statistics for a socket.</span></span> <span data-ttu-id="56874-598">Tcp [**\_ 資訊 \_ v0**](/windows/desktop/api/Mstcpip/ns-mstcpip-tcp_info_v0) 結構中會提供 tcp 統計資料。</span><span class="sxs-lookup"><span data-stu-id="56874-598">The TCP statistics are provided in a [**TCP\_INFO\_v0**](/windows/desktop/api/Mstcpip/ns-mstcpip-tcp_info_v0) structure.</span></span>

<span data-ttu-id="56874-599">與使用 [**GetPerTcpConnectionEStats**](/windows/win32/api/iphlpapi/nf-iphlpapi-getpertcpconnectionestats) 函式來抓取 tcp 統計資料不同的是，使用這個控制項程式碼來抓取 tcp 統計資料並不需要使用者程式碼來載入、儲存和篩選 tcp 連接資料表，也不需要使用較高的許可權。</span><span class="sxs-lookup"><span data-stu-id="56874-599">Unlike retrieving TCP statistics with the [**GetPerTcpConnectionEStats**](/windows/win32/api/iphlpapi/nf-iphlpapi-getpertcpconnectionestats) function, retrieving TCP statistics with this control code does not require the user code to load, store, and filter the TCP connection table, and does not require elevated privileges to use.</span></span>

<span data-ttu-id="56874-600">如需詳細資訊，請參閱 [**SIO \_ TCP \_ 資訊**](/previous-versions/windows/desktop/legacy/mt823415(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="56874-600">For more information, see [**SIO\_TCP\_INFO**](/previous-versions/windows/desktop/legacy/mt823415(v=vs.85)).</span></span> <span data-ttu-id="56874-601">**SIO \_Windows 10 \_** 、1703版、Windows Server 2016 和更新版本都支援 TCP 資訊。</span><span class="sxs-lookup"><span data-stu-id="56874-601">**SIO\_TCP\_INFO** is supported on Windows 10, version 1703, Windows Server 2016, and later.</span></span>

## <a name="remarks"></a><span data-ttu-id="56874-602">備註</span><span class="sxs-lookup"><span data-stu-id="56874-602">Remarks</span></span>

<span data-ttu-id="56874-603">Winsock Ioctls 是以許多不同的標頭檔定義。</span><span class="sxs-lookup"><span data-stu-id="56874-603">Winsock Ioctls are defined in a number of different header files.</span></span> <span data-ttu-id="56874-604">這些包括 *Winsock2. .h*、 *Mswsock .h* 和 *Mstcpip .h* 標頭檔。</span><span class="sxs-lookup"><span data-stu-id="56874-604">These include the *Winsock2.h*, *Mswsock.h*, and *Mstcpip.h* header file.</span></span>

<span data-ttu-id="56874-605">在 Windows Vista （含）以後版本的 Microsoft Windows 軟體開發套件 (SDK) 上，標頭檔的組織已變更，而且 *Ws2def .h*、 *Ws2ipdef .h* 和 *Mswsockdef .h* 標頭檔中也會定義一些 Winsock Ioctls。</span><span class="sxs-lookup"><span data-stu-id="56874-605">On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files has changed and a number of Winsock Ioctls are also defined in the *Ws2def.h*, *Ws2ipdef.h*, and *Mswsockdef.h* header files.</span></span> <span data-ttu-id="56874-606">*Ws2def. h* 標頭檔會自動包含在 *Winsock2* 標頭檔中。</span><span class="sxs-lookup"><span data-stu-id="56874-606">The *Ws2def.h* header file is automatically included by the *Winsock2.h* header file.</span></span> <span data-ttu-id="56874-607">*Ws2ipdef .h* 標頭檔會自動包含在 *Ws2tcpip .h* 標頭檔中。</span><span class="sxs-lookup"><span data-stu-id="56874-607">The *Ws2ipdef.h* header file is automatically included by the *Ws2tcpip.h* header file.</span></span> <span data-ttu-id="56874-608">*Mswsockdef .h* 標頭檔會自動包含在 *Mswsockdef .h* 標頭檔中。</span><span class="sxs-lookup"><span data-stu-id="56874-608">The *Mswsockdef.h* header file is automatically included in the *Mswsockdef.h* header file.</span></span>

## <a name="requirements"></a><span data-ttu-id="56874-609">規格需求</span><span class="sxs-lookup"><span data-stu-id="56874-609">Requirements</span></span>

|<span data-ttu-id="56874-610">需求</span><span class="sxs-lookup"><span data-stu-id="56874-610">Requirement</span></span>|<span data-ttu-id="56874-611">值</span><span class="sxs-lookup"><span data-stu-id="56874-611">Value</span></span>|
|-|-|
| <span data-ttu-id="56874-612">標頭</span><span class="sxs-lookup"><span data-stu-id="56874-612">Header</span></span><br/> | <dl> <span data-ttu-id="56874-613"><dt>Winsock2. h;</dt><dt>Mstcpip .h;</dt><dt>Mswsock .h;</dt><dt>Windows Vista、Windows Server 2008 和 windows 7 (的 Mswsockdef，包括 Mswsock) ;</dt><dt>Windows Vista、Windows Server 2008 和 windows 7 (的 Ws2def，包括 Winsock2) ;</dt><dt>Windows Vista、Windows Server 2008 和 windows 7 (的 Ws2ipdef，包括 Ws2tcpip) </dt></span><span class="sxs-lookup"><span data-stu-id="56874-613"><dt>Winsock2.h; </dt> <dt>Mstcpip.h; </dt> <dt>Mswsock.h; </dt> <dt>Mswsockdef.h on Windows Vista, Windows Server 2008 and Windows 7 (include Mswsock.h); </dt> <dt>Ws2def.h on Windows Vista, Windows Server 2008 and Windows 7 (include Winsock2.h); </dt> <dt>Ws2ipdef.h on Windows Vista, Windows Server 2008 and Windows 7 (include Ws2tcpip.h)</dt></span></span> </dl> |
