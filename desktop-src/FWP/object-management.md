---
title: 物件管理
description: 本節涵蓋 Windows 篩選平台 (WFP) API 物件類型的正確用法。
ms.assetid: 2625ef9a-0e62-4e21-ba93-047965d0d782
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc41560bb85a7e79c0262d77c0b34fe6c1d9bfd6
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/19/2020
ms.locfileid: "104463040"
---
# <a name="object-management"></a><span data-ttu-id="ce81b-103">物件管理</span><span class="sxs-lookup"><span data-stu-id="ce81b-103">Object Management</span></span>

<span data-ttu-id="ce81b-104">本節涵蓋 Windows 篩選平台 (WFP) API 物件類型的正確用法。</span><span class="sxs-lookup"><span data-stu-id="ce81b-104">This section covers the correct use of Windows Filtering Platform (WFP) API object types.</span></span>

## <a name="sessions"></a><span data-ttu-id="ce81b-105">工作階段</span><span class="sxs-lookup"><span data-stu-id="ce81b-105">Sessions</span></span>

<span data-ttu-id="ce81b-106">WFP API 是會話導向的，大部分的函式呼叫都是在會話的內容中進行。</span><span class="sxs-lookup"><span data-stu-id="ce81b-106">The WFP API is session-oriented, and most function calls are made within the context of a session.</span></span> <span data-ttu-id="ce81b-107">藉由呼叫 [**FwpmEngineOpen0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineopen0)來建立新的用戶端會話。</span><span class="sxs-lookup"><span data-stu-id="ce81b-107">A new client session is created by calling [**FwpmEngineOpen0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineopen0).</span></span> <span data-ttu-id="ce81b-108">當用戶端呼叫 [**FwpmEngineClose0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineclose0) 或用戶端進程終止時，會話便會結束。</span><span class="sxs-lookup"><span data-stu-id="ce81b-108">The session ends either when the client calls [**FwpmEngineClose0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineclose0) or the client process terminates.</span></span> <span data-ttu-id="ce81b-109">當會話損毀時（基於用途或 RPC 取消），基礎篩選引擎 (BFE) 先中止任何現有的交易。</span><span class="sxs-lookup"><span data-stu-id="ce81b-109">When a session is destroyed, either on purpose or by the RPC rundown, the Base Filtering Engine (BFE) first aborts any existing transaction.</span></span>

<span data-ttu-id="ce81b-110">建立新的會話時，呼叫端可以將 [**FWPM \_ 會話 \_ 旗標 \_ 動態**](/windows/desktop/api/Fwpmtypes/ns-fwpmtypes-fwpm_session0) 旗標傳遞給 [**FwpmEngineOpen0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineopen0)，以建立動態會話。</span><span class="sxs-lookup"><span data-stu-id="ce81b-110">When creating a new session, the caller can create a dynamic session by passing the [**FWPM\_SESSION\_FLAG\_DYNAMIC**](/windows/desktop/api/Fwpmtypes/ns-fwpmtypes-fwpm_session0) flag to [**FwpmEngineOpen0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmengineopen0).</span></span> <span data-ttu-id="ce81b-111">當會話結束時，會自動刪除動態會話期間加入的任何物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-111">Any objects added during a dynamic session are automatically deleted when the session ends.</span></span>

## <a name="transactions"></a><span data-ttu-id="ce81b-112">交易</span><span class="sxs-lookup"><span data-stu-id="ce81b-112">Transactions</span></span>

<span data-ttu-id="ce81b-113">WFP API 是交易式的，大部分的函式呼叫都是在交易的內容中進行。</span><span class="sxs-lookup"><span data-stu-id="ce81b-113">The WFP API is transactional, and most function calls are made within the context of a transaction.</span></span> <span data-ttu-id="ce81b-114">呼叫端可以使用 [**FwpmTransactionBegin0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionbegin0)、 [**FwpmTransactionCommit0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactioncommit0)和 [**FwpmTransactionAbort0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionabort0) 來明確控制交易。</span><span class="sxs-lookup"><span data-stu-id="ce81b-114">Callers can use [**FwpmTransactionBegin0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionbegin0), [**FwpmTransactionCommit0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactioncommit0), and [**FwpmTransactionAbort0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionabort0) to explicitly control transactions.</span></span> <span data-ttu-id="ce81b-115">但是，如果在明確交易之外進行函式呼叫，則會在隱含交易內執行函式。</span><span class="sxs-lookup"><span data-stu-id="ce81b-115">However, if a function call is made outside of an explicit transaction, it will be executed within an implicit transaction.</span></span> <span data-ttu-id="ce81b-116">如果交易正在進行中，當會話終止時，它會自動中止。</span><span class="sxs-lookup"><span data-stu-id="ce81b-116">If a transaction is in progress, when a session terminates, it is automatically aborted.</span></span> <span data-ttu-id="ce81b-117">永遠不會強制中止隱含交易。</span><span class="sxs-lookup"><span data-stu-id="ce81b-117">Implicit transactions are never forcibly aborted.</span></span>

<span data-ttu-id="ce81b-118">交易可以是唯讀或讀取/寫入，而且會強制執行嚴格的不可部分完成一致性隔離持久 ([ACID](../cossdk/acid-properties.md)) 的語法。</span><span class="sxs-lookup"><span data-stu-id="ce81b-118">Transactions are either read-only or read/write and enforce rigorous Atomic Consistent Isolated Durable ([ACID](../cossdk/acid-properties.md)) semantics.</span></span>

<span data-ttu-id="ce81b-119">每個用戶端會話一次只能有一個交易在進行中。</span><span class="sxs-lookup"><span data-stu-id="ce81b-119">Each client session can have only one transaction in progress at a time.</span></span> <span data-ttu-id="ce81b-120">如果呼叫端在認可或中止第一個交易之前嘗試開始第二個交易，BFE 會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce81b-120">If the caller attempts to begin a second transaction before committing or aborting the first, BFE returns an error.</span></span>

<span data-ttu-id="ce81b-121">如果作業在交易過程中失敗，則不會影響交易的整體狀態。</span><span class="sxs-lookup"><span data-stu-id="ce81b-121">If an operation fails during the course of a transaction, it does not affect the overall state of the transaction.</span></span> <span data-ttu-id="ce81b-122">例如，假設用戶端開始交易，並在第四個呼叫失敗之前成功呼叫 [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0) 三次。</span><span class="sxs-lookup"><span data-stu-id="ce81b-122">For example, suppose the client begins a transaction and successfully calls [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0) three times before a fourth call fails.</span></span> <span data-ttu-id="ce81b-123">用戶端現在可以選擇下列選項：</span><span class="sxs-lookup"><span data-stu-id="ce81b-123">The client now has the option of:</span></span>

-   <span data-ttu-id="ce81b-124">中止交易，在這種情況下，將不會新增任何篩選。</span><span class="sxs-lookup"><span data-stu-id="ce81b-124">Aborting the transaction, in which case none of the filters will be added.</span></span>
-   <span data-ttu-id="ce81b-125">認可交易，在這種情況下，將會新增前三個篩選準則。</span><span class="sxs-lookup"><span data-stu-id="ce81b-125">Committing the transaction, in which case the first three filters will be added.</span></span>
-   <span data-ttu-id="ce81b-126">繼續進行更多作業，包括可能會重試失敗的 [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0)。</span><span class="sxs-lookup"><span data-stu-id="ce81b-126">Continuing with more operations including potentially retrying the failed [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0).</span></span>

<span data-ttu-id="ce81b-127">開始交易時，BFE 會等待會話的 [**txnWaitTimeoutInMSec**](/windows/desktop/api/Fwpmtypes/ns-fwpmtypes-fwpm_session0) 到期，以取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce81b-127">When beginning a transaction, BFE will wait until the session's [**txnWaitTimeoutInMSec**](/windows/desktop/api/Fwpmtypes/ns-fwpmtypes-fwpm_session0) expires to acquire the lock.</span></span> <span data-ttu-id="ce81b-128">如果在這段時間內未取得鎖定，則鎖定取得 (，且 [**FwpmTransactionBegin0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionbegin0) 呼叫) 將會失敗。</span><span class="sxs-lookup"><span data-stu-id="ce81b-128">If the lock is not acquired within this time, the lock acquisition (and the [**FwpmTransactionBegin0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmtransactionbegin0) call) will fail.</span></span> <span data-ttu-id="ce81b-129">這可防止用戶端無限期地回應。</span><span class="sxs-lookup"><span data-stu-id="ce81b-129">This prevents clients from indefinitely failing to respond.</span></span> <span data-ttu-id="ce81b-130">如果用戶端未指定鎖定超時，則預設為15秒。</span><span class="sxs-lookup"><span data-stu-id="ce81b-130">If the client did not specify a lock timeout, it defaults to 15 seconds.</span></span>

<span data-ttu-id="ce81b-131">每一筆交易也有鎖定超時。</span><span class="sxs-lookup"><span data-stu-id="ce81b-131">Each transaction also has a lock timeout.</span></span> <span data-ttu-id="ce81b-132">這是它可以擁有鎖定的最大時間量。</span><span class="sxs-lookup"><span data-stu-id="ce81b-132">This is the maximum amount of time that it can own the lock.</span></span> <span data-ttu-id="ce81b-133">如果擁有者未在這段時間內釋放鎖定，則會強制中止交易，而導致釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce81b-133">If the owner does not release the lock within this time, the transaction is forcibly aborted, causing the lock to be released.</span></span> <span data-ttu-id="ce81b-134">鎖定超時無法設定。</span><span class="sxs-lookup"><span data-stu-id="ce81b-134">The lock timeout is not configurable.</span></span> <span data-ttu-id="ce81b-135">它對核心模式呼叫端是無限的，而且使用者模式呼叫端的時間是一小時。</span><span class="sxs-lookup"><span data-stu-id="ce81b-135">It is infinite for kernel-mode callers and one hour for user-mode callers.</span></span> <span data-ttu-id="ce81b-136">如果交易遭到強制中止，則在該交易內進行的下一次呼叫會失敗，並會 **\_ \_ \_ 中止 TXN**。</span><span class="sxs-lookup"><span data-stu-id="ce81b-136">If a transaction is forcibly aborted, the next call made within that transaction will fail with **FWP\_E\_TXN\_ABORTED**.</span></span>

## <a name="object-lifetimes"></a><span data-ttu-id="ce81b-137">物件存留期</span><span class="sxs-lookup"><span data-stu-id="ce81b-137">Object Lifetimes</span></span>

<span data-ttu-id="ce81b-138">物件可以有四個可能的存留期之一：</span><span class="sxs-lookup"><span data-stu-id="ce81b-138">Objects can have one of four possible lifetimes:</span></span>

-   <span data-ttu-id="ce81b-139">動態—只有在使用動態會話控制碼加入物件時，物件才會是動態的。</span><span class="sxs-lookup"><span data-stu-id="ce81b-139">Dynamic — An object is dynamic only if it is added using a dynamic session handle.</span></span> <span data-ttu-id="ce81b-140">動態物件會一直存留，直到其被刪除或擁有會話終止為止。</span><span class="sxs-lookup"><span data-stu-id="ce81b-140">Dynamic objects live until they are deleted or the owning session terminates.</span></span>
-   <span data-ttu-id="ce81b-141">靜態：物件預設為靜態。</span><span class="sxs-lookup"><span data-stu-id="ce81b-141">Static — Objects are static by default.</span></span> <span data-ttu-id="ce81b-142">靜態物件會一直存留到刪除為止、BFE 停止或系統關機。</span><span class="sxs-lookup"><span data-stu-id="ce81b-142">Static objects live until they are deleted, BFE stops, or the system is shutdown.</span></span>
-   <span data-ttu-id="ce81b-143">持續性：持續性物件是藉由將適當的 **FWPM \_ \* \_ 旗標 \_ 持續** 旗標傳遞給 **FWPM \* Add0** 函式所建立。</span><span class="sxs-lookup"><span data-stu-id="ce81b-143">Persistent — Persistent objects are created by passing the appropriate **FWPM\_\*\_FLAG\_PERSISTENT** flag to an **Fwpm\*Add0** function.</span></span> <span data-ttu-id="ce81b-144">持續性物件會存留到刪除為止。</span><span class="sxs-lookup"><span data-stu-id="ce81b-144">Persistent objects live until they are deleted.</span></span>
-   <span data-ttu-id="ce81b-145">內建-內建物件是由 BFE 預先定義，無法新增或刪除。</span><span class="sxs-lookup"><span data-stu-id="ce81b-145">Built-in — Built-in objects are predefined by BFE and cannot be added or deleted.</span></span> <span data-ttu-id="ce81b-146">它們會永遠存留。</span><span class="sxs-lookup"><span data-stu-id="ce81b-146">They live forever.</span></span>

<span data-ttu-id="ce81b-147">您可以藉由將適當的旗標傳遞給 [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0)，將核心模式層中的篩選標記為開機時間篩選器。</span><span class="sxs-lookup"><span data-stu-id="ce81b-147">Filters in kernel-mode layers can be marked as boot-time filters by passing the appropriate flag to [**FwpmFilterAdd0**](/windows/desktop/api/Fwpmu/nf-fwpmu-fwpmfilteradd0).</span></span> <span data-ttu-id="ce81b-148">開機時間篩選器會在 TCP/IP 驅動程式啟動時新增至系統，並在 BFE 完成初始化時移除。</span><span class="sxs-lookup"><span data-stu-id="ce81b-148">Boot-time filters are added to the system when the TCP/IP driver starts, and removed when BFE finishes initialization.</span></span> <span data-ttu-id="ce81b-149">當 BFE 啟動時，就會新增持續性物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-149">Persistent objects are added when BFE starts.</span></span>

<span data-ttu-id="ce81b-150">在許多情況下，如果提供者已停用，原則提供者可能不想強制執行其持續性原則。</span><span class="sxs-lookup"><span data-stu-id="ce81b-150">In many cases, a policy provider may not want its persistent policy enforced if the provider has been disabled.</span></span> <span data-ttu-id="ce81b-151">加入提供者時，呼叫端可以指定選擇性的 Windows 服務名稱。</span><span class="sxs-lookup"><span data-stu-id="ce81b-151">When adding a provider, the caller can specify an optional Windows service name.</span></span> <span data-ttu-id="ce81b-152">加入持續性物件時，呼叫端可以選擇性地指定「擁有」該物件的提供者。</span><span class="sxs-lookup"><span data-stu-id="ce81b-152">When adding persistent objects, the caller can optionally specify the provider that "owns" that object.</span></span> <span data-ttu-id="ce81b-153">在服務啟動時，只有當 BFE 未與提供者相關聯，或相關聯的提供者沒有 Windows 服務名稱，或相關聯的 Windows 服務設定為自動啟動時，才會將持續性物件新增至系統。</span><span class="sxs-lookup"><span data-stu-id="ce81b-153">At service start, BFE only adds persistent objects to the system if they are not associated with a provider, or the associated provider has no Windows service name, or the associated Windows service is set to auto-start.</span></span>

## <a name="object-associations"></a><span data-ttu-id="ce81b-154">物件關聯</span><span class="sxs-lookup"><span data-stu-id="ce81b-154">Object Associations</span></span>

<span data-ttu-id="ce81b-155">某些物件具有其他物件的參考。</span><span class="sxs-lookup"><span data-stu-id="ce81b-155">Some objects have references to other objects.</span></span> <span data-ttu-id="ce81b-156">例如，篩選準則一律會參考圖層，並可參考標注和提供者內容。</span><span class="sxs-lookup"><span data-stu-id="ce81b-156">For example, a filter always references a layer and may reference a callout and a provider context.</span></span> <span data-ttu-id="ce81b-157">物件無法參考可能存留期較短的物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-157">Objects cannot refer to objects that may have a shorter lifetime.</span></span> <span data-ttu-id="ce81b-158">因此，動態物件無法從不同的會話參考動態物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-158">Thus, a dynamic object cannot refer to a dynamic object from a different session.</span></span> <span data-ttu-id="ce81b-159">靜態物件無法參考動態物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-159">A static object cannot refer to a dynamic object.</span></span> <span data-ttu-id="ce81b-160">持續性物件無法參考動態物件、靜態物件或其他提供者所擁有的持續性物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-160">A persistent object cannot refer to a dynamic object, a static object, or a persistent object owned by a different provider.</span></span>

<span data-ttu-id="ce81b-161">必須先刪除所有參考該物件的物件，才能刪除該物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-161">An object cannot be deleted until all objects that reference it have first been deleted.</span></span>

## <a name="luids-and-guids"></a><span data-ttu-id="ce81b-162">Luid 和 Guid</span><span class="sxs-lookup"><span data-stu-id="ce81b-162">LUIDs and GUIDs</span></span>

<span data-ttu-id="ce81b-163">所有使用者模式的 WFP API 物件 (FWPM) 是由全域唯一識別碼 (**guid**) ，並依 **guid** s 參考其他物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-163">All user mode WFP API objects (FWPM) are identified by a globally unique identifier (**GUID**) and reference other objects by their **GUID** s.</span></span> <span data-ttu-id="ce81b-164">**GUID** 只需要在物件類型內是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ce81b-164">The **GUID** need only be unique within the object type.</span></span> <span data-ttu-id="ce81b-165">例如，篩選準則和提供者內容可以有相同的 **GUID**，但不能有兩個篩選準則。</span><span class="sxs-lookup"><span data-stu-id="ce81b-165">For example, a filter and a provider context can have the same **GUID**, but two filters cannot.</span></span> <span data-ttu-id="ce81b-166">加入新的物件時，呼叫端可以指派物件的 **GUID** ，或將它保持為零初始化，讓 BFE 指派 **GUID**。</span><span class="sxs-lookup"><span data-stu-id="ce81b-166">When adding a new object, callers can assign the object's **GUID** or leave it zero-initialized and let BFE assign the **GUID**.</span></span>

<span data-ttu-id="ce81b-167">所有核心模式的 WFP API 物件 (FWPS) 是由本機唯一識別碼 (**luid**) 所識別，並依其 LUID 參考其他物件。</span><span class="sxs-lookup"><span data-stu-id="ce81b-167">All kernel mode WFP API objects (FWPS) are identified by a locally unique identifier (**LUID**) and reference other objects by their LUID.</span></span> <span data-ttu-id="ce81b-168">從 **GUID** 切換至 **LUID** 可讓 WFP 節省非分頁的集區，並將執行時間處理優化。</span><span class="sxs-lookup"><span data-stu-id="ce81b-168">The switch from **GUID** to **LUID** enables WFP to conserve non-paged pool and optimize run-time processing.</span></span> <span data-ttu-id="ce81b-169">**LUID** 的寬度取決於物件類型，以及從 **UINT16** 到 **UINT64** 的範圍。</span><span class="sxs-lookup"><span data-stu-id="ce81b-169">The width of the **LUID** depends on the object type and ranges from a **UINT16** to a **UINT64**.</span></span> <span data-ttu-id="ce81b-170">**LUID** 一律會由 BFE 指派。</span><span class="sxs-lookup"><span data-stu-id="ce81b-170">**LUID** s are always assigned by BFE.</span></span>

 

 