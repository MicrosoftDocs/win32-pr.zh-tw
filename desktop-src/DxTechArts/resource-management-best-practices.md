---
title: 資源管理最佳作法
description: 本文討論一般處理資源的最佳作法、受控和非受控資源的行為，並提供一些資源通常是由執行時間和驅動程式處理的詳細資料。
ms.assetid: 265ae0b2-f268-a4a4-551e-9d3dae886517
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 27cdadb8cee3cb57f4208657054784937ecd1ea2
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104315856"
---
# <a name="resource-management-best-practices"></a><span data-ttu-id="b801a-103">資源管理最佳作法</span><span class="sxs-lookup"><span data-stu-id="b801a-103">Resource Management Best Practices</span></span>

<span data-ttu-id="b801a-104">受控紋理（也稱為自動材質管理）自第6版起已可在 DirectX 中使用，並在後續的版本中進行了許多修訂和增強功能。</span><span class="sxs-lookup"><span data-stu-id="b801a-104">Managed textures, also known as automatic texture management, have been available in DirectX since version 6, with several revisions and enhancements made in subsequent releases.</span></span> <span data-ttu-id="b801a-105">從 Direct3D 9 API 的版本開始，自動資源管理包含紋理、頂點緩衝區和索引緩衝區的支援，全都具有一致的共用介面。</span><span class="sxs-lookup"><span data-stu-id="b801a-105">As of the release of the Direct3D 9 API, the automatic resource management includes support for textures, vertex buffers, and index buffers, all with a consistent shared interface.</span></span> <span data-ttu-id="b801a-106">使用 Direct3D 資源管理員，應用程式可以大幅簡化遺失裝置狀況的處理，而且可以依賴系統來處理合理數量的影片記憶體資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-106">By using the Direct3D resource manager, applications can greatly simplify the handling of lost-device situations and can rely on the system to handle a reasonable amount of over-commitment of video memory resources.</span></span>

<span data-ttu-id="b801a-107">開發人員有時可能會在使用受控資源時遇到問題，部分原因是系統的抽象本質。</span><span class="sxs-lookup"><span data-stu-id="b801a-107">Developers sometimes have difficulties using managed resources, in part due to the abstract nature of the system.</span></span> <span data-ttu-id="b801a-108">雖然許多常見的資源案例都適用于受控資源，但在使用非受控資源時，某些情況下會有更好的表現。</span><span class="sxs-lookup"><span data-stu-id="b801a-108">While many common scenarios for resources are a good fit for managed resources, some cases perform better when using unmanaged resources.</span></span> <span data-ttu-id="b801a-109">本文討論一般處理資源的最佳作法、受控和非受控資源的行為，並提供一些資源通常是由執行時間和驅動程式處理的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="b801a-109">This article discusses best practices for dealing with resources generally, how managed and unmanaged resources behave, and provides some detail on how resources are typically handled by the runtime and drivers.</span></span>

<span data-ttu-id="b801a-110">本文涵蓋這些概念：</span><span class="sxs-lookup"><span data-stu-id="b801a-110">This article covers these concepts:</span></span>

-   [<span data-ttu-id="b801a-111">視訊記憶體</span><span class="sxs-lookup"><span data-stu-id="b801a-111">Video Memory</span></span>](#video-memory)
-   [<span data-ttu-id="b801a-112">Managed 資源</span><span class="sxs-lookup"><span data-stu-id="b801a-112">Managed Resources</span></span>](#managed-resources)
-   [<span data-ttu-id="b801a-113">驅動程式管理的資源</span><span class="sxs-lookup"><span data-stu-id="b801a-113">Driver-Managed Resources</span></span>](#driver-managed-resources)
-   [<span data-ttu-id="b801a-114">預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-114">Default Resources</span></span>](#default-resources)
    -   [<span data-ttu-id="b801a-115">使用 Managed 和預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-115">Using Both Managed and Default Resources</span></span>](#using-both-managed-and-default-resources)
    -   [<span data-ttu-id="b801a-116">動態預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-116">Dynamic Default Resources</span></span>](#dynamic-default-resources)
-   [<span data-ttu-id="b801a-117">系統記憶體資源</span><span class="sxs-lookup"><span data-stu-id="b801a-117">System Memory Resources</span></span>](#system-memory-resources)
-   [<span data-ttu-id="b801a-118">一般建議</span><span class="sxs-lookup"><span data-stu-id="b801a-118">General Recommendations</span></span>](#general-recommendations)
-   [<span data-ttu-id="b801a-119">相關主題</span><span class="sxs-lookup"><span data-stu-id="b801a-119">Related topics</span></span>](#related-topics)

## <a name="video-memory"></a><span data-ttu-id="b801a-120">視訊記憶體</span><span class="sxs-lookup"><span data-stu-id="b801a-120">Video Memory</span></span>

<span data-ttu-id="b801a-121">若要讓影片系統使用資源，它必須位於 GPU 可存取的記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b801a-121">For the video system to make use of a resource, it must be located in memory that is accessible to the GPU.</span></span> <span data-ttu-id="b801a-122">本機視訊記憶體提供 GPU 的最佳效能，而某些資源 (例如轉譯目標和深度/樣板緩衝區) 必須位於本機視訊記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b801a-122">Local video memory provides the best performance for the GPU, and certain resources (such as render targets and depth/stencil buffers) must be located in local video memory.</span></span> <span data-ttu-id="b801a-123">隨著 AGP 的出現，GPU 也可以直接存取系統記憶體的一部分。</span><span class="sxs-lookup"><span data-stu-id="b801a-123">With the advent of AGP, the GPU can also access a portion of the system memory directly.</span></span> <span data-ttu-id="b801a-124">這個記憶體區域（稱為「AGP 光圈」）稱為非本機視訊記憶體，不適用於其他用途。</span><span class="sxs-lookup"><span data-stu-id="b801a-124">This memory area, known as the AGP aperture, is referred to as non-local video memory and is not available for other purposes.</span></span> <span data-ttu-id="b801a-125">非本機視訊記憶體可由 CPU 讀取及寫入，這通常沒有對本機視訊記憶體的高效能存取，因此非常適合用來作為共用記憶體資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-125">Non-local video memory can be read from and written to by the CPU, which typically has no high-performance access to local video memory, and is thus ideal for use as a shared memory resource.</span></span> <span data-ttu-id="b801a-126">有關 AGP 記憶體的重要事項是，如同本機視訊記憶體一樣，在裝置遺失的情況下會失效，而且必須還原位於該處的持續性資產。</span><span class="sxs-lookup"><span data-stu-id="b801a-126">A key thing to remember about AGP memory is that it, like local video memory, is invalidated in lost-device situations, and persistent assets located there must be restored.</span></span>

<span data-ttu-id="b801a-127">**圖1。GPU、CPU、視頻 RAM 和系統 RAM 的關聯性**</span><span class="sxs-lookup"><span data-stu-id="b801a-127">**Figure 1. Relationship of the GPU, CPU, video RAM, and system RAM**</span></span>

![gpu、cpu、視頻 ram 和系統 ram 的關聯性](images/managingresources1.gif)

<span data-ttu-id="b801a-129">某些整合式影片解決方案利用 (UMA) 的統一記憶體架構，其中的主要記憶體可由系統的所有元件定址。</span><span class="sxs-lookup"><span data-stu-id="b801a-129">Some integrated video solutions make use of a unified memory architecture (UMA), where main memory is addressable by all components of the systems.</span></span> <span data-ttu-id="b801a-130">Direct3D 支援 UMA，而不需要變更應用程式，而是利用與本機視訊記憶體設定相同的提示。</span><span class="sxs-lookup"><span data-stu-id="b801a-130">Direct3D supports UMA without requiring any change to the application, utilizing the same hints as for local video memory configurations.</span></span> <span data-ttu-id="b801a-131">針對這類系統，資源一律位於系統記憶體中，而且驅動程式會負責確保資源的運作方式，與在更傳統的架構中的運作方式相同，同時利用 UMA 的屬性和硬體實行的任何特定行為。</span><span class="sxs-lookup"><span data-stu-id="b801a-131">For such systems, resources are always located in system memory, and the driver is responsible for ensuring that resources work much like they do in a more traditional architecture while taking advantage of UMA's properties and any specific behavior of the hardware implementation.</span></span>

<span data-ttu-id="b801a-132">**[圖 2]在統一記憶體架構中，GPU 和 CPU 可與系統 RAM 有同等的存取權**</span><span class="sxs-lookup"><span data-stu-id="b801a-132">**Figure 2. GPU and CPU have equal access to system RAM in a unified memory architecture**</span></span>

![在統一記憶體架構中，gpu 和 cpu 可與系統 ram 有同等的存取權](images/managingresources2.gif)

## <a name="managed-resources"></a><span data-ttu-id="b801a-134">Managed 資源</span><span class="sxs-lookup"><span data-stu-id="b801a-134">Managed Resources</span></span>

<span data-ttu-id="b801a-135">大部分的資源應該建立為集區管理中的受控資源 \_ 。</span><span class="sxs-lookup"><span data-stu-id="b801a-135">The majority of your resources should be created as managed resources in POOL\_MANAGED.</span></span> <span data-ttu-id="b801a-136">系統會在系統記憶體中建立所有資源，然後視需要複製到視訊記憶體中。</span><span class="sxs-lookup"><span data-stu-id="b801a-136">All your resources will be created in system memory and then copied as needed into video memory.</span></span> <span data-ttu-id="b801a-137">遺失-裝置的狀況會自動從系統記憶體複本處理。</span><span class="sxs-lookup"><span data-stu-id="b801a-137">Lost-device situations will be handled automatically from the system memory copy.</span></span> <span data-ttu-id="b801a-138">由於並非所有受控資源都需要一次放入視訊記憶體，因此您可以過度認可記憶體，其中資源的較小影片記憶體工作集是在任何指定的框架中轉譯所需的。</span><span class="sxs-lookup"><span data-stu-id="b801a-138">Since not all managed resources are required to fit into video memory all at once, you can over-commit memory where a smaller video memory working set of resources is all that is required to render in any given frame.</span></span> <span data-ttu-id="b801a-139">請注意，這可能是因為大部分的備份存放區系統記憶體會在一段時間內分頁到磁片，所以重設作業可能會變慢，原因是需要將此資料放回來還原遺失的視訊記憶體。</span><span class="sxs-lookup"><span data-stu-id="b801a-139">Note that it is likely that the majority of this backing-store system memory will be paged out to disk over time, which is why the Reset operation can be slow due to the need to page this data back in to restore the lost video memory.</span></span>

<span data-ttu-id="b801a-140">執行時間會保留上次使用資源的時間戳記，而當視訊記憶體配置失敗而無法載入所需的 managed 資源時，它會以 LRU 的方式釋出以這個時間戳記為基礎的資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-140">The runtime keeps a timestamp for the last time a resource is used, and when a video memory allocation fails for loading a needed managed resource, it will release resources based on this timestamp in a LRU fashion.</span></span> <span data-ttu-id="b801a-141">使用 [**SetPriority**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) 的優先順序高於時間戳記，因此較常用的資源應該設定為較高的優先順序值。</span><span class="sxs-lookup"><span data-stu-id="b801a-141">Usage of [**SetPriority**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3dresource9-setpriority) takes precedence over the timestamp, so more commonly used resources should be set to a higher priority value.</span></span> <span data-ttu-id="b801a-142">Direct3D 9.0 的資訊與驅動程式所管理的視訊記憶體有限，因此執行時間可能需要收回數個資源，才能建立夠大的區域，使配置成功。</span><span class="sxs-lookup"><span data-stu-id="b801a-142">Direct3D 9.0 has limited information about the video memory managed by the driver, so the runtime may need to evict several resources to create a large enough region for the allocation to succeed.</span></span> <span data-ttu-id="b801a-143">適當的優先順序有助於消除某些情況下會收回的情況，之後不久就會要求您這樣做。</span><span class="sxs-lookup"><span data-stu-id="b801a-143">Proper priorities can help eliminate situations where something gets evicted and then is required again shortly thereafter.</span></span> <span data-ttu-id="b801a-144">應用程式也可以呼叫 [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) 來強制移除所有的 managed 資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-144">The application can also call [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) to force all the managed resources to be removed.</span></span> <span data-ttu-id="b801a-145">同樣地，這可能是一項耗時的作業，可重載下一個框架所需的所有資源，但對於工作集的變更會大幅增加，以及移除視訊記憶體片段而言非常有用。</span><span class="sxs-lookup"><span data-stu-id="b801a-145">Again, this can be a time-consuming operation to reload all the resources required for the next frame, but is very useful for level transitions where the working set changes significantly and for removing video memory fragmentation.</span></span>

<span data-ttu-id="b801a-146">系統也會保留框架計數，以允許執行時間偵測剛選擇要收回的資源是否已在目前的框架之前使用，這表示在單一框架中使用更多資源的情況下，會有較多資源可放入視訊記憶體的狀況。</span><span class="sxs-lookup"><span data-stu-id="b801a-146">A frame count is also kept to allow the runtime to detect if the resource it just chose to evict was used early the current frame, which implies a thrashing situation where more resources are in use in a single frame than will fit into video memory.</span></span> <span data-ttu-id="b801a-147">這會觸發取代原則切換為 MRU，而不是 LRU 的其餘部分，因為這通常會在這類情況下稍微更好地執行。</span><span class="sxs-lookup"><span data-stu-id="b801a-147">This triggers the replacement policy to switch to a MRU fashion rather than LRU for the remainder of the frame as this tends to perform slightly better under such conditions.</span></span> <span data-ttu-id="b801a-148">這種行為會大幅影響轉譯效能。</span><span class="sxs-lookup"><span data-stu-id="b801a-148">Such thrashing behavior will significantly impact the rendering performance.</span></span> <span data-ttu-id="b801a-149">請注意，目前框架的概念會系結至 [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene)，因此使用 managed 資源的任何應用程式都必須定期呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="b801a-149">Note that the notion of current frame is tied to [**EndScene**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-endscene), so any application making use of managed resources needs to make regular calls to this method.</span></span>

<span data-ttu-id="b801a-150">如果開發人員想要尋找有關如何在其應用程式中進行受控資源的詳細資訊，可以透過 [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) 介面使用 RESOURCEMANAGER 事件查詢。</span><span class="sxs-lookup"><span data-stu-id="b801a-150">Developers looking to find more information about how managed resources are behaving in their application can make use of the RESOURCEMANAGER event query via the [**IDirect3DQuery9**](/windows/desktop/api/d3d9helper/nn-d3d9helper-idirect3dquery9) interface.</span></span> <span data-ttu-id="b801a-151">這僅適用于使用偵錯工具執行時間，因此這項資訊無法由應用程式相依，但可提供執行時間所管理資源的深入詳細資料。</span><span class="sxs-lookup"><span data-stu-id="b801a-151">This only works when using the debug runtimes, so this information cannot be depended upon by the application, but it provides deep detail on the resources managed by the runtime.</span></span>

<span data-ttu-id="b801a-152">雖然瞭解 resource manager 的運作方式有助於微調和偵測應用程式，但請務必不要將您的應用程式緊密地系結到目前執行時間或驅動程式的執行詳細資料。</span><span class="sxs-lookup"><span data-stu-id="b801a-152">While understanding how the resource manager works can help when tuning and debugging your applications, it is important to not tie your application too tightly to the implementation details of the current runtime or drivers.</span></span> <span data-ttu-id="b801a-153">驅動程式或硬體變更的修訂可能會大幅改變行為，而未來版本的 Direct3D 將大幅改善且精密的資源管理。</span><span class="sxs-lookup"><span data-stu-id="b801a-153">Revisions of the driver or changes in hardware can significantly change the behavior, and future versions of Direct3D will have significantly improved and sophisticated resource management.</span></span>

## <a name="driver-managed-resources"></a><span data-ttu-id="b801a-154">Driver-Managed 資源</span><span class="sxs-lookup"><span data-stu-id="b801a-154">Driver-Managed Resources</span></span>

<span data-ttu-id="b801a-155">Direct3D 驅動程式可自由執行驅動程式管理的材質功能（由 D3DCAPS2 CANMANAGERESOURCE 所表示）， \_ 這可讓驅動程式處理資源管理，而不是執行時間。</span><span class="sxs-lookup"><span data-stu-id="b801a-155">Direct3D drivers are free to implement the driver managed textures capability, indicated by D3DCAPS2\_CANMANAGERESOURCE, which allows the driver to handle the resource management instead of the runtime.</span></span> <span data-ttu-id="b801a-156">對於執行這項功能的 (罕見) 驅動程式，驅動程式資源管理員的確切行為可能會有很大的差異，您應洽詢驅動程式廠商，以取得其執行方式的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="b801a-156">For the (rare) driver that implements this feature, the exact behavior of the driver's resource manager can vary widely, and you should contact the driver's vendor for details on how this works for their implementation.</span></span> <span data-ttu-id="b801a-157">或者，您可以在 \_ 建立裝置時指定 D3DCREATE 停用 \_ 驅動程式管理，以確保一律會使用運行 \_ 時間管理員。</span><span class="sxs-lookup"><span data-stu-id="b801a-157">Alternatively, you can ensure that the runtime manager is always used instead by specifying D3DCREATE\_DISABLE\_DRIVER\_MANAGEMENT when creating the device.</span></span>

## <a name="default-resources"></a><span data-ttu-id="b801a-158">預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-158">Default Resources</span></span>

<span data-ttu-id="b801a-159">雖然 managed 資源很簡單、有效率且容易使用，但有時候使用影片記憶體的情況有時候是慣用或甚至是必要的。</span><span class="sxs-lookup"><span data-stu-id="b801a-159">While managed resources are simple, efficient, and easy to use, there are times when using video memory directly is preferred or even required.</span></span> <span data-ttu-id="b801a-160">這類資源會建立在集區 \_ 預設分類中。</span><span class="sxs-lookup"><span data-stu-id="b801a-160">Such resources are created in the POOL\_DEFAULT category.</span></span> <span data-ttu-id="b801a-161">使用這類資源會導致您的應用程式產生額外的複雜性。</span><span class="sxs-lookup"><span data-stu-id="b801a-161">Making use of such resources does cause additional complications for your application.</span></span> <span data-ttu-id="b801a-162">需要程式碼來處理所有集區預設資源的遺失裝置狀況 \_ ，而且在將資料複製到其中時，必須將效能考慮納入考慮。</span><span class="sxs-lookup"><span data-stu-id="b801a-162">Code is required to cope with the lost-device situation for all the POOL\_DEFAULT resources, and performance considerations must be taken into account when copying data into them.</span></span> <span data-ttu-id="b801a-163">若無法指定使用 \_ WRITEONLY 或讓轉譯目標成為可鎖定，也可能會對效能產生嚴重的負面影響。</span><span class="sxs-lookup"><span data-stu-id="b801a-163">Failure to specify USAGE\_WRITEONLY or making a render target lockable can also impose serious performance penalties.</span></span>

<span data-ttu-id="b801a-164"> \_ \_ 除非使用特定的提示旗標，否則在集區預設資源上呼叫鎖定比較可能會導致 GPU 停止運作，而不是使用集區管理的資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-164">Calling **Lock** on a POOL\_DEFAULT resource is more likely to cause the GPU to stall than working with a POOL\_MANAGED resource, unless using certain hint flags.</span></span> <span data-ttu-id="b801a-165">根據資源的位置，傳回的指標可能是暫時系統記憶體緩衝區，也可以是直接指向 AGP 記憶體的指標。</span><span class="sxs-lookup"><span data-stu-id="b801a-165">Depending on the location of the resource, the pointer returned could be to a temporary system memory buffer, or it can be a pointer directly into AGP memory.</span></span> <span data-ttu-id="b801a-166">如果是暫時性系統記憶體緩衝區，則在 **解除鎖定** 呼叫之後，資料必須傳輸至視訊記憶體。</span><span class="sxs-lookup"><span data-stu-id="b801a-166">If it is a temporary system memory buffer, data will need to be transferred to the video memory after the **Unlock** call.</span></span> <span data-ttu-id="b801a-167">如果影片資源不是僅限寫入，則在 **鎖定** 期間必須將資料傳輸到暫存緩衝區。</span><span class="sxs-lookup"><span data-stu-id="b801a-167">If the video resource is not write-only, data will have to be transferred into the temporary buffer during the **Lock**.</span></span> <span data-ttu-id="b801a-168">如果是 AGP 記憶體區域，則會避免使用暫存複本，但所需的快取行為可能會導致效能變慢。</span><span class="sxs-lookup"><span data-stu-id="b801a-168">If it is an AGP memory area, temporary copies are avoided but the cache behavior required can result in slow performance.</span></span>

<span data-ttu-id="b801a-169">請小心將完整的快取行資料寫入至任何 AGP 光圈記憶體的指標，以避免造成寫入合併的負面影響，這會引發讀寫迴圈，而且偏好使用記憶體區域的順序存取。</span><span class="sxs-lookup"><span data-stu-id="b801a-169">Care should be taken to write a full cache line of data into any pointer to AGP aperture memory to avoid the penalty of write-combing, which induces a read-write cycle, and sequential access of the memory area is preferred.</span></span> <span data-ttu-id="b801a-170">如果您的應用程式需要在建立期間隨機存取資料，而且您不想要針對緩衝區使用受控資源，您應該改為使用系統記憶體複本。</span><span class="sxs-lookup"><span data-stu-id="b801a-170">If your application needs to make random access to data during creation, and you do not wish to make use of a managed resource for the buffer, you should work with a system memory copy instead.</span></span> <span data-ttu-id="b801a-171">一旦建立資料之後，您就可以將結果串流至鎖定的資源記憶體，以避免對快取寫入組合作業支付高度的負面影響。</span><span class="sxs-lookup"><span data-stu-id="b801a-171">Once the data has been created, you can then stream the result into the locked resource memory to avoid paying a high penalty for the cache write-combining operation.</span></span>

<span data-ttu-id="b801a-172">您 \_ 可以使用鎖定 NOOVERWRITE 旗標，以有效率的方式為某些資源附加資料，但在理想的情況下，可以避免對相同資源的多個 **鎖定** 和 **解除鎖定** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b801a-172">The LOCK\_NOOVERWRITE flag can be used to append data in an efficient manner for some resources, but ideally, multiple **Lock** and **Unlock** calls to the same resource can be avoided.</span></span> <span data-ttu-id="b801a-173">為了達到最佳效能，請務必適當地使用各種鎖定旗標，如同在填滿鎖定的記憶體時，使用快取的資料存取模式。</span><span class="sxs-lookup"><span data-stu-id="b801a-173">Making proper use of the various lock flags is important to optimal performance, as is using a cache-friendly pattern of data access when filling locked memory.</span></span>

### <a name="using-both-managed-and-default-resources"></a><span data-ttu-id="b801a-174">使用 Managed 和預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-174">Using Both Managed and Default Resources</span></span>

<span data-ttu-id="b801a-175">混合受控和集區 \_ 預設資源的配置，可能會導致視訊記憶體分散，並將執行時間的視訊記憶體視圖與 managed 資源的可用視訊記憶體進行混淆。</span><span class="sxs-lookup"><span data-stu-id="b801a-175">Mixing allocations of managed and POOL\_DEFAULT resources can cause video memory fragmentation and confuse the runtime's view of the video memory available for managed resources.</span></span> <span data-ttu-id="b801a-176">在理想的情況下，您應該先建立所有集區 \_ 預設資源，然後再使用集區 \_ 受控資源，或在配置非受控資源之前先使用 [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b801a-176">Ideally, you should create all POOL\_DEFAULT resources before making use of POOL\_MANAGED resources or make use of the [**EvictManagedResources**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-evictmanagedresources) call before allocating unmanaged resources.</span></span> <span data-ttu-id="b801a-177">請記住，從 \_ 存放在視頻記憶體中的集區預設進行的所有配置，會將記憶體分配給資源管理員無法使用的資源，或任何其他用途。</span><span class="sxs-lookup"><span data-stu-id="b801a-177">Remember that all allocations made from POOL\_DEFAULT that reside in video memory tie up memory for the life that resource that is unavailable for use by the resource manager or for any other purpose.</span></span>

<span data-ttu-id="b801a-178">請注意，與舊版 Direct3D 不同的是，第9版執行時間會自動收回某些受控資源，然後再放棄未受管理的資源配置，以找出記憶體不足的情況，但這可能會建立額外的片段，甚至強制資源進入最接近的位置 (例如，在非本機視訊記憶體) 中有靜態紋理。</span><span class="sxs-lookup"><span data-stu-id="b801a-178">Note that unlike previous versions of Direct3D, the version 9 runtime automatically evicts some managed resources before giving up on a failed unmanaged resource allocation for a lack of video memory, but this can potentially create additional fragmentation and even force a resource into a sub-optimal location (for example, having a static texture in non-local video memory).</span></span> <span data-ttu-id="b801a-179">同樣地，最好在使用任何受控資源之前，事先配置所有必要的非受控資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-179">Again, it is best to allocate all required unmanaged resources up front and before using any managed resources.</span></span>

### <a name="dynamic-default-resources"></a><span data-ttu-id="b801a-180">動態預設資源</span><span class="sxs-lookup"><span data-stu-id="b801a-180">Dynamic Default Resources</span></span>

<span data-ttu-id="b801a-181">以較高頻率產生和更新的資料不需要備份存放區，因為還原裝置時，將會重新建立所有資訊。</span><span class="sxs-lookup"><span data-stu-id="b801a-181">Data that is generated and updated at a high frequency has no need for the backing-store since all the information will be re-created when restoring the device.</span></span> <span data-ttu-id="b801a-182">這類資料通常是以集區預設值建立的最佳方式 \_ ，指定使用 \_ 動態提示，如此一來，驅動程式就可以在放置資源時進行優化決策，以瞭解它會經常更新。</span><span class="sxs-lookup"><span data-stu-id="b801a-182">Such data is typically best created in POOL\_DEFAULT, specifying the USAGE\_DYNAMIC hint, so that the driver can make optimization decisions when placing the resource, knowing that it will be updated often.</span></span> <span data-ttu-id="b801a-183">這通常表示將資源放入非本機的視訊記憶體中，因此，GPU 存取的速度通常會比本機視訊記憶體慢很多。</span><span class="sxs-lookup"><span data-stu-id="b801a-183">This typically means putting the resource into non-local video memory, and thus, it is usually much slower for the GPU to access than local video memory.</span></span> <span data-ttu-id="b801a-184">針對 UMA 架構，驅動程式可能會選擇動態資源的特定位置，以優化 CPU 寫入存取。</span><span class="sxs-lookup"><span data-stu-id="b801a-184">For UMA architectures, the driver might choose a particular placement for dynamic resources to optimize for CPU write access.</span></span>

<span data-ttu-id="b801a-185">這種使用方式一般適用于軟體外觀解決方案，以及填滿頂點/索引緩衝區的 CPU 型物件系統，而鎖定 \_ 捨棄旗標可確保在資源仍在先前框架中使用的情況下，不會建立停止封鎖。</span><span class="sxs-lookup"><span data-stu-id="b801a-185">This usage is typical for software skinning solutions and CPU-based particle systems filling out vertex/index buffers, and the LOCK\_DISCARD flag will ensure that stalls are not created in cases where the resource is still in use from the previous frame.</span></span> <span data-ttu-id="b801a-186">在此情況下，使用受控資源會更新系統記憶體緩衝區，然後將其複製到視訊記憶體，然後在被取代之前，只使用一或兩個框架。</span><span class="sxs-lookup"><span data-stu-id="b801a-186">Using a managed resource in this case would update a system memory buffer, which would then be copied to video memory, and then used for only a frame or two before being replaced.</span></span> <span data-ttu-id="b801a-187">針對具有非本機視頻記憶體的系統，會藉由適當地使用此動態模式來消除額外的複本。</span><span class="sxs-lookup"><span data-stu-id="b801a-187">For systems with non-local video memory, the extra copy is eliminated by proper use of this dynamic pattern.</span></span>

<span data-ttu-id="b801a-188">標準紋理無法鎖定，而且只能透過 [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) 或 [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture)來更新。</span><span class="sxs-lookup"><span data-stu-id="b801a-188">Standard textures cannot be locked, and can only be updated via [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="b801a-189">某些系統支援動態紋理（可以鎖定）並使用鎖定 \_ 捨棄模式，但是在 \_ 使用這類資源之前，必須檢查功能位 (D3DCAPS2 DYNAMICTEXTURES) 。</span><span class="sxs-lookup"><span data-stu-id="b801a-189">Some systems support dynamic textures, which can be locked, and use the LOCK\_DISCARD pattern, but a capabilities bit (D3DCAPS2\_DYNAMICTEXTURES) must be checked before making use of such resources.</span></span> <span data-ttu-id="b801a-190">針對高度動態紋理 (影片或程式) ，您的應用程式可以建立相符的集區 \_ 預設值和集區 \_ SYSTEMMEM 資源，並使用 **UpdateTexture** 處理影片記憶體更新。</span><span class="sxs-lookup"><span data-stu-id="b801a-190">For highly dynamic textures (video or procedural), your application could create matching POOL\_DEFAULT and POOL\_SYSTEMMEM resources and handle video-memory updates by using **UpdateTexture**.</span></span> <span data-ttu-id="b801a-191">針對非常頻繁且部分的更新， **UpdateTexture** 典範可能是較佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="b801a-191">For highly frequent and partial updates, the **UpdateTexture** paradigm is likely the better choice.</span></span>

<span data-ttu-id="b801a-192">如同動態資源一樣有用，設計高度依賴動態提交的系統時請務必小心。</span><span class="sxs-lookup"><span data-stu-id="b801a-192">As useful as dynamic resources can be, be careful when designing systems that rely heavily on dynamic submission.</span></span> <span data-ttu-id="b801a-193">靜態資源應該放入集區 \_ 管理中，以確保本機視訊記憶體的良好使用率，並更有效率地使用有限的匯流排和主要記憶體頻寬。</span><span class="sxs-lookup"><span data-stu-id="b801a-193">Static resources should be placed into POOL\_MANAGED to ensure both good utilization of local video memory, and to make more efficient use of limited bus and main memory bandwidth.</span></span> <span data-ttu-id="b801a-194">對於半靜態的資源，您可能會發現偶爾上傳至本機視訊記憶體的成本，遠低於讓它們變成動態所產生的固定匯流排流量。</span><span class="sxs-lookup"><span data-stu-id="b801a-194">For resources that are semi-static, you may find that the cost of an occasional upload to local video memory is much less than the constant bus traffic generated by making them dynamic.</span></span>

## <a name="system-memory-resources"></a><span data-ttu-id="b801a-195">系統記憶體資源</span><span class="sxs-lookup"><span data-stu-id="b801a-195">System Memory Resources</span></span>

<span data-ttu-id="b801a-196">您也可以在集區 SYSTEMMEM 中建立資源 \_ 。</span><span class="sxs-lookup"><span data-stu-id="b801a-196">Resources can also be created in POOL\_SYSTEMMEM.</span></span> <span data-ttu-id="b801a-197">雖然圖形管線無法使用它們，但它們可以作為來源 \_ 使用 [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) 或 [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture)來更新集區預設資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-197">While they cannot be used by the graphics pipeline, they can be used as sources for updating POOL\_DEFAULT resources by using [**UpdateSurface**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatesurface) or [**UpdateTexture**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture).</span></span> <span data-ttu-id="b801a-198">它們的鎖定行為很簡單，不過如果在先前所述的其中一個方法使用時，可能會發生延遲。</span><span class="sxs-lookup"><span data-stu-id="b801a-198">Their locking behavior is simple, although stalls might occur if they are in use by one of the previously mentioned methods.</span></span>

<span data-ttu-id="b801a-199">雖然它們位於系統記憶體中，但集區 \_ SYSTEMMEM 資源僅限於相同的格式和功能 (例如設備磁碟機所支援的大小上限) 。</span><span class="sxs-lookup"><span data-stu-id="b801a-199">Though they reside in system memory, POOL\_SYSTEMMEM resources are limited to the same formats and capabilities (such as maximum size) supported by the device driver.</span></span> <span data-ttu-id="b801a-200">集區 \_ 臨時資源類型是另一種系統記憶體資源形式，可利用執行時間支援的所有格式和功能，但無法供裝置存取。</span><span class="sxs-lookup"><span data-stu-id="b801a-200">The POOL\_SCRATCH resource type is another form of system memory resource that can utilize all formats and capabilities supported by the runtime, but cannot be accessed by the device.</span></span> <span data-ttu-id="b801a-201">臨時資源主要是供內容工具使用。</span><span class="sxs-lookup"><span data-stu-id="b801a-201">Scratch resources are intended primarily for use by content tools.</span></span>

<span data-ttu-id="b801a-202">**圖3。影片 RAM、AGP 光圈和系統 RAM 中的記憶體資源**</span><span class="sxs-lookup"><span data-stu-id="b801a-202">**Figure 3. Memory resources in video RAM, AGP aperture, and system RAM**</span></span>

![影片 ram、agp 光圈和系統 ram 中的記憶體資源](images/managingresources3.gif)

## <a name="general-recommendations"></a><span data-ttu-id="b801a-204">一般建議</span><span class="sxs-lookup"><span data-stu-id="b801a-204">General Recommendations</span></span>

<span data-ttu-id="b801a-205">取得資源管理的技術實行詳細資料，將會有很長的方法可達到您應用程式的效能目標。</span><span class="sxs-lookup"><span data-stu-id="b801a-205">Getting the technical implementation details of resource management correct will go a long way toward achieving your performance goals for your application.</span></span> <span data-ttu-id="b801a-206">規劃如何將資源呈現給 Direct3D，以及即時載入資料的架構設計，是更複雜的工作。</span><span class="sxs-lookup"><span data-stu-id="b801a-206">Planning how the resources are presented to Direct3D and the architectural design around getting the data loaded in a timely fashion is a more complicated task.</span></span> <span data-ttu-id="b801a-207">針對您的應用程式進行這些決策時，建議使用一些最佳作法：</span><span class="sxs-lookup"><span data-stu-id="b801a-207">We recommend a number of best practices when making these decisions for your application:</span></span>

-   <span data-ttu-id="b801a-208">預先處理您所有的資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-208">Pre-process all your resources.</span></span> <span data-ttu-id="b801a-209">在開發期間，依賴資源的昂貴載入時間轉換和優化很方便，但是這樣做會對使用者的電腦造成絕佳的效能負擔。</span><span class="sxs-lookup"><span data-stu-id="b801a-209">Relying on expensive load-time conversion and optimization for your resources is convenient during development, but doing so puts a great performance burden on your users' computers.</span></span> <span data-ttu-id="b801a-210">預先處理的資源更快載入、使用速度更快，並可讓您選擇執行精密的離線工作。</span><span class="sxs-lookup"><span data-stu-id="b801a-210">Pre-processed resources are faster to load, faster to use, and give you the option of doing sophisticated off-line work.</span></span>
-   <span data-ttu-id="b801a-211">避免為每個框架建立許多資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-211">Avoid creating many resources per frame.</span></span> <span data-ttu-id="b801a-212">所需的驅動程式互動可能會將 CPU 和 GPU 序列化，而相關的作業則會大量重設，因為它們通常需要核心轉換。</span><span class="sxs-lookup"><span data-stu-id="b801a-212">The driver interactions required can serialize the CPU and GPU, and the operations involved are heavy-weight, as they often require kernel transitions.</span></span> <span data-ttu-id="b801a-213">在多個畫面上分散建立，或重複使用資源，而不需建立/釋放資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-213">Spread out creation over several frames or reuse resources without creating/releasing them.</span></span> <span data-ttu-id="b801a-214">在理想的情況下，您應該在鎖定或釋出最近用來呈現的資源之前，先等候數個框架。</span><span class="sxs-lookup"><span data-stu-id="b801a-214">Ideally, you should wait several frames before locking or releasing resources that were recently used to render.</span></span>
-   <span data-ttu-id="b801a-215">在框架的結尾，請務必解除系結所有資源通道 (也就是串流來源、材質階段和目前的索引) 。</span><span class="sxs-lookup"><span data-stu-id="b801a-215">At the end of the frame, be sure to unbind all resource channels (that is, stream sources, texture stages, and current indices).</span></span> <span data-ttu-id="b801a-216">這麼做可確保先移除對資源的無關聯參考，然後才會讓資源管理員保留實際已不再使用的資源。</span><span class="sxs-lookup"><span data-stu-id="b801a-216">Doing so will ensure that dangling references to resources are removed before they cause the resource manager to keep resources resident that are actually no longer in use.</span></span>
-   <span data-ttu-id="b801a-217">針對材質，請使用壓縮格式 (例如，DXTn) 搭配 mip 對應，並考慮使用材質塔。</span><span class="sxs-lookup"><span data-stu-id="b801a-217">For textures, use compressed formats (for example, DXTn) with mip-maps, and consider making use of a texture atlas.</span></span> <span data-ttu-id="b801a-218">這些會大幅減少頻寬需求，而且可以減少資源的整體大小，進而提高其效率。</span><span class="sxs-lookup"><span data-stu-id="b801a-218">These greatly reduce bandwidth requirements, and they can reduce the overall size of the resources, thus making them more efficient.</span></span>
-   <span data-ttu-id="b801a-219">針對幾何，請使用已編制索引的幾何，因為這有助於壓縮頂點緩衝區資源，而新式的影片硬體會大幅優化以重複使用頂點。</span><span class="sxs-lookup"><span data-stu-id="b801a-219">For geometry, make use of indexed geometry as this helps compress vertex buffer resources, and modern video hardware is heavily optimized around reuse of vertices.</span></span> <span data-ttu-id="b801a-220">藉由使用可程式化的頂點著色器，您可以壓縮頂點資訊，並在頂點處理期間將其展開。</span><span class="sxs-lookup"><span data-stu-id="b801a-220">By making use of programmable vertex shaders, you can compress the vertex information and expand it during the vertex processing.</span></span> <span data-ttu-id="b801a-221">同樣地，這有助於減少頻寬需求，並讓頂點緩衝區資源更有效率。</span><span class="sxs-lookup"><span data-stu-id="b801a-221">Again, this helps reduce bandwidth requirements and makes vertex buffer resources more efficient.</span></span>
-   <span data-ttu-id="b801a-222">避免過度優化資源管理。</span><span class="sxs-lookup"><span data-stu-id="b801a-222">Avoid over-optimizing your resource management.</span></span> <span data-ttu-id="b801a-223">如果您的驅動程式、硬體和作業系統的未來修訂太過高，可能會導致相容性問題。</span><span class="sxs-lookup"><span data-stu-id="b801a-223">Future revisions of drivers, hardware, and the operating system can potentially cause compatibility problems if the application is tuned too heavily to a particularly combination.</span></span> <span data-ttu-id="b801a-224">因為大部分的應用程式都是受 CPU 限制，所以昂貴的 CPU 管理通常會造成比它解決更多的效能問題。</span><span class="sxs-lookup"><span data-stu-id="b801a-224">Since most applications are CPU-bound, expensive CPU-based management generally causes more performance issues than it solves.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b801a-225">相關主題</span><span class="sxs-lookup"><span data-stu-id="b801a-225">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b801a-226">管理資源</span><span class="sxs-lookup"><span data-stu-id="b801a-226">Managing Resources</span></span>](/windows/desktop/direct3d9/managing-resources)
</dt> <dt>

[<span data-ttu-id="b801a-227">遺失的裝置</span><span class="sxs-lookup"><span data-stu-id="b801a-227">Lost Devices</span></span>](/windows/desktop/direct3d9/lost-devices)
</dt> <dt>

[<span data-ttu-id="b801a-228">效能優化</span><span class="sxs-lookup"><span data-stu-id="b801a-228">Performance Optimizations</span></span>](/windows/desktop/direct3d9/performance-optimizations)
</dt> <dt>

[<span data-ttu-id="b801a-229">壓縮的材質資源</span><span class="sxs-lookup"><span data-stu-id="b801a-229">Compressed Texture Resources</span></span>](/windows/desktop/direct3d9/compressed-texture-resources)
</dt> <dt>

[<span data-ttu-id="b801a-230">查詢</span><span class="sxs-lookup"><span data-stu-id="b801a-230">Queries</span></span>](/windows/desktop/direct3d9/queries)
</dt> <dt>

[<span data-ttu-id="b801a-231">**D3DUSAGE**</span><span class="sxs-lookup"><span data-stu-id="b801a-231">**D3DUSAGE**</span></span>](/windows/desktop/direct3d9/d3dusage)
</dt> <dt>

[<span data-ttu-id="b801a-232">**D3DPOOL**</span><span class="sxs-lookup"><span data-stu-id="b801a-232">**D3DPOOL**</span></span>](/windows/desktop/direct3d9/d3dpool)
</dt> <dt>

[<span data-ttu-id="b801a-233">D3DCREATE</span><span class="sxs-lookup"><span data-stu-id="b801a-233">D3DCREATE</span></span>](/windows/desktop/direct3d9/d3dcreate)
</dt> </dl>

 

 