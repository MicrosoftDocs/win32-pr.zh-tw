---
title: 遊戲計時與多核心處理器
description: 本文建議更準確、可靠的解決方案，以使用 Windows Api QueryPerformanceCounter 和 QueryPerformanceFrequency 來取得高解析度的 CPU 時間。
ms.assetid: 1512324d-dffa-3681-be3f-f63a3b8f11db
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9c5c511f558b59e94945e63c44db225f34ac2583
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106965658"
---
# <a name="game-timing-and-multicore-processors"></a><span data-ttu-id="f925f-103">遊戲計時與多核心處理器</span><span class="sxs-lookup"><span data-stu-id="f925f-103">Game Timing and Multicore Processors</span></span>

<span data-ttu-id="f925f-104">由於電源管理技術在現今的電腦中變得越來越普遍，所以取得高解析度 CPU 時間的常用方法（RDTSC 指令）可能無法再如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="f925f-104">With power management technologies becoming more commonplace in today's computers, a commonly-used method to obtain high-resolution CPU timings, the RDTSC instruction, may no longer work as expected.</span></span> <span data-ttu-id="f925f-105">本文建議更準確、可靠的解決方案，以使用 Windows Api [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) 和 [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency)來取得高解析度的 CPU 時間。</span><span class="sxs-lookup"><span data-stu-id="f925f-105">This article suggests a more accurate, reliable solution to obtain high-resolution CPU timings by using the Windows APIs [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency).</span></span>

-   [<span data-ttu-id="f925f-106">背景</span><span class="sxs-lookup"><span data-stu-id="f925f-106">Background</span></span>](#background)
-   [<span data-ttu-id="f925f-107">建議</span><span class="sxs-lookup"><span data-stu-id="f925f-107">Recommendations</span></span>](#recommendations)
-   [<span data-ttu-id="f925f-108">應用程式相容性</span><span class="sxs-lookup"><span data-stu-id="f925f-108">Application Compatibility</span></span>](#application-compatibility)

## <a name="background"></a><span data-ttu-id="f925f-109">背景</span><span class="sxs-lookup"><span data-stu-id="f925f-109">Background</span></span>

<span data-ttu-id="f925f-110">自 x86 P5 指令集推出之後，許多遊戲開發人員都已使用讀取時間戳記計數器（RDTSC 指令）來執行高解析度的時機。</span><span class="sxs-lookup"><span data-stu-id="f925f-110">Since the introduction of the x86 P5 instruction set, many game developers have made use of read time stamp counter, the RDTSC instruction, to perform high-resolution timing.</span></span> <span data-ttu-id="f925f-111">Windows 多媒體計時器的精確度足以讓聲音和影片進行處理，但框架時間在數十毫秒或更短的時間內，沒有足夠的解析度來提供差異時間資訊。</span><span class="sxs-lookup"><span data-stu-id="f925f-111">The Windows multimedia timers are precise enough for sound and video processing, but with frame times of a dozen milliseconds or less, they don't have enough resolution to provide delta-time information.</span></span> <span data-ttu-id="f925f-112">許多遊戲仍在啟動時使用多媒體計時器來建立 CPU 的頻率，並使用該頻率值調整 RDTSC 的結果，以取得準確的時間。</span><span class="sxs-lookup"><span data-stu-id="f925f-112">Many games still use a multimedia timer at start-up to establish the frequency of the CPU, and they use that frequency value to scale results from RDTSC to get accurate time.</span></span> <span data-ttu-id="f925f-113">由於 RDTSC 的限制，Windows API 會透過 [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) 和 [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency)的常式公開更正確的方式來存取這項功能。</span><span class="sxs-lookup"><span data-stu-id="f925f-113">Due to the limitations of RDTSC, the Windows API exposes the more correct way to access this functionality through the routines of [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency).</span></span>

<span data-ttu-id="f925f-114">此使用 RDTSC 來因應這些基本問題的時機：</span><span class="sxs-lookup"><span data-stu-id="f925f-114">This use of RDTSC for timing suffers from these fundamental issues:</span></span>

-   <span data-ttu-id="f925f-115">不連續的值。</span><span class="sxs-lookup"><span data-stu-id="f925f-115">Discontinuous values.</span></span> <span data-ttu-id="f925f-116">直接使用 RDTSC 會假設執行緒一律在相同處理器上執行。</span><span class="sxs-lookup"><span data-stu-id="f925f-116">Using RDTSC directly assumes that the thread is always running on the same processor.</span></span> <span data-ttu-id="f925f-117">多處理器和雙核心系統不保證會在核心之間同步處理其迴圈計數器。</span><span class="sxs-lookup"><span data-stu-id="f925f-117">Multiprocessor and dual-core systems do not guarantee synchronization of their cycle counters between cores.</span></span> <span data-ttu-id="f925f-118">相較于在不同時間的閒置和還原各核心的新式電源管理技術，這種技術會產生更多的功能，這會導致核心通常會不同步。</span><span class="sxs-lookup"><span data-stu-id="f925f-118">This is exacerbated when combined with modern power management technologies that idle and restore various cores at different times, which results in the cores typically being out of synchronization.</span></span> <span data-ttu-id="f925f-119">若為應用程式，這通常會導致問題或可能當機，因為執行緒會在處理器之間跳躍，並取得導致大型差異、負面差異或暫停時間的計時值。</span><span class="sxs-lookup"><span data-stu-id="f925f-119">For an application, this generally results in glitches or in potential crashes as the thread jumps between the processors and gets timing values that result in large deltas, negative deltas, or halted timing.</span></span>
-   <span data-ttu-id="f925f-120">專用硬體的可用性。</span><span class="sxs-lookup"><span data-stu-id="f925f-120">Availability of dedicated hardware.</span></span> <span data-ttu-id="f925f-121">RDTSC 會鎖定應用程式要求給處理器迴圈計數器的計時資訊。</span><span class="sxs-lookup"><span data-stu-id="f925f-121">RDTSC locks the timing information that the application requests to the processor's cycle counter.</span></span> <span data-ttu-id="f925f-122">多年來，這是取得高精確度時間資訊的最佳方式，但較新的主機板現在包含專用的計時裝置，可提供高解析度的計時資訊，而不會有 RDTSC 的缺點。</span><span class="sxs-lookup"><span data-stu-id="f925f-122">For many years this was the best way to get high-precision timing information, but newer motherboards are now including dedicated timing devices which provide high-resolution timing information without the drawbacks of RDTSC.</span></span>
-   <span data-ttu-id="f925f-123">CPU 頻率的變化性。</span><span class="sxs-lookup"><span data-stu-id="f925f-123">Variability of the CPU's frequency.</span></span> <span data-ttu-id="f925f-124">前提是，CPU 的頻率通常是在程式的存留期內固定的。</span><span class="sxs-lookup"><span data-stu-id="f925f-124">The assumption is often made that the frequency of the CPU is fixed for the life of the program.</span></span> <span data-ttu-id="f925f-125">不過，有了新式電源管理技術，這是不正確的假設。</span><span class="sxs-lookup"><span data-stu-id="f925f-125">However, with modern power management technologies, this is an incorrect assumption.</span></span> <span data-ttu-id="f925f-126">雖然一開始只能使用膝上型電腦和其他行動裝置，但在許多高階桌上型電腦中，變更 CPU 頻率的技術也是一樣的。使用者通常無法接受停用其功能以維持一致的頻率。</span><span class="sxs-lookup"><span data-stu-id="f925f-126">While initially limited to laptop computers and other mobile devices, technology that changes the frequency of the CPU is in use in many high-end desktop PCs; disabling its function to maintain a consistent frequency is generally not acceptable to users.</span></span>

## <a name="recommendations"></a><span data-ttu-id="f925f-127">建議</span><span class="sxs-lookup"><span data-stu-id="f925f-127">Recommendations</span></span>

<span data-ttu-id="f925f-128">遊戲需要準確的計時資訊，但您也需要以避免使用 RDTSC 相關問題的方式來執行計時程式碼。</span><span class="sxs-lookup"><span data-stu-id="f925f-128">Games need accurate timing information, but you also need to implement timing code in a way that avoids the problems associated with using RDTSC.</span></span> <span data-ttu-id="f925f-129">當您執行高解析度的時間時，請採取下列步驟：</span><span class="sxs-lookup"><span data-stu-id="f925f-129">When you implement high-resolution timing, take the following steps:</span></span>

1.  <span data-ttu-id="f925f-130">使用 [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) 和 [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) ，而不是 RDTSC。</span><span class="sxs-lookup"><span data-stu-id="f925f-130">Use [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) instead of RDTSC.</span></span> <span data-ttu-id="f925f-131">這些 Api 可能會使用 RDTSC，但可能會使用主機板上的計時裝置，或可提供高品質高解析度計時資訊的一些其他系統服務。</span><span class="sxs-lookup"><span data-stu-id="f925f-131">These APIs may make use of RDTSC, but might instead make use of a timing devices on the motherboard or some other system services that provide high-quality high-resolution timing information.</span></span> <span data-ttu-id="f925f-132">雖然 RDTSC 的速度比 **QueryPerformanceCounter** 快許多，因為後者是 api 呼叫，它是一個 api，可在每個框架中呼叫數百次，而不會產生顯著的影響。</span><span class="sxs-lookup"><span data-stu-id="f925f-132">While RDTSC is much faster than **QueryPerformanceCounter**, since the latter is an API call, it is an API that can be called several hundred times per frame without any noticeable impact.</span></span> <span data-ttu-id="f925f-133"> (不過，開發人員應該嘗試讓遊戲盡可能地呼叫 **QueryPerformanceCounter** ，以避免任何效能下降。 ) </span><span class="sxs-lookup"><span data-stu-id="f925f-133">(Nevertheless, developers should attempt to have their games call **QueryPerformanceCounter** as little as possible to avoid any performance penalty.)</span></span>
2.  <span data-ttu-id="f925f-134">計算差異時，應該壓制這些值，以確保時間值中的任何錯誤都不會造成當機或不穩定的時間相關計算。</span><span class="sxs-lookup"><span data-stu-id="f925f-134">When computing deltas, the values should be clamped to ensure that any bugs in the timing values do not cause crashes or unstable time-related computations.</span></span> <span data-ttu-id="f925f-135">此夾具範圍應為 0 (，以防止負面差異值) 為根據您預期的最小畫面播放速率的合理值。</span><span class="sxs-lookup"><span data-stu-id="f925f-135">The clamp range should be from 0 (to prevent negative delta values) to some reasonable value based on your lowest expected framerate.</span></span> <span data-ttu-id="f925f-136">固定在應用程式的任何偵錯工具中可能很有用，但如果在某些未優化的模式下進行效能分析或執行遊戲，請務必記住這點。</span><span class="sxs-lookup"><span data-stu-id="f925f-136">Clamping is likely to be useful in any debugging of your application, but be sure to keep it in mind if doing performance analysis or running the game in some unoptimized mode.</span></span>
3.  <span data-ttu-id="f925f-137">計算單一線程上的所有時間。</span><span class="sxs-lookup"><span data-stu-id="f925f-137">Compute all timing on a single thread.</span></span> <span data-ttu-id="f925f-138">計算多個執行緒（例如，每個與特定處理器相關聯的執行緒）的時間，可大幅降低多核心系統的效能。</span><span class="sxs-lookup"><span data-stu-id="f925f-138">Computation of timing on multiple threads — for example, with each thread associated with a specific processor — greatly reduces performance of multi-core systems.</span></span>
4.  <span data-ttu-id="f925f-139">使用 Windows API [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask)，將單一線程設定為保留在單一處理器上。</span><span class="sxs-lookup"><span data-stu-id="f925f-139">Set that single thread to remain on a single processor by using the Windows API [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask).</span></span> <span data-ttu-id="f925f-140">一般來說，這是主要的遊戲執行緒。</span><span class="sxs-lookup"><span data-stu-id="f925f-140">Typically, this is the main game thread.</span></span> <span data-ttu-id="f925f-141">雖然 [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) 和 [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) 通常會針對多個處理器進行調整，但 BIOS 或驅動程式中的錯誤可能會導致這些常式線上程從一個處理器移至另一個處理器時傳回不同的值。</span><span class="sxs-lookup"><span data-stu-id="f925f-141">While [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) typically adjust for multiple processors, bugs in the BIOS or drivers may result in these routines returning different values as the thread moves from one processor to another.</span></span> <span data-ttu-id="f925f-142">因此，最好將執行緒保持在單處理器上。</span><span class="sxs-lookup"><span data-stu-id="f925f-142">So, it's best to keep the thread on a single processor.</span></span>

    <span data-ttu-id="f925f-143">所有其他執行緒應該都能運作，而不需要收集自己的計時器資料。</span><span class="sxs-lookup"><span data-stu-id="f925f-143">All other threads should operate without gathering their own timer data.</span></span> <span data-ttu-id="f925f-144">我們不建議使用背景工作執行緒來計算時間，因為這會成為同步處理的瓶頸。</span><span class="sxs-lookup"><span data-stu-id="f925f-144">We do not recommend using a worker thread to compute timing, as this will become a synchronization bottleneck.</span></span> <span data-ttu-id="f925f-145">相反地，工作者執行緒應該從主執行緒讀取時間戳記，因為工作者執行緒只會讀取時間戳記，所以不需要使用重要區段。</span><span class="sxs-lookup"><span data-stu-id="f925f-145">Instead, worker threads should read timestamps from the main thread, and because the worker threads only read timestamps, there is no need to use critical sections.</span></span>

5.  <span data-ttu-id="f925f-146">只呼叫 [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) 一次，因為當系統正在執行時，頻率不會變更。</span><span class="sxs-lookup"><span data-stu-id="f925f-146">Call [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) only once, because the frequency will not change while the system is running.</span></span>

## <a name="application-compatibility"></a><span data-ttu-id="f925f-147">應用程式相容性</span><span class="sxs-lookup"><span data-stu-id="f925f-147">Application Compatibility</span></span>

<span data-ttu-id="f925f-148">許多開發人員已經對 RDTSC 的行為進行了許多方面的假設，因此當時間執行時，某些現有的應用程式很有可能會在具有多個處理器或核心的系統上執行時出現問題。</span><span class="sxs-lookup"><span data-stu-id="f925f-148">Many developers have made assumptions about the behavior of RDTSC over many years, so it is quite likely that some existing applications will exhibit problems when run on a system with multiple processors or cores due to the timing implementation.</span></span> <span data-ttu-id="f925f-149">這些問題通常會以瑕疵或緩慢移動的方式來表現。</span><span class="sxs-lookup"><span data-stu-id="f925f-149">These problems will usually manifest as glitching or slow-motion movement.</span></span> <span data-ttu-id="f925f-150">對於不知道電源管理的應用程式並不容易，但有一個現有的填充碼可以強制應用程式一律在多處理器系統中的單一處理器上執行。</span><span class="sxs-lookup"><span data-stu-id="f925f-150">There is no easy remedy for applications that are not aware of power management, but there is an existing shim for forcing an application to always run on a single processor in a multiprocessor system.</span></span>

<span data-ttu-id="f925f-151">若要建立此填充碼，請從 [Windows 應用程式相容性](/archive/blogs/yongrhee/download-application-compatibility-toolkit-act-for-windows-10)下載 Microsoft 應用程式相容性工具組。</span><span class="sxs-lookup"><span data-stu-id="f925f-151">To create this shim, download the Microsoft Application Compatibility Toolkit from [Windows Application Compatibility](/archive/blogs/yongrhee/download-application-compatibility-toolkit-act-for-windows-10).</span></span>

<span data-ttu-id="f925f-152">使用工具組的 [相容性管理員]，建立應用程式的資料庫和相關聯的修正程式。</span><span class="sxs-lookup"><span data-stu-id="f925f-152">Using the Compatibility Administrator, part of the toolkit, create a database of your application and associated fixes.</span></span> <span data-ttu-id="f925f-153">為此資料庫建立新的相容性模式，並選取相容性修正 **SingleProcAffinity** ，以強制應用程式的所有線程都在單一處理器/核心上執行。</span><span class="sxs-lookup"><span data-stu-id="f925f-153">Create a new compatibility mode for this database and select the compatibility fix **SingleProcAffinity** to force all of the threads of the application to run on a single processor/core.</span></span> <span data-ttu-id="f925f-154">藉由使用命令列工具 Fixpack.exe (也是工具組) 的一部分，您可以將此資料庫轉換成可安裝的套件以進行安裝、測試和散發。</span><span class="sxs-lookup"><span data-stu-id="f925f-154">By using the command-line tool Fixpack.exe (also part of the toolkit), you can convert this database into an installable package for installation, testing, and distribution.</span></span>

<span data-ttu-id="f925f-155">如需使用相容性系統管理員的指示，請參閱工具組的檔。</span><span class="sxs-lookup"><span data-stu-id="f925f-155">For instruction on using Compatibility Administrator, see the toolkit's documentation.</span></span> <span data-ttu-id="f925f-156">如需使用 Fixpack.exe 的語法和範例，請參閱其命令列說明。</span><span class="sxs-lookup"><span data-stu-id="f925f-156">For syntax for and examples of using Fixpack.exe, see its command-line help.</span></span>

<span data-ttu-id="f925f-157">如需客戶導向的資訊，請參閱下列來自 Microsoft 說明及支援的知識庫文章：</span><span class="sxs-lookup"><span data-stu-id="f925f-157">For customer-oriented information, see the following knowledge base articles from Microsoft Help and Support:</span></span>

-   <span data-ttu-id="f925f-158">[使用者 QueryPerformanceCounter 函式的程式在 Windows Server 2003 和 WINDOWS XP 中的執行效能可能不佳](https://support.microsoft.com/kb/895980) (文章 895980) </span><span class="sxs-lookup"><span data-stu-id="f925f-158">[Programs that user the QueryPerformanceCounter function may perform poorly in Windows Server 2003 and in Windows XP](https://support.microsoft.com/kb/895980) (article 895980)</span></span>
-   <span data-ttu-id="f925f-159">在[使用雙核心處理器 (文章909944的 WINDOWS XP 電腦上，遊戲效能可能不佳](https://support.microsoft.com/kb/909944)) </span><span class="sxs-lookup"><span data-stu-id="f925f-159">[Game performance may be poor on a Windows XP-based computer that is using a dual-core processor](https://support.microsoft.com/kb/909944) (article 909944)</span></span>

 

 