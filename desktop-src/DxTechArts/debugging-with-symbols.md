---
title: 使用符號進行調試
description: 本文提供如何在偵錯工具中最好使用符號的概要說明。
ms.assetid: 7ce0c9c7-485c-8d72-0353-27fd2e369a7c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ff63e2404a07a2f0ab5adcb156d83dc989b42fd4
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104508016"
---
# <a name="debugging-with-symbols"></a><span data-ttu-id="9ccef-103">使用符號進行調試</span><span class="sxs-lookup"><span data-stu-id="9ccef-103">Debugging with Symbols</span></span>

<span data-ttu-id="9ccef-104">本文提供如何在偵錯工具中最好使用符號的概要說明。</span><span class="sxs-lookup"><span data-stu-id="9ccef-104">This article provides a high level overview of how to best use symbols in your debugging process.</span></span> <span data-ttu-id="9ccef-105">它說明如何使用 Microsoft 符號伺服器，以及如何設定及使用您自己的私用符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-105">It explains how to use the Microsoft symbol server, and also how to set up and use your own private symbol server.</span></span> <span data-ttu-id="9ccef-106">這些最佳作法有助於提高您的效能，以及對問題進行偵錯工具的能力，即使是所有與問題相關的符號和可執行檔都不在您的電腦上也一樣。</span><span class="sxs-lookup"><span data-stu-id="9ccef-106">These best practices can help increase your effectiveness and ability to debug issues, even in cases where all the symbols and executable files that are related to a problem are not located on your computer.</span></span>

-   [<span data-ttu-id="9ccef-107">Symbols</span><span class="sxs-lookup"><span data-stu-id="9ccef-107">Symbols</span></span>](#debugging-with-symbols)
-   [<span data-ttu-id="9ccef-108">使用符號進行調試</span><span class="sxs-lookup"><span data-stu-id="9ccef-108">Using Symbols for Debugging</span></span>](#using-symbols-for-debugging)
-   [<span data-ttu-id="9ccef-109">取得您需要的符號</span><span class="sxs-lookup"><span data-stu-id="9ccef-109">Getting the Symbols You Need</span></span>](#getting-the-symbols-you-need)
    -   [<span data-ttu-id="9ccef-110">檢查相同資料夾中的指定 DLL 或 .exe 檔和 PDB 是否相符</span><span class="sxs-lookup"><span data-stu-id="9ccef-110">Check if a given DLL or .exe file and PDB in the same folder match</span></span>](#check-if-a-given-dll-or-exe-file-and-pdb-in-the-same-folder-match)
    -   [<span data-ttu-id="9ccef-111">檢查一組資料夾中的所有 Dll 和可執行檔是否都有相符的 Pdb</span><span class="sxs-lookup"><span data-stu-id="9ccef-111">Check if all the DLLs and executable files in a set of folders have matching PDBs</span></span>](#check-if-all-the-dlls-and-executable-files-in-a-set-of-folders-have-matching-pdbs)
    -   [<span data-ttu-id="9ccef-112">Symchk 的運作方式</span><span class="sxs-lookup"><span data-stu-id="9ccef-112">How symchk Works</span></span>](#how-symchk-works)
-   [<span data-ttu-id="9ccef-113">符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-113">Symbol Servers</span></span>](#symbol-servers)
-   [<span data-ttu-id="9ccef-114">使用 Microsoft 符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-114">Using the Microsoft Symbol Server</span></span>](#using-the-microsoft-symbol-server)
-   [<span data-ttu-id="9ccef-115">手動取得符號</span><span class="sxs-lookup"><span data-stu-id="9ccef-115">Getting Symbols Manually</span></span>](#getting-symbols-manually)
-   [<span data-ttu-id="9ccef-116">設定符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-116">Setting Up a Symbol Server</span></span>](#setting-up-a-symbol-server)
-   [<span data-ttu-id="9ccef-117">將符號新增至符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-117">Adding Symbols to a Symbol Server</span></span>](#adding-symbols-to-a-symbol-server)
-   [<span data-ttu-id="9ccef-118">最佳作法</span><span class="sxs-lookup"><span data-stu-id="9ccef-118">Best Practices</span></span>](#best-practices)

## <a name="symbols"></a><span data-ttu-id="9ccef-119">符號</span><span class="sxs-lookup"><span data-stu-id="9ccef-119">Symbols</span></span>

<span data-ttu-id="9ccef-120">有許多不同類型的符號可以進行調試。</span><span class="sxs-lookup"><span data-stu-id="9ccef-120">A number of different types of symbols are available for debugging.</span></span> <span data-ttu-id="9ccef-121">它們包括 CodeView 符號、COFF、DBG、SYM、PDB，甚至是從二進位檔案匯出資料表產生的匯出符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-121">They include CodeView symbols, COFF, DBG, SYM, PDB, and even export symbols that are generated from a binary files export table.</span></span> <span data-ttu-id="9ccef-122">本白皮書僅討論 VS.NET 和 PDB 格式的符號，因為它們是最新的慣用格式。</span><span class="sxs-lookup"><span data-stu-id="9ccef-122">This white paper discusses only VS.NET and the PDB format symbols, because they are the most recent, preferred format.</span></span> <span data-ttu-id="9ccef-123">預設會針對使用 Visual Studio 所編譯的專案產生。</span><span class="sxs-lookup"><span data-stu-id="9ccef-123">They are generated by default for projects that are compiled by using Visual Studio.</span></span>

<span data-ttu-id="9ccef-124">產生發行可執行檔的 PDB 檔案不會影響任何優化，也不會大幅改變所產生檔案的大小。</span><span class="sxs-lookup"><span data-stu-id="9ccef-124">Generating PDB files for release executables does not affect any optimizations, or significantly alter the size of the generated files.</span></span> <span data-ttu-id="9ccef-125">一般而言，唯一的差別在於路徑，而 PDB 檔案的檔案名則內嵌在可執行檔中。</span><span class="sxs-lookup"><span data-stu-id="9ccef-125">Typically, the only difference is the path, and the file name of the PDB file is embedded in the executable.</span></span> <span data-ttu-id="9ccef-126">基於這個理由，您應該一律產生 PDB 檔案，即使您不想要使用可執行檔來傳送它們也是一樣。</span><span class="sxs-lookup"><span data-stu-id="9ccef-126">For this reason, you should always produce PDB files, even if you don't want to ship them with the executable.</span></span>

<span data-ttu-id="9ccef-127">如果專案是使用 **/zi** 或 **/zi** 建立的， (產生 pdb 資訊) 編譯器參數，以及 **/debug** (產生 DEBUG 資訊) 連結器參數，則會產生 pdb 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-127">PDB files are generated if a project is built by using the **/Zi** or **/ZI** (Produce PDB Information) compiler switch, together with the **/DEBUG** (Generate Debug Info) linker switch.</span></span> <span data-ttu-id="9ccef-128">編譯器產生的 PDB 檔案會合並並寫入至單一 PDB 檔案，該檔案放在與可執行檔相同的目錄中。</span><span class="sxs-lookup"><span data-stu-id="9ccef-128">The compiler-generated PDB files are combined and written into a single PDB file that is placed in the same directory as the executable.</span></span>

<span data-ttu-id="9ccef-129">根據預設，PDB 檔案包含下列資訊：</span><span class="sxs-lookup"><span data-stu-id="9ccef-129">By default, PDB files contain the following information:</span></span>

-   <span data-ttu-id="9ccef-130">公用符號通常 (所有函式、靜態和全域變數) </span><span class="sxs-lookup"><span data-stu-id="9ccef-130">Public symbols (typically all functions, static and global variables)</span></span>
-   <span data-ttu-id="9ccef-131">物件檔案的清單，負責可執行檔中的程式碼區段</span><span class="sxs-lookup"><span data-stu-id="9ccef-131">A list of object files that are responsible for sections of code in the executable</span></span>
-   <span data-ttu-id="9ccef-132"> (FPO) 的框架指標優化資訊</span><span class="sxs-lookup"><span data-stu-id="9ccef-132">Frame pointer optimization information (FPO)</span></span>
-   <span data-ttu-id="9ccef-133">本機變數和資料結構的名稱和類型資訊</span><span class="sxs-lookup"><span data-stu-id="9ccef-133">Name and type information for local variables and data structures</span></span>
-   <span data-ttu-id="9ccef-134">來源檔案和行號資訊</span><span class="sxs-lookup"><span data-stu-id="9ccef-134">Source file and line number information</span></span>

<span data-ttu-id="9ccef-135">如果您在意使用 PDB 檔案資訊的人員，以協助他們對可執行檔進行反向工程，您也可以使用 **/PDBSTRIPPED： filename** 連結器選項來產生已移除的 PDB 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-135">If you are concerned about people using the PDB file information to help them reverse engineer your executable, you can also generate stripped PDB files, by using the **/PDBSTRIPPED:filename** linker option.</span></span> <span data-ttu-id="9ccef-136">如果您有想要從中去除私用資訊的現有 PDB 檔案，您可以使用稱為 pdbcopy 的工具，這是適用于 Windows 的偵錯工具的一部分。</span><span class="sxs-lookup"><span data-stu-id="9ccef-136">If you have existing PDB files that you would like to strip private information from, you can use a tool called pdbcopy, which is part of the debugging tools for Windows.</span></span>

<span data-ttu-id="9ccef-137">依預設，去除的 PDB 檔案包含下列資訊：</span><span class="sxs-lookup"><span data-stu-id="9ccef-137">By default, stripped PDB files contain the following information:</span></span>

-   <span data-ttu-id="9ccef-138">公用符號 (通常只有非靜態函式和全域變數) </span><span class="sxs-lookup"><span data-stu-id="9ccef-138">Public symbols (typically only non-static functions and global variables)</span></span>
-   <span data-ttu-id="9ccef-139">物件檔案的清單，負責可執行檔中的程式碼區段</span><span class="sxs-lookup"><span data-stu-id="9ccef-139">A list of object files that are responsible for sections of code in the executable</span></span>
-   <span data-ttu-id="9ccef-140"> (FPO) 的框架指標優化資訊</span><span class="sxs-lookup"><span data-stu-id="9ccef-140">Frame pointer optimization information (FPO)</span></span>

<span data-ttu-id="9ccef-141">這是允許可靠的偵錯工具所需的最小資訊。</span><span class="sxs-lookup"><span data-stu-id="9ccef-141">This is the minimum information that is required to allow reliable debugging.</span></span> <span data-ttu-id="9ccef-142">最小資訊也會讓您難以取得原始原始程式碼的任何其他資訊。</span><span class="sxs-lookup"><span data-stu-id="9ccef-142">Minimum information also makes it difficult to obtain any additional information about your original source code.</span></span> <span data-ttu-id="9ccef-143">由於已移除的 PDB 檔案和一般 PDB 檔案都會產生，因此您可以將已移除的版本提供給可能需要有限的調試能力的使用者，但會保留完整的 Pdb 機密。</span><span class="sxs-lookup"><span data-stu-id="9ccef-143">Because both a stripped PDB file and a regular PDB file are generated, you can provide the stripped version to users who may need limited debugging abilities, but keep the full PDBs confidential.</span></span> <span data-ttu-id="9ccef-144">請注意， **/PDBSTRIPPED** 會產生第二個較小的 pdb 檔案，因此當您產生要廣泛散發的組建時，請確定您使用正確的 pdb 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-144">Note that **/PDBSTRIPPED** generates a second, smaller PDB file, so make sure that you use the correct PDB file when you generate builds to distribute broadly.</span></span> <span data-ttu-id="9ccef-145">若是一般的專案，一般的 PDB 可能會有幾 mb 的大小，但已移除的 PDB 版本可能只有數百 kb。</span><span class="sxs-lookup"><span data-stu-id="9ccef-145">For a typical project, a regular PDB may be a few megabytes in size, but a stripped version of the PDB may be only a few hundred kilobytes.</span></span>

## <a name="using-symbols-for-debugging"></a><span data-ttu-id="9ccef-146">使用符號進行調試</span><span class="sxs-lookup"><span data-stu-id="9ccef-146">Using Symbols for Debugging</span></span>

<span data-ttu-id="9ccef-147">當您正在對已損毀的應用程式進行偵錯工具時，偵錯工具會嘗試顯示堆疊上導致損毀的函式。</span><span class="sxs-lookup"><span data-stu-id="9ccef-147">When you are debugging an application that has crashed, the debugger attempts to show you the functions on the stack that led up to the crash.</span></span> <span data-ttu-id="9ccef-148">如果沒有 PDB 檔案，偵錯工具就無法解析函式名稱、其參數，或儲存在堆疊上的任何本機變數。</span><span class="sxs-lookup"><span data-stu-id="9ccef-148">Without a PDB file, the debugger can not resolve the function names, their parameters, or any local variables that are stored on the stack.</span></span> <span data-ttu-id="9ccef-149">如果您要進行32位可執行檔的偵錯工具，在某些情況下，您甚至無法取得可靠的堆疊追蹤，而不需要符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-149">If you debug 32-bit executables, there are situations where you cannot even get reliable stack traces without symbols.</span></span> <span data-ttu-id="9ccef-150">有時可能會查看堆疊上的原始值，並找出哪些值可能會傳回位址，但是這些值可能很容易與函數參考或資料混淆。</span><span class="sxs-lookup"><span data-stu-id="9ccef-150">Sometimes it's possible to look at the raw values on the stack, and work out which values might be return addresses, but these can be easily confused with function references or data.</span></span>

<span data-ttu-id="9ccef-151">如果目前堆疊上的函式是使用省略框架指標進行編譯 (**/oy**) 優化，而且如果符號不存在，偵錯工具就無法可靠地判斷哪一個函式稱為目前的函式。</span><span class="sxs-lookup"><span data-stu-id="9ccef-151">If functions on the current stack were compiled by using the Omit Frame Pointers (**/Oy**) optimization, and if symbols are not present, the debugger cannot reliably determine which function called the current function.</span></span> <span data-ttu-id="9ccef-152">這是因為如果沒有框架指標優化 (的 FPO) 資訊，則偵錯工具不能依賴) 的框架 (指標暫存器來指向先前儲存的框架指標，以及父函式的傳回位址。</span><span class="sxs-lookup"><span data-stu-id="9ccef-152">This is because without the Frame Pointer Optimization (FPO) information that PDBs contain, the debugger cannot rely on the frame pointer register (EBP) to point at the saved previous frame pointer and at the return address of the parent function.</span></span> <span data-ttu-id="9ccef-153">相反地，它會猜測。</span><span class="sxs-lookup"><span data-stu-id="9ccef-153">Instead, it guesses.</span></span> <span data-ttu-id="9ccef-154">有時它會正確地取得它。</span><span class="sxs-lookup"><span data-stu-id="9ccef-154">Sometimes it gets it right.</span></span> <span data-ttu-id="9ccef-155">不過，它通常會導致錯誤，這可能會造成誤導。</span><span class="sxs-lookup"><span data-stu-id="9ccef-155">However, it often gets it wrong, which can be misleading.</span></span> <span data-ttu-id="9ccef-156">如果您看到有關遺漏符號或未載入符號的警告，如下列範例所示，請勿信任該點下的堆疊。</span><span class="sxs-lookup"><span data-stu-id="9ccef-156">If you see a warning about missing symbols, or no symbols loaded, as in the following example, do not trust the stack from that point down.</span></span>

``` syntax
SWPerfTest.exe!TextFunction(... ...)    Line 59    C++
d3dx9d.dll!008829b5()
[Frames below may be incorrect and/or missing, no symbols loaded for d3dx9d.dll]
SWPerfTest.exe!main(int argc=, const char * * argv=)  Line 328 + 0x12 bytes     C++
SWPerfTest.exe!__mainCRTStartup() Line 716 + 0x17 bytes    C
kernel32.dll!@BaseThreadInitThunk@12() + 0x12 bytes
ntdll.dll!__RtlUserThreadStart@8() + 0x27 bytes
```

<span data-ttu-id="9ccef-157">在許多情況下，您可以繼續進行不含符號的偵錯工具，因為問題是在具有正確符號的位置，而您不需要查看呼叫堆疊下的函式。</span><span class="sxs-lookup"><span data-stu-id="9ccef-157">In many cases, it's possible to continue debugging without symbols, because the problem is in a location that has accurate symbols, and you don't need to look at functions further down the call stack.</span></span> <span data-ttu-id="9ccef-158">即使在呼叫堆疊中的程式庫沒有 Pdb 可用，只要它們是使用框架指標進行編譯，偵錯工具就應該能夠正確地在父函式上猜測。</span><span class="sxs-lookup"><span data-stu-id="9ccef-158">Even if a library that is in your call stack doesn't have PDBs available, as long as they were compiled with frame pointers, the debugger should be able to guess correctly at the parent functions.</span></span> <span data-ttu-id="9ccef-159">從 Windows XP Service Pack 2 開始，所有的 Windows DLL 和可執行檔都會以已停用的 FPO 進行編譯，因為它讓偵錯工具更準確。</span><span class="sxs-lookup"><span data-stu-id="9ccef-159">Starting with Windows XP Service Pack 2, all Windows DLL and executable files are compiled with FPO disabled, because it makes debugging more accurate.</span></span> <span data-ttu-id="9ccef-160">停用 FPO 也可讓取樣分析工具在執行時間期間引導堆疊，並對效能造成最大的影響。</span><span class="sxs-lookup"><span data-stu-id="9ccef-160">Disabling FPO also allows sampling profilers to walk the stack during run-time, with minimal performance impact.</span></span> <span data-ttu-id="9ccef-161">在 Windows XP SP2 之前的 Windows 版本上，所有作業系統二進位檔都需要相符的符號檔，其中包含 FPO 資訊，以允許正確的偵錯工具和分析。</span><span class="sxs-lookup"><span data-stu-id="9ccef-161">On versions of Windows before Windows XP SP2, all operating system binaries require matching symbol files that contain FPO information, to allow accurate debugging and profiling.</span></span>

<span data-ttu-id="9ccef-162">如果您要進行64位原生可執行檔的偵錯工具，則不需要符號檔來產生有效的堆疊追蹤，因為 x64 作業系統和編譯器的設計不需要它們。</span><span class="sxs-lookup"><span data-stu-id="9ccef-162">If you debug 64-bit native executables, you do not need symbol files to produce valid stack traces, because x64 operating systems and compilers are designed not to require them.</span></span> <span data-ttu-id="9ccef-163">不過，您仍然需要符號檔來取得函式名稱、呼叫參數和區域變數。</span><span class="sxs-lookup"><span data-stu-id="9ccef-163">However, you still need symbol files to retrieve the function names, call parameters and local variables.</span></span>

<span data-ttu-id="9ccef-164">不過，某些情況下特別難以進行不含符號的調試。</span><span class="sxs-lookup"><span data-stu-id="9ccef-164">However, some cases are particularly difficult to debug without symbols.</span></span> <span data-ttu-id="9ccef-165">例如，如果您要對已建立 PDB 檔案的程式進行程式設計，而且如果您在 DLL 中損毀的函式在您沒有符號的 DLL 中損毀，您將無法查看造成回呼的函式，因為您將無法解碼堆疊。</span><span class="sxs-lookup"><span data-stu-id="9ccef-165">For example, if you debug a program for which you built a PDB file, and if you crash in a callback from a function in a DLL that you don't have symbols for, you will not be able to see which function caused the callback, because you will not be able to decode the stack.</span></span> <span data-ttu-id="9ccef-166">這通常發生在協力廠商程式庫中（如果未提供 Pdb），或在舊版作業系統元件中，如果無法使用 Pdb。</span><span class="sxs-lookup"><span data-stu-id="9ccef-166">This frequently happens in third-party libraries, if PDBs are not provided, or in old operating system components, if PDBs are not available.</span></span> <span data-ttu-id="9ccef-167">回呼通常會在訊息傳遞、列舉、記憶體配置或例外狀況處理期間發生。</span><span class="sxs-lookup"><span data-stu-id="9ccef-167">Callbacks often happen during message passing, enumeration, memory allocation, or exception handling.</span></span> <span data-ttu-id="9ccef-168">在沒有正確堆疊的情況下偵測這些函式可能很令人沮喪。</span><span class="sxs-lookup"><span data-stu-id="9ccef-168">Debugging these functions without an accurate stack can be frustrating.</span></span>

<span data-ttu-id="9ccef-169">若要可靠地偵測在不同電腦上產生的迷你傾印，或在您不擁有的程式碼中損毀的程式碼，請務必能夠存取迷你傾印中所參考之可執行檔的所有符號和二進位檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-169">To reliably debug mini-dumps that are generated on a different computer, or that crashed in code that you do not own, it's important to be able to access all the symbols and binaries for the executables that are referenced in the mini-dump.</span></span> <span data-ttu-id="9ccef-170">如果符號伺服器可以使用符號和二進位檔，則偵錯工具會自動取得這些符號和二進位檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-170">If the symbols and binaries are available from a symbol server, they are automatically obtained by the debugger.</span></span> <span data-ttu-id="9ccef-171">如需迷你傾印的詳細資訊，請參閱「損毀傾印 [分析](/windows/desktop/DxTechArts/crash-dump-analysis) 」技術白皮書。</span><span class="sxs-lookup"><span data-stu-id="9ccef-171">For more information on mini-dumps, see the [Crash Dump Analysis](/windows/desktop/DxTechArts/crash-dump-analysis) white paper.</span></span>

## <a name="getting-the-symbols-you-need"></a><span data-ttu-id="9ccef-172">取得您需要的符號</span><span class="sxs-lookup"><span data-stu-id="9ccef-172">Getting the Symbols You Need</span></span>

<span data-ttu-id="9ccef-173">如果您要建立應用程式，並在自己的電腦上進行偵錯工具，則 Visual Studio 和其他 Microsoft 偵錯工具（例如 WinDbg）通常會設定為僅適用。</span><span class="sxs-lookup"><span data-stu-id="9ccef-173">Visual Studio and other Microsoft debuggers, such as WinDbg, are typically set up to just work if you are building an application and debugging it on your own computer.</span></span> <span data-ttu-id="9ccef-174">如果您需要將可執行檔授與其他人，如果您的電腦上有多個版本的 DLL 或 .exe 檔案，或是想要正確地對使用 Windows 或其他程式庫的應用程式（例如 DirectX）進行偵錯工具，就必須瞭解偵錯工具如何尋找和載入符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-174">If you need to give your executable to someone else, if you have multiple versions of a DLL or an .exe file on your computer, or if you want to accurately debug an application that uses Windows or other libraries, such as DirectX, you need to understand how debuggers find and load symbols.</span></span> <span data-ttu-id="9ccef-175">偵錯工具會使用使用者所指定的符號搜尋路徑（可在 Visual Studio 的選項 \\ 調試 \\ 符號）或 \_ NT \_ 符號 \_ 路徑環境變數中找到。</span><span class="sxs-lookup"><span data-stu-id="9ccef-175">The debugger uses either the symbol search path that is specified by the user—which is found in Options\\Debugging\\Symbols in Visual Studio—or the \_NT\_SYMBOL\_PATH environment variable.</span></span> <span data-ttu-id="9ccef-176">偵錯工具通常會在下列位置搜尋相符的 Pdb：</span><span class="sxs-lookup"><span data-stu-id="9ccef-176">Typically, the debugger searches for matching PDBs in the following locations:</span></span>

-   <span data-ttu-id="9ccef-177">DLL 或可執行檔內部指定的位置</span><span class="sxs-lookup"><span data-stu-id="9ccef-177">The location that is specified inside the DLL or the executable file.</span></span>

    <span data-ttu-id="9ccef-178">如果您已在電腦上建立 DLL 或可執行檔，連結器預設會將相關聯之 PDB 檔案的完整路徑和檔案名放在 DLL 或可執行檔中。</span><span class="sxs-lookup"><span data-stu-id="9ccef-178">If you have built a DLL or an executable file on your computer, by default the linker places the full path and file name of the associated PDB file inside the DLL or the executable file.</span></span> <span data-ttu-id="9ccef-179">當您進行偵錯工具時，偵錯工具會先檢查符號檔是否存在於 DLL 或可執行檔內所指定的位置。</span><span class="sxs-lookup"><span data-stu-id="9ccef-179">When you debug, the debugger first checks to see if the symbol file exists in the location that is specified inside the DLL or the executable file.</span></span> <span data-ttu-id="9ccef-180">這項功能很有説明，因為您的電腦上已編譯的程式碼一定會有符號可用。</span><span class="sxs-lookup"><span data-stu-id="9ccef-180">This is helpful, because you always have symbols available for code that you have compiled on your computer.</span></span>

-   <span data-ttu-id="9ccef-181">Pdb 可能存在於與 DLL 或可執行檔相同的資料夾中。</span><span class="sxs-lookup"><span data-stu-id="9ccef-181">PDBs that may be present in the same folder as the DLL or executable file.</span></span>
-   <span data-ttu-id="9ccef-182">任何本機符號快取資料夾。</span><span class="sxs-lookup"><span data-stu-id="9ccef-182">Any local symbol cache folders.</span></span>
-   <span data-ttu-id="9ccef-183">任何區域網路檔案共用符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-183">Any local network file share symbol servers.</span></span>
-   <span data-ttu-id="9ccef-184">任何網際網路符號伺服器，例如 Microsoft 符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-184">Any Internet symbol servers, such as the Microsoft symbol server.</span></span>

<span data-ttu-id="9ccef-185">為確保您擁有正確的偵錯工具所需的所有 Pdb，請安裝適用于 Windows 的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="9ccef-185">To make sure that you have all the PDBs that you need for accurate debugging, install the debugging tools for Windows.</span></span> <span data-ttu-id="9ccef-186">您可以在 [Windows 的偵錯工具](/windows-hardware/drivers/debugger/)中找到32和64位版本。</span><span class="sxs-lookup"><span data-stu-id="9ccef-186">The 32 and 64 bit versions can be found at [Debugging Tools for Windows](/windows-hardware/drivers/debugger/).</span></span>

<span data-ttu-id="9ccef-187">隨此封裝安裝的公用程式是 symchk.exe。</span><span class="sxs-lookup"><span data-stu-id="9ccef-187">A useful tool that is installed with this package is symchk.exe.</span></span> <span data-ttu-id="9ccef-188">它有助於找出遺漏或不正確的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-188">It can help to identify missing or incorrect symbols.</span></span> <span data-ttu-id="9ccef-189">此工具有大量的可能命令列選項。</span><span class="sxs-lookup"><span data-stu-id="9ccef-189">This tool has a large number of potential command line options.</span></span> <span data-ttu-id="9ccef-190">以下是兩個更實用且常用的兩個。</span><span class="sxs-lookup"><span data-stu-id="9ccef-190">Here are two of the more useful and commonly used ones.</span></span>

### <a name="check-if-a-given-dll-or-exe-file-and-pdb-in-the-same-folder-match"></a><span data-ttu-id="9ccef-191">檢查相同資料夾中的指定 DLL 或 .exe 檔和 PDB 是否相符</span><span class="sxs-lookup"><span data-stu-id="9ccef-191">Check if a given DLL or .exe file and PDB in the same folder match</span></span>

``` syntax
"c:\Program Files\Debugging Tools for Windows\symchk" testing.dll /s

SYMCHK: FAILED files = 0
SYMCHK: PASSED + IGNORED files = 1
```

<span data-ttu-id="9ccef-192">**/S** 選項會指示 **symchk** 只尋找目前資料夾中的符號，而不會尋找任何符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-192">The **/s** option tells **symchk** to look for symbols only in the current folder, and not to look in any symbol servers.</span></span>

### <a name="check-if-all-the-dlls-and-executable-files-in-a-set-of-folders-have-matching-pdbs"></a><span data-ttu-id="9ccef-193">檢查一組資料夾中的所有 Dll 和可執行檔是否都有相符的 Pdb</span><span class="sxs-lookup"><span data-stu-id="9ccef-193">Check if all the DLLs and executable files in a set of folders have matching PDBs</span></span>

``` syntax
"c:\Program Files\Debugging Tools for Windows\symchk" *.* /r
```

<span data-ttu-id="9ccef-194">**/R** 選項會將 **symchk** 設定為以遞迴方式跨越資料夾，以檢查所有可執行檔是否有相符的 pdb。</span><span class="sxs-lookup"><span data-stu-id="9ccef-194">The **/r** option sets **symchk** to recursively traverse through folders, to check that all the executable files have matching PDBs.</span></span> <span data-ttu-id="9ccef-195">如果沒有 **/s** 選項， **symchk** 會使用目前的 \_ NT \_ 符號 \_ 路徑來搜尋任何私用或本機伺服器或 Microsoft 符號伺服器上的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-195">Without the **/s** option, **symchk** uses the current \_NT\_SYMBOL\_PATH to search for symbols on any private or local server, or on the Microsoft symbol servers.</span></span> <span data-ttu-id="9ccef-196">**Symchk** 工具只會搜尋可執行檔的符號 ( .exe、.dll 和類似的) 。</span><span class="sxs-lookup"><span data-stu-id="9ccef-196">The **symchk** tool searches only for symbols for executable files (.exe, .dll, and similar).</span></span> <span data-ttu-id="9ccef-197">您無法使用萬用字元來搜尋無法執行檔的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-197">You cannot use wild cards search for symbols for non-executable files.</span></span>

### <a name="how-symchk-works"></a><span data-ttu-id="9ccef-198">Symchk 的運作方式</span><span class="sxs-lookup"><span data-stu-id="9ccef-198">How symchk Works</span></span>

<span data-ttu-id="9ccef-199">當連結器產生 .dll、可執行檔和 PDB 檔案時，它會在每個檔案中儲存相同的 Guid。</span><span class="sxs-lookup"><span data-stu-id="9ccef-199">When the linker generates .dll, executable, and PDB files, it stores identical GUIDs in each file.</span></span> <span data-ttu-id="9ccef-200">工具會使用 GUID 來判斷指定的 PDB 檔案是否符合 DLL 或可執行檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-200">The GUID is used by tools to determine if a given PDB file matches a DLL or an executable file.</span></span> <span data-ttu-id="9ccef-201">如果您使用資源編輯器或禁止複製編碼方式來改變 DLL 或可執行檔，或藉由變更其版本資訊，則會更新 GUID，而且偵錯工具無法載入 PDB 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-201">If you alter a DLL or an executable file—by using a resource editor or copy protection encoding, or by altering its version information—the GUID is updated and the debugger cannot load the PDB file.</span></span> <span data-ttu-id="9ccef-202">基於這個理由，請務必避免在連結器建立 DLL 或可執行檔之後，加以操作。</span><span class="sxs-lookup"><span data-stu-id="9ccef-202">For this reason, it's very important to avoid manipulating the DLL or executable file after it is created by the linker.</span></span>

<span data-ttu-id="9ccef-203">您也可以使用 VS.NET 隨附的 DUMPBIN 公用程式來顯示所搜尋的符號路徑，並查看是否找到符合指定 DLL 或可執行檔的符號檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-203">You can also use the DUMPBIN utility that comes with VS.NET to show the symbol paths that are searched, and to see if symbol files are found that match a given DLL or executable file.</span></span> <span data-ttu-id="9ccef-204">例如：</span><span class="sxs-lookup"><span data-stu-id="9ccef-204">For example:</span></span>

``` syntax
DUMPBIN /PDBPATH:VERBOSE filename.exe
```

## <a name="symbol-servers"></a><span data-ttu-id="9ccef-205">符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-205">Symbol Servers</span></span>

<span data-ttu-id="9ccef-206">符號伺服器是多個可執行檔和符號檔版本的儲存機制。</span><span class="sxs-lookup"><span data-stu-id="9ccef-206">A symbol server is a repository for multiple versions of executable and symbol files.</span></span> <span data-ttu-id="9ccef-207">它包含符號檔本身或關聯符號檔的指標。</span><span class="sxs-lookup"><span data-stu-id="9ccef-207">It contains either the symbol files themselves, or pointers to the associated symbol files.</span></span> <span data-ttu-id="9ccef-208">偵錯工具瞭解如何使用符號伺服器，並可使用它們來搜尋遺漏或未知的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-208">Debuggers understand how to use symbol servers, and can use them to search for missing or unknown symbols.</span></span>

<span data-ttu-id="9ccef-209">您也可以從 Microsoft 符號伺服器取得 DLL 和可執行檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-209">DLL and executable files are also available from the Microsoft symbol server.</span></span> <span data-ttu-id="9ccef-210">這可讓您針對電腦上可能不存在的作業系統檔案，對損毀和檢查程式碼進行偵測。</span><span class="sxs-lookup"><span data-stu-id="9ccef-210">This makes it possible to debug crashes and examine code for operating system files that may not exist on your machine.</span></span> <span data-ttu-id="9ccef-211">如果偵錯工具遇到在您用來進行偵錯工具的系統上不存在的可執行檔或 DLL，它會自動要求 Microsoft 符號伺服器的符號和二進位檔案複本。</span><span class="sxs-lookup"><span data-stu-id="9ccef-211">If a debugger encounters an executable file or a DLL that does not exist on the system that you are using for debugging, it automatically requests both the symbols and a copy of the binary file from the Microsoft symbol servers.</span></span> <span data-ttu-id="9ccef-212">如果您要將具有許多版本的元件（例如 msvcrt.dll）進行偵錯工具，而且需要檢查程式碼中是否有不存在於電腦上的版本，這會很有説明。</span><span class="sxs-lookup"><span data-stu-id="9ccef-212">This is helpful if you are debugging a component that has many versions—for example, msvcrt.dll—and you need to examine the code for a version that does not exist on your computer.</span></span> <span data-ttu-id="9ccef-213">這也有助於偵測在作業系統上產生的迷你傾印，該作業系統與您用來進行偵錯工具的系統不同。</span><span class="sxs-lookup"><span data-stu-id="9ccef-213">This also helps debug mini-dumps that are generated on an operating system that is different from the system that you are using for debugging.</span></span>

<span data-ttu-id="9ccef-214">Microsoft 會在其外部可存取的符號伺服器上，發佈所有作業系統和其他轉散發元件（例如 DirectX SDK）的所有 PDB 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-214">Microsoft publishes all the PDB files for all operating systems and other redistributed components, such as the DirectX SDK, on its externally accessible symbol server.</span></span> <span data-ttu-id="9ccef-215">這可讓您輕鬆地對使用這些 DLL 或可執行檔的應用程式進行 debug 錯。</span><span class="sxs-lookup"><span data-stu-id="9ccef-215">This makes it easy to debug an application that uses these DLL or executable files.</span></span> <span data-ttu-id="9ccef-216">您可以使用 Microsoft 符號伺服器來解析符號，以及電腦上建立之元件的任何本機符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-216">You can use the Microsoft symbol server to resolve symbols, together with any local symbols for components that were built on your computer.</span></span>

<span data-ttu-id="9ccef-217">您可以設定您的電腦使用 Microsoft 符號伺服器，讓您能夠存取所有的 Microsoft 符號檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-217">You can set up your computer to use the Microsoft symbol server, which gives you access to all Microsoft symbol files.</span></span> <span data-ttu-id="9ccef-218">您也可以設定公司、小組或網路的私人符號伺服器，以用來儲存多個您正在處理之專案的舊版本，或為您從 Microsoft 符號伺服器使用的符號提供本機快取。</span><span class="sxs-lookup"><span data-stu-id="9ccef-218">You can also set up a private symbol server for your company, team or network, which can be used to store multiple older versions of a project you are working on, or to provide a local cache for the symbols that you use from the Microsoft symbol server.</span></span>

<span data-ttu-id="9ccef-219">若要使用符號伺服器，請在名為 \_ NT 符號路徑的環境變數中指定搜尋路徑 \_ \_ 。</span><span class="sxs-lookup"><span data-stu-id="9ccef-219">To use a symbol server, specify the search path in an environment variable that is called \_NT\_SYMBOL\_PATH.</span></span> <span data-ttu-id="9ccef-220">偵錯工具和新式工具（例如 WinDbg、NTSD 或 Visual Studio）會自動使用此路徑來搜尋符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-220">Debuggers and modern tools, such as WinDbg, NTSD or Visual Studio, automatically use this path to search for symbols.</span></span>

<span data-ttu-id="9ccef-221">當偵錯工具搜尋符號時，它會先在本機搜尋。</span><span class="sxs-lookup"><span data-stu-id="9ccef-221">When a debugger searches for symbols, it first searches locally.</span></span> <span data-ttu-id="9ccef-222">然後，它會查看符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-222">Then it looks on symbol servers.</span></span> <span data-ttu-id="9ccef-223">當它找到相符的符號時，會將符號檔傳送至您的本機快取。</span><span class="sxs-lookup"><span data-stu-id="9ccef-223">When it finds a matching symbol, it transfers the symbol file to your local cache.</span></span> <span data-ttu-id="9ccef-224">一般 DLL 或可執行檔的符號範圍是從1到 100 MB 的大小。</span><span class="sxs-lookup"><span data-stu-id="9ccef-224">The symbols for a typical DLL or executable file range from 1 to 100 MB in size.</span></span> <span data-ttu-id="9ccef-225">因此，如果您要對包含許多 Dll 的處理常式進行偵錯工具，可能需要花一些時間來解析所有的符號，並將它們傳送到本機快取。</span><span class="sxs-lookup"><span data-stu-id="9ccef-225">Therefore, if you are debugging a process that includes many DLLs, it can take some time to resolve all the symbols and transfer them to a local cache.</span></span>

## <a name="using-the-microsoft-symbol-server"></a><span data-ttu-id="9ccef-226">使用 Microsoft 符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-226">Using the Microsoft Symbol Server</span></span>

<span data-ttu-id="9ccef-227">Microsoft 符號伺服器可讓您取得所有最新的符號，包括已修補或更新檔案的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-227">The Microsoft symbol server allows you to obtain all the latest symbols, including symbols for patched or updated files.</span></span> <span data-ttu-id="9ccef-228">Microsoft 符號伺服器可從取得 <https://msdl.microsoft.com/download/symbols> 。</span><span class="sxs-lookup"><span data-stu-id="9ccef-228">The Microsoft symbol server is available at <https://msdl.microsoft.com/download/symbols>.</span></span>

<span data-ttu-id="9ccef-229">您可以使用下列其中一種方式來存取符號伺服器：</span><span class="sxs-lookup"><span data-stu-id="9ccef-229">You can access the symbol server in one of the following ways:</span></span>

-   <span data-ttu-id="9ccef-230">直接輸入伺服器位址。</span><span class="sxs-lookup"><span data-stu-id="9ccef-230">Enter the server address directly.</span></span> <span data-ttu-id="9ccef-231">在 Visual Studio 中，從 [ **工具** ] 功能表選擇 [ **選項**]，然後選擇 [ **調試**]，然後選擇 [ **符號**]。</span><span class="sxs-lookup"><span data-stu-id="9ccef-231">In Visual Studio, from the **Tools** menu, choose **Options**, then choose **Debugging**, and then choose **Symbols**.</span></span>
-   <span data-ttu-id="9ccef-232">使用環境變數 \_ NT \_ 符號 \_ 路徑。</span><span class="sxs-lookup"><span data-stu-id="9ccef-232">Use the environment variable \_NT\_SYMBOL\_PATH.</span></span> <span data-ttu-id="9ccef-233">建議採用此方法。</span><span class="sxs-lookup"><span data-stu-id="9ccef-233">We recommend this method.</span></span>

    <span data-ttu-id="9ccef-234">所有偵錯工具都使用此功能。</span><span class="sxs-lookup"><span data-stu-id="9ccef-234">This is used by all debugging tools.</span></span> <span data-ttu-id="9ccef-235">Visual Studio 也會使用它，並在 Visual Studio 開啟時進行讀取和解碼。</span><span class="sxs-lookup"><span data-stu-id="9ccef-235">It is also used by Visual Studio, and is read and decoded when Visual Studio opens.</span></span> <span data-ttu-id="9ccef-236">因此，如果您變更它，就必須重新開機 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="9ccef-236">Therefore, if you change it, you need to restart Visual Studio.</span></span>

    <span data-ttu-id="9ccef-237">此環境變數可讓您指定多個符號伺服器，例如內部私用符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-237">This environment variable allows you to specify multiple symbol servers—for example, an internal private symbol server.</span></span> <span data-ttu-id="9ccef-238">它也可讓您指定本機快取目錄，以針對您從符號伺服器（不論是在內部或透過網際網路）查閱的所有符號儲存 Pdb。</span><span class="sxs-lookup"><span data-stu-id="9ccef-238">It also allows you to specify a local cache directory to store PDBs for all symbols that you look up from symbol servers, both internally and over the Internet.</span></span>

<span data-ttu-id="9ccef-239">\_NT \_ 符號路徑變數的語法 \_ 為：</span><span class="sxs-lookup"><span data-stu-id="9ccef-239">The syntax for the \_NT\_SYMBOL\_PATH variable is:</span></span>

``` syntax
srv*[local cache]*[private symbol server]*https://msdl.microsoft.com/download/symbols
```

<span data-ttu-id="9ccef-240">將本機快取取代 \[ \] 為您電腦上您想要儲存任何使用的符號快取的目錄名稱，例如% SYSTEMROOT% \\ 符號或 c： \\ 符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-240">Replace \[local cache\] with the name of a directory on your computer where you want to store a cache of any symbols used—for example, %SYSTEMROOT%\\Symbols, or c:\\symbols.</span></span>

<span data-ttu-id="9ccef-241">\[私用符號伺服器 \] 是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="9ccef-241">The \[private symbol server\] is optional.</span></span> <span data-ttu-id="9ccef-242">它可以指向位於您網路上的符號伺服器，也可以指向您的小組、產品群組或公司所共用的符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-242">It can point to a symbol server that is located on your network, or it can point to a symbol server that is shared by your team, product group, or company.</span></span>

<span data-ttu-id="9ccef-243">若只要使用 Microsoft 符號伺服器搭配符號的本機快取，以加快透過網際網路的存取，請使用下列 \_ NT \_ 符號 \_ 路徑設定：</span><span class="sxs-lookup"><span data-stu-id="9ccef-243">To use only the Microsoft symbol server together with a local cache of symbols, to speed up access over the Internet, use the following setting for \_NT\_SYMBOL\_PATH:</span></span>

``` syntax
srv*c:\symbols*https://msdl.microsoft.com/download/symbols
```

<span data-ttu-id="9ccef-244">您可以 \_ \_ \_ 在與 Microsoft 偵錯工具 for Windows 套件一起安裝的說明檔中，找到 NT 符號路徑的其他選項。</span><span class="sxs-lookup"><span data-stu-id="9ccef-244">You can find other options for the \_NT\_SYMBOL\_PATH in the help file that is installed with the Microsoft Debugging Tools for Windows package.</span></span>

<span data-ttu-id="9ccef-245">如果您使用符號伺服器，沒有符號的可執行檔可能會增加啟動偵錯工具所需的時間。</span><span class="sxs-lookup"><span data-stu-id="9ccef-245">Executables without symbols can increase the time it takes to launch a debugger if you use a symbol server.</span></span> <span data-ttu-id="9ccef-246">這是因為偵錯工具會在每次嘗試載入可執行檔時查詢符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-246">This is because the debugger queries the symbol server each time it tries to load the executable.</span></span> <span data-ttu-id="9ccef-247">基於這個理由，最好一律要求所有元件的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-247">For this reason, it is best to always request symbols for all components.</span></span>

<span data-ttu-id="9ccef-248">可能無法要求每個元件的符號，例如，視頻驅動程式可能在您的進程空間中有 Dll，而且 Microsoft 符號伺服器上有必要的 PDB 檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-248">It may not be possible to request symbols for every component—for example, video drivers may have DLLs in your process space, and the required PDB files are available on the Microsoft symbol server.</span></span> <span data-ttu-id="9ccef-249">在此情況下，當您啟動偵錯工具時，會有短暫的延遲。</span><span class="sxs-lookup"><span data-stu-id="9ccef-249">In this case, there is a small delay when you start a debugging session.</span></span>

<span data-ttu-id="9ccef-250">若要避免這種短暫的延遲，您可以執行偵錯工具一次，以從 Microsoft 符號伺服器在本機快取所有符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-250">To avoid even this small delay, you can run the debugger once, to cache all the symbols locally from the Microsoft symbol server.</span></span> <span data-ttu-id="9ccef-251">然後，修改您 \_ \_ 的 NT 符號 \_ 路徑以移除 Microsoft 符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-251">Then, modify your \_NT\_SYMBOL\_PATH to remove the Microsoft symbol server.</span></span> <span data-ttu-id="9ccef-252">除非可執行檔變更，否則檢查沒有符號的可執行檔將不需要透過網際網路進行查詢，因為您有 Microsoft 符號伺服器所需之所有符號的本機快取複本。</span><span class="sxs-lookup"><span data-stu-id="9ccef-252">Unless the executable files change, checks for executable files that do not have symbols will not require a query over the Internet, because you have local cached copies of all the symbols that you need from the Microsoft symbol server.</span></span>

## <a name="getting-symbols-manually"></a><span data-ttu-id="9ccef-253">手動取得符號</span><span class="sxs-lookup"><span data-stu-id="9ccef-253">Getting Symbols Manually</span></span>

<span data-ttu-id="9ccef-254">如果您已正確設定偵錯工具，它會自動從您的本機快取或從符號伺服器載入所需的任何符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-254">If you have set up your debugger correctly, it automatically loads any symbols that it requires from your local cache or from a symbol server.</span></span> <span data-ttu-id="9ccef-255">如果您想要只取得單一可執行檔或可執行檔的資料夾的符號，您可以使用 **symchk**。</span><span class="sxs-lookup"><span data-stu-id="9ccef-255">If you would like to get the symbols for just a single executable, or for a folder of executables, you can use **symchk**.</span></span> <span data-ttu-id="9ccef-256">例如，如果您想要將 \_ Windows 系統資料夾中 d3dx930.dll 檔的符號下載到目前的目錄中，您可以使用下列命令：</span><span class="sxs-lookup"><span data-stu-id="9ccef-256">For example, if you want to download the symbols for the d3dx9\_30.dll file in the Windows System folder into the current directory, you can use the following command:</span></span>

``` syntax
"c:\Program Files\Debugging Tools for Windows\symchk" c:\Windows\System32\d3dx9_30.dll /oc \.
```

<span data-ttu-id="9ccef-257">**Symchk** 工具有許多其他用途。</span><span class="sxs-lookup"><span data-stu-id="9ccef-257">The **symchk** tool has many other uses.</span></span> <span data-ttu-id="9ccef-258">如需詳細資訊，請參閱 **symchk/？** 或查看 Microsoft 的 Windows 偵錯工具檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-258">For details, see **symchk /?**, or look in the Microsoft Debugging Tools for Windows documentation.</span></span>

## <a name="setting-up-a-symbol-server"></a><span data-ttu-id="9ccef-259">設定符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-259">Setting Up a Symbol Server</span></span>

<span data-ttu-id="9ccef-260">設定符號伺服器非常簡單。</span><span class="sxs-lookup"><span data-stu-id="9ccef-260">Setting up a symbol server is very simple.</span></span> <span data-ttu-id="9ccef-261">這項功能很有用，原因如下：</span><span class="sxs-lookup"><span data-stu-id="9ccef-261">It is useful for the following reasons:</span></span>

-   <span data-ttu-id="9ccef-262">以節省頻寬，或加速公司、小組或產品的符號解析。</span><span class="sxs-lookup"><span data-stu-id="9ccef-262">To save bandwidth, or to speed up symbol resolution for your company, team or product.</span></span> <span data-ttu-id="9ccef-263">您網路上本機檔案共用上的內部符號伺服器會快取外部符號伺服器的任何參考，例如 Microsoft 符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-263">An internal symbol server on a local file share on your network caches any references to external symbol servers, such as the Microsoft symbol server.</span></span> <span data-ttu-id="9ccef-264">許多人都可以快速存取本機或內部符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-264">A local or internal symbol server can be accessed quickly by many people at the same time.</span></span> <span data-ttu-id="9ccef-265">因此，它可節省頻寬，以及重複符號要求可以建立的延遲。</span><span class="sxs-lookup"><span data-stu-id="9ccef-265">Therefore, it saves bandwidth and the latency that duplicate symbol requests can create.</span></span>
-   <span data-ttu-id="9ccef-266">儲存舊版組建、版本或應用程式外部版本的符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-266">To store symbols for old builds, versions or external releases of your application.</span></span> <span data-ttu-id="9ccef-267">藉由將這些組建的符號儲存在您可以輕鬆存取的符號伺服器上，您可以在任何具有偵錯工具的電腦和本機符號伺服器的連接上，對這些組建中的當機和問題進行偵測。</span><span class="sxs-lookup"><span data-stu-id="9ccef-267">By storing the symbols for these builds on a symbol server that you can easily access, you can debug crashes and problems in these builds on any computer that has a debugger and a connection to the local symbol server.</span></span> <span data-ttu-id="9ccef-268">如果您要針對您未自行建立的可執行檔（也就是由另一位程式設計人員或組建電腦所產生的組建）來進行您的可執行檔所產生的偵測，則這特別有用。</span><span class="sxs-lookup"><span data-stu-id="9ccef-268">This is particularly useful if you debug mini-dumps that are generated by executables that you did not build yourself—that is, builds that were generated by another programmer or by a build machine.</span></span> <span data-ttu-id="9ccef-269">如果這些組建的符號儲存在符號伺服器上，您將會有可靠且正確的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="9ccef-269">If the symbols for these builds are stored on your symbol server, you will have reliable and accurate debugging.</span></span>
-   <span data-ttu-id="9ccef-270">將符號保持在最新狀態。</span><span class="sxs-lookup"><span data-stu-id="9ccef-270">To keep symbols up to date.</span></span> <span data-ttu-id="9ccef-271">更新元件時（例如 Windows Update 或 DirectX SDK 修改的 OS 元件），您仍然可以使用所有最新的符號來進行 debug。</span><span class="sxs-lookup"><span data-stu-id="9ccef-271">When components are updated, such as OS components that are modified by Windows Update or by the DirectX SDK, you can still debug by using all the latest symbols.</span></span>

<span data-ttu-id="9ccef-272">在您自己的區域網路上設定符號伺服器，就像是在伺服器上建立檔案共用，並授與使用者存取共用的完整許可權來建立檔案和資料夾一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="9ccef-272">Setting up a symbol server on your own local network is as simple as creating a file share on a server and giving users full permissions to access the share, to create files and folders.</span></span> <span data-ttu-id="9ccef-273">此共用應建立在伺服器作業系統（例如 Windows Server 2003）上，如此一來，就能同時存取共用的人數不受限制。</span><span class="sxs-lookup"><span data-stu-id="9ccef-273">This share should be created on a server operating system, such as Windows Server 2003, so that the number of people who can access the share simultaneously is not limited.</span></span>

<span data-ttu-id="9ccef-274">例如，如果您在 mainserver 符號上設定檔案共用 \\ \\ \\ ，則小組的成員會將 \_ NT \_ 符號 \_ 路徑設定為下列專案：</span><span class="sxs-lookup"><span data-stu-id="9ccef-274">For example, if you set up a file share on \\\\mainserver\\symbols, then the members of your team set the \_NT\_SYMBOL\_PATH to the following:</span></span>

``` syntax
Srv*c:\symbols*\\mainserver\symbols*https://msdl.microsoft.com/download/symbols
```

<span data-ttu-id="9ccef-275">在抓取符號的情況下，檔案和資料夾會出現在 \\ \\ mainserver \\ 符號共用目錄，以及個別快取的 c： \\ 符號目錄中。</span><span class="sxs-lookup"><span data-stu-id="9ccef-275">As symbols are retrieved, files and folders appear in the \\\\mainserver\\symbols shared directory, as well as in individual caches, in the c:\\symbols directory.</span></span>

<span data-ttu-id="9ccef-276">這通常牽涉到設定和使用您自己的符號伺服器或 Microsoft 符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-276">This is typically all that is involved in setting up and using either your own symbol server, or the Microsoft symbol server.</span></span>

## <a name="adding-symbols-to-a-symbol-server"></a><span data-ttu-id="9ccef-277">將符號新增至符號伺服器</span><span class="sxs-lookup"><span data-stu-id="9ccef-277">Adding Symbols to a Symbol Server</span></span>

<span data-ttu-id="9ccef-278">若要在符號伺服器共用上新增、刪除或編輯檔案，請使用 symstore.exe 工具。</span><span class="sxs-lookup"><span data-stu-id="9ccef-278">To add, delete or edit files on a symbol server share, use the symstore.exe tool.</span></span> <span data-ttu-id="9ccef-279">這項工具是 Microsoft 的 Windows 偵錯工具封裝的一部分。</span><span class="sxs-lookup"><span data-stu-id="9ccef-279">This tool is part of the Microsoft Debugging Tools for Windows package.</span></span> <span data-ttu-id="9ccef-280">適用于 Windows 的偵錯工具套件中包含符號伺服器、symstore 工具和索引符號的完整檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-280">Full documentation on symbol servers, the symstore tool, and indexing symbols is included in the Debugging Tools for Windows package.</span></span>

<span data-ttu-id="9ccef-281">您可能會想要將符號直接新增到您自己的符號伺服器，做為組建程式的一部分，或讓您的協力廠商程式庫或工具的整個小組都能使用符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-281">You may want to add symbols directly to your own symbol server, as part of a build process, or to make symbols available to your whole team for third-party libraries or tools.</span></span> <span data-ttu-id="9ccef-282">將符號新增至符號伺服器檔案共用的程式稱為「索引符號」。</span><span class="sxs-lookup"><span data-stu-id="9ccef-282">The process of adding a symbol to a symbol server file share is called indexing symbols.</span></span> <span data-ttu-id="9ccef-283">有兩種常見的方式可編制符號的索引。</span><span class="sxs-lookup"><span data-stu-id="9ccef-283">There are two common ways to index symbols.</span></span> <span data-ttu-id="9ccef-284">您可以將符號檔複製到符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-284">A symbol file can be copied to the symbol server.</span></span> <span data-ttu-id="9ccef-285">或者，您可以將符號位置的指標複製到符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-285">Or, a pointer to the location of the symbol can be copied to the symbol server.</span></span> <span data-ttu-id="9ccef-286">如果您有包含舊組建的封存資料夾，您可能會想要為已經存在於共用上的 PDB 檔案建立指標的索引，而不是複製符號。</span><span class="sxs-lookup"><span data-stu-id="9ccef-286">If you have an archive folder that contains your old builds, you may want to index pointers to the PDB files that are already on the share, instead of duplicating symbols.</span></span> <span data-ttu-id="9ccef-287">由於符號的大小有時可能是數十 mb，因此最好事先規劃在整個開發過程中，您可能需要多少空間來保存專案的所有組建。</span><span class="sxs-lookup"><span data-stu-id="9ccef-287">Because symbols can sometimes be tens of megabytes in size, it's a good idea to plan ahead for how much space you may require to archive all the builds of your project throughout development.</span></span> <span data-ttu-id="9ccef-288">如果您只針對符號的指標編制索引，您可能會在移除舊組建時遇到問題，或變更檔案共用的名稱。</span><span class="sxs-lookup"><span data-stu-id="9ccef-288">If you index only pointers to symbols, you may have problems if you remove old builds, or change the name of a file share.</span></span>

<span data-ttu-id="9ccef-289">例如，若要以遞迴方式為 c： dxsym 中的所有符號進行索引 \\ \\ \\ ，您從2006年10月的 DirectX SDK 取得的額外符號，到名為 mainserver 符號的符號伺服器檔案共用 \\ \\ \\ ，您可以使用下列命令：</span><span class="sxs-lookup"><span data-stu-id="9ccef-289">For example, to index recursively all the symbols in c:\\dxsym\\Extras\\Symbols that you obtained from the October 2006 DirectX SDK onto a symbol server file share called \\\\mainserver\\symbols, you can use the following command:</span></span>

``` syntax
"c:\Program Files\Debugging Tools for Windows\symstore" add /f "C:\dxsym\Extras\Symbols\*.pdb"
/s \\mainserver\symbols /t "October 2006 DirectX SDK " /r
```

<span data-ttu-id="9ccef-290">**/T "comment"** 參數用來將描述加入至新增符號的交易。</span><span class="sxs-lookup"><span data-stu-id="9ccef-290">The **/t "comment"** parameter is used to add a description to the transaction that added the symbols.</span></span> <span data-ttu-id="9ccef-291">在對符號執行系統管理工作時，這會很有用。</span><span class="sxs-lookup"><span data-stu-id="9ccef-291">This can be useful when performing administrative tasks on the symbols.</span></span>

## <a name="best-practices"></a><span data-ttu-id="9ccef-292">最佳做法</span><span class="sxs-lookup"><span data-stu-id="9ccef-292">Best Practices</span></span>

-   <span data-ttu-id="9ccef-293">為您的小組、公司或產品設定您自己的符號伺服器檔案共用。</span><span class="sxs-lookup"><span data-stu-id="9ccef-293">Set up your own symbol server file share for your team, company, or product.</span></span>
-   <span data-ttu-id="9ccef-294">設定 \_ NT \_ 符號 \_ 路徑以指向本機快取、私用符號伺服器，以及 Microsoft 符號伺服器。</span><span class="sxs-lookup"><span data-stu-id="9ccef-294">Set up \_NT\_SYMBOL\_PATH to point to a local cache, to a private symbol server, and to the Microsoft symbol server.</span></span>
-   <span data-ttu-id="9ccef-295">如果偵錯工具無法載入您要進行偵錯工具的符號，請聯繫元件的擁有者以要求符號，至少有一個已移除的 PDB。</span><span class="sxs-lookup"><span data-stu-id="9ccef-295">If a debugger cannot load symbols for a component you are debugging, contact the owner of the component to request symbols—at least a stripped PDB.</span></span>
-   <span data-ttu-id="9ccef-296">設定自動化的組建系統，在私用符號伺服器上為每個產生的組建編制符號索引。</span><span class="sxs-lookup"><span data-stu-id="9ccef-296">Set up an automated build system to index symbols on your private symbol server for each build that is produced.</span></span> <span data-ttu-id="9ccef-297">確定您所散發的組建是由這個進程產生的組建。</span><span class="sxs-lookup"><span data-stu-id="9ccef-297">Make sure that the builds that you distribute are the builds that are generated by this process.</span></span> <span data-ttu-id="9ccef-298">這可確保這些符號永遠可用於偵測問題。</span><span class="sxs-lookup"><span data-stu-id="9ccef-298">This ensures that symbols are always available to debug problems.</span></span>
-   <span data-ttu-id="9ccef-299">設定符號伺服器，以允許偵錯工具直接從以視覺效果來源安全或 Perforce 為基礎的原始檔控制系統，存取特定模組的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="9ccef-299">Set up a symbol server to allow debuggers to access the source code for a specific module directly from a Visual Source Safe or Perforce based source control system.</span></span> <span data-ttu-id="9ccef-300">如果已為已發行的遊戲版本編制來源檔案資訊和符號的索引，可存取您符號伺服器的開發人員可以擁有所回報問題的完整來源層級偵錯工具，而不需要在其開發電腦上保留組建環境或舊版來源檔案。</span><span class="sxs-lookup"><span data-stu-id="9ccef-300">If the source file information and symbols for a released version of a game are indexed, developers who have access to your symbol server can have full source level debugging of reported issues, without keeping build environments or old versions of source files on their development computers.</span></span> <span data-ttu-id="9ccef-301">若要設定符號伺服器以允許編制原始程式檔資訊的索引，請參閱來源伺服器檔。</span><span class="sxs-lookup"><span data-stu-id="9ccef-301">To set up your symbol server to allow indexing of source file information, see source server documentation.</span></span>

 

 