---
title: 適用于遊戲開發人員的64位程式設計
description: 本文說明相容性和移植問題，並協助開發人員輕鬆轉換至64位平臺。
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104023797"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="ea207-103">適用于遊戲開發人員的64位程式設計</span><span class="sxs-lookup"><span data-stu-id="ea207-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="ea207-104">處理器製造商在其桌上型電腦中會以獨佔方式出貨64位處理器，甚至是大多數膝上型電腦的晶片組都支援 x64 技術。</span><span class="sxs-lookup"><span data-stu-id="ea207-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="ea207-105">重要的是，遊戲開發人員必須利用64位處理器提供的改良功能與其新應用程式，並確保其先前的應用程式在新的處理器和64位版本的 Windows Vista 和 Windows 7 上正確執行。</span><span class="sxs-lookup"><span data-stu-id="ea207-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="ea207-106">本文說明相容性和移植問題，並協助開發人員輕鬆轉換至64位平臺。</span><span class="sxs-lookup"><span data-stu-id="ea207-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="ea207-107">Microsoft 目前有下列64位作業系統：</span><span class="sxs-lookup"><span data-stu-id="ea207-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="ea207-108">Windows Server 2003 Service Pack 1</span><span class="sxs-lookup"><span data-stu-id="ea207-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="ea207-109">Windows XP Professional x64 Edition (可供 Oem 和開發人員透過 MSDN 取得) </span><span class="sxs-lookup"><span data-stu-id="ea207-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="ea207-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="ea207-110">Windows Vista</span></span>
-   <span data-ttu-id="ea207-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="ea207-111">Windows Server 2008</span></span>
-   <span data-ttu-id="ea207-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="ea207-112">Windows 7</span></span>
-   <span data-ttu-id="ea207-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="ea207-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="ea207-114">Windows Server 2008 R2 僅提供64位版本。</span><span class="sxs-lookup"><span data-stu-id="ea207-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="ea207-115">可定址記憶體的差異</span><span class="sxs-lookup"><span data-stu-id="ea207-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="ea207-116">在建立時指定大型位址感知</span><span class="sxs-lookup"><span data-stu-id="ea207-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="ea207-117">64位平臺上32位應用程式的相容性</span><span class="sxs-lookup"><span data-stu-id="ea207-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="ea207-118">潛在的相容性陷阱</span><span class="sxs-lookup"><span data-stu-id="ea207-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="ea207-119">將應用程式移植到64位平臺</span><span class="sxs-lookup"><span data-stu-id="ea207-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="ea207-120">移植應用程式的程式碼剖析和優化</span><span class="sxs-lookup"><span data-stu-id="ea207-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="ea207-121">64位作業系統上的 Managed 程式碼</span><span class="sxs-lookup"><span data-stu-id="ea207-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="ea207-122">執行64位作業系統的效能含意</span><span class="sxs-lookup"><span data-stu-id="ea207-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="ea207-123">總結</span><span class="sxs-lookup"><span data-stu-id="ea207-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="ea207-124">可定址記憶體的差異</span><span class="sxs-lookup"><span data-stu-id="ea207-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="ea207-125">大部分的開發人員都會注意到，64位處理器提供可處理的實體和虛擬記憶體數量的巨大飛躍。</span><span class="sxs-lookup"><span data-stu-id="ea207-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="ea207-126">32位平臺上的32位應用程式最多可以處理 2 GB。</span><span class="sxs-lookup"><span data-stu-id="ea207-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="ea207-127">以/LARGEADDRESSAWARE： YES 連結器旗標在32位 Windows XP 或 Windows Server 2003 上建立的32位應用程式，具有特殊的/3gb 開機選項最多可處理 3 GB。</span><span class="sxs-lookup"><span data-stu-id="ea207-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="ea207-128">這會將核心限制為 1 GB，這可能會導致某些驅動程式和（或）服務失敗。</span><span class="sxs-lookup"><span data-stu-id="ea207-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="ea207-129">以/LARGEADDRESSAWARE： YES 連結器旗標在32位版本的 Windows Vista、Windows Server 2008 和 Windows 7 上建立的32位應用程式，可以將記憶體定址到開機設定資料 (BCD) 元素 IncreaseUserVa 所指定的數目。</span><span class="sxs-lookup"><span data-stu-id="ea207-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="ea207-130">IncreaseUserVa 的值範圍從2048（預設值）到 3072 (，符合 Windows XP) 上/3gb 開機選項所設定的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="ea207-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="ea207-131">4 GB 的其餘部分會配置給核心，而且可能會導致驅動程式和服務設定失敗。</span><span class="sxs-lookup"><span data-stu-id="ea207-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="ea207-132">如需有關 BCD 的詳細資訊，請參閱 MSDN 上的 [開機設定資料](https://msdn.microsoft.com/library/aa362692.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="ea207-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="ea207-133">64位平臺上的32位應用程式最多可處理 2 GB，或最多可達 4 GB 的/LARGEADDRESSAWARE： YES 連結器旗標。</span><span class="sxs-lookup"><span data-stu-id="ea207-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="ea207-134">64位應用程式使用43位進行定址，為應用程式提供 8 TB 的虛擬位址，並為核心保留 8 TB。</span><span class="sxs-lookup"><span data-stu-id="ea207-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="ea207-135">除了記憶體以外，使用記憶體對應檔 i/o 的64位應用程式，也會因為增加的虛擬位址空間而大幅受益。</span><span class="sxs-lookup"><span data-stu-id="ea207-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="ea207-136">64位架構也已改善浮點效能，且更快速地傳遞參數。</span><span class="sxs-lookup"><span data-stu-id="ea207-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="ea207-137">64位處理器具有兩倍的暫存器數目，也就是一般用途和串流 SIMD 延伸模組 (SSE) 類型，以及 SSE 和 SSE2 指令集的支援;許多64位處理器甚至支援 SSE3 指令集。</span><span class="sxs-lookup"><span data-stu-id="ea207-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="ea207-138">在建立時指定大型位址感知</span><span class="sxs-lookup"><span data-stu-id="ea207-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="ea207-139">當您建立32位應用程式時，請使用連結器旗標/LARGEADDRESSAWARE 來指定大型位址感知，即使應用程式不是用於64位平臺，也是很好的作法，因為這是免費取得的優點。</span><span class="sxs-lookup"><span data-stu-id="ea207-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="ea207-140">如先前所述，針對組建啟用此旗標，可讓32位程式在32位 OS 或64位作業系統上以特殊開機選項存取更多記憶體。</span><span class="sxs-lookup"><span data-stu-id="ea207-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="ea207-141">不過，開發人員必須小心不要進行指標假設，例如假設在32位指標中絕對沒有設定過高位。</span><span class="sxs-lookup"><span data-stu-id="ea207-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="ea207-142">一般而言，啟用/LARGEADDRESSAWARE 旗標是不錯的作法。</span><span class="sxs-lookup"><span data-stu-id="ea207-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="ea207-143">具有大型位址感知的32位應用程式，可以在執行時間使用目前作業系統設定（藉由呼叫 [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex)）來判斷其可用的虛擬位址空間總數。</span><span class="sxs-lookup"><span data-stu-id="ea207-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="ea207-144">UllTotalVirtual 結果的範圍是從2147352576個位元組 (2 GB) 到4294836224個位元組 (4 GB) 。</span><span class="sxs-lookup"><span data-stu-id="ea207-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="ea207-145">大於 3221094400 (3 GB) 的值只能在64位版本的 Windows 上取得。</span><span class="sxs-lookup"><span data-stu-id="ea207-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="ea207-146">例如，如果 IncreaseUserVa 的值為2560，則結果會是 ullTotalVirtual，其值為2684223488位元組。</span><span class="sxs-lookup"><span data-stu-id="ea207-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="ea207-147">64位平臺上32位應用程式的相容性</span><span class="sxs-lookup"><span data-stu-id="ea207-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="ea207-148">64位 Windows 作業系統與 IA32 架構是二進位相容的，而32位應用程式使用的大部分 Api 都是透過 Windows 64 位模擬器上的 Windows 32 位來提供。</span><span class="sxs-lookup"><span data-stu-id="ea207-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="ea207-149">WOW64 有助於確保這些 Api 能如預期運作。</span><span class="sxs-lookup"><span data-stu-id="ea207-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="ea207-150">WOW64 具有處理32位資料之封送處理的執行層。</span><span class="sxs-lookup"><span data-stu-id="ea207-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="ea207-151">WOW64 會重新導向 DLL 檔案要求、重新導向32位應用程式的一些登錄分支，並反映32和64位應用程式的一些登錄分支。</span><span class="sxs-lookup"><span data-stu-id="ea207-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="ea207-152">如需有關 WOW64 的詳細資訊，請參閱 MSDN 上的 [Wow64 執行詳細資料](/windows/desktop/WinProg64/wow64-implementation-details) 。</span><span class="sxs-lookup"><span data-stu-id="ea207-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="ea207-153">如需建立在 WOW64 上執行之應用程式的最佳作法，請參閱 Windows 硬體開發人員中心上 [的 WOW64 最佳做法](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) 。</span><span class="sxs-lookup"><span data-stu-id="ea207-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="ea207-154">潛在的相容性陷阱</span><span class="sxs-lookup"><span data-stu-id="ea207-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="ea207-155">大部分針對32位平臺開發的應用程式，在64位平臺上都不會有任何問題。</span><span class="sxs-lookup"><span data-stu-id="ea207-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="ea207-156">有些應用程式可能會有問題，可能包含下列各項：</span><span class="sxs-lookup"><span data-stu-id="ea207-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="ea207-157">64位版本之 Windows 作業系統的所有驅動程式都必須是64位版本。</span><span class="sxs-lookup"><span data-stu-id="ea207-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="ea207-158">需要新的64位驅動程式會影響依賴舊驅動程式的禁止複製配置。</span><span class="sxs-lookup"><span data-stu-id="ea207-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="ea207-159">請注意，核心模式驅動程式必須經過 Authenticode 簽署，才能由64位版本的 Windows 載入。</span><span class="sxs-lookup"><span data-stu-id="ea207-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="ea207-160">64位進程無法載入32位的 Dll，而32位進程無法載入64位 Dll。</span><span class="sxs-lookup"><span data-stu-id="ea207-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="ea207-161">開發人員必須先確定協力廠商 Dll 的64位版本可供使用，再繼續進行開發。</span><span class="sxs-lookup"><span data-stu-id="ea207-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="ea207-162">如果您必須在64位進程中使用32位 DLL，則可以使用 Windows 處理序間通訊 (IPC) 。</span><span class="sxs-lookup"><span data-stu-id="ea207-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="ea207-163">COM 元件也可以利用跨進程伺服器和封送處理，在界限之間進行通訊，但這麼做可能會導致效能降低。</span><span class="sxs-lookup"><span data-stu-id="ea207-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="ea207-164">許多 x64 處理器也是多核心處理器，而開發人員需要測試這對其繼承應用程式的影響。</span><span class="sxs-lookup"><span data-stu-id="ea207-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="ea207-165">多核心處理器的詳細資訊，以及遊戲應用程式的含意可在 [遊戲時間和](/windows/desktop/DxTechArts/game-timing-and-multicore-processors)多核心處理器中找到。</span><span class="sxs-lookup"><span data-stu-id="ea207-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="ea207-166">應用程式也應該呼叫 [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) 來探索檔案路徑，因為某些資料夾名稱在某些情況下已變更。</span><span class="sxs-lookup"><span data-stu-id="ea207-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="ea207-167">例如，CSIDL \_ PROGRAM \_ files 會 \\ 針對在64位平臺上執行的32位應用程式（而不是 "c： program files"）傳回 "c： program files (x86) " \\ 。</span><span class="sxs-lookup"><span data-stu-id="ea207-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="ea207-168">開發人員必須留意 WOW64 模擬器的重新導向和反映功能的運作方式。</span><span class="sxs-lookup"><span data-stu-id="ea207-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="ea207-169">此外，開發人員必須謹慎使用可能仍在使用的16位程式。</span><span class="sxs-lookup"><span data-stu-id="ea207-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="ea207-170">WOW64 無法處理16位應用程式;這包括舊的安裝程式和所有 MS-DOS 程式。</span><span class="sxs-lookup"><span data-stu-id="ea207-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="ea207-171">最常見的相容性問題是安裝程式，它會執行16位程式碼，而不會有禁止複製配置的64位驅動程式。</span><span class="sxs-lookup"><span data-stu-id="ea207-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="ea207-172">下一節將討論有關將程式碼移植到64位原生的問題，而開發人員想要確保其舊版程式可在64位平臺上運作。</span><span class="sxs-lookup"><span data-stu-id="ea207-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="ea207-173">這也適用于不熟悉64位程式設計的開發人員。</span><span class="sxs-lookup"><span data-stu-id="ea207-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="ea207-174">將應用程式移植到64位平臺</span><span class="sxs-lookup"><span data-stu-id="ea207-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="ea207-175">擁有適當的工具和程式庫將有助於簡化從32位到64位開發的轉換。</span><span class="sxs-lookup"><span data-stu-id="ea207-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="ea207-176">DirectX 9 SDK 具有可支援 x86 和 x64 型專案的程式庫。</span><span class="sxs-lookup"><span data-stu-id="ea207-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="ea207-177">Microsoft Visual Studio 2005 和 Visual Studio 2008 都支援 x86 和 x64 的程式碼產生，而且它們隨附的程式庫已針對產生 x64 程式碼而優化。</span><span class="sxs-lookup"><span data-stu-id="ea207-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="ea207-178">不過，開發人員也需要將 Visual C 執行時間與應用程式一起散發。</span><span class="sxs-lookup"><span data-stu-id="ea207-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="ea207-179">請注意，Visual Studio 2005 和 Visual Studio 2008 的 Express 版本不包含 x64 編譯器，但 Standard、Professional 和 Team System 版本都是如此。</span><span class="sxs-lookup"><span data-stu-id="ea207-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="ea207-180">以32位平臺為目標的開發人員可以為64位開發做好準備，以便在稍後更輕鬆地進行轉換。</span><span class="sxs-lookup"><span data-stu-id="ea207-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="ea207-181">編譯32位專案時，開發人員應該使用/Wp64 旗標，這會導致產生會影響可攜性之問題的警告。</span><span class="sxs-lookup"><span data-stu-id="ea207-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="ea207-182">切換至64位工具和程式庫一開始可能會產生許多新的組建錯誤;因此，建議您在切換至64位組建之前，先切換位中立的工具和程式庫，並更正任何警告。</span><span class="sxs-lookup"><span data-stu-id="ea207-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="ea207-183">不過，變更工具、變更程式庫及使用某些編譯器旗標並不會足夠。</span><span class="sxs-lookup"><span data-stu-id="ea207-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="ea207-184">您必須重新評估程式碼標準的假設，以確保目前的編碼標準不允許可攜性問題。</span><span class="sxs-lookup"><span data-stu-id="ea207-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="ea207-185">可攜性問題包括指標截斷、資料類型的大小和對齊、依賴32位 Dll、使用舊版 Api、元件程式碼，以及舊的二進位檔案。</span><span class="sxs-lookup"><span data-stu-id="ea207-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="ea207-186">Visual C++ 2010 包括 stdint.h .h 和 cstdint C99 標頭，這些標頭會定義標準可攜性類型 int32 \_ t、uint32 \_ t、int64 \_ t、uint64 \_ t、intptr \_ t 和 uintptr \_ t。</span><span class="sxs-lookup"><span data-stu-id="ea207-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="ea207-187">使用這些搭配標準 ptrdiff \_ t 和 size \_ t 資料類型，可能會進行到以下用來改善程式碼可攜性的 Windows portabilty 類型。</span><span class="sxs-lookup"><span data-stu-id="ea207-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="ea207-188">主要移植問題包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="ea207-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="ea207-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**指標截斷**</span><span class="sxs-lookup"><span data-stu-id="ea207-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="ea207-190">指標是64位 OS 上的64位，因此將指標轉換成其他資料類型可能會導致截斷，指標算術可能會導致損毀。</span><span class="sxs-lookup"><span data-stu-id="ea207-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="ea207-191">使用/Wp64 旗標通常會提供有關這類問題的警告，但是在轉換指標類型時，使用多型型別 (INT \_ ptr、DWORD \_ PTR、SIZE \_ T、UINT ptr 等等) ，在 \_ 轉換指標類型時，最好避免這個問題。</span><span class="sxs-lookup"><span data-stu-id="ea207-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="ea207-192">由於指標在新的平臺上是64位，因此開發人員應該檢查指標的順序以及類別和結構中的資料類型，以減少或消除填補。</span><span class="sxs-lookup"><span data-stu-id="ea207-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="ea207-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**資料類型和二進位檔案**</span><span class="sxs-lookup"><span data-stu-id="ea207-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="ea207-194">當64位平臺上的指標從32位增加到64時，其他資料類型則否。</span><span class="sxs-lookup"><span data-stu-id="ea207-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="ea207-195">固定精確度資料類型 (DWORD32、DWORD64、INT32、INT64、LONG32、LONG64、UINT32、UINT64) 可用於資料類型大小必須已知的位置;例如，在二進位檔案結構中。</span><span class="sxs-lookup"><span data-stu-id="ea207-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="ea207-196">指標大小和資料對齊的變更需要進行特殊處理，以確保32位到64位的相容性。</span><span class="sxs-lookup"><span data-stu-id="ea207-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="ea207-197">如需詳細資訊，請參閱 [準備開始64位的 Windows：新的資料類型](/windows/desktop/WinProg64/the-new-data-types)。</span><span class="sxs-lookup"><span data-stu-id="ea207-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="ea207-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**舊版 Win32 Api 和資料對齊**</span><span class="sxs-lookup"><span data-stu-id="ea207-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="ea207-199">某些 Win32 Api 已被取代，並以更多中立的 API 呼叫（例如 SetWindowLongPtr 取代 SetWindowLong）取代。</span><span class="sxs-lookup"><span data-stu-id="ea207-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="ea207-200">在 x64 平臺上，非對齊存取的效能會受到更大的影響，而不是 x86 平臺。</span><span class="sxs-lookup"><span data-stu-id="ea207-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="ea207-201">類型 \_ 對齊 (t) 和欄位 \_ 位移 (t，成員) 宏可用來判斷可直接由程式碼使用的對齊資訊。</span><span class="sxs-lookup"><span data-stu-id="ea207-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="ea207-202">正確使用這些上述的宏應該消除潛在的未對齊存取罰款。</span><span class="sxs-lookup"><span data-stu-id="ea207-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="ea207-203">您 \_ 可以在64位 windows 程式設計中找到類型對齊宏、欄位 \_ 位移宏和一般64位程式設計資訊的詳細資訊 [：遷移秘訣：其他考慮](/windows/desktop/WinProg64/additional-considerations) 和 [準備使用64位 Windows：使用指標的規則](/windows/desktop/WinProg64/rules-for-using-pointers)。</span><span class="sxs-lookup"><span data-stu-id="ea207-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="ea207-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**元件碼**</span><span class="sxs-lookup"><span data-stu-id="ea207-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="ea207-205">在64位平臺上不支援內嵌組譯程式碼，且需要加以取代。</span><span class="sxs-lookup"><span data-stu-id="ea207-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="ea207-206">架構中的變更可能會有變更的應用程式瓶頸，而 C/c + + 或內建函式可使用更容易閱讀的程式碼來達成類似的結果。</span><span class="sxs-lookup"><span data-stu-id="ea207-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="ea207-207">最建議的作法是將所有元件程式碼切換至 C 或 c + +。</span><span class="sxs-lookup"><span data-stu-id="ea207-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="ea207-208">內建函式可以用來取代元件程式碼，但只應在執行完整分析和分析之後使用。</span><span class="sxs-lookup"><span data-stu-id="ea207-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="ea207-209">X87、MMX 和3DNow！</span><span class="sxs-lookup"><span data-stu-id="ea207-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="ea207-210">指令集已在64位模式中被取代。</span><span class="sxs-lookup"><span data-stu-id="ea207-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="ea207-211">針對32位模式的回溯相容性，仍然有指示集存在;不過，為了避免未來的相容性問題，建議您在目前和未來的專案中使用它們。</span><span class="sxs-lookup"><span data-stu-id="ea207-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="ea207-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**已淘汰的 Api**</span><span class="sxs-lookup"><span data-stu-id="ea207-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="ea207-213">針對64位原生應用程式，已卸載一些較舊的 DirectX Api： DirectPlay 4 和更早版本、DirectDraw 6 及更早版本、Direct3D 8 和更早版本，以及 DirectInput 7 及更早版本。</span><span class="sxs-lookup"><span data-stu-id="ea207-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="ea207-214">此外，DirectMusic 的核心 API 也可供原生64位應用程式使用，但效能層和 DirectMusic 生產者已被取代。</span><span class="sxs-lookup"><span data-stu-id="ea207-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="ea207-215">Visual Studio 會發出淘汰警告，而且這些變更不是使用最新 Api 之開發人員的問題。</span><span class="sxs-lookup"><span data-stu-id="ea207-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="ea207-216">移植應用程式的程式碼剖析和優化</span><span class="sxs-lookup"><span data-stu-id="ea207-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="ea207-217">所有開發人員都需要重新分析即將移植到新架構的任何應用程式。</span><span class="sxs-lookup"><span data-stu-id="ea207-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="ea207-218">許多正在移植到64位平臺的應用程式，其32位版本會有不同的效能設定檔。</span><span class="sxs-lookup"><span data-stu-id="ea207-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="ea207-219">開發人員必須先執行64位效能測試，才能評估需要優化的內容。</span><span class="sxs-lookup"><span data-stu-id="ea207-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="ea207-220">這就是很好的消息，那就是許多傳統的優化都能在64位平臺上運作。</span><span class="sxs-lookup"><span data-stu-id="ea207-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="ea207-221">此外，64位編譯器也可以使用編譯器旗標和程式碼提示的正確用法來執行許多優化。</span><span class="sxs-lookup"><span data-stu-id="ea207-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="ea207-222">某些結構可能會重新排序其內部資料類型，以節省記憶體空間並改善快取。</span><span class="sxs-lookup"><span data-stu-id="ea207-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="ea207-223">在某些情況下，可以使用陣列索引，而不是完整的64位指標。</span><span class="sxs-lookup"><span data-stu-id="ea207-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="ea207-224">/Fp： fast 旗標可改善浮點優化和向量化。</span><span class="sxs-lookup"><span data-stu-id="ea207-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="ea207-225">使用 \_ \_ restrict、declspec (restrict) ，以及 declspec (noalias) 可協助編譯器解析別名並改善登錄檔案的使用。</span><span class="sxs-lookup"><span data-stu-id="ea207-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="ea207-226">如需/fp： fast 的詳細資訊，請參閱 [/fp (指定 Floating-Point 行為) ](/cpp/build/reference/fp-specify-floating-point-behavior)。</span><span class="sxs-lookup"><span data-stu-id="ea207-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="ea207-227">有關限制的詳細資訊 \_ \_ 可在[Microsoft 專有的](/cpp/cpp/microsoft-specific-modifiers)修飾詞中找到。</span><span class="sxs-lookup"><span data-stu-id="ea207-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="ea207-228">如需 declspec (限制) 的詳細資訊，請參閱 [優化最佳做法](/cpp/build/optimization-best-practices)。</span><span class="sxs-lookup"><span data-stu-id="ea207-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="ea207-229">如需 declspec (noalias) 的詳細資訊，請參閱[ \_ \_ declspec (noalias) ](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx)。</span><span class="sxs-lookup"><span data-stu-id="ea207-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="ea207-230">64位作業系統上的 Managed 程式碼</span><span class="sxs-lookup"><span data-stu-id="ea207-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="ea207-231">許多遊戲開發人員會在其工具鏈中使用受控碼，因此瞭解它在64位作業系統上的行為可能會很有説明。</span><span class="sxs-lookup"><span data-stu-id="ea207-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="ea207-232">Managed 程式碼是指令集中性的，因此當您在64位作業系統上執行 managed 應用程式時，Common Language Runtime (CLR) 可以將它當作32位或64位進程來執行。</span><span class="sxs-lookup"><span data-stu-id="ea207-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="ea207-233">根據預設，CLR 會以64位的形式執行受控應用程式，而且不會有任何問題就能正常運作。</span><span class="sxs-lookup"><span data-stu-id="ea207-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="ea207-234">但是，如果您的應用程式相依于原生32位的 DLL，則當應用程式嘗試呼叫此 DLL 時，您的應用程式將會失敗。</span><span class="sxs-lookup"><span data-stu-id="ea207-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="ea207-235">64位進程需要完全64位的程式碼，而且無法從64位進程呼叫32位的 DLL。</span><span class="sxs-lookup"><span data-stu-id="ea207-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="ea207-236">最佳的長期解決方案是將您的機器碼編譯為64位，但完全合理的短期解決方案是只使用/platform： x86 build 旗標將您的受控應用程式標示為僅適用于 x86。</span><span class="sxs-lookup"><span data-stu-id="ea207-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="ea207-237">執行64位作業系統的效能含意</span><span class="sxs-lookup"><span data-stu-id="ea207-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="ea207-238">因為具有 AMD64 和 Intel 64 架構的處理器可以原生執行32位的指示，所以即使是在64的作業系統上，它們仍能以完整的速度執行32位應用程式。</span><span class="sxs-lookup"><span data-stu-id="ea207-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="ea207-239">在呼叫作業系統函式時，在32位和64位之間轉換參數的成本很低，但這項成本通常是可忽略的。</span><span class="sxs-lookup"><span data-stu-id="ea207-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="ea207-240">這表示在64位作業系統上執行32位應用程式時，您應該不會看到任何緩慢的情況。</span><span class="sxs-lookup"><span data-stu-id="ea207-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="ea207-241">當您將應用程式編譯為64位時，計算會變得更複雜。</span><span class="sxs-lookup"><span data-stu-id="ea207-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="ea207-242">64位程式使用64位指標，而其指示稍微放大，因此記憶體需求會稍微增加。</span><span class="sxs-lookup"><span data-stu-id="ea207-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="ea207-243">這可能會導致效能稍微下降。</span><span class="sxs-lookup"><span data-stu-id="ea207-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="ea207-244">另一方面，擁有兩倍的暫存器，並且能夠在單一指令中進行64位整數計算，通常會比補償更多。</span><span class="sxs-lookup"><span data-stu-id="ea207-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="ea207-245">最後的結果是，64位應用程式的執行速度可能會比編譯為32位的應用程式稍微慢一點，但其執行速度通常會稍微快一點。</span><span class="sxs-lookup"><span data-stu-id="ea207-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="ea207-246">總結</span><span class="sxs-lookup"><span data-stu-id="ea207-246">Summary</span></span>

<span data-ttu-id="ea207-247">64位架構可讓開發人員將遊戲的外觀、音效和玩的限制推播。</span><span class="sxs-lookup"><span data-stu-id="ea207-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="ea207-248">不過，從32位程式設計轉換至64位程式設計並不重要。</span><span class="sxs-lookup"><span data-stu-id="ea207-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="ea207-249">藉由瞭解兩者間的差異，以及藉由使用最新的工具，轉換至64位平臺可以更輕鬆且更快速。</span><span class="sxs-lookup"><span data-stu-id="ea207-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="ea207-250">如需有關64位程式設計的詳細資訊，請參閱 [Visual C++ 開發人員中心：64位程式設計](https://msdn.microsoft.com/vstudio//aa336463.aspx)。</span><span class="sxs-lookup"><span data-stu-id="ea207-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 