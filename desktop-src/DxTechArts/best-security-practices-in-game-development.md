---
title: 遊戲開發的最佳安全性作法
description: 本文討論在遊戲開發中使用的最佳做法。
ms.assetid: 20956529-42ed-722b-cfa3-e3230d89fdd7
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9ba4f02d5e1a2e3da2e50feedd89f085a0c063be
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103842471"
---
# <a name="best-security-practices-in-game-development"></a><span data-ttu-id="f1488-103">遊戲開發的最佳安全性作法</span><span class="sxs-lookup"><span data-stu-id="f1488-103">Best Security Practices in Game Development</span></span>

<span data-ttu-id="f1488-104">本文討論在遊戲開發中使用的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="f1488-104">This article discusses best practices to use in game development.</span></span>

-   [<span data-ttu-id="f1488-105">簡介</span><span class="sxs-lookup"><span data-stu-id="f1488-105">Introduction</span></span>](#introduction)
-   [<span data-ttu-id="f1488-106">不安全的程式碼範例</span><span class="sxs-lookup"><span data-stu-id="f1488-106">Examples of Insecure Code</span></span>](#examples-of-insecure-code)
-   [<span data-ttu-id="f1488-107">改善安全性的方法</span><span class="sxs-lookup"><span data-stu-id="f1488-107">Ways to improve security</span></span>](#ways-to-improve-security)
-   [<span data-ttu-id="f1488-108">總結</span><span class="sxs-lookup"><span data-stu-id="f1488-108">Summary</span></span>](#summary)

## <a name="introduction"></a><span data-ttu-id="f1488-109">簡介</span><span class="sxs-lookup"><span data-stu-id="f1488-109">Introduction</span></span>

<span data-ttu-id="f1488-110">有越來越多的人使用使用者製作的內容來玩線上遊戲和遊戲。</span><span class="sxs-lookup"><span data-stu-id="f1488-110">An increasing number of people play online games and games with user-made content.</span></span> <span data-ttu-id="f1488-111">這與 Microsoft Windows 作業系統的提高安全性結合，表示遊戲是不斷成長且更吸引人的目標，可讓攻擊者入侵。</span><span class="sxs-lookup"><span data-stu-id="f1488-111">This, combined with the increasing security of the Microsoft Windows Operating System, means that games are a growing and more tempting target for attackers to exploit.</span></span> <span data-ttu-id="f1488-112">遊戲開發人員應該特別強調，以確保他們發行的遊戲不會建立新的安全性漏洞，讓攻擊者得以入侵。</span><span class="sxs-lookup"><span data-stu-id="f1488-112">Game developers should place a strong emphasis on making sure that the games they release aren't creating new security holes for attackers to exploit.</span></span> <span data-ttu-id="f1488-113">遊戲開發人員必須負責協助防止客戶的電腦遭到惡意網路資料、使用者修改或篡改攻擊，而有意。</span><span class="sxs-lookup"><span data-stu-id="f1488-113">Game developers have a responsibility and a vested interest in helping to prevent their customers' computers from being hacked by malicious network data, user modifications, or tampering.</span></span> <span data-ttu-id="f1488-114">如果惡意探索弱點，可能會導致客戶和/或金錢損失。</span><span class="sxs-lookup"><span data-stu-id="f1488-114">If a vulnerability is exploited, it could result in losing customers and/or money.</span></span> <span data-ttu-id="f1488-115">本文概述並說明在不因而誇大開發時間的情況下，可提高程式碼安全性的一些常見方法和工具。</span><span class="sxs-lookup"><span data-stu-id="f1488-115">This article outlines and explains some common methods and tools to increase code security without over-inflating development time.</span></span>

<span data-ttu-id="f1488-116">發行產品時，開發團隊所做的三個最常見的錯誤包括：</span><span class="sxs-lookup"><span data-stu-id="f1488-116">The three most common mistakes made by a development team when releasing a product are:</span></span>

-   <span data-ttu-id="f1488-117">需要系統管理許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-117">Requiring administrative privileges.</span></span> <span data-ttu-id="f1488-118">遊戲應該不需要系統管理許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-118">Games should not require administrative privileges.</span></span> <span data-ttu-id="f1488-119">如需詳細資訊，請參閱 [遊戲開發人員的使用者帳戶控制](./user-account-control-for-game-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="f1488-119">For more details, see [User Account Control for Game Developers](./user-account-control-for-game-developers.md).</span></span>
-   <span data-ttu-id="f1488-120">未使用自動保護。</span><span class="sxs-lookup"><span data-stu-id="f1488-120">Not using automated protection.</span></span> <span data-ttu-id="f1488-121">開發人員通常不會使用 **/gs**、 **/SAFESEH** 或 **/NX**。</span><span class="sxs-lookup"><span data-stu-id="f1488-121">Developers are generally not using **/GS**, **/SAFESEH**, or **/NX**.</span></span> <span data-ttu-id="f1488-122">使用這些編譯/連結旗標可以找出或消除許多基本的安全性漏洞，而不會大幅增加工作負載。</span><span class="sxs-lookup"><span data-stu-id="f1488-122">Using these compile/link flags can spot or eliminate many basic security holes without significantly increasing workload.</span></span> <span data-ttu-id="f1488-123">本文稍後會討論這些旗標。</span><span class="sxs-lookup"><span data-stu-id="f1488-123">These flags are discussed later in this article.</span></span>
-   <span data-ttu-id="f1488-124">使用禁止的 Api。</span><span class="sxs-lookup"><span data-stu-id="f1488-124">Using forbidden APIs.</span></span> <span data-ttu-id="f1488-125">有許多 Api (**strcpy**、 **strncpy** 等，而且很容易發生程式設計人員錯誤並輕鬆產生安全性漏洞的) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-125">There are many APIs (**strcpy**, **strncpy**, and so on) that are prone to programmer error and easily generate security holes.</span></span> <span data-ttu-id="f1488-126">開發人員應該以安全的版本取代這些 Api。</span><span class="sxs-lookup"><span data-stu-id="f1488-126">Developers should replace these APIs with the safe versions.</span></span> <span data-ttu-id="f1488-127">Visual Studio 2005 提供分析二進位檔案的工具，可自動檢查目的檔是否有 unsafe Api 的參考。</span><span class="sxs-lookup"><span data-stu-id="f1488-127">Visual Studio 2005 comes with a tool for analyzing binary files that can automatically check object files for references to unsafe APIs.</span></span> <span data-ttu-id="f1488-128">如需有關使用此工具所產生之資訊的詳細資訊，請參閱 Martyn Lovell [的 Visual Studio 2005 Safe C 和 c + + 程式庫的程式碼足以擊退攻擊](/archive/msdn-magazine/2005/may/repel-attacks-with-visual-studio-2005-safe-c-and-c-libraries) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-128">For more information on what to do with information generated with this tool, see [Repel Attacks on Your Code with the Visual Studio 2005 Safe C and C++ Libraries](/archive/msdn-magazine/2005/may/repel-attacks-with-visual-studio-2005-safe-c-and-c-libraries) by Martyn Lovell.</span></span> <span data-ttu-id="f1488-129">此外，您也可以取得 [禁止的 .h](https://www.microsoft.com/downloads/details.aspx?FamilyID=6aed14bd-4766-4d9d-9ee2-fa86aad1e3c9) 標頭檔，以協助您從程式碼中移除禁用的函式。</span><span class="sxs-lookup"><span data-stu-id="f1488-129">Also, you can get the [banned.h](https://www.microsoft.com/downloads/details.aspx?FamilyID=6aed14bd-4766-4d9d-9ee2-fa86aad1e3c9) header file that can help you remove banned functions from code.</span></span>

<span data-ttu-id="f1488-130">每個所列出的錯誤都不只是常見的，但在開發工作負載、編碼標準或功能方面都沒有重大變更，可輕鬆地進行修正。</span><span class="sxs-lookup"><span data-stu-id="f1488-130">Each of the listed mistakes is not only common but is easily correctable with no significant change in development workload, coding standards, or functionality.</span></span>

## <a name="examples-of-insecure-code"></a><span data-ttu-id="f1488-131">不安全的程式碼範例</span><span class="sxs-lookup"><span data-stu-id="f1488-131">Examples of Insecure Code</span></span>

<span data-ttu-id="f1488-132">以下是讓攻擊者執行緩衝區溢位攻擊所需的簡單範例：</span><span class="sxs-lookup"><span data-stu-id="f1488-132">The following is a simple example of all it takes to allow an attacker to perform a buffer overrun attack:</span></span>


```
void GetPlayerName(char *pDatafromNet)
{
    char playername[256]; 
    strncpy(playername, pDatafromNet, strlen(pDatafromNet));

    // ...
}
```



<span data-ttu-id="f1488-133">在表面上，這段程式碼看起來沒問題，它會在所有的情況下呼叫安全的函式。</span><span class="sxs-lookup"><span data-stu-id="f1488-133">On the surface this code looks ok — it calls a safe function, after all.</span></span> <span data-ttu-id="f1488-134">來自網路的資料會複製到256個位元組的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f1488-134">Data from the network is copied into a buffer that is 256 bytes.</span></span> <span data-ttu-id="f1488-135">**Strncpy** 函式依賴在來源字串中尋找 Null 結束字元，或受限於提供的緩衝區計數。</span><span class="sxs-lookup"><span data-stu-id="f1488-135">The **strncpy** function relies on finding a NULL terminator in the source string or is limited by the provided buffer count.</span></span> <span data-ttu-id="f1488-136">問題在於緩衝區大小不正確。</span><span class="sxs-lookup"><span data-stu-id="f1488-136">The problem is that the buffer size is incorrect.</span></span> <span data-ttu-id="f1488-137">如果網路中的資料未經過驗證或緩衝區大小錯誤 (如這個範例) 所示，攻擊者可以直接提供大型緩衝區來覆寫堆疊資料，在緩衝區結束之後，將任何資料包含在網路封包中。</span><span class="sxs-lookup"><span data-stu-id="f1488-137">If data from the network isn't validated or the buffer size is wrong (as in this example), an attacker could simply provide a large buffer to overwrite stack data, after the buffer ends, with any data in the network packet.</span></span> <span data-ttu-id="f1488-138">這可讓攻擊者藉由覆寫指令指標並變更傳回位址，來執行任意程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1488-138">This would allow the attacker to execute arbitrary code by overwriting the instruction pointer and changing the return address.</span></span> <span data-ttu-id="f1488-139">此範例最基本的課程是在驗證之前永遠不信任輸入。</span><span class="sxs-lookup"><span data-stu-id="f1488-139">The most basic lesson of this example is to never trust input until it has been verified.</span></span>

<span data-ttu-id="f1488-140">即使資料一開始並不是來自網路，仍會有潛在的風險。</span><span class="sxs-lookup"><span data-stu-id="f1488-140">Even if data doesn't come from the network initially, there still is potential risk.</span></span> <span data-ttu-id="f1488-141">新式遊戲開發需要許多人設計、開發和測試相同的程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="f1488-141">Modern game development requires many people designing, developing, and testing the same code base.</span></span> <span data-ttu-id="f1488-142">我們無法知道未來將如何呼叫函式。</span><span class="sxs-lookup"><span data-stu-id="f1488-142">There is no way to know how the function will be called in the future.</span></span> <span data-ttu-id="f1488-143">永遠詢問您自己的資料來源，以及攻擊者的控制權為何？</span><span class="sxs-lookup"><span data-stu-id="f1488-143">Always ask yourself where the data came from and what could an attacker control?</span></span> <span data-ttu-id="f1488-144">雖然以網路為基礎的攻擊是最常見的，但它們並不是建立安全性漏洞的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="f1488-144">While network-based attacks are the most common, they are not the only methods of creating security holes.</span></span> <span data-ttu-id="f1488-145">攻擊者可以建立 mod，還是以開啟安全性漏洞的方式編輯已儲存的檔案？</span><span class="sxs-lookup"><span data-stu-id="f1488-145">Could an attacker create a mod or edit a saved file in a way that opens a security hole?</span></span> <span data-ttu-id="f1488-146">使用者提供的圖像和音效檔呢？</span><span class="sxs-lookup"><span data-stu-id="f1488-146">What about user-supplied image and sound files?</span></span> <span data-ttu-id="f1488-147">這些檔案的惡意版本可能會在網際網路上張貼，並為您的客戶建立危險的安全性風險。</span><span class="sxs-lookup"><span data-stu-id="f1488-147">Malicious versions of these files could be posted on the Internet and create dangerous security risks for your customers.</span></span>

<span data-ttu-id="f1488-148">請注意，請使用 >strsafe.h 或 Safe CRT （而不是 **strncpy** ）來修正範例。</span><span class="sxs-lookup"><span data-stu-id="f1488-148">As a side note, use strsafe.h or Safe CRT instead of **strncpy** to correct the example.</span></span> <span data-ttu-id="f1488-149">Safe CRT 是 C 執行時間的完整安全性檢修，隨附于 Visual Studio 2005 的一部分。</span><span class="sxs-lookup"><span data-stu-id="f1488-149">Safe CRT is a complete security overhaul of the C Runtime and comes with part of Visual Studio 2005.</span></span> <span data-ttu-id="f1488-150">如需安全 CRT 的詳細資訊，請參閱 Michael Howard 在 [CRT 中的安全性增強功能](https://msdn.microsoft.com/library/8ef0s5kh(VS.80).aspx) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-150">More information about Safe CRT can be found in [Security Enhancements in the CRT](https://msdn.microsoft.com/library/8ef0s5kh(VS.80).aspx) by Michael Howard.</span></span>

## <a name="ways-to-improve-security"></a><span data-ttu-id="f1488-151">改善安全性的方法</span><span class="sxs-lookup"><span data-stu-id="f1488-151">Ways to improve security</span></span>

<span data-ttu-id="f1488-152">有數種方式可改善開發週期的安全性。</span><span class="sxs-lookup"><span data-stu-id="f1488-152">There are several ways to improve security in the development cycle.</span></span> <span data-ttu-id="f1488-153">以下是一些最佳方式：</span><span class="sxs-lookup"><span data-stu-id="f1488-153">Here are some of the best ways:</span></span>

<dl> <dt>

<span data-ttu-id="f1488-154"><span id="Reading_about_security"></span><span id="reading_about_security"></span><span id="READING_ABOUT_SECURITY"></span>閱讀安全性資訊</span><span class="sxs-lookup"><span data-stu-id="f1488-154"><span id="Reading_about_security"></span><span id="reading_about_security"></span><span id="READING_ABOUT_SECURITY"></span>Reading about security</span></span>
</dt> <dd>

<span data-ttu-id="f1488-155">《 Michael Howard 和 David LeBlanc 》這本書 *撰寫安全的程式碼、第二版* ，可提供防止攻擊和緩和入侵的策略和方法的深入說明。</span><span class="sxs-lookup"><span data-stu-id="f1488-155">The book, *Writing Secure Code, Second Edition* by Michael Howard and David LeBlanc, provides an in-depth and clear explanation of strategies and methods of preventing attacks and mitigating exploits.</span></span> <span data-ttu-id="f1488-156">從設計安全性的方法到版本，到保護網路應用程式的技術，本書都涵蓋了遊戲開發人員所需的所有層面，以協助保護自己、其產品和客戶免受攻擊者的攻擊。</span><span class="sxs-lookup"><span data-stu-id="f1488-156">Starting with methods of designing security into a release to techniques for securing network applications, the book covers all aspects that a game developer needs to help protect themselves, their products, and their customers from attackers.</span></span> <span data-ttu-id="f1488-157">本書可以用來在開發 studio 中投注信任感安全性文化特性。</span><span class="sxs-lookup"><span data-stu-id="f1488-157">The book can be used to instill a culture of security in a development studio.</span></span> <span data-ttu-id="f1488-158">別把程式碼安全性視為開發人員的問題或測試人員的問題。</span><span class="sxs-lookup"><span data-stu-id="f1488-158">Don't just think of code security as a developer's problem or a tester's problem.</span></span> <span data-ttu-id="f1488-159">將安全性視為整個團隊的資訊，從程式經理到設計人員到開發人員，都應該考慮它們在專案上的運作方式。</span><span class="sxs-lookup"><span data-stu-id="f1488-159">Think of security as something the whole team — from program manager to designer to developer to tester — should be thinking about when they work on a project.</span></span> <span data-ttu-id="f1488-160">在審核流程中，越眼睛越好，在發行之前攔截安全性漏洞的機率就愈大。</span><span class="sxs-lookup"><span data-stu-id="f1488-160">The more eyes that are part of the review process, the greater the chance of catching a security hole prior to release.</span></span>

<span data-ttu-id="f1488-161">*撰寫安全的程式碼，第二版* 可在 [Microsoft Learning](https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223) 找到，在未來的攻擊中可以找到更多的一般安全性資訊，方法是藉由 Michael Howard [減少受攻擊面](/previous-versions/ms972812(v=msdn.10)) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-161">*Writing Secure Code, Second Edition* can be found at [Microsoft Learning](https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223) and more general security information can be found in [Fending Off Future Attacks by Reducing Attack Surface](/previous-versions/ms972812(v=msdn.10)) by Michael Howard.</span></span>

<span data-ttu-id="f1488-162">Michael Howard、David LeBlanc 和 John Viega 撰寫了另一本書，討論所有常見的作業系統和程式設計語言，其涵蓋 *了 19 Deadly sins of 的軟體安全性*。</span><span class="sxs-lookup"><span data-stu-id="f1488-162">Michael Howard, David LeBlanc, and John Viega have written another book on the subject that covers all common operating systems and programming languages entitled, *19 Deadly Sins of Software Security*.</span></span>

<span data-ttu-id="f1488-163">您可以在 Microsoft 產品的 [開發人員簡報](/previous-versions/dn629515(v=msdn.10)) 下載頁面找到著重于遊戲的安全性簡報。</span><span class="sxs-lookup"><span data-stu-id="f1488-163">Security presentations focused on games can be found at the [Microsoft XNA Developer Presentations](/previous-versions/dn629515(v=msdn.10)) download page.</span></span>

</dd> <dt>

<span data-ttu-id="f1488-164"><span id="Threat_Modeling_Analysis"></span><span id="threat_modeling_analysis"></span><span id="THREAT_MODELING_ANALYSIS"></span>威脅模型分析</span><span class="sxs-lookup"><span data-stu-id="f1488-164"><span id="Threat_Modeling_Analysis"></span><span id="threat_modeling_analysis"></span><span id="THREAT_MODELING_ANALYSIS"></span>Threat Modeling Analysis</span></span>
</dt> <dd>

<span data-ttu-id="f1488-165">威脅分析模型分析是評估系統安全性的好方法，而不是以特定語言或使用工具來評估，但在少數的端對端方法中，可以在幾個會議中完成。</span><span class="sxs-lookup"><span data-stu-id="f1488-165">A threat modeling analysis is a good way of assessing system security, not in a specific language or by using a tool, but in a broad, end-to-end method that can be accomplished in a few meetings.</span></span> <span data-ttu-id="f1488-166">當適當地執行時，執行緒模型可以找出系統的所有優點和缺點，而不會在專案中加入重要的工作負載或會議時間。</span><span class="sxs-lookup"><span data-stu-id="f1488-166">When implemented properly, a thread model can identify all of the strengths and weaknesses of a system, without adding significant workload or meeting time to the project.</span></span> <span data-ttu-id="f1488-167">威脅分析模型的方法也強調了在開發過程中評估系統安全性的概念，以協助確保在將焦點放在最具風險的功能時進行全面的評估。</span><span class="sxs-lookup"><span data-stu-id="f1488-167">The method of threat modeling also emphasizes the idea of assessing system security prior to and during the development process to help ensure that a comprehensive assessment is being made while focusing on the most risky features.</span></span> <span data-ttu-id="f1488-168">您可以將它視為安全性分析工具。</span><span class="sxs-lookup"><span data-stu-id="f1488-168">It can be thought of as a profiler for security.</span></span> <span data-ttu-id="f1488-169">藉由不是以特定語言為基礎或依賴特定工具，威脅分析模型可用於任何在任何類型的專案上運作的開發 studio。</span><span class="sxs-lookup"><span data-stu-id="f1488-169">By not being based on a particular language or relying on a specific tool, threat modeling can be used in any development studio working on any project in any genre.</span></span> <span data-ttu-id="f1488-170">威脅分析模型也是一種很好的方法，可以強化安全性是每個人的責任，而不是其他人的問題。</span><span class="sxs-lookup"><span data-stu-id="f1488-170">Threat modeling is also an excellent method of reinforcing the idea that security is everyone's responsibility and not someone else's problem.</span></span>

<span data-ttu-id="f1488-171">當威脅模型化時，請特別注意：</span><span class="sxs-lookup"><span data-stu-id="f1488-171">When threat modeling, pay special attention to:</span></span>

-   <span data-ttu-id="f1488-172">UDP 資料來源</span><span class="sxs-lookup"><span data-stu-id="f1488-172">UDP data sources</span></span>
-   <span data-ttu-id="f1488-173">不需要驗證的資料來源</span><span class="sxs-lookup"><span data-stu-id="f1488-173">Data sources that don't require authentication</span></span>
-   <span data-ttu-id="f1488-174">經常且通常會在大規模資訊收集過程中探查的資料來源</span><span class="sxs-lookup"><span data-stu-id="f1488-174">Data sources that are frequently and normally probed as part of wide-scale information gathering</span></span>
-   <span data-ttu-id="f1488-175">用戶端將資料直接傳送給其他用戶端的任何能力</span><span class="sxs-lookup"><span data-stu-id="f1488-175">Any ability of a client to directly send data to other clients</span></span>

<span data-ttu-id="f1488-176">這些都是可能有安全性弱點的領域。</span><span class="sxs-lookup"><span data-stu-id="f1488-176">These are the areas that have good potential for security weaknesses.</span></span>

<span data-ttu-id="f1488-177">有關威脅分析模型的詳細資訊，可以在 MSDN 安全性開發中心的 [威脅分析模型](https://technet.microsoft.com/security/) 中找到，也可以在「Frank Swiderski 和「視窗 Snyder」這本書的 [威脅模型](https://www.amazon.com/Threat-Modeling-Microsoft-Professional-Swiderski/dp/0735619913) 中找到。</span><span class="sxs-lookup"><span data-stu-id="f1488-177">More on Threat Modeling can be found at [Threat Modeling](https://technet.microsoft.com/security/) on the MSDN Security Development Center and in the book [Threat Modeling](https://www.amazon.com/Threat-Modeling-Microsoft-Professional-Swiderski/dp/0735619913) by Frank Swiderski and Window Snyder.</span></span>

</dd> <dt>

<span data-ttu-id="f1488-178"><span id="Data_Execution_Prevention___NX_"></span><span id="data_execution_prevention___nx_"></span><span id="DATA_EXECUTION_PREVENTION___NX_"></span>資料執行防止 (/NX) </span><span class="sxs-lookup"><span data-stu-id="f1488-178"><span id="Data_Execution_Prevention___NX_"></span><span id="data_execution_prevention___nx_"></span><span id="DATA_EXECUTION_PREVENTION___NX_"></span>Data Execution Prevention (/NX)</span></span>
</dt> <dd>

<span data-ttu-id="f1488-179">減少多重入侵的最新工具是資料執行防止 (DEP) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-179">A recent tool in mitigating multiple exploits is data execution prevention (DEP).</span></span> <span data-ttu-id="f1488-180">如果您在 build 命令中包含 switch **/NX** ，Visual Studio 會以旗標標示記憶體頁面，指出程式碼是否有權執行。</span><span class="sxs-lookup"><span data-stu-id="f1488-180">If you include the switch **/NX** in the build command, Visual Studio will mark memory pages with flags that denote whether the code has the right to execute or not.</span></span> <span data-ttu-id="f1488-181">任何嘗試在未標示 EXECUTE 許可權的記憶體頁面中執行的程式，將會導致程式終止 forcible。</span><span class="sxs-lookup"><span data-stu-id="f1488-181">Any program attempting to execute in a memory page not flagged with EXECUTE permission will cause a forcible termination of the program.</span></span> <span data-ttu-id="f1488-182">系統會對處理器層級強制執行預防措施，而且會影響使用自我修改程式碼或原生 JIT 語言編譯器的開發人員。</span><span class="sxs-lookup"><span data-stu-id="f1488-182">The prevention is enforced on the processor level and will impact developers who are using self-modifying code or native JIT language compilers.</span></span> <span data-ttu-id="f1488-183">目前，只有 AMD 的 Athlon64 和皓龍處理器和 Intel 的 Itanium 和最新 Pentium 4 處理器支援執行預防，但預期所有的32位和64位處理器都支援未來的執行防止。</span><span class="sxs-lookup"><span data-stu-id="f1488-183">Currently, only AMD's Athlon64 and Opteron processors and Intel's Itanium and latest Pentium 4 processors support execution prevention, but it is expected that all 32-bit and 64-bit processors will support execution prevention in the future.</span></span> <span data-ttu-id="f1488-184"> (開發人員所使用的禁止複製配置可能會受到執行防止的影響，但 Microsoft 已與禁止複製廠商合作，將影響降至最低。 ) 使用 DEP 是不錯的作法。</span><span class="sxs-lookup"><span data-stu-id="f1488-184">(A copy-protection scheme used by a developer may be affected by execution prevention, but Microsoft has been working with copy-protection vendors to minimize the impact.) It is a good practice to use DEP.</span></span>

<span data-ttu-id="f1488-185">如需 DEP 的詳細資訊，請參閱 [資料執行防止](../memory/data-execution-prevention.md)。</span><span class="sxs-lookup"><span data-stu-id="f1488-185">For more details on DEP, see [Data Execution Prevention](../memory/data-execution-prevention.md).</span></span>

</dd> <dt>

<span data-ttu-id="f1488-186"><span id="Buffer_Security_Check___GS__and_Image_has_Safe_Exception_Handlers___SAFESEH_"></span><span id="buffer_security_check___gs__and_image_has_safe_exception_handlers___safeseh_"></span><span id="BUFFER_SECURITY_CHECK___GS__AND_IMAGE_HAS_SAFE_EXCEPTION_HANDLERS___SAFESEH_"></span>緩衝區安全性檢查 (/GS) 和映射具有安全的例外狀況處理常式 (/SAFESEH) </span><span class="sxs-lookup"><span data-stu-id="f1488-186"><span id="Buffer_Security_Check___GS__and_Image_has_Safe_Exception_Handlers___SAFESEH_"></span><span id="buffer_security_check___gs__and_image_has_safe_exception_handlers___safeseh_"></span><span id="BUFFER_SECURITY_CHECK___GS__AND_IMAGE_HAS_SAFE_EXCEPTION_HANDLERS___SAFESEH_"></span>Buffer Security Check (/GS) and Image has Safe Exception Handlers (/SAFESEH)</span></span>
</dt> <dd>

<span data-ttu-id="f1488-187">*緩衝區安全性檢查*（由編譯器旗標 **/gs** 指定）和 *影像具有安全的例外狀況處理常式*，由連結器旗標 **/SAFESEH** 指定 (第一次在 Visual Studio .NET 2003) 中執行，可讓開發人員更輕鬆地保護程式碼的安全。</span><span class="sxs-lookup"><span data-stu-id="f1488-187">*Buffer Security Check*, specified by the compiler flag **/GS**, and *Image has Safe Exception Handlers*, specified by the linker flag **/SAFESEH** (first implemented in Visual Studio .NET 2003), can make the developer's job of securing code a little easier.</span></span>

<span data-ttu-id="f1488-188">使用 **/gs** 旗標會讓編譯器針對某些形式的堆疊型緩衝區溢位來檢查檢查，以覆寫函式的傳回位址。</span><span class="sxs-lookup"><span data-stu-id="f1488-188">Using the **/GS** flag causes the compiler to construct a check for some forms of stack-based buffer overruns that could be exploited to overwrite the return address of a function.</span></span> <span data-ttu-id="f1488-189">使用 **/gs** 將不會偵測到每個可能的緩衝區溢位，也不應該視為全部攔截，而是良好的深度防禦技術。</span><span class="sxs-lookup"><span data-stu-id="f1488-189">Using **/GS** will not detect every potential buffer overrun and shouldn't be considered a catch-all, but a good defense-in-depth technology.</span></span>

<span data-ttu-id="f1488-190">使用 **/SAFESEH** 旗標會指示連結器只產生可執行檔或 dll （如果它也可以產生可執行檔或 dll 的安全例外狀況處理常式資料表）。</span><span class="sxs-lookup"><span data-stu-id="f1488-190">Using the **/SAFESEH** flag will instruct the linker to only generate an executable or DLL if it can also generate a table of the safe exception handlers of the executable or DLL.</span></span> <span data-ttu-id="f1488-191"> () SafeSEH 的安全結構化例外狀況處理，藉由確保在分派例外狀況之前，會將例外狀況處理常式註冊到位於影像檔案的函式資料表中，以避免例外狀況處理作為緩衝區溢位攻擊的目標。</span><span class="sxs-lookup"><span data-stu-id="f1488-191">Safe Structured Exception Handling (SafeSEH) eliminates exception handling as a target of buffer overrun attacks by ensuring that, before an exception is dispatched, the exception handler is registered in the function table located within the image file.</span></span> <span data-ttu-id="f1488-192">這些保護優點可透過 Windows XP SP2、Windows Server 2003、Windows Vista 和 Windows 7 啟用。</span><span class="sxs-lookup"><span data-stu-id="f1488-192">These protection benefits are enabled with Windows XP SP2, Windows Server 2003, Windows Vista, and Windows 7.</span></span> <span data-ttu-id="f1488-193">此外，若要讓 **/SAFESEH** 正常運作，則必須將它用於「全部」或「無」的方法。</span><span class="sxs-lookup"><span data-stu-id="f1488-193">Also for **/SAFESEH** to work properly, it must be used in an all-or-nothing method.</span></span> <span data-ttu-id="f1488-194">所有包含系結至可執行檔或 DLL 之程式碼的程式庫都必須使用 **/SAFESEH** 進行編譯，否則就不會產生資料表。</span><span class="sxs-lookup"><span data-stu-id="f1488-194">All libraries containing code bound to an executable or DLL must be compiled with **/SAFESEH** or the table will not be generated.</span></span>

<span data-ttu-id="f1488-195">有關 [緩衝區安全性檢查](https://msdn.microsoft.com/library/8dbf701c(vs.71).aspx) (**/Gs**) 和 [映射有安全例外狀況處理常式](https://msdn.microsoft.com/library/9a89h429(vs.71).aspx) 的詳細資訊 (**/SAFESEH**) 可在 MSDN 中找到。</span><span class="sxs-lookup"><span data-stu-id="f1488-195">More information about [Buffer Security Check](https://msdn.microsoft.com/library/8dbf701c(vs.71).aspx) (**/GS**) and [Image has Safe Exception Handlers](https://msdn.microsoft.com/library/9a89h429(vs.71).aspx) (**/SAFESEH**) can be found in MSDN.</span></span>

<span data-ttu-id="f1488-196">另請參閱 Microsoft Visual Studio 2012 [ **/SDL** 旗](/cpp/build/reference/sdl-enable-additional-security-checks?view=vs-2019)標的相關資訊，以及對 [ **/gs** 旗](https://www.microsoft.com/security/blog/2012/01/26/enhancements-to-gs-in-visual-studio-11/)標 Visual Studio 2012 的增強功能。</span><span class="sxs-lookup"><span data-stu-id="f1488-196">See also info about Microsoft Visual Studio 2012's [**/SDL** flag](/cpp/build/reference/sdl-enable-additional-security-checks?view=vs-2019) and Visual Studio 2012's [enhancements to the **/GS** flag](https://www.microsoft.com/security/blog/2012/01/26/enhancements-to-gs-in-visual-studio-11/).</span></span>

</dd> <dt>

<span data-ttu-id="f1488-197"><span id="PREfast"></span><span id="prefast"></span><span id="PREFAST"></span>PREfast</span><span class="sxs-lookup"><span data-stu-id="f1488-197"><span id="PREfast"></span><span id="prefast"></span><span id="PREFAST"></span>PREfast</span></span>
</dt> <dd>

<span data-ttu-id="f1488-198">PREfast 是 Microsoft 提供的免費工具，可分析編譯 C 或 c + + 中的執行路徑，以協助找出執行時間的 bug。</span><span class="sxs-lookup"><span data-stu-id="f1488-198">PREfast is a free tool offered by Microsoft that analyzes execution paths in compiled C or C++ to help find run-time bugs.</span></span> <span data-ttu-id="f1488-199">PREfast 的運作方式是在所有函式中處理所有執行路徑，並評估每個路徑的問題。</span><span class="sxs-lookup"><span data-stu-id="f1488-199">PREfast operates by working through all execution paths in all functions and assessing each path for problems.</span></span> <span data-ttu-id="f1488-200">這項工具最初用來開發驅動程式和其他核心程式代碼，可協助遊戲開發人員消除一些難以尋找或編譯器會忽略的 bug，藉此節省時間。</span><span class="sxs-lookup"><span data-stu-id="f1488-200">Originally used to develop drivers and other kernel code, this tool can help game developers save time by eliminating some bugs that are hard to find or are ignored by the compiler.</span></span> <span data-ttu-id="f1488-201">使用 PREfast 是降低工作負載的絕佳方法，並專注于開發小組和測試團隊的工作。</span><span class="sxs-lookup"><span data-stu-id="f1488-201">Using PREfast is an excellent way of reducing workload and focusing the efforts of both the development team and test team.</span></span> <span data-ttu-id="f1488-202">PREfast 可在 Visual Studio Team Suite 中取得，並 Visual Studio Team Edition for Software Developers 為程式碼分析，由編譯器參數 **/analyze** 啟用。</span><span class="sxs-lookup"><span data-stu-id="f1488-202">PREfast is available in Visual Studio Team Suite and Visual Studio Team Edition for Software Developers as Code Analysis, enabled by the compiler switch **/analyze**.</span></span> <span data-ttu-id="f1488-203"> (此選項也適用于隨附于 Windows 軟體開發套件的免費編譯器版本。 ) </span><span class="sxs-lookup"><span data-stu-id="f1488-203">(This option is also available in the free version of the compiler that ships with the Windows Software Development Kit.)</span></span>

> [!Note]  
> <span data-ttu-id="f1488-204">Visual Studio 2012 支援所有版本中的 **/analyze** 。</span><span class="sxs-lookup"><span data-stu-id="f1488-204">Visual Studio 2012 supports **/analyze** in all editions.</span></span> <span data-ttu-id="f1488-205">如需所有 Visual Studio 版本中程式碼分析可用性的詳細資訊，請參閱程式 [代碼分析的新功能](/archive/blogs/codeanalysis/?m=20123)。</span><span class="sxs-lookup"><span data-stu-id="f1488-205">For more info about code analysis availability in all editions of Visual Studio, see [What’s New in Code Analysis](/archive/blogs/codeanalysis/?m=20123).</span></span>

 

<span data-ttu-id="f1488-206">透過使用標頭注釋 (特別是) 的緩衝區指標引數，PREfast 可能會公開其他問題，例如記憶體覆寫錯誤、損毀的常見來源，以及潛在的安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="f1488-206">Through the use of header annotation (particularly for buffer pointer arguments), PREfast can expose additional issues, such as memory overwrite bugs, a common source of crashes and potential security vulnerabilities.</span></span> <span data-ttu-id="f1488-207">這是使用標準注釋語言 (SAL) 來完成，這是 C/c + + 函式原型的標記形式，可提供預期指標引數語義的詳細資訊，以及與長度參數、宣告的緩衝區大小等相關的詳細資訊。所有適用于 Windows 作業系統的標頭都會加上批註，並在您自己的程式庫的公用 API 標頭中新增 SAL 標記，讓 PREfast 能夠在您的用戶端程式代碼中針對這類 Api 執行更詳細且更積極的檢查。</span><span class="sxs-lookup"><span data-stu-id="f1488-207">This is done by using the Standard Annotation Language (SAL), which is a form of mark-up for C/C++ function prototypes that provide additional information about expected pointer argument semantics and correlation with length parameters, declared buffer sizes, etc. All of the headers for Windows operating systems are annotated, and adding SAL mark-up in public API headers in your own libraries enables PREfast to perform more detailed and aggressive checks in your client code for such APIs.</span></span> <span data-ttu-id="f1488-208">For an introduction to SAL and links to more information, see Michael Howard's blog entry, "[A Brief Introduction to the Standard Annotation Language (SAL)](/archive/blogs/michael_howard/a-brief-introduction-to-the-standard-annotation-language-sal)."</span><span class="sxs-lookup"><span data-stu-id="f1488-208">For an introduction to SAL and links to more information, see Michael Howard's blog entry, "[A Brief Introduction to the Standard Annotation Language (SAL)](/archive/blogs/michael_howard/a-brief-introduction-to-the-standard-annotation-language-sal)."</span></span>

</dd> <dt>

<span data-ttu-id="f1488-209"><span id="Windows_Application_Verifier"></span><span id="windows_application_verifier"></span><span id="WINDOWS_APPLICATION_VERIFIER"></span>Windows 應用程式驗證器</span><span class="sxs-lookup"><span data-stu-id="f1488-209"><span id="Windows_Application_Verifier"></span><span id="windows_application_verifier"></span><span id="WINDOWS_APPLICATION_VERIFIER"></span>Windows Application Verifier</span></span>
</dt> <dd>

<span data-ttu-id="f1488-210">Windows 應用程式驗證器（或 AppVerifier）可以在一個工具中提供多個功能，以協助測試人員。</span><span class="sxs-lookup"><span data-stu-id="f1488-210">The Windows Application Verifier, or AppVerifier, can help testers by providing multiple functions in one tool.</span></span> <span data-ttu-id="f1488-211">AppVerifier 是為了讓常見的程式設計錯誤更容易測試而開發的工具。</span><span class="sxs-lookup"><span data-stu-id="f1488-211">The AppVerifier is a tool that was developed to make common programming errors more testable.</span></span> <span data-ttu-id="f1488-212">AppVerifier 可以檢查傳遞給 API 呼叫的參數、插入錯誤的輸入以檢查錯誤處理能力，以及記錄對登錄和檔案系統的變更。</span><span class="sxs-lookup"><span data-stu-id="f1488-212">AppVerifier can check parameters passed to API calls, inject erroneous input to check error handling ability, and log changes to the registry and file system.</span></span> <span data-ttu-id="f1488-213">AppVerifier 也可以偵測堆積中的緩衝區溢位，檢查是否已正確定義 ACL)  (的存取控制清單，並強制執行通訊端 Api 的安全使用。</span><span class="sxs-lookup"><span data-stu-id="f1488-213">AppVerifier can also detect buffer overruns in the heap, check that an Access Control List (ACL) has been properly defined, and enforce the safe use of socket APIs.</span></span> <span data-ttu-id="f1488-214">雖然並非詳盡，但 AppVerifier 可以是測試人員工具箱中的一項工具，以協助開發 studio 發行品質的產品。</span><span class="sxs-lookup"><span data-stu-id="f1488-214">While not exhaustive, AppVerifier can be one tool in the tester's toolbox to help a development studio release a quality product.</span></span>

<span data-ttu-id="f1488-215">如需應用程式驗證器的詳細資訊，請參閱 MSDN 上的 [應用程式驗證器](/previous-versions/visualstudio/visual-studio-2008/ms220948(v=vs.90)) 和 [使用軟體發展生命週期中的應用程式驗證器](/previous-versions/aa480483(v=msdn.10)) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-215">For more information about Application Verifier, see [Application Verifier](/previous-versions/visualstudio/visual-studio-2008/ms220948(v=vs.90)) and [Using Application Verifier Within Your Software Development Lifecycle](/previous-versions/aa480483(v=msdn.10)) on MSDN.</span></span>

</dd> <dt>

<span data-ttu-id="f1488-216"><span id="Fuzz_Testing"></span><span id="fuzz_testing"></span><span id="FUZZ_TESTING"></span>模糊測試</span><span class="sxs-lookup"><span data-stu-id="f1488-216"><span id="Fuzz_Testing"></span><span id="fuzz_testing"></span><span id="FUZZ_TESTING"></span>Fuzz Testing</span></span>
</dt> <dd>

<span data-ttu-id="f1488-217">*模糊測試* 是一種半自動化的測試方法，可以增強目前的測試方法。</span><span class="sxs-lookup"><span data-stu-id="f1488-217">*Fuzz testing* is a semi-automated method of testing that can enhance current testing methodologies.</span></span> <span data-ttu-id="f1488-218">模糊測試背後的核心概念，是藉由輸入亂數據來查看有哪些中斷，來全面評估所有輸入;這包括所有網路資料、mods > 和已儲存的遊戲等等。模糊測試相當簡單。</span><span class="sxs-lookup"><span data-stu-id="f1488-218">The central idea behind fuzz testing is to make a full assessment of all inputs by inputing random data to see what breaks; this includes all network data, mods and saved games, etc. Fuzz testing is fairly easy to do.</span></span> <span data-ttu-id="f1488-219">只要插入隨機位元組、翻轉連續的位元組或否定數值，就可以改變格式正確的檔案或網路資料。</span><span class="sxs-lookup"><span data-stu-id="f1488-219">Simply alter well-formed files or network data by inserting random bytes, flipping adjacent bytes, or negating numerical values.</span></span> <span data-ttu-id="f1488-220">0xff、0xffff、0xffffffff、0x00、0x0000、0x00000000 和0x80000000 是可在模糊測試時公開安全性漏洞的值。</span><span class="sxs-lookup"><span data-stu-id="f1488-220">0xff, 0xffff, 0xffffffff, 0x00, 0x0000, 0x00000000, and 0x80000000 are values that are good at exposing security holes while fuzz testing.</span></span> <span data-ttu-id="f1488-221">您可以使用 AppVerifier 觀察產生的互動組合。</span><span class="sxs-lookup"><span data-stu-id="f1488-221">You can observe the resulting interaction combinations using AppVerifier.</span></span> <span data-ttu-id="f1488-222">雖然模糊化並非詳盡的，但很容易就能實現和自動化，而且可以攔截出更難以捉摸和無法預測的錯誤。</span><span class="sxs-lookup"><span data-stu-id="f1488-222">While fuzzing is not exhaustive, it is easy to implement and automate, and it can catch the more elusive and unpredictable bugs.</span></span>

<span data-ttu-id="f1488-223">如需模糊測試的詳細資訊，請參閱 *遊戲安全性中* 的 [Gamefest 2007](/previous-versions/dn629515(v=msdn.10))展示實用步驟。</span><span class="sxs-lookup"><span data-stu-id="f1488-223">For more information on fuzz testing, see the [Gamefest 2007](/previous-versions/dn629515(v=msdn.10)) presentation *Practical Steps in Game Security*.</span></span>

</dd> <dt>

<span data-ttu-id="f1488-224"><span id="Authenticode_Signing"></span><span id="authenticode_signing"></span><span id="AUTHENTICODE_SIGNING"></span>Authenticode 簽署</span><span class="sxs-lookup"><span data-stu-id="f1488-224"><span id="Authenticode_Signing"></span><span id="authenticode_signing"></span><span id="AUTHENTICODE_SIGNING"></span>Authenticode Signing</span></span>
</dt> <dd>

<span data-ttu-id="f1488-225">Authenticode 是一種方法，可確保使用者收到的可執行檔、DLL 檔和 Windows installer 封裝 ( .msi 檔案) ，而不會改變開發人員所發行的內容。</span><span class="sxs-lookup"><span data-stu-id="f1488-225">Authenticode is a method of ensuring that executable files, DLL files, and Windows installer packages (.msi files) that the user receives are unaltered from what a developer released.</span></span> <span data-ttu-id="f1488-226">藉由使用密碼編譯原則、受信任實體和產業標準的組合，Authenticode 可驗證可執行內容的完整性。</span><span class="sxs-lookup"><span data-stu-id="f1488-226">By using a combination of cryptographic principles, trusted entities, and industry standards, Authenticode verifies the integrity of executable content.</span></span> <span data-ttu-id="f1488-227">Microsoft 提供密碼編譯 API CryptoAPI，可用來自動偵測已簽署程式碼的篡改。</span><span class="sxs-lookup"><span data-stu-id="f1488-227">Microsoft provides a cryptographic API, CryptoAPI, that can be used to auto-detect tampering of signed code.</span></span> <span data-ttu-id="f1488-228">如果在發行之後發生安全性漏洞，就可以撤銷憑證，並使用該憑證簽署的所有程式碼都會停止驗證。</span><span class="sxs-lookup"><span data-stu-id="f1488-228">If a security leak occurs after a release, a certificate can be revoked and all code signed with that certificate will stop authenticating.</span></span> <span data-ttu-id="f1488-229">撤銷憑證將會撤銷所有以該憑證簽署之標題的驗證。</span><span class="sxs-lookup"><span data-stu-id="f1488-229">Revoking a certificate will revoke the validation of all titles signed with that certificate.</span></span> <span data-ttu-id="f1488-230">Windows 的設計目的是要使用 Authenticode 簽章，並在特定情況下警示使用者未簽署的程式碼，這可能會使使用者的電腦遭受攻擊。</span><span class="sxs-lookup"><span data-stu-id="f1488-230">Windows has been designed to work with Authenticode signing and will alert a user of unsigned code, in specific situations, that could expose a user's PC to attack.</span></span>

<span data-ttu-id="f1488-231">Authenticode 不應被視為消除安全性問題的方法，而是在發行可執行檔之後偵測到的方法。</span><span class="sxs-lookup"><span data-stu-id="f1488-231">Authenticode should not be considered a method of eliminating security issues, but a method of detecting tampering after an executable has been released.</span></span> <span data-ttu-id="f1488-232">可執行檔或 DLL （包含可利用的安全性問題）可以使用 Authenticode 進行簽署和驗證，但仍然會對新系統造成安全性問題。</span><span class="sxs-lookup"><span data-stu-id="f1488-232">An executable or DLL that contains an exploitable security issue can be signed and verified using Authenticode, but it will still introduce the security issue to the new system.</span></span> <span data-ttu-id="f1488-233">只有在產品或更新已驗證為安全之後，才應該簽署程式碼，以確保使用者具有未遭篡改的版本。</span><span class="sxs-lookup"><span data-stu-id="f1488-233">Only after a product or update has been verified to be secure should the code be signed to assure users that they have a release that hasn't been tampered with.</span></span>

<span data-ttu-id="f1488-234">即使開發人員認為沒有修改其發行的威脅，其他技術和服務也會依賴 Authenticode。</span><span class="sxs-lookup"><span data-stu-id="f1488-234">Even if a developer feels that there is no threat of their releases being modified, other technologies and services rely on Authenticode.</span></span> <span data-ttu-id="f1488-235">程式碼簽署很容易整合和自動化;開發人員沒有任何理由會簽署其發行。</span><span class="sxs-lookup"><span data-stu-id="f1488-235">Code signing is easy to integrate and automate; there is no reason for developers to not have their releases signed.</span></span>

<span data-ttu-id="f1488-236">如需 Authenticode 簽署的詳細資訊，請參閱 [遊戲開發人員的 Authenticode 簽署](./authenticode-signing-for-game-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="f1488-236">For more information on Authenticode signing, see [Authenticode Signing for Game Developers](./authenticode-signing-for-game-developers.md).</span></span>

</dd> <dt>

<span data-ttu-id="f1488-237"><span id="Minimize_Privileges"></span><span id="minimize_privileges"></span><span id="MINIMIZE_PRIVILEGES"></span>最小化許可權</span><span class="sxs-lookup"><span data-stu-id="f1488-237"><span id="Minimize_Privileges"></span><span id="minimize_privileges"></span><span id="MINIMIZE_PRIVILEGES"></span>Minimize Privileges</span></span>
</dt> <dd>

<span data-ttu-id="f1488-238">一般程式應以操作所需的最低許可權集合來執行。</span><span class="sxs-lookup"><span data-stu-id="f1488-238">In general processes should run with the minimum set of privileges required to operate.</span></span> <span data-ttu-id="f1488-239">在 Windows Vista 和 Windows 7 上，您可以使用 [ [使用者帳戶控制](./user-account-control-for-game-developers.md)] 來完成這項作業，讓遊戲以標準使用者而非系統管理員的身分執行。</span><span class="sxs-lookup"><span data-stu-id="f1488-239">On Windows Vista and Windows 7, this is accomplished by using [User Account Control](./user-account-control-for-game-developers.md), allowing the game to run as a Standard User rather than an administrator.</span></span> <span data-ttu-id="f1488-240">針對 Windows XP，遊戲通常一律以系統管理員身分執行。</span><span class="sxs-lookup"><span data-stu-id="f1488-240">For Windows XP, typically games are always running as administrator.</span></span> <span data-ttu-id="f1488-241">即使是在 Windows Vista 和 Windows 7 上，有時也需要提高某些特定作業的完整系統管理員許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-241">Even on Windows Vista and Windows 7, it is sometimes necessary to elevate to full administrator rights for some specific operations.</span></span>

<span data-ttu-id="f1488-242">在以完整系統管理許可權執行進程的情況下，通常只需要標準使用者以外的一些許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-242">In the cases where the process is running with full administrative rights, usually only a few rights beyond those of a Standard User are actually required.</span></span> <span data-ttu-id="f1488-243">系統管理存取權包括合法程式碼不需要的許多許可權，但攻擊者可能會利用程式中的一些弱點。</span><span class="sxs-lookup"><span data-stu-id="f1488-243">Administrative access includes many rights that are not required by legitimate code, but could be used by an attacker, through some weakness in the process.</span></span> <span data-ttu-id="f1488-244">這類許可權的範例包括 SE \_ 取得 \_ 擁有權、se \_ DEBUG、se \_ 建立 \_ 權杖、se \_ ASSIGNPRIMARYTOKEN、SE \_ TCB、se \_ 安全性、SE \_ LOAD \_ 驅動程式、se \_ SYSTEMTIME、se \_ 備份、se \_ 還原、se \_ 關機和 se \_ AUDIT (查看許可權 [常數](../secauthz/privilege-constants.md)) 。</span><span class="sxs-lookup"><span data-stu-id="f1488-244">Examples of such rights include SE\_TAKE\_OWNERSHIP, SE\_DEBUG, SE\_CREATE\_TOKEN, SE\_ASSIGNPRIMARYTOKEN, SE\_TCB, SE\_SECURITY, SE\_LOAD\_DRIVER, SE\_SYSTEMTIME, SE\_BACKUP, SE\_RESTORE, SE\_SHUTDOWN, and SE\_AUDIT (see [Priviledge Constants](../secauthz/privilege-constants.md)).</span></span>

<span data-ttu-id="f1488-245">雖然處理常式在啟動之後無法獲得更多許可權，但它可以輕鬆地授與許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-245">While a process cannot gain more rights once started, it can easily give up rights.</span></span> <span data-ttu-id="f1488-246">在啟動時，進程可以立即使用 Win32 Api 來移除不需要的許可權。</span><span class="sxs-lookup"><span data-stu-id="f1488-246">At startup, the process can immediately use Win32 APIs to remove rights that it does not require.</span></span>

</dd> <dt>

<span data-ttu-id="f1488-247"><span id="Utilize_Windows_Security_Features"></span><span id="utilize_windows_security_features"></span><span id="UTILIZE_WINDOWS_SECURITY_FEATURES"></span>利用 Windows 安全性功能</span><span class="sxs-lookup"><span data-stu-id="f1488-247"><span id="Utilize_Windows_Security_Features"></span><span id="utilize_windows_security_features"></span><span id="UTILIZE_WINDOWS_SECURITY_FEATURES"></span>Utilize Windows Security Features</span></span>
</dt> <dd>

<span data-ttu-id="f1488-248">Windows Vista 和 Windows 7 包含許多可改善程式碼安全性的新功能。</span><span class="sxs-lookup"><span data-stu-id="f1488-248">Windows Vista and Windows 7 includes a number of new features that improve code security.</span></span> <span data-ttu-id="f1488-249">「[使用者帳戶控制](./user-account-control-for-game-developers.md)」當然是最重要的一項，也是最重要的功能，但還有其他功能。</span><span class="sxs-lookup"><span data-stu-id="f1488-249">[User Account Control](./user-account-control-for-game-developers.md) is certainly the most important one to understand and embrace, but there are other features as well.</span></span> <span data-ttu-id="f1488-250">除了 windows XP SP2 的技術（例如 Windows 防火牆、資料執行防止、緩衝區安全性檢查，以及安全的例外狀況處理常式，在 Windows Vista 和 Windows 7 上也有提供），還有三個要考慮的新安全性功能：</span><span class="sxs-lookup"><span data-stu-id="f1488-250">In addition to the Windows XP SP2 technologies, such as the Windows Firewall, Data Execution Prevention, Buffer Security Check, and Safe Exception Handlers which are also available on Windows Vista and Windows 7, there are three newer security features to consider:</span></span>

-   <span data-ttu-id="f1488-251">加入宣告位址空間配置隨機功能。</span><span class="sxs-lookup"><span data-stu-id="f1488-251">The opt-in Address Space Layout Randomization feature.</span></span> <span data-ttu-id="f1488-252">這是藉由連結 Visual Studio 2005 Service Pack 1 或 Visual Studio 2008 上的選項 **/DYNAMICBASE** 來啟用。</span><span class="sxs-lookup"><span data-stu-id="f1488-252">This is enabled by linking with the option **/DYNAMICBASE** on Visual Studio 2005 Service Pack 1 or Visual Studio 2008.</span></span> <span data-ttu-id="f1488-253">如此一來，系統就會在您的進程空間中隨機化許多重要系統 Dll 的位置，使其更難以撰寫可在網際網路上廣泛傳播的可攻擊攻擊程式。</span><span class="sxs-lookup"><span data-stu-id="f1488-253">This causes the system to randomize the positions of many of the key system DLLs in your process space, making it much more difficult to write exploitable attack programs that propagate broadly across the Internet.</span></span> <span data-ttu-id="f1488-254">Windows XP 和舊版的 Windows 會忽略此連結器旗標。</span><span class="sxs-lookup"><span data-stu-id="f1488-254">This linker flag is ignored by Windows XP and older versions of Windows.</span></span>
-   <span data-ttu-id="f1488-255">堆積損毀可能會導致整個類別的安全性漏洞，因此 Windows Vista 和 Windows 7 的記憶體系統現在支援在偵測到堆積損毀時終止進程的模式。</span><span class="sxs-lookup"><span data-stu-id="f1488-255">Heap corruption can lead to an entire class of security exploits, so the memory system of Windows Vista and Windows 7 now supports a mode which terminates the process if heap corruption is detected.</span></span> <span data-ttu-id="f1488-256">使用 **HeapEnableTermianteOnCorruption** 呼叫 [**HeapSetInformation**](/windows/win32/api/heapapi/nf-heapapi-heapsetinformation)時，將會加入宣告此行為。</span><span class="sxs-lookup"><span data-stu-id="f1488-256">Calling [**HeapSetInformation**](/windows/win32/api/heapapi/nf-heapapi-heapsetinformation) with **HeapEnableTermianteOnCorruption** will opt-in to this behavior.</span></span> <span data-ttu-id="f1488-257">在 Windows XP 和舊版的 Windows 上，此呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1488-257">This call fails on Windows XP and older version of Windows.</span></span>
-   <span data-ttu-id="f1488-258">撰寫服務時，可以使用新功能來設定這些服務，以指定實際需要的許可權，以及限制特定 SID 的資源存取權。</span><span class="sxs-lookup"><span data-stu-id="f1488-258">When writing services, they can be configured using a new feature to specify which privileges are actually required, as well as to limit resource access to a specific SID.</span></span> <span data-ttu-id="f1488-259">這是透過 [ChangeSeviceConfig2](/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2a)，使用服務設定 \_ \_ 所需的 \_ 許可權 \_ 資訊和服務設定 \_ \_ 服務 \_ SID \_ 資訊來完成。</span><span class="sxs-lookup"><span data-stu-id="f1488-259">This is done through [ChangeSeviceConfig2](/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2a), using SERVICE\_CONFIG\_REQUIRED\_PRIVILEGES\_INFO and SERVICE\_CONFIG\_SERVICE\_SID\_INFO.</span></span>

</dd> </dl>

## <a name="summary"></a><span data-ttu-id="f1488-260">總結</span><span class="sxs-lookup"><span data-stu-id="f1488-260">Summary</span></span>

<span data-ttu-id="f1488-261">為目前和未來的 marketplace 開發遊戲相當昂貴且耗時。</span><span class="sxs-lookup"><span data-stu-id="f1488-261">Developing a game for the current and future marketplace is costly and time consuming.</span></span> <span data-ttu-id="f1488-262">釋出含有安全性問題的遊戲，最終會產生更多的金錢和時間來妥善修正。</span><span class="sxs-lookup"><span data-stu-id="f1488-262">Releasing a game with security issues will ultimately cost more money and time to properly fix.</span></span> <span data-ttu-id="f1488-263">因此，所有遊戲開發人員都有興趣整合工具和技術，以在發行之前減輕安全性攻擊。</span><span class="sxs-lookup"><span data-stu-id="f1488-263">So, it is in the interests of all game developers to integrate tools and techniques to mitigate security exploits prior to release.</span></span>

<span data-ttu-id="f1488-264">這篇文章中的資訊只是開發 studio 為了協助自己和客戶而能做的簡介。</span><span class="sxs-lookup"><span data-stu-id="f1488-264">The information in this article is just an introduction to what a development studio can do to help themselves and their customers.</span></span> <span data-ttu-id="f1488-265">如需一般安全性作法和安全性資訊的詳細資訊，請參閱 [Microsoft 安全性開發人員中心](https://technet.microsoft.com/security/)。</span><span class="sxs-lookup"><span data-stu-id="f1488-265">More information of general security practices and security information can be found at [Microsoft Security Developer Center](https://technet.microsoft.com/security/).</span></span>

 

 