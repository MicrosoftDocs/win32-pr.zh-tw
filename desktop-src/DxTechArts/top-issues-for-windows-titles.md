---
title: Windows 標題的主要問題
description: 本文將重點放在目前產生的電腦遊戲中，我們看到了許多常見的問題。
ms.assetid: 89b83473-1aa9-9a2d-8778-15cfb91cdea4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 547c977f7d8e4895ef73ba229a9012854a7c6d27
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "107001284"
---
# <a name="top-issues-for-windows-titles"></a><span data-ttu-id="43b4c-103">Windows 標題的主要問題</span><span class="sxs-lookup"><span data-stu-id="43b4c-103">Top Issues for Windows Titles</span></span>

<span data-ttu-id="43b4c-104">Microsoft Windows 遊戲和圖形技術開發人員關係群組每年會執行許多 Windows 遊戲的效能分析。</span><span class="sxs-lookup"><span data-stu-id="43b4c-104">The Microsoft Windows Gaming and Graphics Technologies Developer Relations group performs performance analysis for many Windows games each year.</span></span> <span data-ttu-id="43b4c-105">在這些課程中，我們會取得實際操作體驗，以系結至每天收到的開發人員意見反應和查詢。</span><span class="sxs-lookup"><span data-stu-id="43b4c-105">During these sessions, we get hands-on experience to tie into the developer feedback and queries we receive daily.</span></span> <span data-ttu-id="43b4c-106">有時候我們會協助您追蹤標題中有神秘的損毀或其他問題，讓我們進一步瞭解開發人員遇到的問題。</span><span class="sxs-lookup"><span data-stu-id="43b4c-106">Occasionally we help track down a mysterious crash or other problem in a title, which gives us further insight into problems that developers are encountering.</span></span>

<span data-ttu-id="43b4c-107">本文將重點放在目前產生的電腦遊戲中，我們看到了許多常見的問題。</span><span class="sxs-lookup"><span data-stu-id="43b4c-107">This article highlights many of the common issues we've seen in current-generation PC games.</span></span>

-   [<span data-ttu-id="43b4c-108">CPU-有限效能</span><span class="sxs-lookup"><span data-stu-id="43b4c-108">CPU-Limited Performance</span></span>](#cpu-limited-performance)
-   [<span data-ttu-id="43b4c-109">不良的 Batch 管理</span><span class="sxs-lookup"><span data-stu-id="43b4c-109">Poor Batch Management</span></span>](#poor-batch-management)
-   [<span data-ttu-id="43b4c-110">記憶體複製過多</span><span class="sxs-lookup"><span data-stu-id="43b4c-110">Excessive Memory Copying</span></span>](#excessive-memory-copying)
-   [<span data-ttu-id="43b4c-111">過度使用動態繪圖提交</span><span class="sxs-lookup"><span data-stu-id="43b4c-111">Excessive Use of Dynamic Draw Submission</span></span>](#excessive-use-of-dynamic-draw-submission)
-   [<span data-ttu-id="43b4c-112">檔案處理的高度負擔</span><span class="sxs-lookup"><span data-stu-id="43b4c-112">High Overhead in File Processing</span></span>](#high-overhead-in-file-processing)
-   [<span data-ttu-id="43b4c-113">緩慢且挫折的安裝</span><span class="sxs-lookup"><span data-stu-id="43b4c-113">Slow and Frustrating Installation</span></span>](#slow-and-frustrating-installation)
-   [<span data-ttu-id="43b4c-114">缺乏實體記憶體的考慮</span><span class="sxs-lookup"><span data-stu-id="43b4c-114">Lack of Consideration of Physical Memory</span></span>](#lack-of-consideration-of-physical-memory)
-   [<span data-ttu-id="43b4c-115">過度依賴 Real-Time 音訊取樣率轉換</span><span class="sxs-lookup"><span data-stu-id="43b4c-115">Over-Reliance on Real-Time Audio Sample Rate Conversion</span></span>](#over-reliance-on-real-time-audio-sample-rate-conversion)
-   [<span data-ttu-id="43b4c-116">虛擬記憶體的分散程度</span><span class="sxs-lookup"><span data-stu-id="43b4c-116">Fragmention of Virtual Memory</span></span>](#fragmention-of-virtual-memory)
-   [<span data-ttu-id="43b4c-117">操作 Floating-Point 控制字組</span><span class="sxs-lookup"><span data-stu-id="43b4c-117">Manipulation of the Floating-Point Control Word</span></span>](#manipulation-of-the-floating-point-control-word)
-   [<span data-ttu-id="43b4c-118">選用的 DirectX 執行時間安裝</span><span class="sxs-lookup"><span data-stu-id="43b4c-118">Optional Installation of the DirectX Runtime</span></span>](#optional-installation-of-the-directx-runtime)
-   [<span data-ttu-id="43b4c-119">過度使用執行緒同步處理</span><span class="sxs-lookup"><span data-stu-id="43b4c-119">Excessive Use of Thread Synchronization</span></span>](#excessive-use-of-thread-synchronization)
-   [<span data-ttu-id="43b4c-120">使用 RDTSC</span><span class="sxs-lookup"><span data-stu-id="43b4c-120">Use of RDTSC</span></span>](#use-of-rdtsc)

## <a name="cpu-limited-performance"></a><span data-ttu-id="43b4c-121">CPU-Limited 效能</span><span class="sxs-lookup"><span data-stu-id="43b4c-121">CPU-Limited Performance</span></span>

<span data-ttu-id="43b4c-122">大部分的遊戲在具有高效能圖形處理器 (Gpu) 的系統上受到 CPU 效能的限制。</span><span class="sxs-lookup"><span data-stu-id="43b4c-122">The vast majority of games are limited by CPU performance on systems with high-performance graphics processing units (GPUs).</span></span> <span data-ttu-id="43b4c-123">這有時是因為對繪製提交使用批次處理不佳，但更常見的原因是其他遊戲系統耗用大量可用的 CPU 週期。</span><span class="sxs-lookup"><span data-stu-id="43b4c-123">This is sometimes due to poor use of batching for draw submissions, but more typically, this is due to other game systems consuming a large portion of the available CPU cycles.</span></span> <span data-ttu-id="43b4c-124">在我們已將 GPU 視為限制的幾種情況下，其原因是很高的填滿率或圖元著色器需求、高解析度設定，或視訊卡的低頂點著色器效能。</span><span class="sxs-lookup"><span data-stu-id="43b4c-124">In the few cases in which we have seen the GPU as the limitation, the cause is very high fill rates or pixel shader demand, in high-resolution settings, or low vertex-shader performance by a video card.</span></span>

<span data-ttu-id="43b4c-125">因為大部分的標題都有 CPU 限制，所以最大的效能獲勝來自于將需要大量 CPU 的遊戲系統優化。</span><span class="sxs-lookup"><span data-stu-id="43b4c-125">Because most titles are CPU-limited, the biggest performance wins come from optimizing CPU-intensive game systems.</span></span> <span data-ttu-id="43b4c-126">一般而言，AI 或物理系統以及相關聯的衝突偵測邏輯，是在正常運作的 Microsoft Direct3D 應用程式中，CPU 週期的主要取用者。</span><span class="sxs-lookup"><span data-stu-id="43b4c-126">Typically, the AI or physics systems and the associated collision-detection logic are the primary consumers of CPU cycles in well-behaving Microsoft Direct3D applications.</span></span> <span data-ttu-id="43b4c-127">改善這些系統的任何工作，都可以改善遊戲的整體效能。</span><span class="sxs-lookup"><span data-stu-id="43b4c-127">Any work to improve these systems can improve the overall performance of the game.</span></span>

## <a name="poor-batch-management"></a><span data-ttu-id="43b4c-128">不良的 Batch 管理</span><span class="sxs-lookup"><span data-stu-id="43b4c-128">Poor Batch Management</span></span>

<span data-ttu-id="43b4c-129">使用 GPU 達成良好的平行處理原則時，繪製批次必須包含足夠的幾何，而著色器有正確的複雜度，讓視訊卡保持忙碌，而不使用太多批次來處理命令緩衝區。</span><span class="sxs-lookup"><span data-stu-id="43b4c-129">Achieving good parallelism with the GPU requires that draw batches contain enough geometry — and the shaders have the right complexity — to keep the video card busy, while not using so many batches that the command buffer is flooded.</span></span> <span data-ttu-id="43b4c-130">在目前世代的硬體上，我們建議每個畫面上大約300或更少的繪圖批次提交 (較低效能的 Cpu) ，以防止驅動程式處理命令緩衝區成為效能瓶頸。</span><span class="sxs-lookup"><span data-stu-id="43b4c-130">On current-generation hardware, we recommend approximately 300 or fewer draw-batch submissions per frame (fewer on lower-performance CPUs) to prevent the driver's processing of the command-buffer from becoming a performance bottleneck.</span></span> <span data-ttu-id="43b4c-131">有些其他的 API 狀態呼叫和驅動程式組合可能會產生昂貴的 CPU 處理 (驅動程式編譯著色器，例如) ，因此強烈建議進行例行的效能分析。</span><span class="sxs-lookup"><span data-stu-id="43b4c-131">Some other API state calls and driver combinations can result in costly CPU processing (driver compiling of shaders, for example), so we highly recommend routine performance analysis.</span></span>

## <a name="excessive-memory-copying"></a><span data-ttu-id="43b4c-132">記憶體複製過多</span><span class="sxs-lookup"><span data-stu-id="43b4c-132">Excessive Memory Copying</span></span>

<span data-ttu-id="43b4c-133">在開發大部分的電腦標題期間，開發人員會使用方便的資料結構和字串進行內容管理。</span><span class="sxs-lookup"><span data-stu-id="43b4c-133">During the development of most PC titles, developers use convenient data structures and strings for content management.</span></span> <span data-ttu-id="43b4c-134">字串比較、複製和其他操作所需的 CPU 工作量通常具有可測量的額外負荷，尤其是在考慮與快取和記憶體子系統相關聯的效能點擊時。</span><span class="sxs-lookup"><span data-stu-id="43b4c-134">The CPU work required for string comparison, copying, and other manipulations often has a measurable overhead, particularly when taking into account the performance hits associated with the cache and memory subsystem.</span></span> <span data-ttu-id="43b4c-135">當產品進入主要測試和發行階段之後，在開發這些系統來移除或最小化依賴字串處理的情況時，應該進行規劃。</span><span class="sxs-lookup"><span data-stu-id="43b4c-135">Plans should be made when developing these systems for removing or minimizing the reliance on string processing once the product enters into the primary testing and release phases.</span></span>

## <a name="excessive-use-of-dynamic-draw-submission"></a><span data-ttu-id="43b4c-136">過度使用動態繪圖提交</span><span class="sxs-lookup"><span data-stu-id="43b4c-136">Excessive Use of Dynamic Draw Submission</span></span>

<span data-ttu-id="43b4c-137">新式的影片硬體在處理靜態資料時執行得很順利。</span><span class="sxs-lookup"><span data-stu-id="43b4c-137">Modern video hardware performs well when dealing with static data.</span></span> <span data-ttu-id="43b4c-138">高階介面卡通常會有非常大量的影片記憶體，但動態資料無法有效利用此記憶體。</span><span class="sxs-lookup"><span data-stu-id="43b4c-138">High-end adapters often have a very large amount of video memory, but this memory cannot be effectively utilized by dynamic data.</span></span>

<span data-ttu-id="43b4c-139">雖然動態頂點緩衝區/索引緩衝區的有效使用模式可以針對動態內容來執行，但許多標題仍會使用這種方法來進行靜態內容的其他用途。</span><span class="sxs-lookup"><span data-stu-id="43b4c-139">While reasonably efficient usage patterns of dynamic vertex buffers/index buffers can be implemented for dynamic content, many titles overuse this idiom for what is otherwise static content.</span></span> <span data-ttu-id="43b4c-140">我們最常看到的是二進位空間分割 (BSP) 樹狀結構和以入口網站為基礎的系統，這些系統會將幾何儲存在未對應至硬體的資料結構中，且必須針對每個畫面格處理到緩衝區。</span><span class="sxs-lookup"><span data-stu-id="43b4c-140">We most often see this with binary space partitioning (BSP) trees and portal-based systems that store geometry in a data structure that does not map to the hardware and must be processed into buffers for every frame.</span></span> <span data-ttu-id="43b4c-141">盡可能將最多的內容放入靜態資源，可大幅降低將資料傳送至視訊卡的頻寬負荷、更充分利用內部 VRAM，並減少處理此內容所涉及的 CPU/快取額外負荷。</span><span class="sxs-lookup"><span data-stu-id="43b4c-141">Putting as much content into static resources as possible can greatly reduce the bandwidth overhead of transferring data to the video card, make better use of on-board VRAM, and reduce the CPU/cache overhead involved in processing this content.</span></span>

## <a name="high-overhead-in-file-processing"></a><span data-ttu-id="43b4c-142">檔案處理的高度負擔</span><span class="sxs-lookup"><span data-stu-id="43b4c-142">High Overhead in File Processing</span></span>

<span data-ttu-id="43b4c-143">電腦遊戲已取得較長載入時間的信譽，特別是與具有嚴格載入時間需求的主控台標題相較之下。</span><span class="sxs-lookup"><span data-stu-id="43b4c-143">PC games have gotten a reputation for long loading times, particular when compared with console titles with strict loading-time requirements.</span></span> <span data-ttu-id="43b4c-144">我們對許多標題使用檔案子系統的方式進行分析，會顯示一些常見的問題。</span><span class="sxs-lookup"><span data-stu-id="43b4c-144">Our analysis of the way that many titles make use of the file subsystem reveals some common issues.</span></span>

<span data-ttu-id="43b4c-145">開啟檔案的額外負荷通常比開發人員預期更高。</span><span class="sxs-lookup"><span data-stu-id="43b4c-145">The overhead of opening a file is usually much higher than developers expect.</span></span> <span data-ttu-id="43b4c-146">利用廣泛使用的隨選病毒掃描程式和 NTFS 的額外功能，開啟檔案是相當昂貴的作業。</span><span class="sxs-lookup"><span data-stu-id="43b4c-146">With on-demand virus scanners in widespread use, and the additional functionality of NTFS, opening a file is a fairly expensive operation.</span></span> <span data-ttu-id="43b4c-147">一次開啟多個檔案或重複開啟和關閉相同的檔案，因此處理檔案管理的方法不佳。</span><span class="sxs-lookup"><span data-stu-id="43b4c-147">Opening many files at once or opening and closing the same file repeatedly is therefore a poor method of dealing with file management.</span></span> <span data-ttu-id="43b4c-148">有些遊戲試圖藉由在開啟檔案之前測試是否存在，來降低此效能成本。</span><span class="sxs-lookup"><span data-stu-id="43b4c-148">Some games have attempted to mitigate this performance cost by testing for the existence of a file before opening it.</span></span> <span data-ttu-id="43b4c-149">實際的情況是，測試檔案在 NTFS 上是否存在，需要開啟檔案，因此在開啟結果之前先進行測試，再將成本支付兩次。</span><span class="sxs-lookup"><span data-stu-id="43b4c-149">The reality is that testing for the existence of a file on NTFS requires opening the file, so testing before opening results in paying the cost twice.</span></span>

<span data-ttu-id="43b4c-150">如果遊戲允許附加元件的修改或 mods >，或仍包含開發架構來檢查覆寫資料檔案，可能會因為檢查這些檔案而造成載入遊戲的延遲，即使這些檔案不存在也一樣。</span><span class="sxs-lookup"><span data-stu-id="43b4c-150">Games that allow add-on modifications, or mods, or that still include development scaffolding to check for override data files, can have significant delays in loading the game because of checking for these files, even when those files are not present.</span></span> <span data-ttu-id="43b4c-151">建議遊戲在以特殊命令列參數或其他模式指標執行時，只檢查這些檔案，如此一來，只有使用這項功能的使用者才會實際支付這些 (的效能成本，通常會) 檢查。</span><span class="sxs-lookup"><span data-stu-id="43b4c-151">We recommend that games only check for these files when run with a special command-line switch, or other mode indicator, so that only those users who make use of this functionality actually pay the performance cost of these (often extensive) checks.</span></span>

<span data-ttu-id="43b4c-152">您可以從檔案系統取得額外的效能，如下所示：</span><span class="sxs-lookup"><span data-stu-id="43b4c-152">Additional performance can be obtained from the file system by the following:</span></span>

-   <span data-ttu-id="43b4c-153">適當使用檔案系統提示檔案旗標 \_ \_ 隨機 \_ 存取和檔案旗 \_ 標 \_ 順序 \_ 掃描</span><span class="sxs-lookup"><span data-stu-id="43b4c-153">Appropriate use of the file system hints FILE\_FLAG\_RANDOM\_ACCESS and FILE\_FLAG\_SEQUENTIAL\_SCAN</span></span>
-   <span data-ttu-id="43b4c-154">調整緩衝區大小，以避免對作業系統的讀取/寫入 Api 進行大量呼叫</span><span class="sxs-lookup"><span data-stu-id="43b4c-154">Sizing buffers to avoid a large quantity of calls to the read/write APIs of the OS</span></span>
-   <span data-ttu-id="43b4c-155">以非同步方式存取檔案</span><span class="sxs-lookup"><span data-stu-id="43b4c-155">Accessing files asynchronously</span></span>
-   <span data-ttu-id="43b4c-156">在背景載入執行緒</span><span class="sxs-lookup"><span data-stu-id="43b4c-156">Loading threads in the background</span></span>

<span data-ttu-id="43b4c-157">我們也強烈建議在組建或安裝期間將資料離線 (轉換) 而不是在第一次執行遊戲時依賴轉換，因為這樣做會為每位使用者帶來明顯的效能稅金。</span><span class="sxs-lookup"><span data-stu-id="43b4c-157">We also strongly recommend converting data offline (at build or installation time) rather than relying on conversion when the game is first run, as doing so imposes a significant performance tax for every user.</span></span>

## <a name="slow-and-frustrating-installation"></a><span data-ttu-id="43b4c-158">緩慢且挫折的安裝</span><span class="sxs-lookup"><span data-stu-id="43b4c-158">Slow and Frustrating Installation</span></span>

<span data-ttu-id="43b4c-159">我們看到的另一個常見問題是許多新式電腦遊戲所需的安裝時間很長。</span><span class="sxs-lookup"><span data-stu-id="43b4c-159">Another common issue we've seen is very long installation times required for many modern PC games.</span></span> <span data-ttu-id="43b4c-160">安裝程式會提示使用者許多次，有時候只是告訴使用者，例如「您不需要安裝 DirectX」。</span><span class="sxs-lookup"><span data-stu-id="43b4c-160">The installers prompt the user many times, sometimes simply to tell the user, for example, "You do not need DirectX installed."</span></span> <span data-ttu-id="43b4c-161">一般而言，這些違規的安裝程式需要使用者在安裝遊戲之前，先選取 **[下一步** **] 或 [確定]** ，然後才開始安裝遊戲。</span><span class="sxs-lookup"><span data-stu-id="43b4c-161">Generally, these offending installers require the user to select **Next** or **OK** many times before installation of the game actually begins.</span></span> <span data-ttu-id="43b4c-162">開始之後，我們看過一些標題需要一小時或更長的時間，使用者才會獲得播放遊戲的機會。</span><span class="sxs-lookup"><span data-stu-id="43b4c-162">Once it does begin, we've seen some titles take an hour or more before the user gets the opportunity to play the game.</span></span> <span data-ttu-id="43b4c-163">我們強烈認為遊戲播放體驗的第一個小時不應該是安裝。</span><span class="sxs-lookup"><span data-stu-id="43b4c-163">We feel strongly that the first hour of game play experience should not be the installation.</span></span>

<span data-ttu-id="43b4c-164">我們建議使用許多方法來處理安裝。</span><span class="sxs-lookup"><span data-stu-id="43b4c-164">We recommend a number of approaches for dealing with installation.</span></span> <span data-ttu-id="43b4c-165">首先，讓提示保持簡單且最小。</span><span class="sxs-lookup"><span data-stu-id="43b4c-165">First, keep the prompts simple and to a minimum.</span></span> <span data-ttu-id="43b4c-166">其次，架構您的遊戲資料，讓部分或全部資料檔案可以在可能的情況下直接從散發磁片使用—新式 DVD 光碟機的頻寬非常高。</span><span class="sxs-lookup"><span data-stu-id="43b4c-166">Second, architect your game data such that some or all the data files can be used directly from the distribution disk where possible — modern DVD drives have very high bandwidth.</span></span> <span data-ttu-id="43b4c-167">第三，請考慮在您的標題中執行隨選安裝，以減少或消除安裝程式，並讓使用者能夠儘快進入遊戲中。</span><span class="sxs-lookup"><span data-stu-id="43b4c-167">Third, consider implementing install-on-demand in your titles to reduce or eliminate the installation process and allow users to get into the game as quickly as possible.</span></span> <span data-ttu-id="43b4c-168"> (如需安裝隨選安裝的詳細資訊，請參閱 [適用于遊戲的隨選安裝](/windows/desktop/DxTechArts/install-on-demand-for-games)。 ) </span><span class="sxs-lookup"><span data-stu-id="43b4c-168">(For more information about installing on demand, see [Install-on-Demand for Games](/windows/desktop/DxTechArts/install-on-demand-for-games).)</span></span>

<span data-ttu-id="43b4c-169">如需更多關於遊戲安裝的建議，請參閱 [簡化遊戲安裝](/windows/desktop/DxTechArts/simplifying-game-installation)。</span><span class="sxs-lookup"><span data-stu-id="43b4c-169">For more recommendations about game installation, see [Simplifying Game Installation](/windows/desktop/DxTechArts/simplifying-game-installation).</span></span>

## <a name="lack-of-consideration-of-physical-memory"></a><span data-ttu-id="43b4c-170">缺乏實體記憶體的考慮</span><span class="sxs-lookup"><span data-stu-id="43b4c-170">Lack of Consideration of Physical Memory</span></span>

<span data-ttu-id="43b4c-171">由於市場上的電腦硬體有各式各樣的變化，因此標題通常會使用臨機操作設定測試來選取圖形詳細資料層級的預設設定。</span><span class="sxs-lookup"><span data-stu-id="43b4c-171">Because of the wide variability of PC hardware in the market, titles typically make use of ad hoc configuration tests to select default settings for the level of graphical detail.</span></span> <span data-ttu-id="43b4c-172">我們看到的部分標題是在這些測試中使用影片記憶體大小，但無法使其與實體記憶體大小產生關聯。</span><span class="sxs-lookup"><span data-stu-id="43b4c-172">Some of the titles we've seen are using video memory size in these tests, but failing to correlate this with physical memory size.</span></span> <span data-ttu-id="43b4c-173">為了處理遺失裝置的狀況，大部分的視訊記憶體 (卡上的本機 VRAM 和非本機的 AGP 記憶體光圈) 都必須透過使用受控資源或自訂資料結構，由實體記憶體支援。</span><span class="sxs-lookup"><span data-stu-id="43b4c-173">In order to handle lost-device situations, the majority of the video memory (both local VRAM on the card and the non-local AGP memory aperture) must be backed by physical memory, either through the use of managed resources or custom data structures.</span></span> <span data-ttu-id="43b4c-174">某些高階視訊卡的 VRAM 大小 rivaling 低終端 CPU 記憶的大小。</span><span class="sxs-lookup"><span data-stu-id="43b4c-174">Some high-end video cards have VRAM sizes rivaling the size of low-end CPU memories.</span></span> <span data-ttu-id="43b4c-175">相較于視訊卡，系統的實體記憶體有限，大部分的 VRAM 都無法有效使用，且應設定較低的詳細設定。</span><span class="sxs-lookup"><span data-stu-id="43b4c-175">In situations where the system has limited physical memory compared to the video card, most of that VRAM cannot be effectively utilized, and lower detail settings should be configured.</span></span>

## <a name="over-reliance-on-real-time-audio-sample-rate-conversion"></a><span data-ttu-id="43b4c-176">Real-Time 音訊取樣率轉換 Over-Reliance</span><span class="sxs-lookup"><span data-stu-id="43b4c-176">Over-Reliance on Real-Time Audio Sample Rate Conversion</span></span>

<span data-ttu-id="43b4c-177">當音訊系統必須在混合到硬體緩衝區期間轉換播放速率時，就會看到另一個常見的 CPU 週期燒錄來源。</span><span class="sxs-lookup"><span data-stu-id="43b4c-177">Another common source of CPU cycle burn we've seen occurs when the audio system is required to convert the playback rate during mix into the hardware buffer.</span></span> <span data-ttu-id="43b4c-178">使用 Windows Driver Model (WDM) 驅動程式時，硬體緩衝區格式不受直接應用程式控制，因為它是核心層級的資源;相反地，會根據所有來源的最高品質格式以及硬體的功能，來選取格式。</span><span class="sxs-lookup"><span data-stu-id="43b4c-178">With Windows Driver Model (WDM) drivers, the hardware buffer format is not under direct application control, because it is a kernel-level resource; instead, the format is selected based on the highest-quality format of all sources and the capabilities of the hardware.</span></span> <span data-ttu-id="43b4c-179">根據預設，Windows XP 會針對此程式使用高品質的取樣率轉換，而且如果大部分的音訊範例都需要速率轉換，則會耗用 CPU 週期的重要部分。</span><span class="sxs-lookup"><span data-stu-id="43b4c-179">By default, Windows XP uses a high-quality sample rate conversion for this process, and if the majority of the audio samples require a rate conversion, a significant portion of the CPU cycles will be consumed.</span></span>

<span data-ttu-id="43b4c-180">建議您使用相同的取樣率來建立所有 DirectSound 緩衝區。</span><span class="sxs-lookup"><span data-stu-id="43b4c-180">We recommend creating all of your DirectSound buffers with the same sample rate.</span></span> <span data-ttu-id="43b4c-181">如果您使用 Microsoft Win32 **waveOut** 函式，您也應該使用一致的取樣率。</span><span class="sxs-lookup"><span data-stu-id="43b4c-181">If you make any use of Microsoft Win32 **waveOut** functions, you should use a consistent sample rate with these, too.</span></span> <span data-ttu-id="43b4c-182">使用 WDM 驅動程式時，核心會將緩衝區全部混合，而如果您對某些緩衝區使用較高的取樣率，則所有其餘部分的取樣率將會轉換成相符的。</span><span class="sxs-lookup"><span data-stu-id="43b4c-182">With WDM drivers, the buffers will all be mixed by the kernel, and if you use a higher sampling rate on some of them, the sample rates of all of the rest will be converted to match.</span></span> <span data-ttu-id="43b4c-183">請注意，這表示所有音訊範例都使用相同的播放速率，包括任何串流音訊解壓縮緩衝區。</span><span class="sxs-lookup"><span data-stu-id="43b4c-183">Note that this implies using the same playback rate for all your audio samples, including any streaming audio decompression buffers.</span></span> <span data-ttu-id="43b4c-184">除非您的目標是 Windows 98 或 Windows Millennium Edition，否則設定主要緩衝區速率不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="43b4c-184">Setting the primary buffer rate has no effect unless you are targeting either Windows 98 or Windows Millennium Edition.</span></span>

> [!Note]  
> <span data-ttu-id="43b4c-185">在 Windows Vista 和更新版本的作業系統上，DirectSound 和 **waveOut** 會針對所有音訊輸出使用 [WINDOWS 音訊會話 API (WASAPI)](/windows/desktop/CoreAudio/wasapi) 。</span><span class="sxs-lookup"><span data-stu-id="43b4c-185">On Windows Vista and later versions of the operating system, DirectSound and **waveOut** use the [Windows Audio Session API (WASAPI)](/windows/desktop/CoreAudio/wasapi) for all audio output.</span></span>

 

## <a name="fragmention-of-virtual-memory"></a><span data-ttu-id="43b4c-186">虛擬記憶體的分散程度</span><span class="sxs-lookup"><span data-stu-id="43b4c-186">Fragmention of Virtual Memory</span></span>

<span data-ttu-id="43b4c-187">我們已在處理常式記憶體空間上看到許多與32位限制相關的最新問題。</span><span class="sxs-lookup"><span data-stu-id="43b4c-187">We've seen a number of recent issues related to the 32-bit limit on process memory space.</span></span> <span data-ttu-id="43b4c-188">雖然使用者模式進程的 2 GB 虛擬位址空間已超過一段時間，但增加了大型記憶體對應檔的使用、自訂記憶體配置器，以及增加 VRAM 大小 (必須對應到進程) 空間，才能導致虛擬記憶體空間配置失敗的情況。</span><span class="sxs-lookup"><span data-stu-id="43b4c-188">While 2 GB of virtual address space for user-mode processes has been more than adequate historically, the increased use of large memory-mapped files, custom memory allocators, and increasing VRAM size (which must be mapped into process space) has started to cause situations where allocations of virtual memory space are failing.</span></span> <span data-ttu-id="43b4c-189">某些非 Microsoft Dll 會在虛擬位址空間的中間使用固定的位置，這會導致產生失敗的分配。</span><span class="sxs-lookup"><span data-stu-id="43b4c-189">Some non-Microsoft DLLs are using fixed-start locations in the middle of the virtual address space, which is causing fragmentation that results in failed allocations.</span></span>

<span data-ttu-id="43b4c-190">當遊戲利用自訂記憶體配置配置來嘗試配置大型連續的虛擬記憶體空間時，最常出現這些問題。</span><span class="sxs-lookup"><span data-stu-id="43b4c-190">These problems most often appear when the game makes use of a custom memory allocation scheme that attempts to allocate a large continuous chunk of virtual memory space.</span></span> <span data-ttu-id="43b4c-191">我們的建議是撰寫配置器，讓它們視需要要求更合理大小的虛擬位址空間部分。</span><span class="sxs-lookup"><span data-stu-id="43b4c-191">Our recommendation is to write allocators such that they request more reasonably sized portions of the virtual address space as needed.</span></span> <span data-ttu-id="43b4c-192">例如，一次要求64或 256 MB，但不是 1 GB。</span><span class="sxs-lookup"><span data-stu-id="43b4c-192">For example, requesting 64 or 256 MB at a time, but not 1 GB.</span></span> <span data-ttu-id="43b4c-193">不過，請務必小心，不要造成進一步的片段。</span><span class="sxs-lookup"><span data-stu-id="43b4c-193">However, care should be taken to not cause further fragmentation.</span></span> <span data-ttu-id="43b4c-194">64位作業系統和硬體的問世將大幅説明這些問題，但必須特別注意目前的32位系統。</span><span class="sxs-lookup"><span data-stu-id="43b4c-194">The advent of 64-bit operating systems and hardware will greatly help these issues in the future, but care must be taken on current-generation 32-bit systems.</span></span>

## <a name="manipulation-of-the-floating-point-control-word"></a><span data-ttu-id="43b4c-195">操作 Floating-Point 控制字組</span><span class="sxs-lookup"><span data-stu-id="43b4c-195">Manipulation of the Floating-Point Control Word</span></span>

<span data-ttu-id="43b4c-196">在偵錯工具中，某些開發人員已透過浮點控制字組的操作，在浮點單位上啟用例外狀況 (FPU) 。</span><span class="sxs-lookup"><span data-stu-id="43b4c-196">As a debugging aid, some developers have been enabling exceptions on the floating-point unit (FPU) via manipulations of the floating-point control word.</span></span> <span data-ttu-id="43b4c-197">這麼做會造成極大的問題，而且可能會導致程式損毀。</span><span class="sxs-lookup"><span data-stu-id="43b4c-197">Doing this is highly problematic and will likely cause the process to crash.</span></span> <span data-ttu-id="43b4c-198">就像呼叫慣例一樣，系統會要求保留 ebx 登錄，而大部分的系統都會假設 FPU 處於預設狀態，將會提供合理的結果，而不會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="43b4c-198">Just like the calling convention requires that the ebx register be preserved, the majority of the system assumes that the FPU is in a default state, will give reasonable results, and won't generate exceptions.</span></span> <span data-ttu-id="43b4c-199">驅動程式和其他系統元件通常會根據假設在暫存器中出現不正確狀況的標準錯誤值來計算結果，但如果已啟用例外狀況，這些將會被未處理，並導致損毀。</span><span class="sxs-lookup"><span data-stu-id="43b4c-199">Drivers and other system components will often compute results based on the assumption that standard error values will appear in the registers for bad conditions, but if exceptions are enabled, these will go unhandled and result in crashes.</span></span>

<span data-ttu-id="43b4c-200">除非使用 D3DCREATE FPU PRESERVE 旗標，否則 Direct3D 會將浮點單位設為單精確度浮點數，並將其四捨五入為最接近的初始設定，除非使用了 \_ FPU \_ PRESERVE 旗標，在這種情況下，浮點控制字組會維持不變。</span><span class="sxs-lookup"><span data-stu-id="43b4c-200">Direct3D will set the floating-point unit to single-precision, round-to-nearest as part of initialization for the calling thread, unless the D3DCREATE\_FPU\_PRESERVE flag is used, in which case, the floating-point control word is untouched.</span></span> <span data-ttu-id="43b4c-201">因為控制字組是每個執行緒的設定，所以確保所有應用程式執行緒都設定為單精確度模式，可能會將效能優化。</span><span class="sxs-lookup"><span data-stu-id="43b4c-201">Since the control word is a per-thread setting, ensuring that all of your application threads are set to single-precision mode may optimize performance.</span></span> <span data-ttu-id="43b4c-202">請記住，呼叫 [**\_ control87**](https://msdn.microsoft.com/library/e9b52ceh(v=VS.71).aspx)對 x64 原生程式碼而言是不正確，它會改為使用 SSE，而且在 Xbox 360 CPU 的 PowerPC 架構架構上相當昂貴。</span><span class="sxs-lookup"><span data-stu-id="43b4c-202">Remember that calling [**\_control87**](https://msdn.microsoft.com/library/e9b52ceh(v=VS.71).aspx) is not valid for x64-native coding, which uses SSE exclusively instead, and it is extremely expensive on the PowerPC-based architecture of the Xbox 360 CPU.</span></span>

> [!Note]  
> <span data-ttu-id="43b4c-203">如果您修改了控制字組，請使用 [**\_ controlfp \_**](https://msdn.microsoft.com/library/c9676k6h(v=VS.80).aspx) ，請注意，對於 x64 平臺，您無法透過控制字組變更浮點精確度。</span><span class="sxs-lookup"><span data-stu-id="43b4c-203">If you modify the control word, use [**\_controlfp\_s**](https://msdn.microsoft.com/library/c9676k6h(v=VS.80).aspx) and be aware that for x64 platforms you can't change the floating-point precision via the control word.</span></span>

 

<span data-ttu-id="43b4c-204">在需要不同舍入規則或其他行為的任何程式庫中（例如處理軟體頂點著色器或編譯），我們會儲存並還原控制字組。</span><span class="sxs-lookup"><span data-stu-id="43b4c-204">In any libraries where we need to have different rounding rules or other behavior — such as dealing with software vertex shaders or compilation — we save and restore the control word.</span></span> <span data-ttu-id="43b4c-205">如果遊戲需要使用非標準的舍入或 FPU 例外狀況，它應該儲存並還原浮點控制字組，您應該確定它不會呼叫未經過證實的任何外部程式碼，而不會受到這些問題的保護，包括系統 Api。</span><span class="sxs-lookup"><span data-stu-id="43b4c-205">If a game needs to make use of non-standard rounding or FPU exceptions, it should save and restore the floating-point control word, and you should be sure that it does not call any external code that has not been proven to be safe from these problems, including system APIs.</span></span>

## <a name="optional-installation-of-the-directx-runtime"></a><span data-ttu-id="43b4c-206">選用的 DirectX 執行時間安裝</span><span class="sxs-lookup"><span data-stu-id="43b4c-206">Optional Installation of the DirectX Runtime</span></span>

<span data-ttu-id="43b4c-207">許多遊戲會詢問使用者是否要安裝 DirectX。</span><span class="sxs-lookup"><span data-stu-id="43b4c-207">A number of games ask the user whether to install DirectX.</span></span> <span data-ttu-id="43b4c-208">如果使用者假設系統已安裝最新的 DirectX 可轉散發套件並跳過安裝，則這可能會導致問題，並在後續安裝成功時繼續進行。</span><span class="sxs-lookup"><span data-stu-id="43b4c-208">This can cause problems if the user assumes that the system has the latest DirectX redistributable installed and skips installation, and subsequently, the installation continues successfully.</span></span> <span data-ttu-id="43b4c-209">如果遊戲需要特定版本的 D3DX 或其他未安裝的更新功能，遊戲將無法運作，且使用者將會感到非常挫折。</span><span class="sxs-lookup"><span data-stu-id="43b4c-209">If the game requires a specific version of D3DX, or other updated functionality that was not installed, then the game won't work, and the user will get very frustrated.</span></span>

<span data-ttu-id="43b4c-210">強烈建議遊戲的安裝程式以無訊息模式安裝遊戲所建立的 DirectX 可轉散發套件。</span><span class="sxs-lookup"><span data-stu-id="43b4c-210">It is strongly recommended that the game's installer silently install the DirectX redistributable that the game was built against.</span></span> <span data-ttu-id="43b4c-211">DirectX 安裝程式的設計目的，是要驗證是否需要更新任何事項，並在不需要時快速傳回。</span><span class="sxs-lookup"><span data-stu-id="43b4c-211">The DirectX installation process is designed so that it verifies whether anything needs to be updated and quickly returns if it doesn't.</span></span> <span data-ttu-id="43b4c-212">因此，不需要要求使用者安裝 DirectX。</span><span class="sxs-lookup"><span data-stu-id="43b4c-212">So, there is no need to ask the user about installing DirectX.</span></span>

<span data-ttu-id="43b4c-213">您可以從安裝套件執行此命令來完成 DirectX 的無訊息安裝： **dxsetup.exe/silent**</span><span class="sxs-lookup"><span data-stu-id="43b4c-213">A silent installation of DirectX can be done by running this command from your installation package: **dxsetup.exe /silent**</span></span>

<span data-ttu-id="43b4c-214">此外，可轉散發資料夾的實際大小可設定為僅包含遊戲的目標平臺和使用方式所需的封包檔 ( .cab) 。</span><span class="sxs-lookup"><span data-stu-id="43b4c-214">Furthermore, the actual size of the redistributable folder can be configured to include only those cabinet files (.cab) that are actually needed for the game's target platforms and usage.</span></span>

> [!Note]  
> <span data-ttu-id="43b4c-215">在使用 **dxsetup** 之前，請先閱讀 [ [不要直接設定](https://walbourn.github.io/)]。</span><span class="sxs-lookup"><span data-stu-id="43b4c-215">Before you use **dxsetup**, read [Not So Direct Setup](https://walbourn.github.io/).</span></span>

 

## <a name="excessive-use-of-thread-synchronization"></a><span data-ttu-id="43b4c-216">過度使用執行緒同步處理</span><span class="sxs-lookup"><span data-stu-id="43b4c-216">Excessive Use of Thread Synchronization</span></span>

<span data-ttu-id="43b4c-217">分析遊戲時，常見的熱點通常會與進入和離開重要區段有關。</span><span class="sxs-lookup"><span data-stu-id="43b4c-217">When profiling games, the top hotspots are often found to be related to entering and leaving critical sections.</span></span> <span data-ttu-id="43b4c-218">隨著多核心 Cpu 的普及，在遊戲中使用多執行緒的方式大幅增加，而許多執行都依賴大量的執行緒同步處理。</span><span class="sxs-lookup"><span data-stu-id="43b4c-218">With the prevalence of multi-core CPUs, the use of multithreading in games has increased dramatically, and many implementations rely on heavy use of thread synchronization.</span></span> <span data-ttu-id="43b4c-219">即使沒有爭用的情況下，要採取重要區段的 CPU 時間很重要，而所有其他形式的執行緒同步處理也會更昂貴。</span><span class="sxs-lookup"><span data-stu-id="43b4c-219">The CPU time to take a critical section even without any contention is quite significant, and all other forms of thread synchronization are even more expensive.</span></span> <span data-ttu-id="43b4c-220">因此，必須小心將這些基本專案的使用降至最低。</span><span class="sxs-lookup"><span data-stu-id="43b4c-220">So, care must be taken to minimize the use of these primitives.</span></span>

<span data-ttu-id="43b4c-221">遊戲中過度同步處理的常見來源，是使用 [D3DCREATE \_ 多執行緒](/windows/desktop/direct3d9/d3dcreate)。</span><span class="sxs-lookup"><span data-stu-id="43b4c-221">A common source of excessive synchronization in games is the use of [D3DCREATE\_MULTITHREADED](/windows/desktop/direct3d9/d3dcreate).</span></span> <span data-ttu-id="43b4c-222">此旗標雖然讓 Direct3D 執行緒安全可從多個執行緒進行轉譯，但卻是非常保守的方法，因此會產生高度的同步處理負荷。</span><span class="sxs-lookup"><span data-stu-id="43b4c-222">This flag, while making Direct3D thread-safe for rendering from multiple threads, takes a very conservative approach, resulting in high synchronization overhead.</span></span> <span data-ttu-id="43b4c-223">遊戲應避免此旗標。</span><span class="sxs-lookup"><span data-stu-id="43b4c-223">Games should avoid this flag.</span></span> <span data-ttu-id="43b4c-224">改為建立引擎的架構，讓所有與 Direct3D 的通訊都是來自單一線程，而執行緒之間的任何通訊都會直接處理。</span><span class="sxs-lookup"><span data-stu-id="43b4c-224">Instead, architect the engine so that all communication with Direct3D is from a single thread and any communication between threads is handled directly.</span></span> <span data-ttu-id="43b4c-225">如需設計多執行緒遊戲的詳細資訊，請參閱 [Xbox 360 和 Microsoft Windows 上的多個核心的編碼](/windows/desktop/DxTechArts/coding-for-multiple-cores)文章。</span><span class="sxs-lookup"><span data-stu-id="43b4c-225">For more information about designing multi-threaded games, see the article [Coding For Multiple Cores on Xbox 360 and Microsoft Windows](/windows/desktop/DxTechArts/coding-for-multiple-cores).</span></span>

## <a name="use-of-rdtsc"></a><span data-ttu-id="43b4c-226">使用 RDTSC</span><span class="sxs-lookup"><span data-stu-id="43b4c-226">Use of RDTSC</span></span>

<span data-ttu-id="43b4c-227">不建議使用 x86 指令 **RDTSC** 。</span><span class="sxs-lookup"><span data-stu-id="43b4c-227">Use of the x86 instruction **RDTSC** is not recommended.</span></span> <span data-ttu-id="43b4c-228">**RDTSC** 無法在某些電源管理配置上正確計算時間，以動態方式變更 CPU 頻率，並在許多多核心 cpu 上，不會在核心之間同步處理迴圈計數器。</span><span class="sxs-lookup"><span data-stu-id="43b4c-228">**RDTSC** fails to correctly compute timing on some power management schemes that change the CPU frequency dynamically and on many multi-core CPUs for which the cycle counter is not synchronized between cores.</span></span> <span data-ttu-id="43b4c-229">遊戲應改為使用 [**QueryPerformanceCounter**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter) API。</span><span class="sxs-lookup"><span data-stu-id="43b4c-229">Games should instead use the [**QueryPerformanceCounter**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter) API.</span></span> <span data-ttu-id="43b4c-230">如需有關 **RDTSC** 的問題，以及使用 **QueryPerformanceCounter** 來執行高解析度計時的詳細資訊，請參閱 [遊戲計時和多核心處理器](/windows/desktop/DxTechArts/game-timing-and-multicore-processors)一文。</span><span class="sxs-lookup"><span data-stu-id="43b4c-230">For more information about issues with **RDTSC** and implementing high-resolution timing with **QueryPerformanceCounter**, see the article [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>

 

 