---
title: 利用 High-Definition 滑鼠移動
description: 本文著重于將遊戲中的高定義滑鼠輸入效能優化的最佳方式，例如第一個人的射擊。
ms.assetid: 0138a248-e8e0-a392-564e-7a9229b94b56
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7ebe2abd9487d95b8fe12aa3c6938e21d72d8e2f
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104376080"
---
# <a name="taking-advantage-of-high-definition-mouse-movement"></a><span data-ttu-id="05d69-103">利用 High-Definition 滑鼠移動</span><span class="sxs-lookup"><span data-stu-id="05d69-103">Taking Advantage of High-Definition Mouse Movement</span></span>

<span data-ttu-id="05d69-104">標準電腦滑鼠以每英寸400點傳回資料 (DPI) ，而高定義的滑鼠會在 800 DPI 或更高的時間產生資料。</span><span class="sxs-lookup"><span data-stu-id="05d69-104">A standard computer mouse returns data at 400 dots per inch (DPI), whereas a high-definition mouse generates data at 800 DPI or greater.</span></span> <span data-ttu-id="05d69-105">如此一來，來自高定義滑鼠的輸入會比標準滑鼠更精確。</span><span class="sxs-lookup"><span data-stu-id="05d69-105">This makes input from a high-definition mouse much more precise than that from a standard mouse.</span></span> <span data-ttu-id="05d69-106">但是，無法透過標準的 WM MOUSEMOVE 訊息取得高定義資料 \_ 。</span><span class="sxs-lookup"><span data-stu-id="05d69-106">However, high-definition data cannot be obtained through the standard WM\_MOUSEMOVE messages.</span></span> <span data-ttu-id="05d69-107">一般情況下，遊戲將會從高定義的滑鼠裝置獲益，但只使用 WM MOUSEMOVE 取得滑鼠資料的遊戲將無法 \_ 存取完整、未篩選的滑鼠解析度。</span><span class="sxs-lookup"><span data-stu-id="05d69-107">In general, games will benefit from high-definition mouse devices but games that obtain mouse data using just WM\_MOUSEMOVE won't be able to access the full, unfiltered resolution of the mouse.</span></span>

<span data-ttu-id="05d69-108">許多公司都是製造高定義的滑鼠裝置，例如 Microsoft 和 Logitech。</span><span class="sxs-lookup"><span data-stu-id="05d69-108">A number of companies are manufacturing high-definition mouse devices, such as Microsoft and Logitech.</span></span> <span data-ttu-id="05d69-109">隨著高解析度的滑鼠裝置越來越普及，開發人員必須瞭解如何以最佳方式使用這些裝置所產生的資訊。</span><span class="sxs-lookup"><span data-stu-id="05d69-109">With the increasing popularity of high-resolution mouse devices, it is important that developers understand how to use the information generated by these devices optimally.</span></span> <span data-ttu-id="05d69-110">本文著重于將遊戲中的高定義滑鼠輸入效能優化的最佳方式，例如第一個人的射擊。</span><span class="sxs-lookup"><span data-stu-id="05d69-110">This article focuses on the best way to optimize the performance of high-definition mouse input in a game like a first-person shooter.</span></span>

## <a name="retrieving-mouse-movement-data"></a><span data-ttu-id="05d69-111">正在抓取滑鼠移動資料</span><span class="sxs-lookup"><span data-stu-id="05d69-111">Retrieving Mouse Movement Data</span></span>

<span data-ttu-id="05d69-112">以下是用來取出滑鼠資料的三種主要方法：</span><span class="sxs-lookup"><span data-stu-id="05d69-112">Here are the three primary methods to retrieve mouse data:</span></span>

-   [<span data-ttu-id="05d69-113">WM \_ MOUSEMOVE</span><span class="sxs-lookup"><span data-stu-id="05d69-113">WM\_MOUSEMOVE</span></span>](/windows)
-   [<span data-ttu-id="05d69-114">WM \_ 輸入</span><span class="sxs-lookup"><span data-stu-id="05d69-114">WM\_INPUT</span></span>](/windows)
-   [<span data-ttu-id="05d69-115">DirectInput</span><span class="sxs-lookup"><span data-stu-id="05d69-115">DirectInput</span></span>](#directinput)

<span data-ttu-id="05d69-116">每種方法都有其優點和缺點，視資料的使用方式而定。</span><span class="sxs-lookup"><span data-stu-id="05d69-116">There are advantages and disadvantages to each method, depending on how the data will be used.</span></span>

### <a name="wm_mousemove"></a><span data-ttu-id="05d69-117">WM \_ MOUSEMOVE</span><span class="sxs-lookup"><span data-stu-id="05d69-117">WM\_MOUSEMOVE</span></span>

<span data-ttu-id="05d69-118">讀取滑鼠移動資料最簡單的方法是透過 WM \_ MOUSEMOVE 訊息。</span><span class="sxs-lookup"><span data-stu-id="05d69-118">The simplest method of reading mouse movement data is through WM\_MOUSEMOVE messages.</span></span> <span data-ttu-id="05d69-119">以下是如何從 WM MOUSEMOVE 訊息讀取滑鼠移動資料的範例 \_ ：</span><span class="sxs-lookup"><span data-stu-id="05d69-119">The following is an example of how to read mouse movement data from the WM\_MOUSEMOVE message:</span></span>

```cpp
case WM_MOUSEMOVE:
{
    int xPosAbsolute = GET_X_PARAM(lParam); 
    int yPosAbsolute = GET_Y_PARAM(lParam);
    // ...
    break;
}
```

<span data-ttu-id="05d69-120">從 WM MOUSEMOVE 資料的主要缺點 \_ 是限制為螢幕解析度。</span><span class="sxs-lookup"><span data-stu-id="05d69-120">The primary disadvantage to data from WM\_MOUSEMOVE is that it is limited to the screen resolution.</span></span> <span data-ttu-id="05d69-121">這表示，如果您稍微移動滑鼠，而不是太大而導致指標移至下一個圖元，則不 \_ 會產生任何 WM MOUSEMOVE 訊息。</span><span class="sxs-lookup"><span data-stu-id="05d69-121">This means that if you move the mouse slightly — but not enough to cause the pointer to move to the next pixel — then no WM\_MOUSEMOVE message is generated.</span></span> <span data-ttu-id="05d69-122">因此，使用這個方法來讀取滑鼠移動會使高定義輸入的優點更不一樣。</span><span class="sxs-lookup"><span data-stu-id="05d69-122">So, using this method to read mouse movement negates the benefits of high-definition input.</span></span>

<span data-ttu-id="05d69-123">不過，有了 WM MOUSEMOVE 的優點， \_ 就是 Windows 會將指標加速 (也稱為 ballistics) 至原始滑鼠資料，讓滑鼠指標的行為如同客戶預期般運作。</span><span class="sxs-lookup"><span data-stu-id="05d69-123">The advantage to WM\_MOUSEMOVE, however, is that Windows applies pointer acceleration (also known as ballistics) to the raw mouse data, which makes the mouse pointer behave as customers expect.</span></span> <span data-ttu-id="05d69-124">如此可讓 \_ 多部 wm 的 (透過 wm \_ 輸入或 DirectInput) 的指標控制選項，因為它會導致使用者更自然的行為。</span><span class="sxs-lookup"><span data-stu-id="05d69-124">This makes WM\_MOUSEMOVE the preferred option for pointer control (over WM\_INPUT or DirectInput), since it results in more natural behavior for users.</span></span> <span data-ttu-id="05d69-125">雖然 WM \_ MOUSEMOVE 很適合用來移動滑鼠指標，但不太適合用來移動第一張相機，因為高度定義的精確度將會遺失。</span><span class="sxs-lookup"><span data-stu-id="05d69-125">While WM\_MOUSEMOVE is ideal for moving mouse pointers, it is not so good for moving a first-person camera, since the high-definition precision will be lost.</span></span>

<span data-ttu-id="05d69-126">如需有關 WM mousemove 的詳細資訊 \_ ，請參閱 [**wm \_ mousemove**](/windows/desktop/inputdev/wm-mousemove)。</span><span class="sxs-lookup"><span data-stu-id="05d69-126">For more info about WM\_MOUSEMOVE, see [**WM\_MOUSEMOVE**](/windows/desktop/inputdev/wm-mousemove).</span></span>

### <a name="wm_input"></a><span data-ttu-id="05d69-127">WM \_ 輸入</span><span class="sxs-lookup"><span data-stu-id="05d69-127">WM\_INPUT</span></span>

<span data-ttu-id="05d69-128">取得滑鼠資料的第二種方法是讀取 WM \_ 輸入訊息。</span><span class="sxs-lookup"><span data-stu-id="05d69-128">The second method of obtaining mouse data is to read WM\_INPUT messages.</span></span> <span data-ttu-id="05d69-129">處理 WM \_ 輸入訊息比處理 wm \_ MOUSEMOVE 訊息更複雜，但 \_ 會直接從人類介面裝置讀取 wm 輸入訊息 (隱藏) 堆疊，並反映高定義結果。</span><span class="sxs-lookup"><span data-stu-id="05d69-129">Processing WM\_INPUT messages is more complicated than processing WM\_MOUSEMOVE messages, but WM\_INPUT messages are read directly from the Human Interface Device (HID) stack and reflect high-definition results.</span></span>

<span data-ttu-id="05d69-130">若要讀取來自 WM 輸入訊息的滑鼠移動資料 \_ ，必須先註冊裝置; 下列程式碼提供這項操作的範例：</span><span class="sxs-lookup"><span data-stu-id="05d69-130">To read mouse movement data from the WM\_INPUT message, the device must first be registered; the following code provides an example of this:</span></span>

```cpp
// you can #include <hidusage.h> for these defines
#ifndef HID_USAGE_PAGE_GENERIC
#define HID_USAGE_PAGE_GENERIC         ((USHORT) 0x01)
#endif
#ifndef HID_USAGE_GENERIC_MOUSE
#define HID_USAGE_GENERIC_MOUSE        ((USHORT) 0x02)
#endif

RAWINPUTDEVICE Rid[1];
Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC; 
Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE; 
Rid[0].dwFlags = RIDEV_INPUTSINK;   
Rid[0].hwndTarget = hWnd;
RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));
```

<span data-ttu-id="05d69-131">下列程式碼會 \_ 在應用程式的 WinProc 處理常式中處理 WM 輸入訊息：</span><span class="sxs-lookup"><span data-stu-id="05d69-131">The following code handles WM\_INPUT messages in the application's WinProc handler:</span></span>

```cpp
case WM_INPUT: 
{
    UINT dwSize = sizeof(RAWINPUT);
    static BYTE lpb[sizeof(RAWINPUT)];

    GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER));

    RAWINPUT* raw = (RAWINPUT*)lpb;

    if (raw->header.dwType == RIM_TYPEMOUSE) 
    {
        int xPosRelative = raw->data.mouse.lLastX;
        int yPosRelative = raw->data.mouse.lLastY;
    } 
    break;
}
```

<span data-ttu-id="05d69-132">使用 WM 輸入的好處 \_ 是，您的遊戲可能會以最低層級從滑鼠接收原始資料。</span><span class="sxs-lookup"><span data-stu-id="05d69-132">The advantage to using WM\_INPUT is that your game receives raw data from the mouse at the lowest level possible.</span></span>

<span data-ttu-id="05d69-133">缺點是，WM \_ 輸入沒有套用至其資料的 ballistics，因此如果您想要利用這項資料來驅動資料指標，將需要額外的投入時間，讓資料指標的行為就像在 Windows 中一樣。</span><span class="sxs-lookup"><span data-stu-id="05d69-133">The disadvantage is that WM\_INPUT has no ballistics applied to its data, so if you want to drive a cursor with this data, extra effort will be required to make the cursor behave like it does in Windows.</span></span> <span data-ttu-id="05d69-134">如需套用指標 ballistics 的詳細資訊，請參閱 [WINDOWS XP 的指標 ballistics](https://www.microsoft.com/whdc/archive/pointer-bal.mspx)。</span><span class="sxs-lookup"><span data-stu-id="05d69-134">For more information about applying pointer ballistics, see [Pointer Ballistics for Windows XP](https://www.microsoft.com/whdc/archive/pointer-bal.mspx).</span></span>

<span data-ttu-id="05d69-135">如需有關 WM 輸入的詳細資訊 \_ ，請參閱 [關於 Raw 輸入](/windows/desktop/inputdev/about-raw-input)。</span><span class="sxs-lookup"><span data-stu-id="05d69-135">For more info about WM\_INPUT, see [About Raw Input](/windows/desktop/inputdev/about-raw-input).</span></span>

### <a name="directinput"></a><span data-ttu-id="05d69-136">DirectInput</span><span class="sxs-lookup"><span data-stu-id="05d69-136">DirectInput</span></span>

<span data-ttu-id="05d69-137">[DirectInput](/windows-hardware/drivers/hid/directinput) 是一組 API 呼叫，可將系統上的輸入裝置抽象化。</span><span class="sxs-lookup"><span data-stu-id="05d69-137">[DirectInput](/windows-hardware/drivers/hid/directinput) is a set of API calls that abstracts input devices on the system.</span></span> <span data-ttu-id="05d69-138">就內部而言，DirectInput 會建立第二個執行緒來讀取 WM \_ 輸入資料，而使用 DirectInput api 會增加額外負荷，而不只是直接讀取 wm \_ 輸入。</span><span class="sxs-lookup"><span data-stu-id="05d69-138">Internally, DirectInput creates a second thread to read WM\_INPUT data, and using the DirectInput APIs will add more overhead than simply reading WM\_INPUT directly.</span></span> <span data-ttu-id="05d69-139">DirectInput 僅適用于從 DirectInput 操縱杆讀取資料;但是，如果您只需要支援適用于 Windows 的 Xbox 360 控制器，請改用 [XInput](/windows/desktop/xinput/xinput-game-controller-apis-portal) 。</span><span class="sxs-lookup"><span data-stu-id="05d69-139">DirectInput is only useful for reading data from DirectInput joysticks; however, if you only need to support the Xbox 360 controller for Windows, use [XInput](/windows/desktop/xinput/xinput-game-controller-apis-portal) instead.</span></span> <span data-ttu-id="05d69-140">整體來說，使用 DirectInput 從滑鼠或鍵盤裝置讀取資料時，不會提供任何優點，而且不建議在這些案例中使用 DirectInput。</span><span class="sxs-lookup"><span data-stu-id="05d69-140">Overall, using DirectInput offers no advantages when reading data from mouse or keyboard devices, and the use of DirectInput in these scenarios is discouraged.</span></span>

<span data-ttu-id="05d69-141">將使用 [DirectInput](/windows-hardware/drivers/hid/directinput)（如下列程式碼所示）的複雜性與先前所述的方法進行比較。</span><span class="sxs-lookup"><span data-stu-id="05d69-141">Compare the complexity of using [DirectInput](/windows-hardware/drivers/hid/directinput), shown in the following code, to the methods previously described.</span></span> <span data-ttu-id="05d69-142">建立 DirectInput 滑鼠需要下列一組呼叫：</span><span class="sxs-lookup"><span data-stu-id="05d69-142">The following set of calls are needed to create a DirectInput mouse:</span></span>

```cpp
LPDIRECTINPUT8 pDI;
LPDIRECTINPUTDEVICE8 pMouse;

hr = DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&pDI, NULL);
if(FAILED(hr))
    return hr;

hr = pDI->CreateDevice(GUID_SysMouse, &pMouse, NULL);
if(FAILED(hr))
    return hr;

hr = pMouse->SetDataFormat(&c_dfDIMouse2);
if(FAILED(hr))
    return hr;

hr = pMouse->SetCooperativeLevel(hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
if(FAILED(hr))
    return hr;

if(!bImmediate)
{
    DIPROPDWORD dipdw;
    dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj        = 0;
    dipdw.diph.dwHow        = DIPH_DEVICE;
    dipdw.dwData            = 16; // Arbitrary buffer size

    if(FAILED(hr = pMouse->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph)))
        return hr;
}

pMouse->Acquire();
```

<span data-ttu-id="05d69-143">然後可以讀取每個畫面格的 DirectInput 滑鼠裝置：</span><span class="sxs-lookup"><span data-stu-id="05d69-143">And then the DirectInput mouse device can be read each frame:</span></span>

```cpp
DIMOUSESTATE2 dims2; 
ZeroMemory(&dims2, sizeof(dims2));

hr = pMouse->GetDeviceState(sizeof(DIMOUSESTATE2), &dims2);
if(FAILED(hr)) 
{
    hr = pMouse->Acquire();
    while(hr == DIERR_INPUTLOST) 
        hr = pMouse->Acquire();

    return S_OK; 
}

int xPosRelative = dims2.lX;
int yPosRelative = dims2.lY;
```

## <a name="summary"></a><span data-ttu-id="05d69-144">總結</span><span class="sxs-lookup"><span data-stu-id="05d69-144">Summary</span></span>

<span data-ttu-id="05d69-145">整體來說，接收高定義滑鼠移動資料的最佳方法是輸入 WM \_ 。</span><span class="sxs-lookup"><span data-stu-id="05d69-145">Overall, the best method to receive high-definition mouse movement data is WM\_INPUT.</span></span> <span data-ttu-id="05d69-146">如果您的使用者只是移動滑鼠指標，則請考慮使用 WM \_ MOUSEMOVE，以避免需要執行指標 ballistics。</span><span class="sxs-lookup"><span data-stu-id="05d69-146">If your users are just moving a mouse pointer, then consider using WM\_MOUSEMOVE to avoid needing to perform pointer ballistics.</span></span> <span data-ttu-id="05d69-147">這兩個視窗訊息都可以正常運作，即使滑鼠不是高定義的滑鼠也一樣。</span><span class="sxs-lookup"><span data-stu-id="05d69-147">Both of these window messages will work well even if the mouse isn't a high-definition mouse.</span></span> <span data-ttu-id="05d69-148">藉由支援高定義，Windows 遊戲可為使用者提供更精確的控制。</span><span class="sxs-lookup"><span data-stu-id="05d69-148">By supporting high definition, Windows games can offer more precise control to users.</span></span>