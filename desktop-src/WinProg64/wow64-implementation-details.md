---
title: WOW64 執行詳細資料
description: WOW64 模擬器會以使用者模式執行。
ms.assetid: 93daf9d0-dfdb-42c3-8c3d-397b21991e83
keywords:
- WOW64 64 位 Windows 程式設計，環境變數
- WOW64 64 位 Windows 程式設計，執行
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4c7d095369b883171e39bffd4dc629b7f80a7f39
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104092825"
---
# <a name="wow64-implementation-details"></a><span data-ttu-id="49078-105">WOW64 執行詳細資料</span><span class="sxs-lookup"><span data-stu-id="49078-105">WOW64 Implementation Details</span></span>

<span data-ttu-id="49078-106">WOW64 模擬器會以使用者模式執行。</span><span class="sxs-lookup"><span data-stu-id="49078-106">The WOW64 emulator runs in user mode.</span></span> <span data-ttu-id="49078-107">它會提供32位版本的 Ntdll.dll 和處理器核心之間的介面，並攔截核心呼叫。</span><span class="sxs-lookup"><span data-stu-id="49078-107">It provides an interface between the 32-bit version of Ntdll.dll and the kernel of the processor, and it intercepts kernel calls.</span></span> <span data-ttu-id="49078-108">WOW64 模擬器包含下列 Dll：</span><span class="sxs-lookup"><span data-stu-id="49078-108">The WOW64 emulator consists of the following DLLs:</span></span>

-   <span data-ttu-id="49078-109">Wow64.dll 提供核心模擬基礎結構，以及 Ntoskrnl.exe 進入點函數的 Thunk。</span><span class="sxs-lookup"><span data-stu-id="49078-109">Wow64.dll provides the core emulation infrastructure and the thunks for the Ntoskrnl.exe entry-point functions.</span></span>
-   <span data-ttu-id="49078-110">Wow64Win.dll 為 Win32k.sys 的進入點函數提供 Thunk。</span><span class="sxs-lookup"><span data-stu-id="49078-110">Wow64Win.dll provides thunks for the Win32k.sys entry-point functions.</span></span>
-   <span data-ttu-id="49078-111"> (x64 僅) Wow64Cpu.dll 提供在 x64 上執行 x86 程式的支援。</span><span class="sxs-lookup"><span data-stu-id="49078-111">(x64 only) Wow64Cpu.dll provides support for running x86 programs on x64.</span></span>
-   <span data-ttu-id="49078-112"> (僅限 Intel Itanium) IA32Exec 包含 x86 軟體模擬器。</span><span class="sxs-lookup"><span data-stu-id="49078-112">(Intel Itanium only) IA32Exec.bin contains the x86 software emulator.</span></span>
-   <span data-ttu-id="49078-113"> (Intel Itanium 僅) Wowia32x.dll 提供 IA32Exec 和 WOW64 之間的介面。</span><span class="sxs-lookup"><span data-stu-id="49078-113">(Intel Itanium only) Wowia32x.dll provides the interface between IA32Exec.bin and WOW64.</span></span>
-   <span data-ttu-id="49078-114"> (僅限 ARM64) xtajit.dll 包含 x86 軟體模擬器。</span><span class="sxs-lookup"><span data-stu-id="49078-114">(ARM64 only) xtajit.dll contains the x86 software emulator.</span></span>
-   <span data-ttu-id="49078-115"> (僅限 ARM64) wowarmw.dll 提供在 ARM64 上執行 ARM32 程式的支援。</span><span class="sxs-lookup"><span data-stu-id="49078-115">(ARM64 only) wowarmw.dll provides support for running ARM32 programs on ARM64.</span></span>

<span data-ttu-id="49078-116">這些 Dll 以及64位版本的 Ntdll.dll 是唯一可以載入至32位進程的64位二進位檔。</span><span class="sxs-lookup"><span data-stu-id="49078-116">These DLLs, along with the 64-bit version of Ntdll.dll, are the only 64-bit binaries that can be loaded into a 32-bit process.</span></span> <span data-ttu-id="49078-117">在 ARM 上的 Windows 10 上，CHPE (編譯的混合式可執行檔) 二進位檔也可能載入至 x86 32 位進程。</span><span class="sxs-lookup"><span data-stu-id="49078-117">On Windows 10 on ARM, CHPE (Compiled Hybrid Portable Executable) binaries may also be loaded into an x86 32-bit process.</span></span>

<span data-ttu-id="49078-118">在啟動時，Wow64.dll 會載入 x86 版本的 Ntdll.dll (或 CHPE 版本（若已啟用) ）並執行其初始化程式碼，以載入所有必要的32位 Dll。</span><span class="sxs-lookup"><span data-stu-id="49078-118">At startup, Wow64.dll loads the x86 version of Ntdll.dll (or the CHPE version, if enabled) and runs its initialization code, which loads all necessary 32-bit DLLs.</span></span> <span data-ttu-id="49078-119">幾乎所有的32位 Dll 都是32位 Windows 二進位檔的未修改複本，但基於效能考慮，部分會載入為 CHPE。</span><span class="sxs-lookup"><span data-stu-id="49078-119">Almost all 32-bit DLLs are unmodified copies of 32-bit Windows binaries, though some are loaded as CHPE for performance reasons.</span></span> <span data-ttu-id="49078-120">其中某些 Dll 的寫入方式與在32位的 Windows 上的 WOW64 不同，通常是因為它們與64位系統元件共用記憶體。</span><span class="sxs-lookup"><span data-stu-id="49078-120">Some of these DLLs are written to behave differently on WOW64 than they do on 32-bit Windows, usually because they share memory with 64-bit system components.</span></span> <span data-ttu-id="49078-121">所有超過32位限制的使用者模式位址空間都是由系統所保留。</span><span class="sxs-lookup"><span data-stu-id="49078-121">All user-mode address space above the 32-bit limit is reserved by the system.</span></span> <span data-ttu-id="49078-122">如需詳細資訊，請參閱 [WOW64 下的效能和記憶體耗用量](performance-and-memory-consumption.md)。</span><span class="sxs-lookup"><span data-stu-id="49078-122">For more information, see [Performance and Memory Consumption under WOW64](performance-and-memory-consumption.md).</span></span>

<span data-ttu-id="49078-123">我們不會使用 x86 系統服務呼叫順序，而是會重建進行系統呼叫的32位二進位檔，以使用自訂的呼叫序列。</span><span class="sxs-lookup"><span data-stu-id="49078-123">Instead of using the x86 system-service call sequence, 32-bit binaries that make system calls are rebuilt to use a custom calling sequence.</span></span> <span data-ttu-id="49078-124">此呼叫順序的成本較低，因為 WOW64 會維持在使用者模式中，所以無法攔截。</span><span class="sxs-lookup"><span data-stu-id="49078-124">This calling sequence is inexpensive for WOW64 to intercept because it remains entirely in user mode.</span></span> <span data-ttu-id="49078-125">當偵測到自訂呼叫順序時，WOW64 CPU 會轉換回原生64位模式並呼叫 Wow64.dll。</span><span class="sxs-lookup"><span data-stu-id="49078-125">When the custom calling sequence is detected, the WOW64 CPU transitions back to native 64-bit mode and calls into Wow64.dll.</span></span> <span data-ttu-id="49078-126">Thunking 是在使用者模式中完成，以降低對64位核心的影響，並降低 Thunk 中可能造成核心模式損毀、資料損毀或安全性漏洞的錯誤風險。</span><span class="sxs-lookup"><span data-stu-id="49078-126">Thunking is done in user mode to reduce the impact on the 64-bit kernel and to reduce the risk of a bug in the thunk that might cause a kernel-mode crash, data corruption, or a security hole.</span></span> <span data-ttu-id="49078-127">Thunk 會從32位堆疊解壓縮引數，並將它們延伸至64位，然後進行原生系統呼叫。</span><span class="sxs-lookup"><span data-stu-id="49078-127">The thunks extract arguments from the 32-bit stack, extend them to 64 bits, then make the native system call.</span></span>

## <a name="environment-variables"></a><span data-ttu-id="49078-128">環境變數</span><span class="sxs-lookup"><span data-stu-id="49078-128">Environment Variables</span></span>

<span data-ttu-id="49078-129">當64位進程建立32位進程，或當32位進程建立64位進程時，WOW64 會為建立的進程設定環境變數，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="49078-129">When a 32-bit process is created by a 64-bit process, or when a 64-bit process is created by a 32-bit process, WOW64 sets the environment variables for the created process as shown in the following table.</span></span>



| <span data-ttu-id="49078-130">處理序</span><span class="sxs-lookup"><span data-stu-id="49078-130">Process</span></span>                   | <span data-ttu-id="49078-131">環境變數</span><span class="sxs-lookup"><span data-stu-id="49078-131">Environment variables</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|---------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="49078-132">64位進程</span><span class="sxs-lookup"><span data-stu-id="49078-132">64-bit process</span></span><br/> | <span data-ttu-id="49078-133">處理器 \_ 架構 = AMD64 或處理器 \_ 架構 = IA64 或處理器 \_ 架構 = ARM64</span><span class="sxs-lookup"><span data-stu-id="49078-133">PROCESSOR\_ARCHITECTURE=AMD64 or PROCESSOR\_ARCHITECTURE=IA64 or PROCESSOR\_ARCHITECTURE=ARM64</span></span><br/> <span data-ttu-id="49078-134">ProgramFiles =% ProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-134">ProgramFiles=%ProgramFiles%</span></span><br/> <span data-ttu-id="49078-135">ProgramW6432 =% ProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-135">ProgramW6432=%ProgramFiles%</span></span><br/> <span data-ttu-id="49078-136">CommonProgramFiles =% CommonProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-136">CommonProgramFiles=%CommonProgramFiles%</span></span><br/> <span data-ttu-id="49078-137">CommonProgramW6432 =% CommonProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-137">CommonProgramW6432=%CommonProgramFiles%</span></span><br/> <span data-ttu-id="49078-138">**Windows server 2008、Windows Vista、Windows server 2003 和 WINDOWS XP：** 從 Windows 7 和 Windows Server 2008 R2 開始，已新增 ProgramW6432 和 CommonProgramW6432 環境變數。</span><span class="sxs-lookup"><span data-stu-id="49078-138">**Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:** The ProgramW6432 and CommonProgramW6432 environment variables were added starting with Windows 7 and Windows Server 2008 R2.</span></span> <br/> |
| <span data-ttu-id="49078-139">32位進程</span><span class="sxs-lookup"><span data-stu-id="49078-139">32-bit process</span></span><br/> | <span data-ttu-id="49078-140">處理器 \_ 架構 = x86</span><span class="sxs-lookup"><span data-stu-id="49078-140">PROCESSOR\_ARCHITECTURE=x86</span></span><br/> <span data-ttu-id="49078-141">處理器 \_ ARCHITEW6432 =% 處理器 \_ 架構%</span><span class="sxs-lookup"><span data-stu-id="49078-141">PROCESSOR\_ARCHITEW6432=%PROCESSOR\_ARCHITECTURE%</span></span><br/> <span data-ttu-id="49078-142">ProgramFiles =% ProgramFiles (x86) %</span><span class="sxs-lookup"><span data-stu-id="49078-142">ProgramFiles=%ProgramFiles(x86)%</span></span><br/> <span data-ttu-id="49078-143">ProgramW6432 =% ProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-143">ProgramW6432=%ProgramFiles%</span></span><br/> <span data-ttu-id="49078-144">CommonProgramFiles =% CommonProgramFiles (x86) %</span><span class="sxs-lookup"><span data-stu-id="49078-144">CommonProgramFiles=%CommonProgramFiles(x86)%</span></span><br/> <span data-ttu-id="49078-145">CommonProgramW6432 =% CommonProgramFiles%</span><span class="sxs-lookup"><span data-stu-id="49078-145">CommonProgramW6432=%CommonProgramFiles%</span></span><br/>                                                                                                                                                                                                                  |



 

## <a name="global-hooks"></a><span data-ttu-id="49078-146">全域攔截</span><span class="sxs-lookup"><span data-stu-id="49078-146">Global Hooks</span></span>

<span data-ttu-id="49078-147">如果符合下列條件，則可以使用 [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa) 函數將 DLL 插入另一個進程：</span><span class="sxs-lookup"><span data-stu-id="49078-147">The [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa) function can be used to inject a DLL into another process if the following conditions are met:</span></span>

-   <span data-ttu-id="49078-148">32位 DLL 只能插入32位的進程中，而64位 DLL 只能插入至64位進程。</span><span class="sxs-lookup"><span data-stu-id="49078-148">A 32-bit DLL can be injected only into a 32-bit process, and a 64-bit DLL can be injected only into a 64-bit process.</span></span> <span data-ttu-id="49078-149">您無法將32位 DLL 插入64位進程，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="49078-149">It is not possible to inject a 32-bit DLL into a 64-bit process or vice versa.</span></span>
-   <span data-ttu-id="49078-150">32位和64位 Dll 必須有不同的名稱。</span><span class="sxs-lookup"><span data-stu-id="49078-150">The 32-bit and 64-bit DLLs must have different names.</span></span>
-   <span data-ttu-id="49078-151">DLL 和進程的架構必須相符。</span><span class="sxs-lookup"><span data-stu-id="49078-151">The architectures of the DLL and the process must match.</span></span> <span data-ttu-id="49078-152">例如，您不能將32位 x86 DLL 插入32位 ARM 進程中。</span><span class="sxs-lookup"><span data-stu-id="49078-152">For instance, you cannot inject a 32-bit x86 DLL into a 32-bit ARM process.</span></span>

<span data-ttu-id="49078-153">如需詳細資訊，請參閱 [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa)。</span><span class="sxs-lookup"><span data-stu-id="49078-153">For more information, see [**SetWindowsHookEx**](/windows/win32/api/winuser/nf-winuser-setwindowshookexa).</span></span>

<span data-ttu-id="49078-154">請注意，您可以在安裝攔截的執行緒上呼叫 **WH \_ 滑鼠**、 **WH \_ 鍵盤**、 **WH \_ 日誌 \***、 **WH \_ SHELL** 和低層級的勾點，而不是在處理攔截的執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="49078-154">Be aware that the **WH\_MOUSE**, **WH\_KEYBOARD**, **WH\_JOURNAL\***, **WH\_SHELL**, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook.</span></span> <span data-ttu-id="49078-155">針對這些攔截器，如果32位攔截器早于攔截鏈中的64位攔截器，則可能會呼叫32位和64位的勾點。</span><span class="sxs-lookup"><span data-stu-id="49078-155">For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.</span></span> <span data-ttu-id="49078-156">如需詳細資訊，請參閱 [使用](../winmsg/using-hooks.md)勾點。</span><span class="sxs-lookup"><span data-stu-id="49078-156">For more information, see [Using Hooks](../winmsg/using-hooks.md).</span></span>

 

