---
description: D3DX 是提供 helper 服務的公用程式庫。 它是 Direct3D 元件之上的一層。
ms.assetid: 7892370f-0807-4ab7-b7cd-a7e1182e3f9c
title: 'D3DX 中的網格支援 (Direct3D 9) '
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fb0b2b1dd0e5d4c5a212005afe400bb559f1689a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "103935620"
---
# <a name="mesh-support-in-d3dx-direct3d-9"></a><span data-ttu-id="e09c4-104">D3DX 中的網格支援 (Direct3D 9) </span><span class="sxs-lookup"><span data-stu-id="e09c4-104">Mesh Support in D3DX (Direct3D 9)</span></span>

<span data-ttu-id="e09c4-105">D3DX 是提供 helper 服務的公用程式庫。</span><span class="sxs-lookup"><span data-stu-id="e09c4-105">D3DX is a utility library that provides helper services.</span></span> <span data-ttu-id="e09c4-106">它是 Direct3D 元件之上的一層。</span><span class="sxs-lookup"><span data-stu-id="e09c4-106">It is a layer above the Direct3D component.</span></span>

## <a name="meshes"></a><span data-ttu-id="e09c4-107">網狀</span><span class="sxs-lookup"><span data-stu-id="e09c4-107">Meshes</span></span>

<span data-ttu-id="e09c4-108">D3DX 會執行網格結構來載入、操作和轉譯. x 檔案內容。</span><span class="sxs-lookup"><span data-stu-id="e09c4-108">D3DX implements the mesh construct to load, manipulate, and render .x file contents.</span></span> <span data-ttu-id="e09c4-109">網格基本上是定義某些幾何的頂點集合，以及定義臉部的一組索引。</span><span class="sxs-lookup"><span data-stu-id="e09c4-109">A mesh is basically a collection of vertices defining some geometry, and a set of indices defining the faces.</span></span> <span data-ttu-id="e09c4-110">有數種網格類型。</span><span class="sxs-lookup"><span data-stu-id="e09c4-110">There are several mesh types.</span></span>

<span data-ttu-id="e09c4-111">[**ID3DXBaseMesh**](id3dxbasemesh.md) 提供基本概念。</span><span class="sxs-lookup"><span data-stu-id="e09c4-111">[**ID3DXBaseMesh**](id3dxbasemesh.md) provides the fundamentals.</span></span> <span data-ttu-id="e09c4-112">[**ID3DXMesh**](id3dxmesh.md) 繼承自 ID3DXBaseMesh，並使用每個晶片頂點快取來新增網格優化。</span><span class="sxs-lookup"><span data-stu-id="e09c4-112">[**ID3DXMesh**](id3dxmesh.md) inherits from ID3DXBaseMesh, and adds mesh optimization using per-chip vertex cache.</span></span> <span data-ttu-id="e09c4-113">[**ID3DXSkinInfo**](id3dxskininfo.md) 提供 skinned 網格支援。</span><span class="sxs-lookup"><span data-stu-id="e09c4-113">[**ID3DXSkinInfo**](id3dxskininfo.md) provides skinned mesh support.</span></span>

<span data-ttu-id="e09c4-114">[**ID3DXBaseMesh**](id3dxbasemesh.md) 提供的方法可操作和查詢從基底網格繼承的 [**ID3DXMesh**](id3dxmesh.md) 網格物件。</span><span class="sxs-lookup"><span data-stu-id="e09c4-114">[**ID3DXBaseMesh**](id3dxbasemesh.md) provides methods to manipulate and query [**ID3DXMesh**](id3dxmesh.md) mesh objects, which inherit from the base mesh.</span></span> <span data-ttu-id="e09c4-115">這包括相鄰作業、幾何緩衝區抓取、鎖定/解除鎖定作業 (頂點和索引) ，以及複製、轉譯、臉部和頂點資訊。</span><span class="sxs-lookup"><span data-stu-id="e09c4-115">This includes adjacency operations, geometry buffer retrieval, lock/unlock operations (vertex and index), and copying, rendering, face, and vertex information.</span></span>

> [!Note]  
> <span data-ttu-id="e09c4-116">ID3DXPMesh 和 ID3DXSPMesh 介面 (，以支援漸進式和簡化的網格，並已卸載舊版 Direct3D 9 中可用的) 。</span><span class="sxs-lookup"><span data-stu-id="e09c4-116">The ID3DXPMesh and ID3DXSPMesh interfaces (to support progressive and simplified meshes, respectively) available in earlier releases of Direct3D 9 have been dropped.</span></span>

 

## <a name="mesh-architecture"></a><span data-ttu-id="e09c4-117">網狀架構</span><span class="sxs-lookup"><span data-stu-id="e09c4-117">Mesh Architecture</span></span>

<span data-ttu-id="e09c4-118">網格包含複雜模型的資料。</span><span class="sxs-lookup"><span data-stu-id="e09c4-118">A mesh contains the data for a complex model.</span></span> <span data-ttu-id="e09c4-119">它是一個抽象資料容器，其中包含紋理和材質等資源，以及位置資料和相鄰資料等屬性。</span><span class="sxs-lookup"><span data-stu-id="e09c4-119">It is an abstract data container that contains resources such as textures and materials, and attributes such as position data and adjacency data.</span></span> <span data-ttu-id="e09c4-120">有數種網格運算可改善繪圖效能以及表面的外觀。</span><span class="sxs-lookup"><span data-stu-id="e09c4-120">There are several mesh operations that improve drawing performance and the appearance of a surface.</span></span> <span data-ttu-id="e09c4-121">此外，還有一些其他網格概念會影響網格作業的功能。</span><span class="sxs-lookup"><span data-stu-id="e09c4-121">In addition, there are a number of other mesh concepts that will effect the functionality of mesh operations.</span></span> <span data-ttu-id="e09c4-122">瞭解這些網格概念，讓您可以加以套用可改善網格效能。</span><span class="sxs-lookup"><span data-stu-id="e09c4-122">Understanding these mesh concepts so you can apply them will improve mesh performance.</span></span>

## <a name="mesh-object-data"></a><span data-ttu-id="e09c4-123">網格物件資料</span><span class="sxs-lookup"><span data-stu-id="e09c4-123">Mesh Object Data</span></span>

<span data-ttu-id="e09c4-124">網格包含頂點緩衝區、索引緩衝區和屬性緩衝區。</span><span class="sxs-lookup"><span data-stu-id="e09c4-124">A mesh contains a vertex buffer, an index buffer, and an attribute buffer.</span></span>

-   <span data-ttu-id="e09c4-125">頂點緩衝區包含頂點資料，也就是網格頂點。</span><span class="sxs-lookup"><span data-stu-id="e09c4-125">The vertex buffer contains the vertex data, which are the mesh vertices.</span></span>
-   <span data-ttu-id="e09c4-126">索引緩衝區包含用來存取頂點緩衝區的頂點索引。</span><span class="sxs-lookup"><span data-stu-id="e09c4-126">The index buffer contains vertex indices for accessing the vertex buffer.</span></span> <span data-ttu-id="e09c4-127">這可以減少重複的頂點來減少頂點緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="e09c4-127">This can reduce the vertex buffer size by reducing duplicate vertices.</span></span> <span data-ttu-id="e09c4-128">只有索引網格會使用索引緩衝區。</span><span class="sxs-lookup"><span data-stu-id="e09c4-128">Only an indexed mesh uses the index buffer.</span></span> <span data-ttu-id="e09c4-129">例如，如果網格是由三角形清單所組成，就不會使用索引緩衝區。</span><span class="sxs-lookup"><span data-stu-id="e09c4-129">If a mesh is made up of a triangle list, for example, it does not use the index buffer.</span></span>
-   <span data-ttu-id="e09c4-130">屬性緩衝區包含屬性資料。</span><span class="sxs-lookup"><span data-stu-id="e09c4-130">The attribute buffer contains attribute data.</span></span> <span data-ttu-id="e09c4-131">屬性是網格頂點的屬性，不是特定的順序。</span><span class="sxs-lookup"><span data-stu-id="e09c4-131">Attributes are properties of the mesh vertices, in no particular order.</span></span> <span data-ttu-id="e09c4-132">D3DX 網格會針對每個臉部，將屬性儲存在 DWORD 群組中。</span><span class="sxs-lookup"><span data-stu-id="e09c4-132">A D3DX mesh stores attributes in a group of DWORDS, for each face.</span></span>

### <a name="attribute-tables"></a><span data-ttu-id="e09c4-133">屬性資料表</span><span class="sxs-lookup"><span data-stu-id="e09c4-133">Attribute Tables</span></span>

<span data-ttu-id="e09c4-134">屬性資料表是屬性緩衝區內容的精確標記法。</span><span class="sxs-lookup"><span data-stu-id="e09c4-134">An attribute table is a concise representation of the contents of an attribute buffer.</span></span> <span data-ttu-id="e09c4-135">您可以藉由使用 D3DXMESHOPT ATTRSORT 來呼叫其中一個 Optimize 方法 \_ 、鎖定屬性緩衝區，並將資料填入資料，或是藉由呼叫 SetAttributeTable 來建立屬性資料表。</span><span class="sxs-lookup"><span data-stu-id="e09c4-135">Attribute tables can be created by calling one of the Optimize methods with D3DXMESHOPT\_ATTRSORT, by locking the attribute buffer and filling it with data, or by calling SetAttributeTable.</span></span> <span data-ttu-id="e09c4-136">當網格重新排列成群組時，網格包含屬性工作表。</span><span class="sxs-lookup"><span data-stu-id="e09c4-136">A mesh contains an attribute table when the mesh is reordered into groups.</span></span> <span data-ttu-id="e09c4-137">如果在呼叫 Optimize 時，會發生這種情況，假設已 \_ 提供 (D3DXMESHOPT ATTRSORT 或更高) 的屬性排序選項。</span><span class="sxs-lookup"><span data-stu-id="e09c4-137">This happens when Optimize is called, assuming an attribute sorting option (D3DXMESHOPT\_ATTRSORT or higher) is supplied.</span></span> <span data-ttu-id="e09c4-138">D3DX 網格使用已編制索引的三角形清單，因此會以 [**IDirect3DDevice9：:D rawindexedprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)來繪製。</span><span class="sxs-lookup"><span data-stu-id="e09c4-138">D3DX Meshes use indexed triangle lists, and are therefore drawn with [**IDirect3DDevice9::DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive).</span></span>

<span data-ttu-id="e09c4-139">由於呼叫 Optimize 的結果，因此會建立屬性資料表。</span><span class="sxs-lookup"><span data-stu-id="e09c4-139">Attribute tables are created as a result of calling Optimize.</span></span> <span data-ttu-id="e09c4-140">臉部不一定要相鄰，因為 Optimize 會將它們重新排列為相鄰。</span><span class="sxs-lookup"><span data-stu-id="e09c4-140">The faces don't have to be adjacent, because Optimize will reorder them to be adjacent.</span></span> <span data-ttu-id="e09c4-141">例如，人類網格的手可以使用相同的屬性。</span><span class="sxs-lookup"><span data-stu-id="e09c4-141">For example, the hands of a human mesh could use the same attribute.</span></span> <span data-ttu-id="e09c4-142">此識別碼有助於將臉部排序成群組。</span><span class="sxs-lookup"><span data-stu-id="e09c4-142">The id helps sort the faces into groups.</span></span> <span data-ttu-id="e09c4-143">來自. x 檔案的網格已自動產生材質和材質屬性的屬性。</span><span class="sxs-lookup"><span data-stu-id="e09c4-143">Meshes from .x files have automatically generated attributes for material and texture properties.</span></span> <span data-ttu-id="e09c4-144">您必須呼叫 Optimize (ATTRSORT) 或更有效的優化 (VERTEXCACHE) ，以取得良好的效能。</span><span class="sxs-lookup"><span data-stu-id="e09c4-144">You do need to call Optimize(ATTRSORT) or the more effective Optimize(VERTEXCACHE) to get good performance.</span></span> <span data-ttu-id="e09c4-145">Load 函式會嘗試以其儲存所在的確切形式來呈現資料。</span><span class="sxs-lookup"><span data-stu-id="e09c4-145">The load functions try to present the data in the exact form it was saved out in.</span></span> <span data-ttu-id="e09c4-146">如果您使用頂點緩衝區/索引緩衝區型網格，則網狀架構會提供優化函式，並在極少額外負荷的情況下進行外觀轉換。</span><span class="sxs-lookup"><span data-stu-id="e09c4-146">If you are using a vertex buffer/index buffer based mesh, the mesh API provides optimization functions and skinning transformations with little overhead.</span></span>

<span data-ttu-id="e09c4-147">優化類型是累計的，從最不理想的 (D3DXMESHOPT \_ COMPACT) 到最理想的 (D3DXMESHOPT \_ IGNOREVERTS) 。</span><span class="sxs-lookup"><span data-stu-id="e09c4-147">The optimization types are cumulative, starting from the least optimal (D3DXMESHOPT\_COMPACT) to the most optimal (D3DXMESHOPT\_IGNOREVERTS).</span></span> <span data-ttu-id="e09c4-148">D3DXMESHOPT \_ STRIPREORDER 會執行壓縮和屬性排序。</span><span class="sxs-lookup"><span data-stu-id="e09c4-148">D3DXMESHOPT\_STRIPREORDER does a compaction and attribute sort.</span></span> <span data-ttu-id="e09c4-149">\_即使在沒有真正頂點快取的裝置上，一律建議使用 D3DXMESHOPT VERTEXCACHE。</span><span class="sxs-lookup"><span data-stu-id="e09c4-149">D3DXMESHOPT\_VERTEXCACHE is always recommended, even on devices without a true vertex cache.</span></span>

## <a name="application-data"></a><span data-ttu-id="e09c4-150">應用程式資料</span><span class="sxs-lookup"><span data-stu-id="e09c4-150">Application Data</span></span>

<span data-ttu-id="e09c4-151">應用程式資料是應用程式所管理的網格資料。</span><span class="sxs-lookup"><span data-stu-id="e09c4-151">Application data is mesh data that is managed by an application.</span></span> <span data-ttu-id="e09c4-152">網格頂點資料與這些緩衝區所管理的資料之間有緊密的結合。</span><span class="sxs-lookup"><span data-stu-id="e09c4-152">There is a tight coupling between the mesh vertex data and the data managed by these buffers.</span></span>

<span data-ttu-id="e09c4-153">材質緩衝區包含 n 個材質。</span><span class="sxs-lookup"><span data-stu-id="e09c4-153">The materials buffer contains n materials.</span></span> <span data-ttu-id="e09c4-154">載入. x 檔案時，Load 函數會傳回材質。</span><span class="sxs-lookup"><span data-stu-id="e09c4-154">The materials are returned by the Load function when the .x file is loaded.</span></span> <span data-ttu-id="e09c4-155">每個子集都可以有自己的材質和材質。</span><span class="sxs-lookup"><span data-stu-id="e09c4-155">Each subset can have its own materials and textures.</span></span> <span data-ttu-id="e09c4-156">材質緩衝區是靜態的。</span><span class="sxs-lookup"><span data-stu-id="e09c4-156">The materials buffer is static.</span></span>

<span data-ttu-id="e09c4-157">鄰接緩衝區包含邊緣、臉部和相鄰臉部的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="e09c4-157">The adjacency buffer contains information about edges, faces, and adjacent faces.</span></span> <span data-ttu-id="e09c4-158">某些網格操作取決於知道哪些臉部彼此相鄰。</span><span class="sxs-lookup"><span data-stu-id="e09c4-158">Some mesh operations depend on knowing which faces are adjacent to each other.</span></span> <span data-ttu-id="e09c4-159">這項資訊（稱為相鄰資料）會保留在連續的緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="e09c4-159">This information, called adjacency data, is kept in an adjacency buffer.</span></span> <span data-ttu-id="e09c4-160">它不是網格的一部分，而是由應用程式維護，而且必須在必要時提供給網格方法。</span><span class="sxs-lookup"><span data-stu-id="e09c4-160">It is not part of the mesh but is maintained by the application and must be supplied to the mesh methods when necessary.</span></span>

<span data-ttu-id="e09c4-161">效果實例緩衝區包含效果實例的清單。</span><span class="sxs-lookup"><span data-stu-id="e09c4-161">The effects instance buffer contains a list of effect instances.</span></span> <span data-ttu-id="e09c4-162">效果實例會儲存狀態。</span><span class="sxs-lookup"><span data-stu-id="e09c4-162">An effect instance stores state.</span></span> <span data-ttu-id="e09c4-163">這是用來初始化管線的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="e09c4-163">This state information is used to initialize the pipeline.</span></span> <span data-ttu-id="e09c4-164">效果實例包含效果中的名稱/值配對。</span><span class="sxs-lookup"><span data-stu-id="e09c4-164">An effect instance contains name-value pairs in an effect.</span></span>

## <a name="advanced-mesh-topics"></a><span data-ttu-id="e09c4-165">Advanced 網格主題</span><span class="sxs-lookup"><span data-stu-id="e09c4-165">Advanced Mesh Topics</span></span>

<span data-ttu-id="e09c4-166">優化網格是以基底網格功能為基礎，並使用兩種方法新增頂點快取優化功能： Optimize （建立新的網格）和 OptimizeInPlace （可修改原始網格）。</span><span class="sxs-lookup"><span data-stu-id="e09c4-166">Optimized meshes build on the base mesh functionality and add vertex-cache optimization capability with two methods: Optimize, which creates a new mesh, and OptimizeInPlace, which modifies the original mesh.</span></span>

<span data-ttu-id="e09c4-167">D3DXGeneratePMesh 使用 D3DX 簡化演算法從輸入網格產生漸進式網格。</span><span class="sxs-lookup"><span data-stu-id="e09c4-167">D3DXGeneratePMesh uses the D3DX simplification algorithm to generate a progressive mesh from the input mesh.</span></span> <span data-ttu-id="e09c4-168">D3DXSimplifyMesh 會使用相同的簡化演算法，從輸入網格產生給定詳細資料層級的標準網格。</span><span class="sxs-lookup"><span data-stu-id="e09c4-168">D3DXSimplifyMesh generates a standard mesh of the given level-of-detail from an input mesh using the same simplification algorithm.</span></span> <span data-ttu-id="e09c4-169">使用者可以控制透過每個頂點指定的權數，以及針對每個頂點指定的加權所使用的錯誤度量。</span><span class="sxs-lookup"><span data-stu-id="e09c4-169">The user has control over the error metric used through the weights specified per-vertex component and weights specified per vertex.</span></span> <span data-ttu-id="e09c4-170">每個元件的加權會乘以每個邊緣折迭所計算之錯誤的元件部分。</span><span class="sxs-lookup"><span data-stu-id="e09c4-170">Per-component weights are multiplied against that components portion of error calculated per edge collapse.</span></span> <span data-ttu-id="e09c4-171">每個頂點加權會乘以決定要移除該頂點的錯誤度量值。</span><span class="sxs-lookup"><span data-stu-id="e09c4-171">Per-vertex weights are multiplied against the error metric value determined for removal of that vertex.</span></span> <span data-ttu-id="e09c4-172">例如，如果您不想要移除頂點，請將該特定頂點的權數設定為大數值。</span><span class="sxs-lookup"><span data-stu-id="e09c4-172">For example, if you never want a vertex to be removed, set that specific vertex's weight to a large value.</span></span> <span data-ttu-id="e09c4-173">相反地，如果您想要先移除它，請將它設定為小於 1)  (的小數值。</span><span class="sxs-lookup"><span data-stu-id="e09c4-173">Conversely, if you want it removed earlier, set it to a small value (less than 1).</span></span>

<span data-ttu-id="e09c4-174">[**ID3DXSkinInfo**](id3dxskininfo.md) 支援 skinned 的字元。</span><span class="sxs-lookup"><span data-stu-id="e09c4-174">[**ID3DXSkinInfo**](id3dxskininfo.md) supports skinned characters.</span></span> <span data-ttu-id="e09c4-175">Skinned 字元是由一組網格所定義，而一組會影響網格頂點的一組骨骼。</span><span class="sxs-lookup"><span data-stu-id="e09c4-175">A skinned character is defined by a set of meshes and a set of bones that affect the vertices of the meshes.</span></span> <span data-ttu-id="e09c4-176">這些骨骼會以轉換階層表示。</span><span class="sxs-lookup"><span data-stu-id="e09c4-176">The bones are represented as a transform hierarchy.</span></span> <span data-ttu-id="e09c4-177">每個網格都有一個會影響它的每個骨骼的矩陣，這會將網格轉換成骨骼的區域座標空間。</span><span class="sxs-lookup"><span data-stu-id="e09c4-177">For each mesh, there is a matrix for every bone that affects it, which transforms the mesh into the local coordinate space of the bone.</span></span> <span data-ttu-id="e09c4-178">此矩陣是網格之骨骼的骨骼空間轉換。</span><span class="sxs-lookup"><span data-stu-id="e09c4-178">This matrix is the bone-space transform of the bone for the mesh.</span></span> <span data-ttu-id="e09c4-179">這是在撰寫程式中與網格相關聯的時候定義。</span><span class="sxs-lookup"><span data-stu-id="e09c4-179">This is defined at the time the skeleton is associated with the mesh in the authoring process.</span></span>

### <a name="skinning"></a><span data-ttu-id="e09c4-180">皮膚形變</span><span class="sxs-lookup"><span data-stu-id="e09c4-180">Skinning</span></span>

<span data-ttu-id="e09c4-181">「外觀」是使用骨骼來轉換網格頂點的技巧。</span><span class="sxs-lookup"><span data-stu-id="e09c4-181">Skinning is a technique for transforming mesh vertices using bones.</span></span> <span data-ttu-id="e09c4-182">通常會在階層式基本架構中排列骨骼，與人類主體中的骨骼非常類似。</span><span class="sxs-lookup"><span data-stu-id="e09c4-182">Bones are typically arranged in a hierarchical skeleton, much like the bones in a human body.</span></span> <span data-ttu-id="e09c4-183">物件頂點接著會與骨骼相關聯，例如將面板附加至骨骼。</span><span class="sxs-lookup"><span data-stu-id="e09c4-183">Object vertices are then associated with the bones, like attaching skin to the bones.</span></span> <span data-ttu-id="e09c4-184">當骨骼轉換時，面板也會轉換。</span><span class="sxs-lookup"><span data-stu-id="e09c4-184">When the bones get transformed, the skin is also transformed.</span></span>

<span data-ttu-id="e09c4-185">Skinned 網格使用骨骼來影響一些頂點。</span><span class="sxs-lookup"><span data-stu-id="e09c4-185">Skinned meshes use bones to influence a number of vertices.</span></span> <span data-ttu-id="e09c4-186">骨骼轉換資料是由使用者提供，以影響如何 SRT 的骨骼。</span><span class="sxs-lookup"><span data-stu-id="e09c4-186">Bone transformation data is supplied by the user, to influence how to SRT the bones.</span></span> <span data-ttu-id="e09c4-187">網格會使用轉換的骨骼來影響與骨骼相關聯的頂點。</span><span class="sxs-lookup"><span data-stu-id="e09c4-187">The mesh uses the transformed bones to influence the vertices associated with the bones.</span></span> <span data-ttu-id="e09c4-188">調色板是 SRT 轉換的陣列。</span><span class="sxs-lookup"><span data-stu-id="e09c4-188">Palettes are arrays of SRT transformations.</span></span> <span data-ttu-id="e09c4-189">調色板通常會實作為矩陣，但它們可以包含 SRT 值。</span><span class="sxs-lookup"><span data-stu-id="e09c4-189">Palettes are often implemented as matrices, but they can contain SRT values.</span></span>

### <a name="progressive-mesh-trimming"></a><span data-ttu-id="e09c4-190">漸進式網格修剪</span><span class="sxs-lookup"><span data-stu-id="e09c4-190">Progressive Mesh Trimming</span></span>

<span data-ttu-id="e09c4-191">低詳細資料區域可承受遺失不會變更表面呈現外觀的頂點。</span><span class="sxs-lookup"><span data-stu-id="e09c4-191">Low detail areas can afford to lose vertices which don't change the rendered appearance of the surface.</span></span> <span data-ttu-id="e09c4-192">尤其是當物件從相機移到更遠的情況時。</span><span class="sxs-lookup"><span data-stu-id="e09c4-192">This is especially true of objects as they move farther from the camera.</span></span> <span data-ttu-id="e09c4-193">這稱為詳細層級。</span><span class="sxs-lookup"><span data-stu-id="e09c4-193">This is referred to as level-of-detail.</span></span> <span data-ttu-id="e09c4-194">使用者擁有 API 層級的轉譯控制項，可設定詳細資料層級以最大化呈現效率。</span><span class="sxs-lookup"><span data-stu-id="e09c4-194">Users have API-level render controls for setting the level-of-detail to maximize rendering efficiency.</span></span>

<span data-ttu-id="e09c4-195">漸進式網格物件以大量臉部開頭，並使用簡化來減少臉部數目。</span><span class="sxs-lookup"><span data-stu-id="e09c4-195">Progressive mesh objects start with a high number of faces and use simplification to reduce the number of faces.</span></span> <span data-ttu-id="e09c4-196">與 view 無關的漸進式網格稱為「視圖獨立的漸進式網格」 (VIPM) 。</span><span class="sxs-lookup"><span data-stu-id="e09c4-196">A progressive mesh that is view independent is referred to as a view-independent progressive mesh (VIPM).</span></span>

<span data-ttu-id="e09c4-197">減少臉部數目的另一種方式是藉由修剪。</span><span class="sxs-lookup"><span data-stu-id="e09c4-197">Another way to reduce the number of faces is by trimming.</span></span> <span data-ttu-id="e09c4-198">這實際上會從網格中移除頂點和臉部。</span><span class="sxs-lookup"><span data-stu-id="e09c4-198">This actually removes vertices and faces from the mesh.</span></span> <span data-ttu-id="e09c4-199">您可以在高階 (上進行修剪，以限制臉部的最大數量) 或在低端 (以限制臉部的最小數目。 ) 修剪可改善繪圖的效能，不過，請小心使用來維持視覺品質。</span><span class="sxs-lookup"><span data-stu-id="e09c4-199">Trimming can be done at the high end (to limit the max number of faces) or at the low end (to limit the minimum number of faces.) Trimming improves draw performance, however, care should be used to preserve the visual quality.</span></span> <span data-ttu-id="e09c4-200">漸進式網格 SDK 範例會示範修剪。</span><span class="sxs-lookup"><span data-stu-id="e09c4-200">Trimming is demonstrated in the Progressive Mesh SDK Sample.</span></span>

<span data-ttu-id="e09c4-201">針對高可見度區域，可以使用漸進式詳細資料層級 (PLOD) 來增加解析度。</span><span class="sxs-lookup"><span data-stu-id="e09c4-201">For high visibility areas, the resolution can be increased using progressive level of detail (PLOD).</span></span> <span data-ttu-id="e09c4-202">這是將單一臉部分成兩面的技巧。</span><span class="sxs-lookup"><span data-stu-id="e09c4-202">This is a technique for breaking a single face into two faces.</span></span>

### <a name="patch-meshes"></a><span data-ttu-id="e09c4-203">修補程式網格</span><span class="sxs-lookup"><span data-stu-id="e09c4-203">Patch Meshes</span></span>

<span data-ttu-id="e09c4-204">也支援兩種特製化的修補程式網格類型：矩形和三角形的修補程式。</span><span class="sxs-lookup"><span data-stu-id="e09c4-204">Two specialized types of patch meshes are also supported: rectangle and triangle patches.</span></span> <span data-ttu-id="e09c4-205">矩形修補程式網格是一個修補程式網格，其控制點是以纏繞、矩形的序列來配置。</span><span class="sxs-lookup"><span data-stu-id="e09c4-205">The rectangle patch mesh is a patch mesh whose control points are laid out in a winding, rectangular sequence.</span></span> <span data-ttu-id="e09c4-206">矩形和三角形修補程式用來建立高序位的表面。</span><span class="sxs-lookup"><span data-stu-id="e09c4-206">Rectangle and triangle patches are used to create high-order surfaces.</span></span> <span data-ttu-id="e09c4-207">它們並不像是三角形網格一般。</span><span class="sxs-lookup"><span data-stu-id="e09c4-207">They are not as commonly used as triangle meshes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e09c4-208">相關主題</span><span class="sxs-lookup"><span data-stu-id="e09c4-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e09c4-209">D3DX</span><span class="sxs-lookup"><span data-stu-id="e09c4-209">D3DX</span></span>](d3dx.md)
</dt> </dl>

 

 
