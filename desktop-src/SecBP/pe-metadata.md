---
description: 本文提供 PE 映射中控制流程防護中繼資料的其他詳細資料。
title: PE 中繼資料
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106998905"
---
# <a name="pe-metadata"></a><span data-ttu-id="6b739-103">PE 中繼資料</span><span class="sxs-lookup"><span data-stu-id="6b739-103">PE metadata</span></span>

<span data-ttu-id="6b739-104">本文提供控制流程防護 (CFG) PE 映射中中繼資料的額外詳細資料。</span><span class="sxs-lookup"><span data-stu-id="6b739-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="6b739-105">假設您熟悉 PE 映射中的 CFG 元資料結構。</span><span class="sxs-lookup"><span data-stu-id="6b739-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="6b739-106">請參閱 [Pe 格式](../debug/pe-format.md) 主題，以取得 pe 映射中 CFG 中繼資料的高階檔集。</span><span class="sxs-lookup"><span data-stu-id="6b739-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="6b739-107">有效間接呼叫目標的函式會列在附加至 load configuration 目錄的 **GuardCFFunctionTable** 中，有時也稱為 **GFIDS** 資料表，以求簡潔。</span><span class="sxs-lookup"><span data-stu-id="6b739-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="6b739-108">這是已排序的相對虛擬位址清單 (RVA) ，其中包含有效的 CFG 呼叫目標的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="6b739-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="6b739-109">一般來說，這些都是定址的函式符號。</span><span class="sxs-lookup"><span data-stu-id="6b739-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="6b739-110">想要進行 CFG 強制的映射必須列舉其 **GFIDS** 資料表中的所有位址取得函式符號。</span><span class="sxs-lookup"><span data-stu-id="6b739-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="6b739-111">**GFIDS** 資料表中的 RVA 清單必須正確地排序，否則不會載入映射。</span><span class="sxs-lookup"><span data-stu-id="6b739-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="6b739-112">**GFIDS** 資料表是 4 + *n* 位元組的陣列，其中 *n* 是由 ( (GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT) 指定。</span><span class="sxs-lookup"><span data-stu-id="6b739-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="6b739-113">"GuardFlags" 是 load configuration 目錄的 GuardFlags 欄位。</span><span class="sxs-lookup"><span data-stu-id="6b739-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="6b739-114">這可讓您在未來將額外的中繼資料附加至 CFG 呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="6b739-115">唯一定義的中繼資料是選擇性的1位元組額外旗標欄位 ( 「GFIDS 旗標」 ) 如果有任何呼叫目標具有中繼資料，則會附加至每個 **GFIDS** 專案。</span><span class="sxs-lookup"><span data-stu-id="6b739-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="6b739-116">已定義兩個 **GFIDS** 旗標：</span><span class="sxs-lookup"><span data-stu-id="6b739-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="6b739-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="6b739-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="6b739-118">明確地隱藏呼叫目標 (請勿將它視為適用于 CFG 的用途) </span><span class="sxs-lookup"><span data-stu-id="6b739-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="6b739-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span><span class="sxs-lookup"><span data-stu-id="6b739-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="6b739-120">已抑制匯出的呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-120">Call target is export suppressed.</span></span> <span data-ttu-id="6b739-121">如需詳細資料，請參閱 [匯出隱藏](#export-suppression) 專案</span><span class="sxs-lookup"><span data-stu-id="6b739-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="6b739-122">基於未來的相容性，工具不應該設定尚未定義的 **GFIDS** 旗標，且不應包含超過目前定義之1位元組的額外 **GFIDS** 額外中繼資料位元組，因為其他旗標的意義或尚未指派其他中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6b739-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="6b739-123">您可以藉由傾印二進位檔的 **GFIDS** 資料表（例如 Ntdll.dll 在新式 Windows 10 作業系統版本上，找到包含額外中繼資料位元組的映射範例。</span><span class="sxs-lookup"><span data-stu-id="6b739-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="6b739-124">工具只能將函式符號宣告為有效的呼叫目標，可能會針對可能會取得標籤的組合程式碼考慮其他考慮。</span><span class="sxs-lookup"><span data-stu-id="6b739-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="6b739-125">基於歷史原因，組合器程式碼可能依賴 PROC 或. altentry 以外的程式碼標籤，而不是由連結器轉換成 CFG 呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="6b739-126">此外，基於歷史原因，程式碼可能會刻意將程式碼宣告為數據，以避免包含在 **GFIDS** 資料表中。</span><span class="sxs-lookup"><span data-stu-id="6b739-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="6b739-127">例如，一個物件檔案可能會將符號實作為程式碼，而另一個則會將它宣告為數據，以便取得符號的位址，而不會產生有效的 CFG 目標記錄。</span><span class="sxs-lookup"><span data-stu-id="6b739-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="6b739-128">為了提供相容性，建議工具組支援這種作法。</span><span class="sxs-lookup"><span data-stu-id="6b739-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="6b739-129">支援 CFG 以及需要或執行 CFG 檢查的映射應該設定 IMAGE_GUARD_CF_INSTRUMENTED 和 IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags 位，而且應該在映射標頭中設定 IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics 位。</span><span class="sxs-lookup"><span data-stu-id="6b739-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="6b739-130">Load configuration 目錄會通告兩個函式指標： GuardCFCheckFunctionPointer 和 GuardCFDispatchFunctionPointer (後者僅支援 AMD64) 等特定架構。</span><span class="sxs-lookup"><span data-stu-id="6b739-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="6b739-131">這些函式指標應指向唯讀的記憶體，以使 CFG 安全性生效;作業系統的 DLL 載入器會在映射載入期間重新保護記憶體暫時，以儲存函式指標。</span><span class="sxs-lookup"><span data-stu-id="6b739-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="6b739-132">一般用法可能是將這些內容合併到包含匯入位址資料表的相同區段， (IAT) 。</span><span class="sxs-lookup"><span data-stu-id="6b739-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="6b739-133">GuardCFCheckFunctionPointer 會提供作業系統載入器所提供符號的位址，該符號可使用第一個整數引數暫存器中的函式指標來呼叫 (ECX 在 x86) 上會傳回成功，如果呼叫目標不是有效的 CFG 目標，則會中止進程。</span><span class="sxs-lookup"><span data-stu-id="6b739-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="6b739-134">GuardCFDispatchFunctionPointer 會提供作業系統載入器所提供符號的位址，此符號會接受 register RAX 中的呼叫目標，並執行結合的 CFG 檢查和對呼叫目標的尾分支優化呼叫 (登錄 R4-r10/R11 會保留供 GuardCFDispatchFunctionPointer 使用，而整數引數暫存器則保留供最終呼叫目標) 使用。</span><span class="sxs-lookup"><span data-stu-id="6b739-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="6b739-135">映射中 CFG 符號的預設位址應該指向一個函式，該函式只會傳回 (GuardCFCheckFunctionPointer) 或傳回防護隱藏符號 (或最好從執行 "jmp rax" 指令的 **GFIDS** 資料表符號) 完全省略。</span><span class="sxs-lookup"><span data-stu-id="6b739-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="6b739-136">針對 AMD64 GuardCFDispatchFunctionPointer，當映射在 CFG 感知的作業系統上載入，而 CFG 已啟用時，OS DLL 載入器會安裝適當的函式指標，進而提供回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="6b739-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="6b739-137">如果映射不打算使用 CFG 分派設備，則映射可以為負載設定中的 GuardCFDispatchFunctionPointer 提供0。</span><span class="sxs-lookup"><span data-stu-id="6b739-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="6b739-138">這應該針對非 AMD64 架構進行，以供未來相容，以防這些架構最終以某種形式支援 CFG 分派機制。</span><span class="sxs-lookup"><span data-stu-id="6b739-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="6b739-139">請注意，Windows 8.1 AMD64 不支援 CFG 分派，而且會保留 GuardCFDispatchFunctionPointer 的預設函式指標。</span><span class="sxs-lookup"><span data-stu-id="6b739-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="6b739-140">只有 Windows 10 和更新版本的作業系統才支援 CFG 分派。</span><span class="sxs-lookup"><span data-stu-id="6b739-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="6b739-141">使用者模式 CFG 可能只會針對標示為位址空間配置隨機載入的影像強制執行 (ASLR) 相容 (由/DYNAMICBASE 選項指定為 Microsoft 連結器) 。</span><span class="sxs-lookup"><span data-stu-id="6b739-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="6b739-142">這是因為作業系統會在內部處理 CFG，其中基本上是連接到 ASLR 基礎結構。</span><span class="sxs-lookup"><span data-stu-id="6b739-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="6b739-143">一般而言，CFG 的使用者應該在第一個步驟中啟用其映射的 ASLR。</span><span class="sxs-lookup"><span data-stu-id="6b739-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="6b739-144">工具不應假設作業系統一律會忽略未設定 ASLR 的 CFG，但通常應該同時設定兩者。</span><span class="sxs-lookup"><span data-stu-id="6b739-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="6b739-145">編譯器指示詞</span><span class="sxs-lookup"><span data-stu-id="6b739-145">Compiler directives</span></span>

- <span data-ttu-id="6b739-146">您可以使用 __declspec (防護 (隱藏) ) 修飾詞，或使用適用于 asm 程式碼的/guardsym： symname，S 連結器指示詞 (（例如) ），將呼叫目標標示為明確隱藏。</span><span class="sxs-lookup"><span data-stu-id="6b739-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="6b739-147">這會導致呼叫目標包含在 **GFIDS** 資料表中，但會以作業系統將呼叫目標視為不正確方式進行標示。</span><span class="sxs-lookup"><span data-stu-id="6b739-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="6b739-148">某些非生產案例（例如，在某些較舊的作業系統上啟用特定的 application verifier instrumentation）可以讓隱藏的呼叫目標被視為有效，但在一般情況下，這些案例都不應該是生產案例。</span><span class="sxs-lookup"><span data-stu-id="6b739-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="6b739-149">這個指示詞適用于批註「危險」的函式，這些函式不應該視為有效的呼叫目標，即使一般的 CFG 規則會包含它們也一樣。</span><span class="sxs-lookup"><span data-stu-id="6b739-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="6b739-150">程式碼可以使用 __declspec (guard (nocf) ) 修飾詞來表示不需要 CFG 檢查。</span><span class="sxs-lookup"><span data-stu-id="6b739-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="6b739-151">這會指示編譯器不要插入整個函數的任何 CFG 檢查。</span><span class="sxs-lookup"><span data-stu-id="6b739-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="6b739-152">編譯器應該小心將這個指示詞傳播至內嵌函式所提供的任何程式碼，該函式會標示為不需要 CFG 檢查。</span><span class="sxs-lookup"><span data-stu-id="6b739-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="6b739-153">這種方法通常只會在程式設計師手動插入「CFG 相等」保護的特定情況下使用。</span><span class="sxs-lookup"><span data-stu-id="6b739-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="6b739-154">程式設計師知道這些函式是透過一些唯讀的函式資料表來呼叫，其位址是透過唯讀記憶體參考取得，而其索引已遮罩至函式資料表的限制。</span><span class="sxs-lookup"><span data-stu-id="6b739-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="6b739-155">這種方法也可以套用至不是內嵌的小型包裝函式，而不是透過函式指標進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="6b739-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="6b739-156">由於這個指示詞的使用不正確可能會危及 CFG 的安全性，因此程式設計人員必須非常小心地使用指示詞。</span><span class="sxs-lookup"><span data-stu-id="6b739-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="6b739-157">一般來說，這種使用方式僅限於只呼叫一個函式的非常小函式。</span><span class="sxs-lookup"><span data-stu-id="6b739-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="6b739-158">匯入處理</span><span class="sxs-lookup"><span data-stu-id="6b739-158">Import handling</span></span>

- <span data-ttu-id="6b739-159">透過 IAT 的呼叫不應使用 CFG 保護。</span><span class="sxs-lookup"><span data-stu-id="6b739-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="6b739-160">此 IAT 在新式映射中是唯讀的 (假設 IAT 是在 PE 標頭中宣告的，在這種情況下，它必須在自己的頁面上) 。</span><span class="sxs-lookup"><span data-stu-id="6b739-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="6b739-161">IAT 可用來觸達防護隱藏的函式，因此這是正確性需求。</span><span class="sxs-lookup"><span data-stu-id="6b739-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="6b739-162">透過 IAT 的唯讀記憶體保護會取代 CFG，因為在解析映射匯入快照之後，呼叫目標系結是不可變的，且系結解析更精細。</span><span class="sxs-lookup"><span data-stu-id="6b739-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="6b739-163">受保護的延遲載入：透過延遲載入 IAT 的呼叫不應使用 CFG 保護，原因與標準 IAT 相同。</span><span class="sxs-lookup"><span data-stu-id="6b739-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="6b739-164">延遲載入 IAT 應該在它自己的區段中，而影像應設定 IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags 位。</span><span class="sxs-lookup"><span data-stu-id="6b739-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="6b739-165">這表示如果使用作業系統的延遲負載支援 Windows 8 和更新版本的作業系統，作業系統的 DLL 載入器應該會在匯出解析期間變更延遲載入 IAT 的保護。</span><span class="sxs-lookup"><span data-stu-id="6b739-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="6b739-166">如果原生作業系統延遲負載支援正在使用中，則此步驟的同步處理是由作業系統 DLL 載入器所管理 (例如 ResolveDelayLoadedAPI) 因此，其他元件都不應該重新保護頁面跨越宣告的延遲載入 IAT。</span><span class="sxs-lookup"><span data-stu-id="6b739-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="6b739-167">為了與舊版預先配置的作業系統相容，工具可能會啟用將延遲載入 IAT 移至其專屬區段的選項 (標準方式 ". didat" ) 、在映射標頭中受保護為讀取/寫入，以及另外設定 IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION 旗標。</span><span class="sxs-lookup"><span data-stu-id="6b739-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="6b739-168">這種設定會讓 CFG 感知作業系統 DLL 載入器重新保護包含 IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 資料表的整個區段，以在映射載入期間讀取記憶體。</span><span class="sxs-lookup"><span data-stu-id="6b739-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="6b739-169">如果您不在意在早 CFG 支援的作業系統上執行映射，但工具應根據映射所需的最低作業系統支援來進行決策，則可能不需要將延遲載入 IAT 放在其本身區段中的選項。</span><span class="sxs-lookup"><span data-stu-id="6b739-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="6b739-170">如果映射未使用作業系統的原生延遲載入支援，它仍可設定受保護的延遲載入相關 GuardFlags 位。</span><span class="sxs-lookup"><span data-stu-id="6b739-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="6b739-171">在此設定中，作業系統載入器只會在執行時間提供支援來保護延遲載入 IAT 為唯讀（如果平臺支援），而且會成為映射內部延遲載入解析存根的責任，以同步處理和管理延遲載入 IAT 的保護。</span><span class="sxs-lookup"><span data-stu-id="6b739-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="6b739-172">如果載入設定資料表是儲存在唯讀記憶體中 (這是建議的) ，則在影像的 GuardFlags 欄位中，受保護的延遲載入 IAT 位是否存在，可能會很有用，因為它會作為影像內部延遲載入解析存根的內部提示，以指出它是否應該保護延遲載入 IAT。</span><span class="sxs-lookup"><span data-stu-id="6b739-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="6b739-173">如果已啟用 CFG，建議您預設啟用受保護的延遲載入。</span><span class="sxs-lookup"><span data-stu-id="6b739-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="6b739-174">在較舊的作業系統版本上執行，且使用作業系統原生延遲負載支援的影像（如所述），可能會在其本身的區段支援中使用延遲載入 IAT，以提供回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="6b739-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="6b739-175">這並不是將延遲載入 IAT 標示為唯讀，並將其與另一個區段合併，而這會在較舊的作業系統上中斷，而不了解受保護的延遲負載，並提供原生延遲載入解析支援。</span><span class="sxs-lookup"><span data-stu-id="6b739-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="6b739-176">所有 Windows 10 版本和第一個 Windows 8.1/Windows Server 2012 R2 會建立支援的 CFG (表示2014年11月更新) 引進作業系統中受保護延遲負載的支援。</span><span class="sxs-lookup"><span data-stu-id="6b739-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="6b739-177">函數對齊</span><span class="sxs-lookup"><span data-stu-id="6b739-177">Function alignment</span></span>

- <span data-ttu-id="6b739-178">如果有可能的話， **GFIDS** 資料表中所採用的函式，也應以16位元組對齊。</span><span class="sxs-lookup"><span data-stu-id="6b739-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="6b739-179">這可能並非永遠可行。</span><span class="sxs-lookup"><span data-stu-id="6b739-179">This may not always be possible.</span></span> <span data-ttu-id="6b739-180">例如，如果非 COMDAT 函式是由非 CFG 感知工具組合成一個單位（某些組合器可能會產生），則產生檔案之工具的使用者必須適當地設定對齊。</span><span class="sxs-lookup"><span data-stu-id="6b739-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="6b739-181">在此情況下，工具可能會選擇發出診斷警告，讓使用者可以採取適當的更正動作。</span><span class="sxs-lookup"><span data-stu-id="6b739-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="6b739-182">這是因為 CFG 會將呼叫目標標示為有效，或在16位元組的界限上無效，以提升快速 CFG 檢查的效率。</span><span class="sxs-lookup"><span data-stu-id="6b739-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="6b739-183">如果函式不是16位元組對齊，則整個16位元組位置必須標記為有效，因為您無法在不是函式開頭的程式碼中進行呼叫，所以它不是安全的。</span><span class="sxs-lookup"><span data-stu-id="6b739-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="6b739-184">當您第一次為專案帶來 CFG 時，支援此案例以簡化互通性。</span><span class="sxs-lookup"><span data-stu-id="6b739-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="6b739-185">非 CFG 感知映射會同樣標示為適用于相容性的任何呼叫目標對齊。</span><span class="sxs-lookup"><span data-stu-id="6b739-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="6b739-186">同樣地，具有不當的呼叫目標可減少 CFG 的安全性優點，因此當映射需要 CFG 時，工具應該會針對 **GFIDS** 資料表中的任何事物，自動對齊16位元組的界限。</span><span class="sxs-lookup"><span data-stu-id="6b739-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="6b739-187">不在 **GFIDS** 資料表中的符號不需要針對 CFG 進行特定的對齊。</span><span class="sxs-lookup"><span data-stu-id="6b739-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="6b739-188">匯出隱藏專案</span><span class="sxs-lookup"><span data-stu-id="6b739-188">Export suppression</span></span>

- <span data-ttu-id="6b739-189">CFG 匯出隱藏 (CFG ES) 是一種選擇性模式，可讓處理常式指出只因為它們是 dllexport 符號，而且尚未由 GetProcAddress 動態解決的呼叫目標，將會被視為不適用於 CFG 的用途。</span><span class="sxs-lookup"><span data-stu-id="6b739-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="6b739-190">這樣可減少系統 DLL 匯出的 CFG 介面區。</span><span class="sxs-lookup"><span data-stu-id="6b739-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="6b739-191">匯出隱藏專案牽涉到使用 IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** 旗標加以標記，以傳達合格的「匯出隱藏」 dllexport 呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="6b739-192">Dllexport 符號和 PE 映射進入點應隱含地被視為產生 **GFIDS** 資料表所使用的工具所採用的位址。</span><span class="sxs-lookup"><span data-stu-id="6b739-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="6b739-193">如果匯出符號的對齊是16位元組，而不是使用 dllexport 的其他原因，則可以使用函式資料表中的「匯出隱藏的 **GFIDS** 旗標來標示。</span><span class="sxs-lookup"><span data-stu-id="6b739-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="6b739-194">未對齊16位元組的呼叫目標 **不** 能以 IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** 旗標標記，也無法限制為只在 GetProcAddress 時動態啟用為有效的呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="6b739-195">支援 CFG ES 的映射包含 GuardAddressTakenIatEntryTable，其計數會由 GuardAddressTakenIatEntryCount 提供作為其 load configuration 目錄的一部分。</span><span class="sxs-lookup"><span data-stu-id="6b739-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="6b739-196">此資料表的結構格式與 **GFIDS** 資料表相同。</span><span class="sxs-lookup"><span data-stu-id="6b739-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="6b739-197">它會使用相同的 GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK 機制，將 address 所取得的額外選擇性中繼資料位元組編碼，但在取得 IAT 資料表的位址中，所有中繼資料位元組都必須是零，而且會保留。</span><span class="sxs-lookup"><span data-stu-id="6b739-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="6b739-198">取得的位址 IAT 資料表表示匯入 Thunk 的已排序陣列，其匯入為取得呼叫目標的符號位址。</span><span class="sxs-lookup"><span data-stu-id="6b739-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="6b739-199">此結構可支援存在於遠端模組中的位址符號，以及使用 CFG ES 的 dllexports。</span><span class="sxs-lookup"><span data-stu-id="6b739-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="6b739-200">這類程式碼結構的範例如下：</span><span class="sxs-lookup"><span data-stu-id="6b739-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="6b739-201">所有採用匯入 Thunk 的位址都必須加以列舉，以便作業系統載入器可以找到它們，並且在載入影像和貼上其匯入時，讓適當的呼叫目標有效。</span><span class="sxs-lookup"><span data-stu-id="6b739-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="6b739-202">如果沒有所採取的匯入 Thunk，資料表和計數可以是0。</span><span class="sxs-lookup"><span data-stu-id="6b739-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="6b739-203">模組會設定 IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags 位，以指出它已列舉位址取得 IAT 資料表中的所有位址，並以 IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** 旗標標示符合 CFG ES 資格的所有匯出。</span><span class="sxs-lookup"><span data-stu-id="6b739-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="6b739-204">請注意，可能會有零個這類 Thunk，而且可能也有零個這類 dllexport 符號。</span><span class="sxs-lookup"><span data-stu-id="6b739-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="6b739-205">無法維護取得的位址 IAT 資料表可能是正確性問題，因為某些呼叫目標在載入 DLL 時可能無法有效。</span><span class="sxs-lookup"><span data-stu-id="6b739-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="6b739-206">模組會設定 IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags 位，表示它想要為進程啟用 CFG ES。</span><span class="sxs-lookup"><span data-stu-id="6b739-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="6b739-207">在實務上，這對目前只有 Exe 有意義。</span><span class="sxs-lookup"><span data-stu-id="6b739-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="6b739-208">啟用 CFG ES 的進程不應載入未使用 CFG ES 或執行時間失敗的 Dll，因為 undesignated 位址會取得 IAT 符號。</span><span class="sxs-lookup"><span data-stu-id="6b739-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="6b739-209">啟用 cfg ES 的支援應為啟用 CFG 的個別加入宣告選項。</span><span class="sxs-lookup"><span data-stu-id="6b739-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="6b739-210">根據預設，提供 CFG ES 中繼資料是安全的，且預設為使用 CFG，不過工具組必須小心確保它們會產生正確的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6b739-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="6b739-211">如果沒有，則其產生的映射可能無法在 CFG ES 進程中正確執行。</span><span class="sxs-lookup"><span data-stu-id="6b739-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="6b739-212">您應在強制執行 CFG ES 的測試程式中徹底測試這類支援。</span><span class="sxs-lookup"><span data-stu-id="6b739-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="6b739-213">作業系統內建的系統 Dll 支援可瞭解 CFG ES 之新式 Windows 10 作業系統版本的 CFG ES 中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6b739-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="6b739-214">這項支援之前的作業系統版本並不瞭解 CFG ES，而且會忽略映射中任何 CFG ES 相關的指示詞。</span><span class="sxs-lookup"><span data-stu-id="6b739-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="6b739-215">這類映射仍可回溯相容于較舊的作業系統版本。</span><span class="sxs-lookup"><span data-stu-id="6b739-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="6b739-216">從工具組的角度來看，CFG ES 支援是選擇性的，但建議工具組至少包含列舉足夠的資訊，以便在需要 CFG ES 的進程中執行影像。</span><span class="sxs-lookup"><span data-stu-id="6b739-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="6b739-217">如前所述，工具組支援經過徹底測試，以確保它與 CFG ES 相容，因為大部分的處理常式尚未啟用 CFG ES。</span><span class="sxs-lookup"><span data-stu-id="6b739-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="6b739-218">例外狀況處理和回溯</span><span class="sxs-lookup"><span data-stu-id="6b739-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="6b739-219">.Pdata 註冊中的例外狀況處理常式資訊所指定的語言特定處理常式（例如 __C_specific_handler），不應該在 **GFIDS** 資料表中標示為有效的呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="6b739-220">您可以藉由遍歷唯讀記憶體來查閱它們。</span><span class="sxs-lookup"><span data-stu-id="6b739-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="6b739-221">同樣地，Microsoft C 語言特定處理常式會使用唯讀記憶體搜尋來找出例外狀況處理常式的 funclets，因此不會在 **GFIDS** 資料表中將其 funclets 宣告為有效的呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="6b739-222">長期跳躍處理 (針對非 x86 目標（例如 AMD64) ）：使用 CFG 編譯的工具組和支援的 setjmp () /longjmp () 應該將長跳躍的時間實作為「安全的長跳躍」，以與結構化例外狀況處理 (SEH) 互通。</span><span class="sxs-lookup"><span data-stu-id="6b739-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="6b739-223">這表示長跳躍會實作為呼叫 RtlUnwindEx，並以 STATUS_LONGJUMP 作為提供的例外狀況記錄中的狀態碼，以及 ExceptionInformation [0] 指向的標準 _JUMP_BUFFER。</span><span class="sxs-lookup"><span data-stu-id="6b739-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="6b739-224">跳躍回溯目標應該是回溯的 TargetIp。</span><span class="sxs-lookup"><span data-stu-id="6b739-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="6b739-225">跳躍緩衝區代表當長時間跳躍完成之後，作業系統還原的註冊內容。</span><span class="sxs-lookup"><span data-stu-id="6b739-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="6b739-226">RtlUnwind (例如，使用 STATUS_LONGJUMP 所呼叫的) 具有 CFG 特有的特殊意義。</span><span class="sxs-lookup"><span data-stu-id="6b739-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="6b739-227">長跳躍目標 (_JUMP_BUFFER。Rip 或 _JUMP_BUFFER。ARM64 上的 Lr) 是在作業系統于唯讀記憶體中維護的已載入模組清單中查閱。</span><span class="sxs-lookup"><span data-stu-id="6b739-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="6b739-228">如果跳躍目標的包含模組 (「目的模組」 ) 在其 GuardFlags 欄位中設定 IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT 旗標，則 load configuration 目錄會有一個 GuardLongJumpTargetTable whith [load configuration GuardLongJumpTargetCount] 欄位所指定的元素計數。</span><span class="sxs-lookup"><span data-stu-id="6b739-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="6b739-229">此資料表的結構格式與 **GFIDS** 資料表相同，並使用相同的 GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK 機制來編碼長跳躍資料表中選擇性的額外中繼資料位元組。</span><span class="sxs-lookup"><span data-stu-id="6b739-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="6b739-230">長跳躍表的所有中繼資料位元組都必須為零，而且是保留的。</span><span class="sxs-lookup"><span data-stu-id="6b739-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="6b739-231">長跳躍資料表代表已排序的 Rva 陣列，這些是有效的長跳躍目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="6b739-232">如果長跳躍目的模組在其 GuardFlags 欄位中設定 IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT，則所有長的跳躍目標都必須在 LongJumpTargetTable 中列舉。</span><span class="sxs-lookup"><span data-stu-id="6b739-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="6b739-233">即使模組有零長的跳躍目標，如果工具組支援 CFG 的長期跳躍強化，它仍應設定 IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT 旗標。</span><span class="sxs-lookup"><span data-stu-id="6b739-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="6b739-234">這表示映射沒有長跳躍目標，而且不是舊的映射，作業系統必須假設該映射在未標記的位置會有有效的長跳躍目標，無法執行長跳躍目標檢查。</span><span class="sxs-lookup"><span data-stu-id="6b739-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="6b739-235">如果支援 CFG，建議您預設啟用長跳躍強化。</span><span class="sxs-lookup"><span data-stu-id="6b739-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="6b739-236">這是 Microsoft 編譯器的配置。</span><span class="sxs-lookup"><span data-stu-id="6b739-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="6b739-237">不了解長時間強化強化的作業系統 (預先 Windows 10 或較舊的 Windows 10 版本) 將不會執行長時間跳躍強化檢查，而且會忽略任何長時間跳躍強化的中繼資料，因此長期的快速強化可回溯相容于較舊的作業系統版本。</span><span class="sxs-lookup"><span data-stu-id="6b739-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="6b739-238">若為核心模式映射，「臨界長跳躍」目標資料表不應該包含在 discardable 區段中。</span><span class="sxs-lookup"><span data-stu-id="6b739-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="6b739-239">「防護長跳躍」目標資料表應該一律儲存在唯讀的記憶體中，其安全性屬性才會生效。</span><span class="sxs-lookup"><span data-stu-id="6b739-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="6b739-240">COFF 資訊</span><span class="sxs-lookup"><span data-stu-id="6b739-240">COFF information</span></span>

- <span data-ttu-id="6b739-241">有目的檔標記可宣告物件檔案是否符合 CFG。</span><span class="sxs-lookup"><span data-stu-id="6b739-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="6b739-242">符合 CFG 的目的檔會列出它所產生的有效呼叫目標，以及取得 IAT 中繼資料的任何位址。</span><span class="sxs-lookup"><span data-stu-id="6b739-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="6b739-243">不符合 CFG 的目的檔必須藉由檢查 obj 檔案的 COFF 重新置放，以找出指向函式符號開頭的重新置放，來推斷呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="6b739-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="6b739-244">這可能會 overapproximate 有效的 CFG 呼叫目標，因此在使用 CFG 進行編譯時，工具很希望工具標記其具有 CFG 感知的 obj 檔案，並包含 CFG obj 檔案中繼資料。</span><span class="sxs-lookup"><span data-stu-id="6b739-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="6b739-245">有個目的檔標記可宣告 CFG 強化的長跳躍目標，以進行 cfg 編譯模式。</span><span class="sxs-lookup"><span data-stu-id="6b739-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
