---
title: 函數/屬性名稱在延伸模組中的自動化衝突
description: 在本主題中，\ 0034; object \ 0034;表示以 ADSI 用戶端為物件進行流覽的整個物件。 也就是 ADSI 及其所有副檔名。
ms.assetid: 76207326-879e-408b-8004-06d940401a41
ms.tgt_platform: multiple
keywords:
- 函數和屬性名稱在延伸模組中的自動化衝突
- 擴充功能 ADSI，解決函式和屬性名稱在自動化中的衝突
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d9a7ac99b99ecdf0ee1b940f066d9e8166a15542
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382849"
---
# <a name="resolution-of-functionproperty-name-conflicts-in-automation-in-extensions"></a><span data-ttu-id="c6e8f-106">函數/屬性名稱在延伸模組中的自動化衝突</span><span class="sxs-lookup"><span data-stu-id="c6e8f-106">Resolution of Function/Property Name Conflicts in Automation in Extensions</span></span>

<span data-ttu-id="c6e8f-107">在本主題中，「物件」會以 ADSI 用戶端的形式來表示整個物件。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-107">In this topic, "object" indicates the object, as a whole, as an ADSI client views it.</span></span> <span data-ttu-id="c6e8f-108">也就是 ADSI 及其所有副檔名。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-108">That is, ADSI and all its extensions.</span></span>

## <a name="same-function-name-with-the-same-parameters"></a><span data-ttu-id="c6e8f-109">具有相同參數的相同函式名稱</span><span class="sxs-lookup"><span data-stu-id="c6e8f-109">Same Function Name With the Same Parameters</span></span>

<span data-ttu-id="c6e8f-110">如果物件中有兩個以上的雙重 [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) 介面支援相同名稱的屬性或方法（例如， **Func1**），則會使用下列準則來判斷調用。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-110">If two or more dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in an object support a property or method of the same name, for example, **Func1**, invocation is determined using the following criteria.</span></span> <span data-ttu-id="c6e8f-111">如果用戶端有一個可支援稱為 **Func1** 之方法的雙重介面指標，而且如果 Automation 環境支援 vtable 存取，則會直接透過 ADSI vtable 存取來叫用 **Func1** 。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-111">If the client has a pointer to one of the dual interfaces that support a method called **Func1** and if the Automation environment supports vtable access, **Func1** is invoked directly through ADSI vtable access.</span></span>

<span data-ttu-id="c6e8f-112">如果上述任一條件為 false，則會呼叫 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) 和 [**Idispatch：： invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) 來叫用 **Func1**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-112">If either of the conditions above is false, [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) and [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) are called to invoke **Func1**.</span></span>

<span data-ttu-id="c6e8f-113">如需有關用戶端如何新增雙重介面指標的詳細資訊，以及有關支援 vtable 存取之環境類型的說明，請參閱 [ADSI 擴充模型中的晚期繫結與 Vtable 存取](late-binding-vs--vtable-access-in-the-adsi-extension-model.md)。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-113">For more information and a brief explanation about how a client can add a pointer to a dual interface, and a description of the types of environments that support vtable access, see [Late Binding versus Vtable Access in the ADSI Extension Model](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).</span></span>

<span data-ttu-id="c6e8f-114">由於所有的擴充物件都會將 [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) 函式重新導向至匯總工具，因此匯總工具會控制要叫用的 **Func1** 。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-114">Because all extension objects redirect the [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) functions back to the aggregator, the aggregator controls which **Func1** is invoked.</span></span> <span data-ttu-id="c6e8f-115">這些規則包括：</span><span class="sxs-lookup"><span data-stu-id="c6e8f-115">The rules are:</span></span>

-   <span data-ttu-id="c6e8f-116">如果有任何介面，且匯總工具 (ADSI) 中只有一個介面，則會支援稱為 **Func1** 的函式，而匯總工具會叫用它自己的 **Func1**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-116">If any interface, and there will be only one, if any, in the aggregator (ADSI) supports a function called **Func1**, the aggregator invokes its own **Func1**.</span></span>
-   <span data-ttu-id="c6e8f-117">否則，匯總工具會依登錄中列出的順序，逐一查看其每個擴充功能，並尋找第一個執行名為 **Func1** 函式的擴充功能。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-117">Otherwise, the aggregator goes through each of its extensions, in the order listed in the registry, and finds the first extension that implements a function called **Func1**.</span></span> <span data-ttu-id="c6e8f-118">此第一個延伸模組中的多個雙重 [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) 介面可能會有一個稱為 **Func1** 的函式，但可能不太可能。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-118">It is possible, but unlikely, that multiple dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in this first extension have a function called **Func1**.</span></span> <span data-ttu-id="c6e8f-119">延伸模組必須決定要在自動化中叫用的 **Func1** 。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-119">The extension must determine which **Func1** should always be invoked in Automation.</span></span>

## <a name="same-function-name-with-different-parameters"></a><span data-ttu-id="c6e8f-120">具有不同參數的相同函式名稱</span><span class="sxs-lookup"><span data-stu-id="c6e8f-120">Same Function Name With Different Parameters</span></span>

<span data-ttu-id="c6e8f-121">上一節討論了如何解決函式名稱衝突，也就是在自動化中發生的函式名稱與相同參數清單的函式名稱，例如 number、type 和 order。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-121">The previous section discussed how to resolve function name conflicts, that is, function names that have the same function name and same parameter list, such as number, type and order, when it occurs in Automation.</span></span> <span data-ttu-id="c6e8f-122">如果兩個函式的名稱相同但參數不同，該怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="c6e8f-122">What if two functions have the same name but different parameters?</span></span> <span data-ttu-id="c6e8f-123">如果 ADSI 用戶端使用 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) 叫用函式，而不使用多個名稱來指定參數，adsi 擴充功能模型就無法區分這些函式。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-123">If an ADSI client invokes the function using [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) without using multiple names to specify the parameters, the ADSI extension model cannot disambiguate the functions.</span></span> <span data-ttu-id="c6e8f-124">根據上面討論的解決方式，登錄中透過其中一個介面支援此函式的第一個擴充功能，會叫用此函式的版本，而呼叫可能會失敗或產生不正確的結果。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-124">Based on the resolution scheme discussed in above, the first extension in the registry that supports this function through one of its interfaces has its version of this function invoked, and the call may fail or yield incorrect results.</span></span>

<span data-ttu-id="c6e8f-125">例如：</span><span class="sxs-lookup"><span data-stu-id="c6e8f-125">For example:</span></span>

-   <span data-ttu-id="c6e8f-126">Extn1 (在 [類別 CA] 下的登錄中優先-優先順序較高) 支援 **IInterface1**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-126">Extn1 (first in the registry under class CA – higher priority) supports **IInterface1**.</span></span>
-   <span data-ttu-id="c6e8f-127">Extn2 類別下登錄中的第三個 (第三個-低優先順序) 支援 **IInterface2**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-127">Extn2 (third in the registry under class CA – lower priority) supports **IInterface2**.</span></span>
-   <span data-ttu-id="c6e8f-128">**IInterface1** 支援 **Method1 (int param1，int param2)**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-128">**IInterface1** supports **Method1(int param1, int param2)**.</span></span>
-   <span data-ttu-id="c6e8f-129">**IInterface2** 支援 **Method1 (int param1)**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-129">**IInterface2** supports **Method1(int param1)**.</span></span>

<span data-ttu-id="c6e8f-130">ADSI 用戶端具有類別 CA 物件的 [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) 介面指標。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-130">An ADSI client has an [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interface pointer to an object of class CA.</span></span> <span data-ttu-id="c6e8f-131">它想要叫用 **IInterface2：： Method1**。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-131">It wants to invoke **IInterface2::Method1**.</span></span> <span data-ttu-id="c6e8f-132">如果用戶端呼叫「pDispatch->GetIDsOfNames (IID \_ Null、rgszNames、1、MY \_ LCID、rgDispId) 」，只要在 *Method1 \[ 0 \]* 中儲存函式名稱 "rgszNames"，就會叫用 **IInterface1：： Method1** ，而不是使用所需的 **IInterface2：： Method1** ，而且此函式會失敗，因為參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-132">If the client calls "pDispatch->GetIDsOfNames(IID\_NULL, rgszNames, 1, MY\_LCID, rgDispId)" by just storing the function name "Method1" in *rgszNames\[0\]*, then **IInterface1::Method1** instead of the desired **IInterface2::Method1** is invoked, and the function fails because the number of parameters are different.</span></span>

<span data-ttu-id="c6e8f-133">為了將這個問題降至最低，延伸模組開發人員可以在其函式名稱前面加上其專屬的識別碼，並避免使用相同名稱但不同參數之函式的介面設計。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-133">To minimize this problem, extension developers can prefix their function names with their own specific identifiers and avoid interface designs that use functions of the same name, but different parameters.</span></span>

<span data-ttu-id="c6e8f-134">如果發生名稱衝突，即使介面是雙重介面，ADSI 用戶端仍可直接進行 vtable 存取，以避免此問題。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-134">If a name conflict does occur, ADSI clients can avoid the problem by direct vtable access if the interface is a dual interface.</span></span> <span data-ttu-id="c6e8f-135">如果無法進行直接 vtable 存取，ADSI 用戶端應該使用多個名稱來呼叫 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) ，並指定函式名稱，以及先前所述的陣列 *rgszNames* 中的參數。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-135">If direct vtable access is not possible, ADSI clients should call [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) with multiple names, specifying the function names as well as the parameters in the array *rgszNames* described previously.</span></span>

<span data-ttu-id="c6e8f-136">Visual Basic 5 不會使用多個名稱來呼叫 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) 函數。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-136">Visual Basic 5 does not call the [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) function with multiple names.</span></span> <span data-ttu-id="c6e8f-137">也就是說，它只會將函式名稱傳遞給 **GetIDsOfNames**，而不會傳遞引數。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-137">That is, it passes only the function name to **GetIDsOfNames**, but not arguments.</span></span> <span data-ttu-id="c6e8f-138">不過，Visual Basic 5 可讓使用者藉由直接 vtable 存取來叫用函式，而不是叫用 **IDispatch：： GetIDsOfNames** 函數（如果介面是雙重介面）。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-138">However, Visual Basic 5 allows users to invoke a function by direct vtable access, instead of invoking the **IDispatch::GetIDsOfNames** function if the interface is a dual interface.</span></span> <span data-ttu-id="c6e8f-139">開發人員應該盡可能使用直接 vtable 存取。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-139">Developers should use direct vtable access, if possible.</span></span>

<span data-ttu-id="c6e8f-140">如需名稱衝突解決方式的詳細資訊，請參閱 [解析函數名稱衝突的範例](example-for-resolving-function-name-conflicts.md)。</span><span class="sxs-lookup"><span data-stu-id="c6e8f-140">For more information about name conflict resolution, see [Example for Resolving Function Name Conflicts](example-for-resolving-function-name-conflicts.md).</span></span>

 

 