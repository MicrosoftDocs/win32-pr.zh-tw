---
title: ADSI 提供者的執行問題
description: ADSI 提供者的執行問題
ms.assetid: 0be772aa-e7d8-4d34-b55a-162abfb0bfd4
ms.tgt_platform: multiple
keywords:
- ADSI 提供者 ADSI 的執行問題
- 提供者 ADSI、執行
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c4c362b04244580e448e7bb7bd78889e66db12fe
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382877"
---
# <a name="implementation-issues-for-adsi-providers"></a><span data-ttu-id="51eca-105">ADSI 提供者的執行問題</span><span class="sxs-lookup"><span data-stu-id="51eca-105">Implementation Issues for ADSI Providers</span></span>

<span data-ttu-id="51eca-106">若要執行 ADSI 介面，請先執行 COM 介面 [**IDirectoryObject**](/windows/desktop/api/Iads/nn-iads-idirectoryobject)。</span><span class="sxs-lookup"><span data-stu-id="51eca-106">To implement ADSI interfaces, first implement the COM interface [**IDirectoryObject**](/windows/desktop/api/Iads/nn-iads-idirectoryobject).</span></span> <span data-ttu-id="51eca-107">藉由將此介面提供為最少量的額外負荷層級，您可以提供用戶端應用程式直接從目錄存取目錄物件所需的控制項，而不是透過 ADSI 快取來優化網路效能。</span><span class="sxs-lookup"><span data-stu-id="51eca-107">By providing this interface as a minimal overhead layer, you supply client applications the control required to access directory objects directly from the directory rather than through the ADSI cache, which optimizes network performance.</span></span> <span data-ttu-id="51eca-108">使用這個介面也會提供您自己的實作為彈性。</span><span class="sxs-lookup"><span data-stu-id="51eca-108">Using this interface will also supply your own implementation with the most flexibility.</span></span>

<span data-ttu-id="51eca-109">其次，請執行基本的 ADSI 介面、 [**IADs**](/windows/desktop/api/Iads/nn-iads-iads)、 [**IADsContainer**](/windows/desktop/api/Iads/nn-iads-iadscontainer)、 [**IADsCollection**](/windows/desktop/api/Iads/nn-iads-iadscollection)和 [**IADsPropertyValue**](/windows/desktop/api/Iads/nn-iads-iadspropertyvalue)、 [**IADsPropertyEntry**](/windows/desktop/api/Iads/nn-iads-iadspropertyentry)、 [**IADsPropertyList**](/windows/desktop/api/Iads/nn-iads-iadspropertylist) 屬性快取介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-109">Second, implement the fundamental ADSI interfaces, [**IADs**](/windows/desktop/api/Iads/nn-iads-iads), [**IADsContainer**](/windows/desktop/api/Iads/nn-iads-iadscontainer), [**IADsCollection**](/windows/desktop/api/Iads/nn-iads-iadscollection), and the [**IADsPropertyValue**](/windows/desktop/api/Iads/nn-iads-iadspropertyvalue), [**IADsPropertyEntry**](/windows/desktop/api/Iads/nn-iads-iadspropertyentry), [**IADsPropertyList**](/windows/desktop/api/Iads/nn-iads-iadspropertylist) property cache interfaces.</span></span> <span data-ttu-id="51eca-110">[**IADsGroup**](/windows/desktop/api/Iads/nn-iads-iadsgroup) 和 [**IADsMembers**](/windows/desktop/api/Iads/nn-iads-iadsmembers) 也是系統管理軟體經常需要的介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-110">[**IADsGroup**](/windows/desktop/api/Iads/nn-iads-iadsgroup) and [**IADsMembers**](/windows/desktop/api/Iads/nn-iads-iadsmembers) are also interfaces in frequent demand by system administration software.</span></span>

<span data-ttu-id="51eca-111">第三，如果您的目錄服務具有基礎架構，請執行架構管理介面： [**得到 iadsclass**](/windows/desktop/api/Iads/nn-iads-iadsclass)、 [**IADsProperty**](/windows/desktop/api/Iads/nn-iads-iadsproperty)、 [**IADsSyntax**](/windows/desktop/api/Iads/nn-iads-iadssyntax)。</span><span class="sxs-lookup"><span data-stu-id="51eca-111">Third, implement the schema management interfaces if your directory service has an underlying schema: [**IADsClass**](/windows/desktop/api/Iads/nn-iads-iadsclass), [**IADsProperty**](/windows/desktop/api/Iads/nn-iads-iadsproperty), [**IADsSyntax**](/windows/desktop/api/Iads/nn-iads-iadssyntax).</span></span> <span data-ttu-id="51eca-112">如果沒有基礎架構，請使用這些介面來抽象化目錄服務所使用的類別和屬性。</span><span class="sxs-lookup"><span data-stu-id="51eca-112">If there is no underlying schema, use these interfaces to abstract the classes and properties used by the directory service.</span></span> <span data-ttu-id="51eca-113">架構可以用來將目錄服務的功能發行至 ADSI 用戶端。</span><span class="sxs-lookup"><span data-stu-id="51eca-113">Schemas can be used to publish the features of your directory service to ADSI clients.</span></span>

## <a name="collections"></a><span data-ttu-id="51eca-114">集合</span><span class="sxs-lookup"><span data-stu-id="51eca-114">Collections</span></span>

<span data-ttu-id="51eca-115">ADSI 提供者元件可以遵循三個模型中的其中一個來快取列舉期間的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-115">ADSI provider components can follow one of three models for caching collections during enumeration.</span></span> <span data-ttu-id="51eca-116">當集合中的物件從 ADSI 的外部基礎目錄服務中刪除時，快取模型的選擇會決定 ADSI 的行為。</span><span class="sxs-lookup"><span data-stu-id="51eca-116">The choice of a caching model determines the behavior of ADSI when an object in a collection is deleted from the underlying directory service external to ADSI.</span></span>

<span data-ttu-id="51eca-117">快取模型包括：</span><span class="sxs-lookup"><span data-stu-id="51eca-117">The caching models include:</span></span>

-   <span data-ttu-id="51eca-118">預先快取的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-118">Collections cached in advance.</span></span> <span data-ttu-id="51eca-119">當呼叫 [**IADsCollection：： get \_ \_ NewEnum**](/windows/desktop/api/Iads/nf-iads-iadscollection-get__newenum)來建立新的枚舉器物件時，會從基礎目錄服務完整地取出物件實例的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-119">The collection of object instances is retrieved from the underlying directory service in its entirety when [**IADsCollection::get\_\_NewEnum**](/windows/desktop/api/Iads/nf-iads-iadscollection-get__newenum) is called to create a new enumerator object.</span></span> <span data-ttu-id="51eca-120">如果從基礎目錄服務中刪除已抓取集合中 Active Directory 物件實例的來源物件，用戶端就無法辨識刪除，直到 [**IADs：： GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) 或 [**IADs：： SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) 嘗試存取集合為止。</span><span class="sxs-lookup"><span data-stu-id="51eca-120">If the source object for an Active Directory object instance in the retrieved collection is deleted from the underlying directory service, the client does not recognize the deletion until a [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the collection.</span></span>
-   <span data-ttu-id="51eca-121">以累加方式快取的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-121">Collections incrementally cached.</span></span> <span data-ttu-id="51eca-122">當呼叫 [**IEnumVARIANT：： Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) 時，會從基礎目錄服務一次取出一個物件的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-122">The collection is retrieved from the underlying directory service one object at a time when [**IEnumVARIANT::Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) is called.</span></span> <span data-ttu-id="51eca-123">[**IEnumVARIANT：： Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) 將會回到快取中集合的開頭，而 **IEnumVARIANT：： Next** 會傳回快取的物件，直到到達快取的結尾為止，此時會從基礎存放區加入新的物件。</span><span class="sxs-lookup"><span data-stu-id="51eca-123">[**IEnumVARIANT::Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) will return to the beginning of the collection in the cache and **IEnumVARIANT::Next** will return cached objects until the end of the cache is reached, at which point new objects will be added from the underlying store.</span></span> <span data-ttu-id="51eca-124">當 Active Directory 物件實例位於快取中時，用戶端將不會察覺其從基礎目錄服務刪除，直到 [**IADs：： GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) 或 [**IADs：： SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) 嘗試存取物件為止。</span><span class="sxs-lookup"><span data-stu-id="51eca-124">When an Active Directory object instance is in the cache the client will not become aware of its deletion from the underlying directory service until an [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the object.</span></span>
-   <span data-ttu-id="51eca-125">未快取的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-125">Collections not cached.</span></span> <span data-ttu-id="51eca-126">當呼叫 [**IEnumVARIANT：： Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) 時，會從基礎目錄服務一次取出一個物件的集合。</span><span class="sxs-lookup"><span data-stu-id="51eca-126">The collection is retrieved from the underlying directory service one object at a time when [**IEnumVARIANT::Next**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-next) is called.</span></span> <span data-ttu-id="51eca-127">[**IEnumVARIANT：： Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) 將會回到基礎存放區中集合的開頭。</span><span class="sxs-lookup"><span data-stu-id="51eca-127">[**IEnumVARIANT::Reset**](/windows/win32/api/oaidl/nf-oaidl-ienumvariant-reset) will return to the beginning of the collection in the underlying store.</span></span> <span data-ttu-id="51eca-128">**IEnumVARIANT：： Next** 和 **IEnumVARIANT：： Reset** 作業無法抓取刪除的物件，因為物件是從基礎目錄服務依需求抓取。</span><span class="sxs-lookup"><span data-stu-id="51eca-128">**IEnumVARIANT::Next** and **IEnumVARIANT::Reset** operations cannot retrieve deleted objects, because the objects are retrieved on-demand from the underlying directory service.</span></span> <span data-ttu-id="51eca-129">只會快取目前的物件;如果刪除目前的物件，用戶端就不會察覺其從基礎目錄服務刪除，直到 [**IADs：： GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) 或 [**IADs：： SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) 嘗試存取該物件為止。</span><span class="sxs-lookup"><span data-stu-id="51eca-129">Only the current object is cached; if the current object is deleted, the client will not become aware of its deletion from the underlying directory service until a [**IADs::GetInfo**](/windows/desktop/api/Iads/nf-iads-iads-getinfo) or [**IADs::SetInfo**](/windows/desktop/api/Iads/nf-iads-iads-setinfo) attempts to access the object.</span></span>

<span data-ttu-id="51eca-130">無論快取模型為何，請注意 ADSI 列舉會將 Active Directory 的服務介面傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="51eca-130">Regardless of the caching model, be aware that ADSI enumeration returns Active Directory service interfaces to the caller.</span></span> <span data-ttu-id="51eca-131">為了避免取得新介面指標的額外負荷，ADSI 應用程式應該快取所要操作物件的傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="51eca-131">To avoid the overhead of obtaining a new interface pointer, ADSI applications should cache the returned interface pointers for objects that they intend to manipulate.</span></span> <span data-ttu-id="51eca-132">例如，列舉容器的 Visual Basic 應用程式，並以名稱填入清單方塊，可以快取與名稱相關聯的介面指標，以供稍後使用。</span><span class="sxs-lookup"><span data-stu-id="51eca-132">For example, a Visual Basic application that enumerates a container and populates a list box with names can cache the interface pointers associated with the names for later use.</span></span> <span data-ttu-id="51eca-133">當使用者進行選取時，這個方法會提供比在列舉期間填入清單方塊，以及取得新介面指標的效能更高的效能。</span><span class="sxs-lookup"><span data-stu-id="51eca-133">This approach will provide greater performance than populating the list box during enumeration and obtaining a new interface pointer when the user makes a selection.</span></span>

## <a name="about-dispatch-ids"></a><span data-ttu-id="51eca-134">關於分派識別碼</span><span class="sxs-lookup"><span data-stu-id="51eca-134">About Dispatch IDs</span></span>

<span data-ttu-id="51eca-135">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) 是 com 針對未直接使用 com 介面的控制器定義的自動化介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-135">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) is an Automation interface defined by COM for controllers that do not use COM interfaces directly.</span></span> <span data-ttu-id="51eca-136">透過 **IDispatch** 存取物件稱為「名稱系結」或「晚期繫結」存取，因為它會在執行時間發生 ( 「晚期」 ) 並使用屬性和方法的字串名稱來解析 ( "name" ) 的參考。</span><span class="sxs-lookup"><span data-stu-id="51eca-136">Accessing an object through **IDispatch** is called name-bound or late-bound access, because it occurs at run time ("late") and uses string names of properties and methods to resolve references ("name").</span></span> <span data-ttu-id="51eca-137">在執行時間，用戶端會將其想要呼叫之屬性或方法的字串名稱傳遞給 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) () 方法。</span><span class="sxs-lookup"><span data-stu-id="51eca-137">At run time, clients pass the string name of the property or method they wish to call into the [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)() method.</span></span> <span data-ttu-id="51eca-138">如果物件上有屬性或方法，則會取出對應函式 (dispID) 的分派識別碼。</span><span class="sxs-lookup"><span data-stu-id="51eca-138">If the property or method exists on the object, the dispatch identifier (dispID) of the corresponding function is retrieved.</span></span> <span data-ttu-id="51eca-139">接著會使用 dispID 透過 [**IDispatch：： Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) () 來執行函數。</span><span class="sxs-lookup"><span data-stu-id="51eca-139">The dispID is then used to execute the function through [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)().</span></span> <span data-ttu-id="51eca-140">使用 **IDispatch**，單一物件所公開介面上的屬性和方法會顯示為一般清單。</span><span class="sxs-lookup"><span data-stu-id="51eca-140">Using **IDispatch**, properties and methods on the interfaces exposed by a single object appear as a flat list.</span></span> <span data-ttu-id="51eca-141">由於名稱系結存取需要兩個函式呼叫，因此它的效率不如直接使用 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-141">Because name-bound access requires two function calls, it is less efficient than using a COM interface directly.</span></span> <span data-ttu-id="51eca-142">當效能是考慮時，建議用戶端在物件上使用 ADSI COM 介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-142">Clients are encouraged to use the ADSI COM interfaces on the objects when performance is a consideration.</span></span> <span data-ttu-id="51eca-143">如果介面符合資料類型和參數傳遞的自動化條件約束，則 Advanced Automation 控制器（例如 Visual Basic 4.0）可以呼叫其他 COM 介面和 **IDispatch**。</span><span class="sxs-lookup"><span data-stu-id="51eca-143">Advanced Automation controllers such as Visual Basic 4.0 can call other COM interfaces as well as **IDispatch**, if the interfaces comply with the Automation constraints for data types and parameter passing.</span></span>

<span data-ttu-id="51eca-144">ADSI 提供者會動態產生每個 Active Directory 物件的 Dispid。</span><span class="sxs-lookup"><span data-stu-id="51eca-144">ADSI providers generate dispIDs dynamically for each Active Directory object.</span></span> <span data-ttu-id="51eca-145">針對給定物件，透過 [**IDispatch：： GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) 抓取的 dispid 為產生的值，但不是物件的 IDL 中的值。</span><span class="sxs-lookup"><span data-stu-id="51eca-145">The dispIDs retrieved through [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) for a given object are the generated values, but not the values that are in the IDL for the object.</span></span> <span data-ttu-id="51eca-146">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) 使用者必須呼叫 **GetIDsOfNames** ，才能在執行時間取得有效的 dispid。</span><span class="sxs-lookup"><span data-stu-id="51eca-146">[**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) users must call **GetIDsOfNames** to obtain valid dispIDs at run time.</span></span>

## <a name="type-information-and-type-libraries"></a><span data-ttu-id="51eca-147">類型資訊和型別程式庫</span><span class="sxs-lookup"><span data-stu-id="51eca-147">Type Information and Type Libraries</span></span>

<span data-ttu-id="51eca-148">ADSI SDK 提供的類型程式庫（Activeds），可記錄 ADSI 所支援的所有標準介面。</span><span class="sxs-lookup"><span data-stu-id="51eca-148">The ADSI SDK supplies a type library, Activeds.tlb, that documents all the standard interfaces supported by ADSI.</span></span> <span data-ttu-id="51eca-149">提供者必須針對在 Activeds 中找到的所有介面提供類似的類型程式庫，以及提供者元件內所執行介面的任何其他類型資料。</span><span class="sxs-lookup"><span data-stu-id="51eca-149">A provider must supply a similar type library for all interfaces found in Activeds.tlb, plus any additional type data for the interfaces implemented within the provider component.</span></span>

<span data-ttu-id="51eca-150">以下是 IDL 程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="51eca-150">The following is an IDL code example.</span></span>

``` syntax
[ object, uuid(IID_IADsXYZ), oleautomation, dual ]
interface IADsXYZ: IDispatch
{
// Read-only properties.
[propget]
HRESULT AReadOnlyProp ([out, retval]BSTR *pbstrAReadOnlyProp);
 
// Read/write properties.
[propget]
HRESULT AReadWriteProp ([out, retval]long *plAReadWriteProp);
[propput]
HRESULT AReadWriteProp ([in]long lAReadWriteProp);
 
// Methods.
HRESULT AMethod ([in]DATE dateInParameter,
[out, retval]BSTR *pbstrReturnValue);
};
```

## <a name="thread-safety"></a><span data-ttu-id="51eca-151">執行緒安全性</span><span class="sxs-lookup"><span data-stu-id="51eca-151">Thread Safety</span></span>

<span data-ttu-id="51eca-152">元件物件模型 (COM) 描述下列三種執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="51eca-152">The Component Object Model (COM) describes the following three threading models.</span></span> <span data-ttu-id="51eca-153">COM 應用程式會指出使用 [**CoInitialize**](/windows/win32/api/objbase/nf-objbase-coinitialize) 和 [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) 函式初始化 COM 程式庫時，所使用的模型：</span><span class="sxs-lookup"><span data-stu-id="51eca-153">COM applications indicate which model is in use when initializing the COM library using the [**CoInitialize**](/windows/win32/api/objbase/nf-objbase-coinitialize) and [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) functions:</span></span>

-   <span data-ttu-id="51eca-154">單一線程。</span><span class="sxs-lookup"><span data-stu-id="51eca-154">Single threading.</span></span> <span data-ttu-id="51eca-155">單一執行緒模型假設進程中的單一執行緒執行，進一步假設進程中的 COM 資料結構不需要存取序列化。</span><span class="sxs-lookup"><span data-stu-id="51eca-155">The single threaded model assumes a single thread of execution in a process, further assuming that COM data structures in a process need no access serialization.</span></span>
-   <span data-ttu-id="51eca-156">單元執行緒。</span><span class="sxs-lookup"><span data-stu-id="51eca-156">Apartment threading.</span></span> <span data-ttu-id="51eca-157">COM 物件與建立它的執行緒相關聯。</span><span class="sxs-lookup"><span data-stu-id="51eca-157">A COM object is associated with the thread that created it.</span></span> <span data-ttu-id="51eca-158">呼叫另一個執行緒上的物件時，必須由建立該物件的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="51eca-158">Calls to an object on another thread must be executed by the thread that created that object.</span></span> <span data-ttu-id="51eca-159">為了達成此目的，來源執行緒會叫用用戶端 proxy 來排列方法呼叫，並透過與目的地線程相關聯的 Win32 訊息佇列，將它傳遞至目的地線程中的伺服器 stub 函數。</span><span class="sxs-lookup"><span data-stu-id="51eca-159">To accomplish this, the source thread invokes a client proxy which arranges the method call and delivers it to a server stub function in the destination thread through the Win32 message queue associated with the destination thread.</span></span>
-   <span data-ttu-id="51eca-160">自由執行緒。</span><span class="sxs-lookup"><span data-stu-id="51eca-160">Free threading.</span></span> <span data-ttu-id="51eca-161">COM 物件會假設為安全線程。</span><span class="sxs-lookup"><span data-stu-id="51eca-161">COM objects are assumed to be thread safe.</span></span> <span data-ttu-id="51eca-162">允許多個執行緒存取進程中的任何物件，而不會強加任何序列化。</span><span class="sxs-lookup"><span data-stu-id="51eca-162">Multiple threads are allowed access to any object in the process with no serialization imposed.</span></span>

<span data-ttu-id="51eca-163">ADSI 並非採用任何特定的執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="51eca-163">ADSI does not assume any particular threading model.</span></span> <span data-ttu-id="51eca-164">提供者元件的寫入器應該採用自由執行緒模型，並保證其內部資料結構的一致性，方法是藉由使用同步處理物件（例如重要區段或信號）來保護它們免于安全線程的安全，也就是不協調的更新。</span><span class="sxs-lookup"><span data-stu-id="51eca-164">Writers of provider components should assume the free threading model and guarantee the consistency of their internal data structures by protecting them from thread-unsafe, that is, uncoordinated, updates through the use of synchronization objects such as critical sections or semaphores.</span></span>

## <a name="object-locking"></a><span data-ttu-id="51eca-165">物件鎖定</span><span class="sxs-lookup"><span data-stu-id="51eca-165">Object Locking</span></span>

<span data-ttu-id="51eca-166">ADSI 不會強加或定義物件鎖定配置。</span><span class="sxs-lookup"><span data-stu-id="51eca-166">ADSI does not impose or define an object-locking scheme.</span></span> <span data-ttu-id="51eca-167">使用鎖定來支援存取序列化的命名空間提供者，可以透過 ADSI 的提供者專屬延伸來公開基礎鎖定配置。</span><span class="sxs-lookup"><span data-stu-id="51eca-167">Providers for namespaces that support access serialization using locking can expose the underlying locking scheme through provider-specific extensions to ADSI.</span></span>

## <a name="property-names-within-a-schema"></a><span data-ttu-id="51eca-168">架構中的屬性名稱</span><span class="sxs-lookup"><span data-stu-id="51eca-168">Property Names Within a Schema</span></span>

<span data-ttu-id="51eca-169">ADSI 會將屬性工作表示為 ADSI 架構容器內的屬性物件。</span><span class="sxs-lookup"><span data-stu-id="51eca-169">ADSI represents properties as property objects within the ADSI schema container.</span></span> <span data-ttu-id="51eca-170">這需要在每個架構容器內都有唯一的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="51eca-170">This requires that property names be unique within each schema container.</span></span> <span data-ttu-id="51eca-171">提供者必須確定沒有名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="51eca-171">The provider must ensure that there are no name collisions.</span></span>

## <a name="primary-interface"></a><span data-ttu-id="51eca-172">主要介面</span><span class="sxs-lookup"><span data-stu-id="51eca-172">Primary Interface</span></span>

<span data-ttu-id="51eca-173">當提供者無法識別應以主要介面傳回的介面時，應傳回 **IID \_ IADs** 。</span><span class="sxs-lookup"><span data-stu-id="51eca-173">When a provider cannot identify which interface should be returned as the primary interface, **IID\_IADs** should be returned.</span></span> <span data-ttu-id="51eca-174">這會透過 [**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) 提供物件之所有屬性的名稱系結存取，以及 [**IADs：： Get**](/windows/desktop/api/Iads/nf-iads-iads-get)、 [**IADs：： GetEx**](/windows/desktop/api/Iads/nf-iads-iads-getex)、 [**IADs：:P**](/windows/desktop/api/Iads/nf-iads-iads-put)，以及 [**IADs：:P utex**](/windows/desktop/api/Iads/nf-iads-iads-putex) 方法。</span><span class="sxs-lookup"><span data-stu-id="51eca-174">This provides name-bound access to all properties of an object through [**IDispatch**](/previous-versions/windows/desktop/automat/implementing-the-idispatch-interface) and the [**IADs::Get**](/windows/desktop/api/Iads/nf-iads-iads-get), [**IADs::GetEx**](/windows/desktop/api/Iads/nf-iads-iads-getex), [**IADs::Put**](/windows/desktop/api/Iads/nf-iads-iads-put), and [**IADs::PutEx**](/windows/desktop/api/Iads/nf-iads-iads-putex) methods.</span></span>

 

 