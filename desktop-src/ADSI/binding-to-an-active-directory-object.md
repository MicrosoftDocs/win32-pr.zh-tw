---
title: 系結至 Active Directory 物件
description: 系結至 Active Directory 物件最常見的方式，就是在 ADSI 用戶端和 ADSI 提供者之間使用 GetObject 函數。
ms.assetid: d278ea26-2fd5-4343-8d87-ff85515325fb
ms.tgt_platform: multiple
keywords:
- 系結至 Active Directory 物件 ADSI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 59992dbc88c00be6306dec24523ec4e030d4a516
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/21/2020
ms.locfileid: "103842719"
---
# <a name="binding-to-an-active-directory-object"></a><span data-ttu-id="c35a3-104">系結至 Active Directory 物件</span><span class="sxs-lookup"><span data-stu-id="c35a3-104">Binding to an Active Directory Object</span></span>

<span data-ttu-id="c35a3-105">系結至 Active Directory 物件最常見的方式，就是在 ADSI 用戶端和 ADSI 提供者之間使用 **GetObject** 函數。</span><span class="sxs-lookup"><span data-stu-id="c35a3-105">The most common way to bind to an Active Directory object is to use the **GetObject** function between an ADSI client and an ADSI provider.</span></span> <span data-ttu-id="c35a3-106">這也是顯示提供者元件接收和服務要求方式的最簡單方式。</span><span class="sxs-lookup"><span data-stu-id="c35a3-106">This is also the easiest way to show how the provider component receives and services requests.</span></span> <span data-ttu-id="c35a3-107">ADSI API 函數 [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) 或 Visual Basic 函式 **GetObject** 都會遵循相同的系結步驟。</span><span class="sxs-lookup"><span data-stu-id="c35a3-107">Both the ADSI API function [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) or the Visual Basic function **GetObject** follow the same steps for binding.</span></span>

<span data-ttu-id="c35a3-108">在這個範例中，假設 ADSI 用戶端是一個 ADSI 檢視器應用程式，它的使用者介面收到了 ADsPath "Sample://Seattle/Redmond/Shelly" (1) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-108">For this example, assume the ADSI client is an ADSI viewer application that has received the ADsPath "Sample://Seattle/Redmond/Shelly" from its user interface (1).</span></span> <span data-ttu-id="c35a3-109">下圖詳細說明按下流程箭號的事件順序。</span><span class="sxs-lookup"><span data-stu-id="c35a3-109">The following figure details the sequence of events by numbering the flow arrows.</span></span>

![adsi 元件的詳細觀點](images/dscsex.png)

<span data-ttu-id="c35a3-111">在上圖中，用戶端會起始 Active Directory 物件的介面指標要求，此物件是由 ADSI 服務 (2) 所代表。</span><span class="sxs-lookup"><span data-stu-id="c35a3-111">In the preceding figure, the client initiates the request for an interface pointer on the Active Directory object represented by the ADsPath "Sample://Seattle/Redmond/Shelly" from ADSI services (2).</span></span> <span data-ttu-id="c35a3-112">在初始化期間，服務軟體會填入已安裝之提供者程式設計識別碼的表格 (從登錄中) Progid ( "LDAP："、"Sample："、"WinNT：" 等等) 並將它們與識別適當軟體模組的相符 **CLSID** s 配對。</span><span class="sxs-lookup"><span data-stu-id="c35a3-112">During initialization, the services software populated a table of installed provider programmatic identifiers (ProgIDs) from the registry ("LDAP:","Sample:", "WinNT:", and so on) and paired them with the matching **CLSID** s which identify the appropriate software module.</span></span>

<span data-ttu-id="c35a3-113">ADSI server 會確認 ADsPath 中是否存在 ProgID （在此案例中為 "Sample："）。</span><span class="sxs-lookup"><span data-stu-id="c35a3-113">The ADSI server verifies that the ProgID, in this case "Sample:", exists in the ADsPath.</span></span> <span data-ttu-id="c35a3-114">然後，它會建立系結內容，以優化此物件的進一步參考，並呼叫標準 COM 函式 [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) 來建立 COM 的標記，以用來尋找並系結至代表使用者 "Shelly" 的物件。</span><span class="sxs-lookup"><span data-stu-id="c35a3-114">It then creates a bind context to optimize further references to this object, and calls the standard COM function [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) to create a COM moniker that can be used to find and bind to the object that represents the user "Shelly".</span></span>

<span data-ttu-id="c35a3-115">在下一節中，會在適當的括弧中包含範例提供者元件原始程式碼的檔案名。</span><span class="sxs-lookup"><span data-stu-id="c35a3-115">In the following section, the file names of the example provider component source code are included in parentheses where appropriate.</span></span>

<span data-ttu-id="c35a3-116">如同在其他 COM 伺服器的執行中， [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) 會檢查 ProgID，並在登錄 (3) 中查閱適當的 **CLSID** ，以找出對應的提供者所提供的 class Factory 程式碼 (Cprovcf .cpp) 在適當的提供者 (中) 4。</span><span class="sxs-lookup"><span data-stu-id="c35a3-116">As in other COM server implementations, [**MkParseDisplayName**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) examines the ProgID, and looks up the proper **CLSID** in the registry (3) to find the corresponding provider-supplied class factory code (Cprovcf.cpp) in the appropriate provider implementation (4).</span></span> <span data-ttu-id="c35a3-117">這段程式碼會建立初始最上層物件，該物件會 [**執行 IParseDisplayName：:P arsedisplayname**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) 方法 (Cprov .cpp) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-117">This code creates an initial top-level object that implements the [**IParseDisplayName::ParseDisplayName**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) method (Cprov.cpp).</span></span> <span data-ttu-id="c35a3-118">提供者的 **ParseDisplayName** 會解析提供者本身命名空間中的路徑。</span><span class="sxs-lookup"><span data-stu-id="c35a3-118">The provider's implementation of **ParseDisplayName** resolves the path in the provider's own namespace.</span></span> <span data-ttu-id="c35a3-119">這最後會呼叫 ADsObject，並叫用提供者元件所提供的剖析器 (Parse) ，以確認 ADsPath 對這個命名空間的語法是否正確。</span><span class="sxs-lookup"><span data-stu-id="c35a3-119">This eventually calls ADsObject and invokes the parser supplied with the provider component (Parse.cpp) to verify that the ADsPath is syntactically correct for this namespace.</span></span>

<span data-ttu-id="c35a3-120">**GetObject** 是在 Getobj 中定義，然後判斷要求的物件是命名空間物件、架構物件或其他類型的物件。</span><span class="sxs-lookup"><span data-stu-id="c35a3-120">**GetObject**, that is defined in Getobj.cpp, then determines if the object requested is a namespace object, a schema object, or some other type of object.</span></span> <span data-ttu-id="c35a3-121">如果前兩個類別中的任一個，則會建立該類型的架構類別物件，並抓取適當的介面指標。</span><span class="sxs-lookup"><span data-stu-id="c35a3-121">If either of the first two, that type of schema class object is created and the appropriate interface pointer retrieved.</span></span> <span data-ttu-id="c35a3-122">否則會從 ADsPath (建立範例目錄路徑，例如 \\ 「西雅圖 \\ Redmond \\ Shelly」，但在不同的目錄服務中，它可能必須是 \\ 「OU = 西雅圖 \\ OU = Redmond \\ CN = ) Shelly」，並將控制傳遞至 SampleDSOpenObject，以在範例資料儲存體中開啟物件，並在此情況下抓取其物件類型 (在本例中為 "User" )  (5) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-122">Otherwise the Sample directory path is created from the ADsPath (for example, "\\Seattle\\Redmond\\Shelly", but in a different directory service it might have had to be "\\OU=Seattle\\OU=Redmond\\CN=Shelly") and control passes to SampleDSOpenObject which opens the object in the example data storage and also retrieves its object type (in this case, "User") (5).</span></span>

<span data-ttu-id="c35a3-123">收集資料之後，就會建立新的物件 (6) 來代表 ADsPath 所描述的專案，並抓取該物件上的 [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) 介面指標。</span><span class="sxs-lookup"><span data-stu-id="c35a3-123">With the data gathered, a new object is created (6) to represent the item described by the ADsPath, and a pointer to the [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) interface on that object is retrieved.</span></span> <span data-ttu-id="c35a3-124">在此情況下，會建立支援 **IUnknown** 和 [**IADs**](/windows/desktop/api/Iads/nn-iads-iads) 方法的泛型 Active Directory 物件 (Cgenobj .cpp、Core .cpp) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-124">In this case, a generic Active Directory object is created that supports the **IUnknown** and [**IADs**](/windows/desktop/api/Iads/nn-iads-iads) methods (Cgenobj.cpp, Core.cpp).</span></span> <span data-ttu-id="c35a3-125">CSampleDSGenObject：： AllocateGenObject 常式會讀取類型程式庫資料，為這些新物件建立適當的分派專案，以便支援 [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch)。</span><span class="sxs-lookup"><span data-stu-id="c35a3-125">The CSampleDSGenObject::AllocateGenObject routine reads the type library data to create the proper dispatch entries for these new objects in order to support [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).</span></span>

<span data-ttu-id="c35a3-126">將此介面指標包裝到標記中，會完成 ResolvePathName (Cprov) 函式，並剖析顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="c35a3-126">Wrapping this interface pointer into a moniker completes the ResolvePathName (Cprov.cpp) function and parses the display name.</span></span>

<span data-ttu-id="c35a3-127">基於效能考慮，會快取在此程式期間建立的所有 COM 物件，並透過系結內容進行管理。</span><span class="sxs-lookup"><span data-stu-id="c35a3-127">All the COM objects created during this process are cached for performance reasons and managed through the binding context.</span></span> <span data-ttu-id="c35a3-128">這可改善相同物件上緊接在標記系結之後的其他作業效能。</span><span class="sxs-lookup"><span data-stu-id="c35a3-128">This improves performance for other operations on the same object that immediately follows the moniker binding.</span></span>

<span data-ttu-id="c35a3-129">現在會針對初始 [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) 呼叫所要求的介面識別碼，查詢此格式正確的 Active Directory 物件，並 (7) 中抓取該介面的指標，並將其從 ADSI server 回傳至用戶端 (8&9) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-129">This well-formed Active Directory object is now queried for the interface identifier requested for the initial [**ADsGetObject**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) call and a pointer to that interface is retrieved (7) and passed back through the ADSI server to the client (8&9).</span></span> <span data-ttu-id="c35a3-130">接著，用戶端會透過介面方法直接與提供者元件搭配運作，直到滿足初始要求 (10) 為止。</span><span class="sxs-lookup"><span data-stu-id="c35a3-130">From then on, the client works directly with the provider component through the interface methods until the initial request is satisfied (10).</span></span>

<span data-ttu-id="c35a3-131">此外，用戶端對物件資料的要求通常會採用屬性取得和放置的要求形式，而這些要求全都是透過屬性快取的提供者執行優化 (Cprops .cpp) 。</span><span class="sxs-lookup"><span data-stu-id="c35a3-131">Furthermore, requests for object data from the client usually take the form of requests for property gets and puts, all of which are optimized through the provider implementation of a property cache (Cprops.cpp).</span></span> <span data-ttu-id="c35a3-132">在範例提供者元件的作業系統上的原生資料類型，以及 ADSI 所支援的 Automation [**VARIANT**](/windows/win32/api/oaidl/ns-oaidl-variant) 類型之間，以智慧方式封裝和解壓縮資料（通常包括複製和釋出結構和字串），會在屬性載入至快取 (Smpoper) 之前發生。</span><span class="sxs-lookup"><span data-stu-id="c35a3-132">Intelligently packing and unpacking data, often including copying and freeing structures and strings, between the native data types on the example provider component's operating system and the Automation [**VARIANT**](/windows/win32/api/oaidl/ns-oaidl-variant) type supported by ADSI takes place before the properties are loaded into the cache (Smpoper.cpp).</span></span>

<span data-ttu-id="c35a3-133">範例提供者元件的設計，是為了讓作業系統的實際呼叫會以邏輯方式與提供者元件隔離，以建立可攜至多個作業系統 (RegDSAPI .cpp) 的軟體。</span><span class="sxs-lookup"><span data-stu-id="c35a3-133">The example provider component is designed so that the actual calls to the operating system are logically isolated from the provider component, creating software portable to more than one operating system (RegDSAPI.cpp).</span></span>

 

 