---
title: 架構概觀
description: 此架構總覽提供適用于平板電腦和觸控技術的 Windows Touch API 內容，並說明其如何融入較大的 Windows 7 架構。
ms.assetid: b284e96f-0998-408c-ae84-92a3acdc3014
keywords:
- Windows Touch，架構總覽
- Windows Touch，操作
- Windows Touch，訊息
- Windows Touch，慣性
- Windows Touch，手勢
- 手勢，關於
- 操作，關於
- 慣性，關於
- 操作處理器，架構總覽
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b807113211d77f0aad0ed01fc24570d033063474
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103933255"
---
# <a name="architectural-overview"></a><span data-ttu-id="07b3f-112">架構概觀</span><span class="sxs-lookup"><span data-stu-id="07b3f-112">Architectural Overview</span></span>

<span data-ttu-id="07b3f-113">此架構總覽提供適用于平板電腦和觸控技術的 Windows Touch API 內容，並說明其如何融入較大的 Windows 7 架構。</span><span class="sxs-lookup"><span data-stu-id="07b3f-113">This architectural overview provides context for the Windows Touch API for Tablet and Touch Technologies and explains how it fits into the larger Windows 7 architecture.</span></span>

## <a name="messages-for-windows-touch-input-and-gestures"></a><span data-ttu-id="07b3f-114">Windows Touch 輸入和手勢的訊息</span><span class="sxs-lookup"><span data-stu-id="07b3f-114">Messages for Windows Touch Input and Gestures</span></span>

<span data-ttu-id="07b3f-115">Windows Touch 的訊息功能是在執行期間接聽和解讀訊息而啟用。</span><span class="sxs-lookup"><span data-stu-id="07b3f-115">Messaging features for Windows Touch are enabled by listening and interpreting messages during execution.</span></span> <span data-ttu-id="07b3f-116">下圖顯示如何從硬體產生訊息，然後由 Windows 7 傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="07b3f-116">The following illustration shows how messages are generated from hardware and sent to applications by Windows 7.</span></span>

![圖例顯示 windows 7 如何從多點觸控硬體將訊息傳送至應用程式](images/wm-multitouch-messaging.png)

<span data-ttu-id="07b3f-118">在圖的最左邊的資料行中，觸控式硬體會接收來自使用者的輸入。</span><span class="sxs-lookup"><span data-stu-id="07b3f-118">In the leftmost column of the illustration, touch-sensitive hardware receives input from a user.</span></span> <span data-ttu-id="07b3f-119">然後，驅動程式會在硬體和作業系統之間進行通訊。</span><span class="sxs-lookup"><span data-stu-id="07b3f-119">A driver then communicates between the hardware and the OS.</span></span> <span data-ttu-id="07b3f-120">接著，OS 會產生一個 [**wm \_ 觸控**](wm-touchdown.md) 或 [**wm \_ 手勢**](wm-gesture.md) 訊息，然後傳送至應用程式的 HWND。</span><span class="sxs-lookup"><span data-stu-id="07b3f-120">Next, the OS generates a [**WM\_TOUCH**](wm-touchdown.md) or [**WM\_GESTURE**](wm-gesture.md) message that is then sent to an application's HWND.</span></span> <span data-ttu-id="07b3f-121">然後，應用程式會根據訊息中封裝的資訊來更新 UI。</span><span class="sxs-lookup"><span data-stu-id="07b3f-121">The application then updates the UI given the information encapsulated in the message.</span></span>

<span data-ttu-id="07b3f-122">應用程式預設會接收手勢。</span><span class="sxs-lookup"><span data-stu-id="07b3f-122">Applications receive gestures by default.</span></span> <span data-ttu-id="07b3f-123">除非應用程式使用 [**RegisterTouchWindow**](/windows/desktop/api/winuser/nf-winuser-registertouchwindow) 函式註冊 Windows Touch 輸入訊息，否則 ([**WM \_ 手勢**](wm-gesture.md) 訊息) 的手勢通知會由 Windows 建立並傳送至該應用程式視窗。</span><span class="sxs-lookup"><span data-stu-id="07b3f-123">Unless an application registers for Windows Touch input messages with the [**RegisterTouchWindow**](/windows/desktop/api/winuser/nf-winuser-registertouchwindow) function, notifications for gestures ([**WM\_GESTURE**](wm-gesture.md) messages) are created by Windows and sent to that application window.</span></span> <span data-ttu-id="07b3f-124">如果應用程式視窗註冊接收觸控訊息，Windows Touch 輸入 ([**WM \_ 觸控**](wm-touchdown.md) 訊息的通知) 會傳送至該應用程式視窗。</span><span class="sxs-lookup"><span data-stu-id="07b3f-124">If an application Window registers to receive touch messages, notifications for Windows Touch input ([**WM\_TOUCH**](wm-touchdown.md) messages) are sent to that application window.</span></span> <span data-ttu-id="07b3f-125">Windows Touch 和軌跡訊息在執行觸控或從應用程式視窗開始時的意義上是貪婪的，所有訊息都會傳送至該應用程式，直到手勢完成或主要觸控完成為止。</span><span class="sxs-lookup"><span data-stu-id="07b3f-125">Windows Touch and gesture messages are greedy in the sense that after a touch is made or a gesture begins on an application Window, all messages are sent to that application until the gesture completes or the primary touch is completed.</span></span>

<span data-ttu-id="07b3f-126">針對舊版支援，Windows 會在進行反升，然後傳送或張貼對應至手勢的適當訊息時，解讀 [**WM \_ 手勢**](wm-gesture.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="07b3f-126">For legacy support, Windows interprets [**WM\_GESTURE**](wm-gesture.md) messages if they are bubbled up and then will SEND or POST appropriate messages that map to the gesture.</span></span> <span data-ttu-id="07b3f-127">為了避免中斷舊版支援，請務必使用 DefWindowProc 轉送 WM \_ 手勢訊息。 [](/windows/win32/api/winuser/nf-winuser-defwindowproca)</span><span class="sxs-lookup"><span data-stu-id="07b3f-127">To avoid breaking legacy support, make sure that you forward WM\_GESTURE messages using [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowproca).</span></span> <span data-ttu-id="07b3f-128">如需舊版支援的詳細資訊，請參閱 [Windows Touch 手勢總覽](windows-touch-gestures-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="07b3f-128">More information on legacy support can be found in the section [Windows Touch Gestures Overview](windows-touch-gestures-overview.md).</span></span>

## <a name="manipulations-and-inertia"></a><span data-ttu-id="07b3f-129">操作和慣性</span><span class="sxs-lookup"><span data-stu-id="07b3f-129">Manipulations and Inertia</span></span>

<span data-ttu-id="07b3f-130">Windows Touch 程式設計人員必須能夠以對手勢有意義的方式，從多個來源解讀手勢。</span><span class="sxs-lookup"><span data-stu-id="07b3f-130">Windows Touch programmers must be able to interpret gestures from multiple sources in a manner that is meaningful for the gesture taking place.</span></span> <span data-ttu-id="07b3f-131">Microsoft 提供操作 API 來執行這些計算。</span><span class="sxs-lookup"><span data-stu-id="07b3f-131">Microsoft provides the manipulation API to perform these calculations.</span></span> <span data-ttu-id="07b3f-132">操作基本上是具有與其相關聯之值的手勢，這些值會描述整個手勢。</span><span class="sxs-lookup"><span data-stu-id="07b3f-132">Manipulations are essentially gestures with values associated with them that describe the entire gesture.</span></span> <span data-ttu-id="07b3f-133">將輸入資料連線至操作處理器之後，您可以取得使用者在物件上進行的動作相關資訊。</span><span class="sxs-lookup"><span data-stu-id="07b3f-133">After you connect the input data to the manipulation processor, you can retrieve information pertinent to action that the user makes on the object.</span></span> <span data-ttu-id="07b3f-134">下圖顯示您可以使用操作的其中一種方式。</span><span class="sxs-lookup"><span data-stu-id="07b3f-134">The following figure shows one way you can use manipulations.</span></span>

![圖例顯示傳遞至物件操作處理器的 windows 觸控訊息，此處理程式會使用 imanipulationevents 介面來處理事件 \-](images/manipulation-arch.png)

<span data-ttu-id="07b3f-136">在圖例左上方，使用者已接觸到畫面，這會建立觸控訊息。</span><span class="sxs-lookup"><span data-stu-id="07b3f-136">In the top left of the illustration, the user has touched the screen, which creates touch messages.</span></span> <span data-ttu-id="07b3f-137">這些訊息包含 x 座標和 y 座標，可用來判斷焦點物件。</span><span class="sxs-lookup"><span data-stu-id="07b3f-137">These messages contain an x-coordinate and a y-coordinate that are used to determine the object that is in focus.</span></span> <span data-ttu-id="07b3f-138">焦點物件包含操作處理器。</span><span class="sxs-lookup"><span data-stu-id="07b3f-138">The object in focus contains a manipulation processor.</span></span> <span data-ttu-id="07b3f-139">接下來，在具有 **TOUCHEVENTF \_ UP** 旗標的 [**WM \_ 觸控**](wm-touchdown.md)訊息上，會選取使用者焦點的物件，並參考操作處理器，並將訊息傳送至操作處理器。</span><span class="sxs-lookup"><span data-stu-id="07b3f-139">Next, on the [**WM\_TOUCH**](wm-touchdown.md) message with the **TOUCHEVENTF\_UP** flag, the object in the user's focus is selected, the manipulation processor is referenced, and the message is sent to the manipulation processor.</span></span> <span data-ttu-id="07b3f-140">與此連絡人相關聯的後續 **wm \_ 觸控** 訊息會傳送至操作處理器，直到收到具有 **TOUCHEVENTF \_ UP** 旗標的 **wm \_ 觸控** 訊息，且已對選取的物件進行取值為止。</span><span class="sxs-lookup"><span data-stu-id="07b3f-140">Subsequent **WM\_TOUCH** messages associated with this contact are sent to the manipulation processor until the **WM\_TOUCH** message with the **TOUCHEVENTF\_UP** flag is received and the selected object is dereferenced.</span></span> <span data-ttu-id="07b3f-141">在圖例的右下方區段中，會使用實 [**\_ IManipulationEvents**](/windows/win32/api/manipulations/nn-manipulations-_imanipulationevents)介面的操作事件接收器來處理在建立觸控訊息時所引發的操作事件。</span><span class="sxs-lookup"><span data-stu-id="07b3f-141">In the bottom right section of the illustration, a manipulation event sink that implements the [**\_IManipulationEvents**](/windows/win32/api/manipulations/nn-manipulations-_imanipulationevents) interface is used to handle the manipulation events, which are raised while the touch messages are being created.</span></span> <span data-ttu-id="07b3f-142">事件接收可以根據執行中的操作事件，對介面執行更新。</span><span class="sxs-lookup"><span data-stu-id="07b3f-142">The event sink can perform updates to the interface based on the manipulation events while they occur.</span></span>

<span data-ttu-id="07b3f-143">在 Windows Touch 的應用程式中，通常會納入簡單物理，讓物件順暢地進入停止，而不是在不再觸及它們時突然停止。</span><span class="sxs-lookup"><span data-stu-id="07b3f-143">In Windows Touch applications, it's common to incorporate simple physics so that objects smoothly come to a stop, rather than abruptly stop when they are no longer being touched.</span></span> <span data-ttu-id="07b3f-144">Microsoft 提供慣性 API 來執行這些簡單物理的計算，讓您的應用程式能夠以類似于其他應用程式的方式運作。</span><span class="sxs-lookup"><span data-stu-id="07b3f-144">Microsoft provides the Inertia API to perform the calculations for these simple physics so that your application can behave in a manner similar to other applications.</span></span> <span data-ttu-id="07b3f-145">這也可讓您省下建立強大物理功能所需的工作。</span><span class="sxs-lookup"><span data-stu-id="07b3f-145">This also saves you the effort required to create robust physics functionality.</span></span> <span data-ttu-id="07b3f-146">下圖顯示您可以如何使用慣性。</span><span class="sxs-lookup"><span data-stu-id="07b3f-146">The following figure shows how you can use inertia.</span></span>

![圖例顯示傳遞至物件 iinertiaprocessor 介面的 windows 觸控訊息，此介面會使用 \- imanipulationevents 介面引發事件](images/inertia-arch.png)

<span data-ttu-id="07b3f-148">請注意慣性與操作之間的相似之處。</span><span class="sxs-lookup"><span data-stu-id="07b3f-148">Note the similarities between inertia and manipulation.</span></span> <span data-ttu-id="07b3f-149">兩者之間唯一的差異在於，如果是慣性，則會將解讀的訊息遞交給慣性處理器，而不是操作處理器，而慣性處理器會引發事件。</span><span class="sxs-lookup"><span data-stu-id="07b3f-149">The only difference between the two is that in the case of inertia, interpreted messages are handed to an inertia processor rather than a manipulation processor and the inertia processor raises the events.</span></span> <span data-ttu-id="07b3f-150">在圖例左上方的 **TOUCHEVENTF \_ UP** 旗標上 [**， \_**](wm-touchdown.md)觸控訊息是用來識別焦點中包含慣性處理器和操作處理器的物件。</span><span class="sxs-lookup"><span data-stu-id="07b3f-150">In the top left of the illustration, on the [**WM\_TOUCH**](wm-touchdown.md) message with the **TOUCHEVENTF\_UP** flag, touch messages are used to identify an object in focus that contains an inertia processor and a manipulation processor.</span></span> <span data-ttu-id="07b3f-151">後續的 **WM \_ 觸控** 訊息會傳送至操作處理器，而操作處理器會對應用程式 UI 執行更新。</span><span class="sxs-lookup"><span data-stu-id="07b3f-151">Subsequent **WM\_TOUCH** messages are sent to the manipulation processor and the manipulation processor performs updates to the application UI.</span></span> <span data-ttu-id="07b3f-152">操作完成後，會使用操作中的速度值來設定慣性處理器。</span><span class="sxs-lookup"><span data-stu-id="07b3f-152">After the manipulation completes, velocity values from the manipulation are used to set up an inertia processor.</span></span> <span data-ttu-id="07b3f-153">如中間的資料 [**行所示**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)，在個別執行緒中使用計時器或其他迴圈來呼叫 [**進程**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process)或 [**ProcessTime**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-processtime)方法，直到呼叫表示處理器已完成處理。</span><span class="sxs-lookup"><span data-stu-id="07b3f-153">As illustrated in the middle column, the [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) or [**ProcessTime**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-processtime) method is called on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface using a timer or other loop in a separate thread until the calls indicate the processor is finished processing.</span></span> <span data-ttu-id="07b3f-154">進行這些呼叫時，會引發操作事件，這些事件是由以 [**\_ IManipulationEvents**](/windows/win32/api/manipulations/nn-manipulations-_imanipulationevents)介面為基礎的操作事件接收器所處理。</span><span class="sxs-lookup"><span data-stu-id="07b3f-154">While these calls are made, manipulation events are raised, which are handled by a manipulation event sink based on the [**\_IManipulationEvents**](/windows/win32/api/manipulations/nn-manipulations-_imanipulationevents) interface.</span></span> <span data-ttu-id="07b3f-155">在圖的右下方區段中，此事件接收接著會根據操作事件，在事件接收中透過事件處理常式執行更新，以更新應用程式 UI。</span><span class="sxs-lookup"><span data-stu-id="07b3f-155">At the bottom right section of the illustration, this event sink then performs updates to the application UI based on manipulation events when they occur through event handlers in the event sink.</span></span>

## <a name="related-topics"></a><span data-ttu-id="07b3f-156">相關主題</span><span class="sxs-lookup"><span data-stu-id="07b3f-156">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="07b3f-157">程式設計指南</span><span class="sxs-lookup"><span data-stu-id="07b3f-157">Programming Guide</span></span>](programming-guide.md)
</dt> </dl>

 

 