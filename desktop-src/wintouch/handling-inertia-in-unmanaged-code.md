---
title: 處理非受控碼中的慣性
description: 本節說明如何使用 IInertiaProcessor 介面處理非受控碼中的慣性。
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:
- Windows Touch，慣性
- Windows Touch，操作處理器
- 慣性，非受控碼
- 慣性、IInertiaProcessor 介面
- 慣性、操作處理器
- 操作處理器，慣性
- IInertiaProcessor 介面，非受控碼
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3de56d06547f426de252a89ef5172df3fe4ca439
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "104020931"
---
# <a name="handling-inertia-in-unmanaged-code"></a><span data-ttu-id="0555b-110">處理非受控碼中的慣性</span><span class="sxs-lookup"><span data-stu-id="0555b-110">Handling Inertia in Unmanaged Code</span></span>

<span data-ttu-id="0555b-111">本節說明如何使用 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 介面處理非受控碼中的慣性。</span><span class="sxs-lookup"><span data-stu-id="0555b-111">This section explains how to use the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface for handling inertia in unmanaged code.</span></span>

## <a name="overview"></a><span data-ttu-id="0555b-112">概觀</span><span class="sxs-lookup"><span data-stu-id="0555b-112">Overview</span></span>

<span data-ttu-id="0555b-113">若要在非受控碼中使用慣性，您必須針對操作處理器和慣性處理器來執行事件接收器。</span><span class="sxs-lookup"><span data-stu-id="0555b-113">To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor.</span></span> <span data-ttu-id="0555b-114">首先，將操作支援新增至您的應用程式，如將 [操作支援加入至非受控碼](adding-manipulation-support-in-unmanaged-code.md)一節中所述。</span><span class="sxs-lookup"><span data-stu-id="0555b-114">Start by adding manipulation support to your application as described in the section [Adding Manipulation Support to Unmanaged Code](adding-manipulation-support-in-unmanaged-code.md).</span></span> <span data-ttu-id="0555b-115">請注意，操作支援要求您使用觸控訊息而非手勢訊息，將事件資料送入操作處理器。</span><span class="sxs-lookup"><span data-stu-id="0555b-115">Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor.</span></span> <span data-ttu-id="0555b-116">操作完成後，您也必須針對 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 介面所產生的事件，執行第二個事件接收，或需要修改您現有的事件接收，以容納 **IInertiaProcessor** 和 [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) 介面所產生的事件。</span><span class="sxs-lookup"><span data-stu-id="0555b-116">After you have manipulation working, you must also implement a second event sink for the events that the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the **IInertiaProcessor** and the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) interfaces.</span></span> <span data-ttu-id="0555b-117">基於此範例的目的，從針對將操作支援新增至非受控碼的區段建立的事件接收，以及新增第二個可搭配慣性處理器（而不是操作處理器）的函式，都比較容易。</span><span class="sxs-lookup"><span data-stu-id="0555b-117">For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor.</span></span> <span data-ttu-id="0555b-118">如此一來，事件接收的實作為操作處理器或慣性處理器的功能。</span><span class="sxs-lookup"><span data-stu-id="0555b-118">This way, the event sink implementation can function for either the manipulation processor or the inertia processor.</span></span> <span data-ttu-id="0555b-119">除了新增第二個函式，事件接收器還會有一個變數，指出它是否會根據慣性輸入執行作業，而不是操作輸入。</span><span class="sxs-lookup"><span data-stu-id="0555b-119">In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</span></span>

### <a name="add-inertia-support-to-a-manipulation-processor-event-sink"></a><span data-ttu-id="0555b-120">將慣性支援新增至操作處理器事件接收器</span><span class="sxs-lookup"><span data-stu-id="0555b-120">Add Inertia Support to a Manipulation Processor Event Sink</span></span>

<span data-ttu-id="0555b-121">下列程式碼顯示新的事件接收函式、 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 介面的新成員變數，以及指出接收器是否針對慣性推斷的旗標。</span><span class="sxs-lookup"><span data-stu-id="0555b-121">The following code shows the new event sink constructor, new member variables for an [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface, and a flag indicating whether the sink is extrapolating for inertia.</span></span>


```C++
    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
```




```C++
    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
```



<span data-ttu-id="0555b-122">當您的類別標頭具有新的函式，以及指出您是否推斷的旗標之後，您可以執行事件接收，以針對 [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) 事件和 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 事件具有個別的處理區塊。</span><span class="sxs-lookup"><span data-stu-id="0555b-122">After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) events and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) events.</span></span> <span data-ttu-id="0555b-123">接受 **IManipulationProcessor** 和 **IInertiaProcessor** 的函式應該將 **fExtrapolating** 旗標設為 False，這表示這是 **IManipulationProcessor** 事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="0555b-123">The constructor that accepts an **IManipulationProcessor** and an **IInertiaProcessor** should set the **fExtrapolating** flag to false, which indicates that this is a **IManipulationProcessor** event handler.</span></span> <span data-ttu-id="0555b-124">下列程式碼顯示如何執行使用 **IManipulationProcessor** 之事件接收器的函式。</span><span class="sxs-lookup"><span data-stu-id="0555b-124">The following code shows how the constructor for an event sink that uses the **IManipulationProcessor** could be implemented.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip->put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}
```



<span data-ttu-id="0555b-125">下列程式碼顯示如何執行使用 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 之事件接收器的函式。</span><span class="sxs-lookup"><span data-stu-id="0555b-125">The following code shows how the constructor for an event sink that uses the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) could be implemented.</span></span> <span data-ttu-id="0555b-126">這個函式會將 **fExtrapolating** 旗標設為 true，表示事件接收器類別的這個實例將會執行外推，並且會執行先前由操作處理器事件執行的任何移動作業。</span><span class="sxs-lookup"><span data-stu-id="0555b-126">This constructor sets the **fExtrapolating** flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}   
```



> [!Note]  
> <span data-ttu-id="0555b-127">系統會將來自操作處理器事件接收的事件接收類別實作為慣性處理器的事件接收器重複使用。</span><span class="sxs-lookup"><span data-stu-id="0555b-127">The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</span></span>

 

<span data-ttu-id="0555b-128">現在，當您將這個類別 **CManipulationEventSink** 時，可以將它視為操作處理器的事件接收器，或是作為慣性處理器的事件接收器。</span><span class="sxs-lookup"><span data-stu-id="0555b-128">Now when you construct this class, **CManipulationEventSink**, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor.</span></span> <span data-ttu-id="0555b-129">當它被視為慣性處理器事件接收器時，會將 **fExtrapolating** 旗標設為 true，表示應該推斷操作事件。</span><span class="sxs-lookup"><span data-stu-id="0555b-129">When it's constructed as an inertia processor event sink, it will have the **fExtrapolating** flag set to true, indicating that manipulation events should be extrapolated.</span></span>

> [!Note]  
> <span data-ttu-id="0555b-130">[**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor)和 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)介面都會引發 [**system.windows.uielement.manipulationstarted>**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) 。</span><span class="sxs-lookup"><span data-stu-id="0555b-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) will be raised by both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interfaces.</span></span>

 

<span data-ttu-id="0555b-131">當操作開始時，會設定 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) 介面屬性。</span><span class="sxs-lookup"><span data-stu-id="0555b-131">When manipulation starts, the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface properties are set.</span></span> <span data-ttu-id="0555b-132">下列程式碼顯示如何處理已啟動的事件。</span><span class="sxs-lookup"><span data-stu-id="0555b-132">The following code shows how the started event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert->put_InitialOriginX(x);
    m_pInert->put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert->put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert->put_BoundaryLeft  ( static_cast<float>(screenRect.left   * 100));
    m_pInert->put_BoundaryTop   ( static_cast<float>(screenRect.top    * 100));
    m_pInert->put_BoundaryRight ( static_cast<float>(screenRect.right  * 100));
    m_pInert->put_BoundaryBottom( static_cast<float>(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert->put_ElasticMarginLeft  (static_cast<float>(screenRect.left   * 5));
    m_pInert->put_ElasticMarginTop   (static_cast<float>(screenRect.top    * 5));
    m_pInert->put_ElasticMarginRight (static_cast<float>(screenRect.right  * 95));
    m_pInert->put_ElasticMarginBottom(static_cast<float>(screenRect.bottom * 95));
    
    
    return S_OK;
}
```



<span data-ttu-id="0555b-133">在此範例中，會使用操作差異來四處移動視窗。</span><span class="sxs-lookup"><span data-stu-id="0555b-133">In this example, manipulation deltas are used to move the window around.</span></span> <span data-ttu-id="0555b-134">下列程式碼顯示差異事件的處理方式。</span><span class="sxs-lookup"><span data-stu-id="0555b-134">The following code shows how the delta event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast<int>(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast<int>(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast<int>(oldWidth * scaleDelta),                    // width
        static_cast<int>(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
```



<span data-ttu-id="0555b-135">在此範例中，操作已完成的事件會啟動或停止將在 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)介面上呼叫 [**進程**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process)的計時器。</span><span class="sxs-lookup"><span data-stu-id="0555b-135">In this example, manipulation completed events either start or stop a timer that will call [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span> <span data-ttu-id="0555b-136">下列程式碼顯示如何處理已完成的操作事件。</span><span class="sxs-lookup"><span data-stu-id="0555b-136">The following code shows how the completed manipulation event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip->GetVelocityX(&vX);
        m_pManip->GetVelocityY(&vY);
        m_pManip->GetAngularVelocity(&vA);

        // complete any previous processing
        m_pInert->Complete();
        
        // Reset sets the  initial timestamp
        m_pInert->Reset();
                
        // 
        m_pInert->put_InitialVelocityX(vX);
        m_pInert->put_InitialVelocityY(vY);        
        
        m_pInert->put_InitialOriginX(x);
        m_pInert->put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
```



<span data-ttu-id="0555b-137">下列程式碼示範如何在 **WndProc** 中解讀 **WM \_ 計時器** 訊息，以在 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)介面上執行 [**處理**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process)呼叫。</span><span class="sxs-lookup"><span data-stu-id="0555b-137">The following code shows how you could interpret **WM\_TIMER** messages in **WndProc** to perform calls to [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span>


```C++
case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc->Process(&b);        
  }
  break;
```



### <a name="coinitialize-the-inertia-processor-and-manipulation-processor-and-initialize-the-event-sinks"></a><span data-ttu-id="0555b-138">CoInitialize 慣性處理器和操作處理器，並初始化事件接收器</span><span class="sxs-lookup"><span data-stu-id="0555b-138">CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</span></span>

<span data-ttu-id="0555b-139">當您修改事件接收以同時支援 [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) 和 [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor)之後，您就可以初始化事件接收，並將其設定為從您的應用程式執行。</span><span class="sxs-lookup"><span data-stu-id="0555b-139">After you have your event sink modified to support both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), you are ready to initialize the event sinks and set them up to run from your application.</span></span> <span data-ttu-id="0555b-140">下列程式碼顯示如何配置介面指標。</span><span class="sxs-lookup"><span data-stu-id="0555b-140">The following code shows how the interface pointers are allocated.</span></span>


```C++
//Include windows.h for touch events
#include "windows.h"  

// Manipulation implementation file
#include <manipulations_i.c>
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
```



<span data-ttu-id="0555b-141">下列程式碼範例會示範如何具現化您的介面。</span><span class="sxs-lookup"><span data-stu-id="0555b-141">The following code example shows how to instantiate your interfaces.</span></span>


```C++
   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIInertProc)
   );
```



<span data-ttu-id="0555b-142">下列程式碼範例示範如何在指定介面指標的情況下，建立事件接收器，並註冊觸控輸入的視窗。</span><span class="sxs-lookup"><span data-stu-id="0555b-142">The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</span></span>


```C++
   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
```



## <a name="related-topics"></a><span data-ttu-id="0555b-143">相關主題</span><span class="sxs-lookup"><span data-stu-id="0555b-143">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0555b-144">慣性</span><span class="sxs-lookup"><span data-stu-id="0555b-144">Inertia</span></span>](getting-started-with-inertia.md)
</dt> </dl>

 

 




