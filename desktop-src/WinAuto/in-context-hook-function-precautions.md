---
title: In-Context 攔截函式的預防措施
description: 基於效能考慮，用戶端開發人員會註冊內容攔截函式。
ms.assetid: 14b48920-a291-4519-b005-e559263a0e83
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8c0e319037cb1295725548b3361bf076b4b1f760
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106965661"
---
# <a name="in-context-hook-function-precautions"></a><span data-ttu-id="f1189-103">In-Context 攔截函式的預防措施</span><span class="sxs-lookup"><span data-stu-id="f1189-103">In-Context Hook Function Precautions</span></span>

<span data-ttu-id="f1189-104">基於效能考慮，用戶端開發人員會註冊內容攔截函式。</span><span class="sxs-lookup"><span data-stu-id="f1189-104">For performance reasons, client developers register in-context hook functions.</span></span> <span data-ttu-id="f1189-105">不過，由於這些攔截函式會對應到伺服器的位址空間，因此用戶端和伺服器開發人員必須採取預防措施，以確保事件處理順利進行。</span><span class="sxs-lookup"><span data-stu-id="f1189-105">However, because these hook functions are mapped into the server's address space, client and server developers must take precautions to ensure that the event processing goes smoothly.</span></span>

## <a name="precautions-for-client-developers"></a><span data-ttu-id="f1189-106">用戶端開發人員的預防措施</span><span class="sxs-lookup"><span data-stu-id="f1189-106">Precautions for Client Developers</span></span>

<span data-ttu-id="f1189-107">用戶端開發人員應留意下列問題：</span><span class="sxs-lookup"><span data-stu-id="f1189-107">Client developers should be aware of the following issues:</span></span>

-   <span data-ttu-id="f1189-108">內容攔截函式不應該使用大量的處理器時間，因為攔截函式必須在伺服器應用程式繼續之前傳回。</span><span class="sxs-lookup"><span data-stu-id="f1189-108">In-context hook functions should not use a lot of processor time, because the hook function must return before the server application continues.</span></span>
-   <span data-ttu-id="f1189-109">觸發事件之後，呼叫攔截函式時，與事件相關聯的視窗就可能不再存在。</span><span class="sxs-lookup"><span data-stu-id="f1189-109">After an event is triggered, it is possible that the window associated with an event no longer exists by the time the hook function is called.</span></span> <span data-ttu-id="f1189-110">用戶端必須先確認與事件相關聯的視窗仍然存在，再採取任何其他與事件相關的動作。</span><span class="sxs-lookup"><span data-stu-id="f1189-110">Clients must verify that the window associated with an event still exists before taking any other action related to the event.</span></span> <span data-ttu-id="f1189-111">為了確保視窗仍然存在，用戶端會使用 Microsoft Win32 [**IsWindow**](/windows/desktop/api/winuser/nf-winuser-iswindow) 函數。</span><span class="sxs-lookup"><span data-stu-id="f1189-111">To ensure that a window still exists, clients use the Microsoft Win32 [**IsWindow**](/windows/desktop/api/winuser/nf-winuser-iswindow) function.</span></span>
-   <span data-ttu-id="f1189-112">如果已定義攔截函式的 DLL 連結至另一個 DLL，用戶端開發人員必須確保系統載入另一個 DLL。</span><span class="sxs-lookup"><span data-stu-id="f1189-112">If the DLL in which the hook function is defined links to another DLL, client developers must ensure that the system loads the other DLL.</span></span> <span data-ttu-id="f1189-113">如果使用 .def 檔隱含連結 (並匯入) ，則額外的 DLL 必須位於 Windows 目錄或其中一個系統目錄（例如 Windows \\ system、windows \\ System32 或 windows SysWOW64）中 \\ 。</span><span class="sxs-lookup"><span data-stu-id="f1189-113">If linking implicitly (using .def files and imports), the additional DLL must be in either the Windows directory or one of the system directories such as Windows\\System, Windows\\System32, or Windows\\SysWOW64.</span></span> <span data-ttu-id="f1189-114">如果使用 [**LoadLibrary**](/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya)) 明確地連結 (，則必須在 **LoadLibrary** 的呼叫中指定其他 DLL 所在目錄的完整路徑。</span><span class="sxs-lookup"><span data-stu-id="f1189-114">If linking explicitly (using [**LoadLibrary**](/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya)), the full path to the directory in which the additional DLL resides must be specified in the call to **LoadLibrary**.</span></span>
-   <span data-ttu-id="f1189-115">當包含攔截函式的 DLL 載入至16位應用程式時，內容中攔截函式可能會造成堆疊溢位。</span><span class="sxs-lookup"><span data-stu-id="f1189-115">In-context hook functions may cause a stack overflow when the DLL that contains the hook function is loaded into a 16-bit application.</span></span> <span data-ttu-id="f1189-116">發生此問題的原因是，16位應用程式使用的固定堆疊大小不夠大，無法容納會導致呼叫攔截函式的系統函數調用鏈。</span><span class="sxs-lookup"><span data-stu-id="f1189-116">This problem occurs because 16-bit applications use a fixed stack size that is not large enough to accommodate the chain of system function calls that result in a call to the hook function.</span></span>

## <a name="precautions-for-server-developers"></a><span data-ttu-id="f1189-117">伺服器開發人員的預防措施</span><span class="sxs-lookup"><span data-stu-id="f1189-117">Precautions for Server Developers</span></span>

<span data-ttu-id="f1189-118">伺服器開發人員必須注意，用戶端應用程式可能會註冊內容攔截函式。</span><span class="sxs-lookup"><span data-stu-id="f1189-118">Server developers need to be aware that client applications might register in-context hook functions.</span></span> <span data-ttu-id="f1189-119">當伺服器呼叫 [**NotifyWinEvent**](/windows/desktop/api/Winuser/nf-winuser-notifywinevent)時，必須做好準備以處理 [**WM \_ GETOBJECT**](wm-getobject.md) 和其他 [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) 方法。</span><span class="sxs-lookup"><span data-stu-id="f1189-119">When a server calls [**NotifyWinEvent**](/windows/desktop/api/Winuser/nf-winuser-notifywinevent), it must be prepared to handle [**WM\_GETOBJECT**](wm-getobject.md) and other [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) methods.</span></span>

## <a name="invalid-interface-pointers"></a><span data-ttu-id="f1189-120">不正確介面指標</span><span class="sxs-lookup"><span data-stu-id="f1189-120">Invalid Interface Pointers</span></span>

<span data-ttu-id="f1189-121">當用戶端在內容攔截函式內呼叫 [**AccessibleObjectFromEvent**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromevent) 時，傳回的 [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) 介面指標會直接指向伺服器位址空間中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1189-121">When a client calls [**AccessibleObjectFromEvent**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromevent) within an in-context hook function, the [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) interface pointer that is returned points directly to code in the server's address space.</span></span> <span data-ttu-id="f1189-122">如果用戶端使用這個指標呼叫介面屬性，則元件物件模型 (COM) 程式庫不涉及封送處理 (封裝和傳送跨進程界限的介面參數) 或封送處理跨進程界限傳送的 (解除封裝參數，而不會偵測物件是否終結。</span><span class="sxs-lookup"><span data-stu-id="f1189-122">If the client calls an interface property using this pointer, the Component Object Model (COM) library is not involved with marshaling (packaging and sending interface parameters across process boundaries) or unmarshaling (unpackaging parameters that have been sent across process boundaries) and does not detect if an object is destroyed.</span></span>

<span data-ttu-id="f1189-123">如果用戶端呼叫介面屬性至已終結的物件，則不正確介面指標會在伺服器的位址空間中造成一般保護錯誤，除非伺服器偵測到這種情況。</span><span class="sxs-lookup"><span data-stu-id="f1189-123">If the client calls an interface property to an object that is destroyed, the invalid interface pointer causes a General Protection fault in the server's address space unless the server detects this situation.</span></span>

<span data-ttu-id="f1189-124">為了防止不正確介面指標，伺服器會建立可包裝可存取物件的 [proxy 物件](creating-proxy-objects.md) ，並監視可存取物件的存留期範圍。</span><span class="sxs-lookup"><span data-stu-id="f1189-124">To protect against invalid interface pointers, servers [create proxy objects](creating-proxy-objects.md) that wrap accessible objects and monitor the life span of accessible objects.</span></span> <span data-ttu-id="f1189-125">例如，當用戶端呼叫 [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) 屬性來取得物件的相關資訊時，proxy 會檢查可存取的物件是否仍然可用，如果是，則會將用戶端的要求轉送至可存取的物件。</span><span class="sxs-lookup"><span data-stu-id="f1189-125">For instance, when a client calls an [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) property to get information about an object, the proxy checks whether the accessible object is still available, and if so, forwards the client's request to the accessible object.</span></span> <span data-ttu-id="f1189-126">如果可存取物件已損毀，則 proxy 會將錯誤傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="f1189-126">If the accessible object is destroyed, the proxy returns an error to the client.</span></span>

 

 