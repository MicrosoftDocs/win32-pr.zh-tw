---
title: 空間和邏輯導覽
description: 用戶端會藉由呼叫 IAccessible accNavigate 並指定其中一個導覽常數，來抓取在相同容器內空間或邏輯上接近另一個物件之物件的相關資訊。
ms.assetid: a1ebb50e-76cf-472d-bb0f-3f5bf5ed30d5
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9b9e49772a267e49d723a04005dcbc8a369510b3
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106965859"
---
# <a name="spatial-and-logical-navigation"></a><span data-ttu-id="fecb4-103">空間和邏輯導覽</span><span class="sxs-lookup"><span data-stu-id="fecb4-103">Spatial and Logical Navigation</span></span>

<span data-ttu-id="fecb4-104">用戶端會藉由呼叫 [**IAccessible：： accNavigate**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-accnavigate) 並指定其中一個 [導覽常數](navigation-constants.md)，來抓取在相同容器內空間或邏輯上接近另一個物件之物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="fecb4-104">Clients retrieve information about an object that is spatially or logically near another object within the same container by calling [**IAccessible::accNavigate**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-accnavigate) and specifying one of the [navigation constants](navigation-constants.md).</span></span>

<span data-ttu-id="fecb4-105">使用 *空間導覽* 用戶端時，會根據其在畫面上的位置來流覽至物件。</span><span class="sxs-lookup"><span data-stu-id="fecb4-105">With *spatial navigation* clients navigate to an object based on its location on the screen.</span></span> <span data-ttu-id="fecb4-106">用戶端會從目前的物件向上、向下、向左或向右導覽，以取得相同容器內另一個物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="fecb4-106">Clients navigate up, down, left, or right from the current object to obtain information about another object within the same container.</span></span>

<span data-ttu-id="fecb4-107">使用 *邏輯導覽* 用戶端時，流覽至邏輯上或緊接在另一個物件（由伺服器決定）上的物件。</span><span class="sxs-lookup"><span data-stu-id="fecb4-107">With *logical navigation* clients navigate to the object that logically precedes or follows another object, as determined by the server.</span></span> <span data-ttu-id="fecb4-108">用戶端會以兩種方式流覽至物件的所有子系：</span><span class="sxs-lookup"><span data-stu-id="fecb4-108">Clients navigate to all of an object's children in two ways:</span></span>

-   <span data-ttu-id="fecb4-109">使用 [**NAVDIR \_ FIRSTCHILD**](navigation-constants.md)開始導覽，然後使用 NAVDIR 重複呼叫方法。 [**\_**](navigation-constants.md)</span><span class="sxs-lookup"><span data-stu-id="fecb4-109">Start the navigation with [**NAVDIR\_FIRSTCHILD**](navigation-constants.md) and then repeatedly call the method with [**NAVDIR\_NEXT**](navigation-constants.md).</span></span>
-   <span data-ttu-id="fecb4-110">使用 [**NAVDIR \_ LASTCHILD**](navigation-constants.md) 開始導覽，並使用 [**\_ 先前的 NAVDIR**](navigation-constants.md)重複呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="fecb4-110">Start the navigation with [**NAVDIR\_LASTCHILD**](navigation-constants.md) and repeatedly call the method with [**NAVDIR\_PREVIOUS**](navigation-constants.md).</span></span>

<span data-ttu-id="fecb4-111">不論方向為何，導覽都會造訪屬於父物件的每個可見的子系。</span><span class="sxs-lookup"><span data-stu-id="fecb4-111">Regardless of the direction, the navigation visits each visible child that belongs to the parent object.</span></span> <span data-ttu-id="fecb4-112">隱藏的子系可能會略過邏輯導覽。</span><span class="sxs-lookup"><span data-stu-id="fecb4-112">Invisible children may be skipped with logical navigation.</span></span> <span data-ttu-id="fecb4-113">此外，每個子系只會造訪一次，而流覽不會進行迴圈。</span><span class="sxs-lookup"><span data-stu-id="fecb4-113">Additionally, each child is visited only once, and the navigation does not loop around.</span></span> <span data-ttu-id="fecb4-114">也就是說，如果用戶端嘗試在第一個物件之前或最後一個物件之後流覽，則方法會失敗。</span><span class="sxs-lookup"><span data-stu-id="fecb4-114">That is, the method fails if a client attempts to navigate before the first object or after the last object.</span></span>

<span data-ttu-id="fecb4-115">空間和邏輯導覽是相關的。</span><span class="sxs-lookup"><span data-stu-id="fecb4-115">Spatial and logical navigation are related.</span></span> <span data-ttu-id="fecb4-116">例如，在水準工具列中，使用 [**NAVDIR \_ RIGHT**](navigation-constants.md) 呼叫方法應該會產生與使用 NAVDIR 來呼叫方法相同的結果 [**\_**](navigation-constants.md)。</span><span class="sxs-lookup"><span data-stu-id="fecb4-116">For example, in a horizontal toolbar, calling the method with [**NAVDIR\_RIGHT**](navigation-constants.md) should produce the same results as calling the method with [**NAVDIR\_NEXT**](navigation-constants.md).</span></span>

<span data-ttu-id="fecb4-117">除非指定了 [**NAVDIR \_ FIRSTCHILD**](navigation-constants.md)或 [**NAVDIR \_ LASTCHILD**](navigation-constants.md) ，否則導覽的起始物件是它本身 **或其中一個物件的子** 物件; 在此情況下，流覽必須從物件本身開始。</span><span class="sxs-lookup"><span data-stu-id="fecb4-117">The starting object of the navigation is either the object it **self or one of the object's children, except when either** [**NAVDIR\_FIRSTCHILD**](navigation-constants.md) or [**NAVDIR\_LASTCHILD**](navigation-constants.md) is specified; in this case, the navigation must start from the object itself.</span></span>

<span data-ttu-id="fecb4-118">如果用戶端從可存取的物件流覽至同級使用者介面專案，或如果 *varStart* 的 **LVal** 成員是 **CHILDID \_ SELF** ，而 *navDir* 中指定的旗標是 [**navDir \_ FIRSTCHILD**](navigation-constants.md)或 [**navDir \_ LASTCHILD**](navigation-constants.md)以外的任何導覽旗標，則 *pvarEnd* 中的結果會是子識別碼或 [**IDispatch**](idispatch-interface.md)介面。</span><span class="sxs-lookup"><span data-stu-id="fecb4-118">If a client navigates from an accessible object to a sibling user interface element, or if the **lVal** member of *varStart* is **CHILDID\_SELF** and the specified flag in *navDir* is any navigation flag except [**NAVDIR\_FIRSTCHILD**](navigation-constants.md) or [**NAVDIR\_LASTCHILD**](navigation-constants.md), the result in *pvarEnd* is either a child ID or an [**IDispatch**](idispatch-interface.md) interface.</span></span> <span data-ttu-id="fecb4-119">如果 *pvarEnd* 包含子識別碼，用戶端必須先取得父系的 [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) 介面指標，才能從這個使用者介面專案進行流覽，或取得其相關的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="fecb4-119">If *pvarEnd* contains a child ID, clients must first obtain a pointer to the parent's [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) interface in order to navigate from this user interface element or to obtain more information about it.</span></span> <span data-ttu-id="fecb4-120">為了取得父物件，用戶端會呼叫該物件的 [**IAccessible：： get \_ accParent**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-get_accparent) 屬性或導覽的起始物件。</span><span class="sxs-lookup"><span data-stu-id="fecb4-120">To obtain the parent object, clients call the [**IAccessible::get\_accParent**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-get_accparent) property of the sibling object or the starting object of the navigation.</span></span>

<span data-ttu-id="fecb4-121">請注意，用戶端必須透過呼叫 [**EnumChildWindows**](/windows/desktop/api/winuser/nf-winuser-enumchildwindows) 函式來取得所有浮動物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="fecb4-121">Note that clients must have information about all floating objects by calling the [**EnumChildWindows**](/windows/desktop/api/winuser/nf-winuser-enumchildwindows) function.</span></span> <span data-ttu-id="fecb4-122">由於浮動物件不會裁剪至其父系，因此用戶端不會有兩個物件之間的階層式關聯性相關資訊（在畫面上彼此接近）</span><span class="sxs-lookup"><span data-stu-id="fecb4-122">Because a floating object is not clipped to its parent, clients do not have information about the hierarchical relationship between two objects near one another on the screen.</span></span>

<span data-ttu-id="fecb4-123">下圖是未裁剪至其父系的浮動物件範例。</span><span class="sxs-lookup"><span data-stu-id="fecb4-123">The following graphic is an example of a floating object that is not clipped to its parent.</span></span>

![浮動在較大型 microsoft developer studio 視窗上方之開啟視窗的螢幕擷取畫面](images/floatob.gif)

## <a name="establishing-the-order-in-logical-navigation"></a><span data-ttu-id="fecb4-125">在邏輯導覽中建立順序</span><span class="sxs-lookup"><span data-stu-id="fecb4-125">Establishing the Order in Logical Navigation</span></span>

<span data-ttu-id="fecb4-126">在邏輯導覽中，設計物件的開發人員會建立它們之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="fecb4-126">In logical navigation, the developers who design the objects establish the relationships between them.</span></span> <span data-ttu-id="fecb4-127">邏輯導覽比空間導覽更主觀。</span><span class="sxs-lookup"><span data-stu-id="fecb4-127">Logical navigation is more subjective than spatial navigation.</span></span> <span data-ttu-id="fecb4-128">此外，邏輯導覽中的順序與子識別碼搭配使用的順序不同。</span><span class="sxs-lookup"><span data-stu-id="fecb4-128">Also, the order in logical navigation is not the same as the order used with child IDs.</span></span>

<span data-ttu-id="fecb4-129">對於具有螢幕位置的物件，伺服器開發人員應以大部分使用者認為邏輯的方式來建立導覽順序。</span><span class="sxs-lookup"><span data-stu-id="fecb4-129">For objects that have screen locations, server developers should establish the navigation order in the way that most users would consider logical.</span></span> <span data-ttu-id="fecb4-130">比方說，在英文的國家/地區中，這表示由左至右、由上到下的順序。</span><span class="sxs-lookup"><span data-stu-id="fecb4-130">In English-speaking countries/regions, for instance, this means a left-to-right, top-to-bottom ordering.</span></span>

<span data-ttu-id="fecb4-131">邏輯流覽順序必須平行鍵盤導覽順序。</span><span class="sxs-lookup"><span data-stu-id="fecb4-131">Logical navigation order must parallel keyboard navigation order.</span></span> <span data-ttu-id="fecb4-132">例如，對話方塊包含 **[確定]** 和 [ **取消** ] 按鈕，以及一些編輯控制項。</span><span class="sxs-lookup"><span data-stu-id="fecb4-132">For example, a dialog box contains **OK** and **Cancel** push buttons and a few edit controls.</span></span> <span data-ttu-id="fecb4-133">當用戶端呼叫 [**IAccessible：： accNavigate**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-accnavigate) ，以流覽至該對話方塊中的下一個或上一個物件時，會以使用者按下 TAB 或 SHIFT + tab 的相同順序移動專案之間的焦點。</span><span class="sxs-lookup"><span data-stu-id="fecb4-133">A client that calls [**IAccessible::accNavigate**](/windows/desktop/api/Oleacc/nf-oleacc-iaccessible-accnavigate) to navigate to the next or previous object in that dialog box moves in the same order as a user pressing TAB or SHIFT+TAB to move the focus between items.</span></span>

<span data-ttu-id="fecb4-134">針對沒有定義螢幕位置的物件，邏輯順序是由伺服器開發人員決定，而且用戶端開發人員不應該對其進行任何假設。</span><span class="sxs-lookup"><span data-stu-id="fecb4-134">For objects that do not have defined screen locations, the logical order is decided by server developers, and client developers should make no assumptions about it.</span></span> <span data-ttu-id="fecb4-135">比方說，不可見的物件（例如只會暫時隱藏的物件）可以接受，以與可見的物件交錯。</span><span class="sxs-lookup"><span data-stu-id="fecb4-135">For instance, it is acceptable for non-visible objects, such as objects that are only temporarily hidden, to be interspersed with visible objects.</span></span>

 

 