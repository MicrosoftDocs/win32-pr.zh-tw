---
description: 系統的使用者模式例外狀況處理可支援精密的偵錯工具。
ms.assetid: c45a7dc6-e6b2-4fc4-9522-12d96893f4c7
title: 偵錯工具例外狀況處理
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a6aff6d566e8798aaf4f3113ce6d8f44a3bc71ba
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104467957"
---
# <a name="debugger-exception-handling"></a><span data-ttu-id="ad3a1-103">偵錯工具例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="ad3a1-103">Debugger Exception Handling</span></span>

<span data-ttu-id="ad3a1-104">系統的使用者模式例外狀況處理可支援精密的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-104">The system's handling of user-mode exceptions provides support for sophisticated debuggers.</span></span> <span data-ttu-id="ad3a1-105">如果發生例外狀況的處理常式正在進行中，系統會產生一個 debug 事件。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-105">If the process in which an exception occurs is being debugged, the system generates a debug event.</span></span> <span data-ttu-id="ad3a1-106">如果偵錯工具使用 [**WaitForDebugEvent**](/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent) 函式，debug 事件會導致該函式以指向 [**debug \_ 事件**](/windows/win32/api/minwinbase/ns-minwinbase-debug_event) 結構的指標傳回。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-106">If the debugger is using the [**WaitForDebugEvent**](/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent) function, the debug event causes that function to return with a pointer to a [**DEBUG\_EVENT**](/windows/win32/api/minwinbase/ns-minwinbase-debug_event) structure.</span></span> <span data-ttu-id="ad3a1-107">此結構包含偵錯工具和執行緒識別碼，可供偵錯工具用來存取執行緒的內容記錄。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-107">This structure contains the process and thread identifiers the debugger can use to access the thread's context record.</span></span> <span data-ttu-id="ad3a1-108">此結構也包含例外狀況的 [**\_ DEBUG \_ 資訊**](/windows/win32/api/minwinbase/ns-minwinbase-exception_debug_info) 結構，其中包含例外狀況記錄的複本。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-108">The structure also contains an [**EXCEPTION\_DEBUG\_INFO**](/windows/win32/api/minwinbase/ns-minwinbase-exception_debug_info) structure that includes a copy of the exception record.</span></span>

<span data-ttu-id="ad3a1-109">當系統搜尋例外狀況處理常式時，會進行兩次嘗試來通知進程的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-109">When the system is searching for an exception handler, it makes two attempts to notify a process's debugger.</span></span> <span data-ttu-id="ad3a1-110">第一個通知嘗試會提供偵錯工具處理中斷點或單一步驟例外狀況的機會。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-110">The first notification attempt provides the debugger with an opportunity to handle breakpoint or single-step exceptions.</span></span> <span data-ttu-id="ad3a1-111">這就是所謂的 *第一次通知*。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-111">This is known as *first-chance notification*.</span></span> <span data-ttu-id="ad3a1-112">然後，使用者就可以在執行任何例外狀況處理常式之前，發出偵錯工具命令來操作進程的環境。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-112">The user can then issue debugger commands to manipulate the process's environment before any exception handlers are executed.</span></span> <span data-ttu-id="ad3a1-113">只有當系統找不到處理例外狀況的以框架為基礎的例外狀況處理常式時，才會嘗試第二次通知偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-113">The second attempt to notify the debugger occurs only if the system is unable to find a frame-based exception handler that handles the exception.</span></span> <span data-ttu-id="ad3a1-114">這就是所謂的 *最後機會通知*。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-114">This is known as *last-chance notification*.</span></span> <span data-ttu-id="ad3a1-115">如果偵錯工具未在最後一次發生通知之後處理例外狀況，則系統會終止正在進行調試的進程。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-115">If the debugger does not handle the exception after the last-chance notification, the system terminates the process being debugged.</span></span>

<span data-ttu-id="ad3a1-116">在每次嘗試時，偵錯工具都會使用 [**ContinueDebugEvent**](/windows/win32/api/debugapi/nf-debugapi-continuedebugevent) 函式將控制權交還給系統。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-116">At each notification attempt, the debugger uses the [**ContinueDebugEvent**](/windows/win32/api/debugapi/nf-debugapi-continuedebugevent) function to return control to the system.</span></span> <span data-ttu-id="ad3a1-117">在傳回控制權之前，偵錯工具可以處理例外狀況，並適當地修改執行緒狀態，也可以選擇不要處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-117">Before returning control, the debugger can handle the exception and modify the thread state as appropriate, or it can choose not to handle the exception.</span></span> <span data-ttu-id="ad3a1-118">使用 **ContinueDebugEvent** 時，偵錯工具可能會指出它已處理例外狀況，在此情況下，電腦狀態會還原，而執行緒執行會在發生例外狀況的時間點繼續執行。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-118">Using **ContinueDebugEvent**, the debugger can indicate that it has handled the exception, in which case the machine state is restored and thread execution is continued at the point at which the exception occurred.</span></span> <span data-ttu-id="ad3a1-119">偵錯工具也可以表示它未處理例外狀況，這會導致系統繼續搜尋例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="ad3a1-119">The debugger can also indicate that it did not handle the exception, which causes the system to continue its search for an exception handler.</span></span>

 

 
