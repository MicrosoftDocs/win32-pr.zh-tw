---
title: 架構與元件
description: 本主題說明組成 Microsoft DirectComposition 的元件。
ms.assetid: 7C79B330-41EA-4BA0-9103-BB5A0C3D4CE2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fb2de495aa170560b1e7082cacf1893a8c94905a
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104023910"
---
# <a name="architecture-and-components"></a><span data-ttu-id="02f13-103">架構與元件</span><span class="sxs-lookup"><span data-stu-id="02f13-103">Architecture and components</span></span>

> [!NOTE]
> <span data-ttu-id="02f13-104">針對 Windows 10 上的應用程式，我們建議使用 DirectComposition，而不是使用。</span><span class="sxs-lookup"><span data-stu-id="02f13-104">For apps on Windows 10, we recommend using Windows.UI.Composition APIs instead of DirectComposition.</span></span> <span data-ttu-id="02f13-105">如需詳細資訊，請參閱 [使用視覺分層將您的桌面應用程式現代化](/windows/uwp/composition/visual-layer-in-desktop-apps)。</span><span class="sxs-lookup"><span data-stu-id="02f13-105">For more info, see [Modernize your desktop app using the Visual layer](/windows/uwp/composition/visual-layer-in-desktop-apps).</span></span>

<span data-ttu-id="02f13-106">本主題說明組成 Microsoft DirectComposition 的元件。</span><span class="sxs-lookup"><span data-stu-id="02f13-106">This topic describes the components that make up Microsoft DirectComposition.</span></span> <span data-ttu-id="02f13-107">其中包含下列各節。</span><span class="sxs-lookup"><span data-stu-id="02f13-107">It consists of the following sections.</span></span>

-   [<span data-ttu-id="02f13-108">軟體元件</span><span class="sxs-lookup"><span data-stu-id="02f13-108">Software components</span></span>](#software-components)
-   [<span data-ttu-id="02f13-109">應用程式程式庫</span><span class="sxs-lookup"><span data-stu-id="02f13-109">Application library</span></span>](#application-library)
-   [<span data-ttu-id="02f13-110">撰寫引擎</span><span class="sxs-lookup"><span data-stu-id="02f13-110">Composition engine</span></span>](#composition-engine)
-   [<span data-ttu-id="02f13-111">相關主題</span><span class="sxs-lookup"><span data-stu-id="02f13-111">Related topics</span></span>](#related-topics)

## <a name="software-components"></a><span data-ttu-id="02f13-112">軟體元件</span><span class="sxs-lookup"><span data-stu-id="02f13-112">Software components</span></span>

<span data-ttu-id="02f13-113">DirectComposition 包含下列主要軟體元件。</span><span class="sxs-lookup"><span data-stu-id="02f13-113">DirectComposition consists of the following main software components.</span></span>

-   <span data-ttu-id="02f13-114">使用者模式應用程式程式庫 (dcomp.dll) ，它會執行 (COM) 型公用 API 的元件物件模型。</span><span class="sxs-lookup"><span data-stu-id="02f13-114">A user-mode application library (dcomp.dll) that implements the Component Object Model (COM)-based public API.</span></span>
-   <span data-ttu-id="02f13-115">使用者模式組合引擎 (dwmcore.dll) 裝載于桌面視窗管理員 (DWM) 處理常式 (dwm.exe) ，並執行實際的桌面組合。</span><span class="sxs-lookup"><span data-stu-id="02f13-115">A user-mode composition engine (dwmcore.dll) that is hosted in the Desktop Window Manager (DWM) process (dwm.exe), and performs the actual desktop composition.</span></span>
-   <span data-ttu-id="02f13-116">核心模式物件資料庫 (win32k.sys) 的一部分，可將命令從應用程式封送處理至撰寫引擎。</span><span class="sxs-lookup"><span data-stu-id="02f13-116">A kernel-mode object database (part of win32k.sys) that marshals commands from the application to the composition engine.</span></span>

<span data-ttu-id="02f13-117">組合引擎的單一實例會處理所有應用程式的 DirectComposition 組合樹狀結構，以及代表整個桌面的 DWM 組合樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="02f13-117">A single instance of the composition engine handles the DirectComposition composition trees for all applications and the DWM composition tree, which represents the entire desktop.</span></span> <span data-ttu-id="02f13-118">在每個會話中，核心模式物件資料庫和使用者模式組合引擎都會具現化一次，因此具有多個使用者的終端機伺服器電腦會有這兩個元件的多個實例。</span><span class="sxs-lookup"><span data-stu-id="02f13-118">Both the kernel-mode object database and the user-mode composition engine are instantiated once per session, so a Terminal Server machine with multiple users has multiple instances of both of those components.</span></span>

<span data-ttu-id="02f13-119">下圖顯示主要 DirectComposition 元件，以及它們彼此之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="02f13-119">The following diagram shows the main DirectComposition components and how they relate to one another.</span></span>

![directcomposition 最上層架構](images/directcomposition-top-level-architecture.png)

## <a name="application-library"></a><span data-ttu-id="02f13-121">應用程式程式庫</span><span class="sxs-lookup"><span data-stu-id="02f13-121">Application library</span></span>

<span data-ttu-id="02f13-122">DirectComposition 應用程式程式庫是一個公用的 COM 型 API，其具有從 dcomp.dll 匯出的單一一般進入點，並傳回裝置物件的介面指標。</span><span class="sxs-lookup"><span data-stu-id="02f13-122">The DirectComposition application library is a public COM-based API with a single flat entry-point that is exported from dcomp.dll and returns an interface pointer to a device object.</span></span> <span data-ttu-id="02f13-123">然後，裝置物件有方法可建立其他所有物件，每個物件都是由介面指標表示。</span><span class="sxs-lookup"><span data-stu-id="02f13-123">The device object, in turn, has methods for creating all other objects, each of which is represented by an interface pointer.</span></span> <span data-ttu-id="02f13-124">所有的 DirectComposition 介面都會繼承自並完全執行 [**IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown) 介面。</span><span class="sxs-lookup"><span data-stu-id="02f13-124">All DirectComposition interfaces inherit from and fully implement the [**IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="02f13-125">所有接受 DirectComposition 介面的方法都會檢查介面是否在 dcomp.dll 內部執行，或是否由另一個元件所實。</span><span class="sxs-lookup"><span data-stu-id="02f13-125">All methods that accept DirectComposition interfaces check whether the interface is implemented inside of dcomp.dll or whether it is implemented by another component.</span></span> <span data-ttu-id="02f13-126">因為 DirectComposition 不可延伸，所以將介面視為參數的方法會傳回 E \_ INVALIDARG （如果介面未在 dcomp.dll 中執行）。</span><span class="sxs-lookup"><span data-stu-id="02f13-126">Because DirectComposition is not extensible, methods that take interfaces as parameters return E\_INVALIDARG if the interfaces are not implemented in dcomp.dll.</span></span> <span data-ttu-id="02f13-127">API 不需要任何特殊許可權;它可由在最低存取層級執行的進程呼叫。</span><span class="sxs-lookup"><span data-stu-id="02f13-127">The API requires no special privileges; it can be called by processes running at the lowest level of access.</span></span> <span data-ttu-id="02f13-128">不過，因為 API 不會在會話0中運作，所以不適合服務。</span><span class="sxs-lookup"><span data-stu-id="02f13-128">However, because the API does not operate in session 0, it is not suitable for services.</span></span> <span data-ttu-id="02f13-129">在這些方面，DirectComposition API 類似于其他 Microsoft DirectX Api，最值得注意的是 Direct2D、Microsoft Direct3D 和 Microsoft DirectWrite。</span><span class="sxs-lookup"><span data-stu-id="02f13-129">In these respects, the DirectComposition API is similar to other Microsoft DirectX APIs, most notably Direct2D, Microsoft Direct3D, and Microsoft DirectWrite.</span></span>

<span data-ttu-id="02f13-130">由於撰寫引擎是專門針對非同步執行而設計的，因此 DirectComposition API 中的物件屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="02f13-130">Because the composition engine is designed exclusively for asynchronous execution, object properties in the DirectComposition API are write-only.</span></span> <span data-ttu-id="02f13-131">所有屬性都有 setter 方法，而不是 getter 方法。</span><span class="sxs-lookup"><span data-stu-id="02f13-131">All properties have setter methods, but not getter methods.</span></span> <span data-ttu-id="02f13-132">讀取屬性不僅需要耗用大量資源，也可能不正確，因為組合引擎傳回的任何值都可以立即變成無效。</span><span class="sxs-lookup"><span data-stu-id="02f13-132">Reading properties is not only resource intensive, but can also be inaccurate because any value that the composition engine returns can immediately become invalid.</span></span> <span data-ttu-id="02f13-133">舉例來說，如果獨立的動畫系結至正在讀取的屬性，就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="02f13-133">This can happen if, for example, an independent animation is bound to the property that is being read.</span></span>

<span data-ttu-id="02f13-134">API 是安全線程。</span><span class="sxs-lookup"><span data-stu-id="02f13-134">The API is thread-safe.</span></span> <span data-ttu-id="02f13-135">應用程式隨時都可以從任何執行緒呼叫任何方法。</span><span class="sxs-lookup"><span data-stu-id="02f13-135">An application can call any method from any thread at any time.</span></span> <span data-ttu-id="02f13-136">不過，因為許多 API 方法都必須以特定順序呼叫，所以如果沒有任何同步處理，則應用程式可能會因執行緒的交錯方式而遇到無法預期的行為。</span><span class="sxs-lookup"><span data-stu-id="02f13-136">However, because many API methods must be called in a particular sequence, without any synchronization an application can experience unpredictable behavior depending on how the threads interleave.</span></span> <span data-ttu-id="02f13-137">例如，如果兩個執行緒同時將相同物件的相同屬性變更為不同的值，應用程式就無法預測兩個值中的哪一個是屬性的最終值。</span><span class="sxs-lookup"><span data-stu-id="02f13-137">For example, if two threads change the same property of the same object to different values at the same time, the application cannot predict which of the two values will be the final value of the property.</span></span> <span data-ttu-id="02f13-138">同樣地，如果兩個執行緒呼叫相同裝置上的 [**commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit) ，則這兩個執行緒都不會取得真正的交易行為，因為在某個執行緒上的 **commit** 呼叫將會提交兩個執行緒所發出之所有命令的批次，而不只是呼叫 **commit** 的執行緒。</span><span class="sxs-lookup"><span data-stu-id="02f13-138">Similarly, if two threads call [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit) on the same device, neither thread gets truly transactional behavior because a call to **Commit** on one thread will submit the batch of all commands issued by both threads, not just the one that called **Commit**.</span></span>

<span data-ttu-id="02f13-139">系統會維護每個裝置物件的所有內部狀態。</span><span class="sxs-lookup"><span data-stu-id="02f13-139">The system maintains all internal state per device object.</span></span> <span data-ttu-id="02f13-140">如果應用程式建立兩個或多個 DirectComposition 的裝置物件，應用程式可以維護獨立批次，以及兩者之間的其他狀態。</span><span class="sxs-lookup"><span data-stu-id="02f13-140">If an application creates two or more DirectComposition device objects, the application can maintain independent batches and other state between the two.</span></span>

<span data-ttu-id="02f13-141">所有 DirectComposition 物件都具有裝置物件親和性;特定裝置物件所建立的物件只能用於該裝置物件，且只能與相同裝置物件所建立的其他物件相關聯。</span><span class="sxs-lookup"><span data-stu-id="02f13-141">All DirectComposition objects have device object affinity; objects created by a particular device object can be used only with that device object, and can be associated only with other objects created by the same device object.</span></span> <span data-ttu-id="02f13-142">換句話說，每個裝置物件都是分開的獨立功能島。</span><span class="sxs-lookup"><span data-stu-id="02f13-142">In other words, each device object is a separate disjoint island of functionality.</span></span> <span data-ttu-id="02f13-143">其中一個例外狀況是視覺效果類別，允許建立視覺樹狀結構，其中的視覺效果可以屬於與其父系不同的裝置物件。</span><span class="sxs-lookup"><span data-stu-id="02f13-143">The one exception is the visual class, which permits the building of visual trees where a visual can belong to a different device object than its parent.</span></span> <span data-ttu-id="02f13-144">這可讓應用程式和控制項管理單一組合樹狀結構，而不需要共用單一 DirectComposition 裝置物件的情況。</span><span class="sxs-lookup"><span data-stu-id="02f13-144">This enables scenarios where an application and a control can manage a single composition tree without also needing to share a single DirectComposition device object.</span></span>

## <a name="composition-engine"></a><span data-ttu-id="02f13-145">撰寫引擎</span><span class="sxs-lookup"><span data-stu-id="02f13-145">Composition engine</span></span>

<span data-ttu-id="02f13-146">DirectComposition 組合引擎會在專用的進程上執行，與任何應用程式進程不同。</span><span class="sxs-lookup"><span data-stu-id="02f13-146">The DirectComposition composition engine runs on a dedicated process, separate from any application process.</span></span> <span data-ttu-id="02f13-147">單一撰寫程式（dwm.exe）支援會話中的每個應用程式。</span><span class="sxs-lookup"><span data-stu-id="02f13-147">A single composition process, dwm.exe, supports every application in a session.</span></span> <span data-ttu-id="02f13-148">每個應用程式都可以針對它所擁有的每個視窗建立兩個視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="02f13-148">Each application can create two visual trees for each window that it owns.</span></span> <span data-ttu-id="02f13-149">所有的樹狀結構實際上都實作為較大型視覺化樹狀結構的子樹，也包含 DWM 的組合結構。</span><span class="sxs-lookup"><span data-stu-id="02f13-149">All of the trees are actually implemented as subtrees of a larger visual tree that also encompasses the composition structures of DWM.</span></span> <span data-ttu-id="02f13-150">DWM 會針對會話中的每個桌面，各建立一個大型的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="02f13-150">The DWM constructs one large visual tree for each desktop in a session.</span></span> <span data-ttu-id="02f13-151">以下是這個架構的主要優點：</span><span class="sxs-lookup"><span data-stu-id="02f13-151">Here are the key advantages to this architecture:</span></span>

-   <span data-ttu-id="02f13-152">組合引擎可以存取所有應用程式點陣圖和視覺化樹狀結構，以啟用跨進程視窗互通性和組合。</span><span class="sxs-lookup"><span data-stu-id="02f13-152">The composition engine has access to all application bitmaps and visual trees, which enables cross-process window interoperability and composition.</span></span>
-   <span data-ttu-id="02f13-153">撰寫引擎會在與任何應用程式程式不同的信任系統進程中執行，讓具有低存取權限的應用程式可以安全地撰寫受保護的內容。</span><span class="sxs-lookup"><span data-stu-id="02f13-153">The composition engine runs in a trusted system process that is separate from any application process, enabling applications that have low access rights to securely compose protected content.</span></span>
-   <span data-ttu-id="02f13-154">撰寫引擎可以偵測特定視窗完全 pixels occluded 的時間，並避免浪費 CPU 和圖形處理器單位 (GPU) 資源為視窗組成。</span><span class="sxs-lookup"><span data-stu-id="02f13-154">The composition engine can detect when a particular window is fully occluded and avoid wasting CPU and graphics processing unit (GPU) resources composing for the window.</span></span>
-   <span data-ttu-id="02f13-155">撰寫引擎可以直接組成螢幕背景緩衝區，而不需要個別進程組合引擎所需的額外複本。</span><span class="sxs-lookup"><span data-stu-id="02f13-155">The composition engine can compose directly to the screen back buffer, avoiding the need for an extra copy that is required for per-process composition engines.</span></span>
-   <span data-ttu-id="02f13-156">所有應用程式都會共用單一 Direct3D 裝置以進行組合，可節省可觀的記憶體</span><span class="sxs-lookup"><span data-stu-id="02f13-156">All applications share a single Direct3D device for composition, which offers considerable memory savings</span></span>

<span data-ttu-id="02f13-157">視覺化樹狀結構是保留的結構。</span><span class="sxs-lookup"><span data-stu-id="02f13-157">The visual tree is a retained structure.</span></span> <span data-ttu-id="02f13-158">DirectComposition API 公開以不可部分完成處理的變更批次編輯結構的方法。</span><span class="sxs-lookup"><span data-stu-id="02f13-158">The DirectComposition API exposes methods to edit the structure in batches of changes that are processed atomically.</span></span> <span data-ttu-id="02f13-159">DirectComposition API 中的根物件是裝置物件，可作為所有其他 DirectComposition 物件的 factory，並包含稱為 [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit)的方法。</span><span class="sxs-lookup"><span data-stu-id="02f13-159">The root object in the DirectComposition API is the device object, which serves as the factory for all other DirectComposition objects and contains a method called [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit).</span></span> <span data-ttu-id="02f13-160">撰寫引擎不會反映應用程式對視覺化樹狀結構所做的任何變更，直到應用程式呼叫 **Commit** 為止，屆時最後一次 **認可** 之後的所有變更都會處理為單一交易。</span><span class="sxs-lookup"><span data-stu-id="02f13-160">The composition engine does not reflect any changes that the application makes to the visual tree until the application calls **Commit**, at which point all changes since the last **Commit** are processed as a single transaction.</span></span>

<span data-ttu-id="02f13-161">呼叫 [**commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit) 的需求與「框架」的概念類似，不同之處在于，因為組合引擎會以非同步方式執行，所以可能會在呼叫 **認可** 之間呈現數個不同的畫面格。</span><span class="sxs-lookup"><span data-stu-id="02f13-161">The requirement to call [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit) is similar to the concept of a "frame" except that, because the composition engine runs asynchronously, it can present several different frames between calls to **Commit**.</span></span> <span data-ttu-id="02f13-162">在 DirectComposition 中， *框架* 是組合引擎的單一反復專案，而應用程式在兩個 **認可** 呼叫之間花費的間隔稱為 *批次*。</span><span class="sxs-lookup"><span data-stu-id="02f13-162">In DirectComposition, a *frame* is a single iteration of the composition engine, and the interval spent by an application between two calls to **Commit** is called a *batch*.</span></span>

<span data-ttu-id="02f13-163">DirectComposition 會將所有應用程式呼叫批次到 DirectComposition API。</span><span class="sxs-lookup"><span data-stu-id="02f13-163">DirectComposition batches all application calls to the DirectComposition API.</span></span> <span data-ttu-id="02f13-164">在 win32k.sys 會話驅動程式中所執行的核心物件資料庫會儲存與 API 呼叫相關聯的所有狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="02f13-164">The kernel object database, which is implemented in the win32k.sys session driver, stores all state information that is associated with the API calls.</span></span>

<span data-ttu-id="02f13-165">組合引擎會為顯示中的每個垂直空白產生一個畫面格。</span><span class="sxs-lookup"><span data-stu-id="02f13-165">The composition engine produces one frame for each vertical blank in the display.</span></span> <span data-ttu-id="02f13-166">畫面格會以垂直的空白啟動，並以後續垂直空白為目標。</span><span class="sxs-lookup"><span data-stu-id="02f13-166">The frame is started at a vertical blank and targets the subsequent vertical blank.</span></span> <span data-ttu-id="02f13-167">當框架啟動時，組合引擎會挑選所有暫止的批次，並在該框架中包含其命令。</span><span class="sxs-lookup"><span data-stu-id="02f13-167">When the frame starts, the composition engine picks up all pending batches and includes their commands in that frame.</span></span> <span data-ttu-id="02f13-168">當應用程式呼叫 [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit)時，會將批次放在暫止的佇列中，而暫止的佇列會在框架的開頭以原子方式進行清除。</span><span class="sxs-lookup"><span data-stu-id="02f13-168">Batches are placed in a pending queue when the application calls [**Commit**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-commit), and the pending queue is flushed atomically at the beginning of the frame.</span></span> <span data-ttu-id="02f13-169">因此，有一個會標示框架開頭的時間點。</span><span class="sxs-lookup"><span data-stu-id="02f13-169">Therefore, there is a single point in time that marks the beginning of a frame.</span></span> <span data-ttu-id="02f13-170">在此時間點之前提交的任何批次都會包含在框架中，而在之後提交的任何批次必須等到下一個畫面格才能處理。</span><span class="sxs-lookup"><span data-stu-id="02f13-170">Any batches submitted before this point are included in the frame, while any batches submitted after must wait until the next frame to be processed.</span></span> <span data-ttu-id="02f13-171">完整撰寫迴圈如下所示：</span><span class="sxs-lookup"><span data-stu-id="02f13-171">The full composition loop is as follows:</span></span>

1.  <span data-ttu-id="02f13-172">估計下一個垂直空白的時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-172">Estimate the time of the next vertical blank.</span></span>
2.  <span data-ttu-id="02f13-173">取出所有暫止的批次。</span><span class="sxs-lookup"><span data-stu-id="02f13-173">Retrieve all pending batches.</span></span>
3.  <span data-ttu-id="02f13-174">處理已取出的批次。</span><span class="sxs-lookup"><span data-stu-id="02f13-174">Process the retrieved batches.</span></span>
4.  <span data-ttu-id="02f13-175">使用步驟1中估計的時間更新所有動畫。</span><span class="sxs-lookup"><span data-stu-id="02f13-175">Update all animations using the time estimated in step 1.</span></span>
5.  <span data-ttu-id="02f13-176">判斷需要重新撰寫的螢幕區域。</span><span class="sxs-lookup"><span data-stu-id="02f13-176">Determine the regions of the screen that need to be re-composed.</span></span>
6.  <span data-ttu-id="02f13-177">重新撰寫中途區域。</span><span class="sxs-lookup"><span data-stu-id="02f13-177">Re-compose the dirty regions.</span></span>
7.  <span data-ttu-id="02f13-178">藉由為每個畫面翻轉背面和前端緩衝區來呈現畫面格。</span><span class="sxs-lookup"><span data-stu-id="02f13-178">Present the frame by flipping the back and front buffers for each screen.</span></span>
8.  <span data-ttu-id="02f13-179">如果未在步驟6和7中撰寫任何內容並加以呈現，請等候批次認可。</span><span class="sxs-lookup"><span data-stu-id="02f13-179">If nothing was composed and presented in steps 6 and 7, wait for a batch to be committed.</span></span>
9.  <span data-ttu-id="02f13-180">等候下一個垂直空白。</span><span class="sxs-lookup"><span data-stu-id="02f13-180">Wait for the next vertical blank.</span></span>

<span data-ttu-id="02f13-181">如果有多個監視器連接到單一視訊卡，組合引擎會使用主要監視器的垂直空白來驅動組合迴圈，並設定動畫取樣時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-181">If there are multiple monitors attached to a single video adapter, the composition engine uses the vertical blank of the primary monitor to drive the composition loop and set the animation sampling times.</span></span> <span data-ttu-id="02f13-182">每個監視器都會以個別的全螢幕翻轉鏈表示;撰寫引擎會使用單一 Direct3D 裝置，以迴圈配置資源的方式，為每個監視器重複步驟6和7。</span><span class="sxs-lookup"><span data-stu-id="02f13-182">Each monitor is represented by a separate full-screen flip chain; the composition engine repeats steps 6 and 7 for each monitor, in a round-robin fashion, using a single Direct3D device.</span></span> <span data-ttu-id="02f13-183">如果也有多張視訊卡，組合引擎會針對步驟6和7中的每個視訊卡使用個別的 Direct3D 裝置。</span><span class="sxs-lookup"><span data-stu-id="02f13-183">If there are also multiple video adapters, the composition engine uses a separate Direct3D device for each video adapter in steps 6 and 7.</span></span>

<span data-ttu-id="02f13-184">下拉式列示方塊架的排程一律是從垂直空白開始，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="02f13-184">Composition frames are scheduled to always start at a vertical blank, as the following illustration shows.</span></span>

![下拉式列示方塊架排程](images/composition-frame-scheduling.png)

<span data-ttu-id="02f13-186">如果組合引擎沒有任何要執行的工作，因為組合樹狀結構未變更，撰寫執行緒會在等候新的批次時進入睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="02f13-186">If the composition engine has no work to do because the composition tree has not changed, the composition thread sleeps while waiting for a new batch.</span></span> <span data-ttu-id="02f13-187">當提交新批次時，組合執行緒會喚醒，但會立即回到睡眠狀態，直到下一個垂直空白為止。</span><span class="sxs-lookup"><span data-stu-id="02f13-187">When a new batch is submitted, the composition thread wakes up but immediately goes back to sleep until the next vertical blank.</span></span> <span data-ttu-id="02f13-188">此行為可確保應用程式和組合引擎的可預測框架開始和結束時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-188">This behavior ensures predictable frame start and end times for applications and for the composition engine.</span></span>

<span data-ttu-id="02f13-189">組合引擎會發佈框架呈現時間和目前的畫面播放速率。</span><span class="sxs-lookup"><span data-stu-id="02f13-189">The composition engine publishes the frame presentation times and the current frame rate.</span></span> <span data-ttu-id="02f13-190">發佈這項資訊可讓應用程式針對自己的批次預估呈現時間，進而啟用動畫的同步處理。</span><span class="sxs-lookup"><span data-stu-id="02f13-190">Publishing this information enables applications to estimate the presentation time for their own batches, which in turns enables animations to be synchronized.</span></span> <span data-ttu-id="02f13-191">尤其是，應用程式可以使用組合引擎的框架統計資料組合，以及 UI 執行緒產生批次所需的歷程記錄模型，以判斷其本身動畫的取樣時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-191">In particular, an application can use a combination of frame statistics from the composition engine, and a historical model of how long its UI thread takes to produce a batch, to determine the sampling time for its own animations.</span></span>

<span data-ttu-id="02f13-192">例如，在上圖所示的應用程式批次開始時，應用程式可以查詢組合引擎以判斷下一個畫面格的精確呈現時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-192">For example, at the beginning of the application batch shown in the previous illustration, the application can query the composition engine to determine the exact presentation time of the next frame.</span></span> <span data-ttu-id="02f13-193">然後，應用程式可以使用目前的時間，以及它所產生的先前批次的相關資訊，以判斷應用程式是否可以在下一個垂直空白之前完成目前的批次。</span><span class="sxs-lookup"><span data-stu-id="02f13-193">The application can then use the current time, along with information about previous batches that it has produced, to determine whether the application can complete the current batch before the next vertical blank.</span></span> <span data-ttu-id="02f13-194">因此，應用程式會使用框架呈現時間作為其本身動畫的取樣時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-194">Therefore, the application uses the frame presentation time as the sampling time for its own animations.</span></span> <span data-ttu-id="02f13-195">如果應用程式判斷不太可能在目前的垂直空白中完成工作，則應用程式可以改為使用後續的畫面格時間做為取樣時間，方法是使用組合引擎所傳回的畫面播放速率資訊來計算該時間。</span><span class="sxs-lookup"><span data-stu-id="02f13-195">If the application determines that it is unlikely to complete its work in the current vertical blank, the application can use the subsequent frame time as the sampling time instead, using the frame rate information returned by the composition engine to compute that time.</span></span>

## <a name="related-topics"></a><span data-ttu-id="02f13-196">相關主題</span><span class="sxs-lookup"><span data-stu-id="02f13-196">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="02f13-197">DirectComposition 概念</span><span class="sxs-lookup"><span data-stu-id="02f13-197">DirectComposition Concepts</span></span>](directcomposition-concepts.md)
</dt> </dl>

 

 