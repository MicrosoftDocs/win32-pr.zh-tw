---
description: 瞭解如何在 windows 7 和 Windows Server 2008 R2 平臺的 Windows 應用程式中避免記憶體流失。
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: 防止 Windows 應用程式中的記憶體流失
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/06/2021
ms.locfileid: "104555028"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="2f072-103">防止 Windows 應用程式中的記憶體流失</span><span class="sxs-lookup"><span data-stu-id="2f072-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="2f072-104">受影響的平臺</span><span class="sxs-lookup"><span data-stu-id="2f072-104">Affected Platforms</span></span>

<span data-ttu-id="2f072-105">**客戶** 端-Windows 7</span><span class="sxs-lookup"><span data-stu-id="2f072-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="2f072-106">**伺服器** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="2f072-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="2f072-107">Description</span><span class="sxs-lookup"><span data-stu-id="2f072-107">Description</span></span>

<span data-ttu-id="2f072-108">記憶體流失是指應用程式無法在不再需要時釋放記憶體的錯誤類別。</span><span class="sxs-lookup"><span data-stu-id="2f072-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="2f072-109">經過一段時間後，記憶體流失會影響特定應用程式和作業系統的效能。</span><span class="sxs-lookup"><span data-stu-id="2f072-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="2f072-110">由於過度分頁，大量流失可能會導致無法接受的回應時間。</span><span class="sxs-lookup"><span data-stu-id="2f072-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="2f072-111">最後，應用程式和作業系統的其他部分將會發生失敗。</span><span class="sxs-lookup"><span data-stu-id="2f072-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="2f072-112">Windows 將會在進程終止時釋出應用程式所配置的所有記憶體，因此短時間執行的應用程式不會大幅影響整體系統效能。</span><span class="sxs-lookup"><span data-stu-id="2f072-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="2f072-113">不過，長時間執行的進程（例如服務或甚至是 Explorer 外掛程式）可能會大幅影響系統的可靠性，並且可能會強制使用者重新開機 Windows，以便讓系統再次可供使用。</span><span class="sxs-lookup"><span data-stu-id="2f072-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="2f072-114">應用程式可以使用多個方法來代表其配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="2f072-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="2f072-115">如果未在使用後釋出，每種配置類型可能會導致流失。</span><span class="sxs-lookup"><span data-stu-id="2f072-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="2f072-116">以下是一些常見配置模式的範例：</span><span class="sxs-lookup"><span data-stu-id="2f072-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="2f072-117">透過 [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc)函式或其 C/c + + 執行時間對等專案 **malloc** 或 **new** 的堆積記憶體</span><span class="sxs-lookup"><span data-stu-id="2f072-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="2f072-118">經由 [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) 函式從作業系統直接配置。</span><span class="sxs-lookup"><span data-stu-id="2f072-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="2f072-119">透過 Kernel32.dll Api （例如 [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea)、 [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)或 [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)）建立的核心控制碼，代表應用程式保留核心記憶體</span><span class="sxs-lookup"><span data-stu-id="2f072-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="2f072-120">根據預設，透過 User32 和 Gdi32 Api 建立的 GDI 和使用者控制碼 (，每個進程都有10000控制碼的配額) </span><span class="sxs-lookup"><span data-stu-id="2f072-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="2f072-121">最佳做法</span><span class="sxs-lookup"><span data-stu-id="2f072-121">Best Practices</span></span>

<span data-ttu-id="2f072-122">監視應用程式在一段時間內的資源耗用量，是偵測及診斷記憶體流失的第一步。</span><span class="sxs-lookup"><span data-stu-id="2f072-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="2f072-123">使用 Windows 工作管理員並新增下列資料行：「認可大小」、「處理」、「使用者物件」和「GDI 物件」。</span><span class="sxs-lookup"><span data-stu-id="2f072-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="2f072-124">這可讓您建立應用程式的基準，並監視一段時間的資源使用量。</span><span class="sxs-lookup"><span data-stu-id="2f072-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![顯示 Windows 工作管理員中 [進程] 頁面的螢幕擷取畫面。](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="2f072-126">下列 Microsoft 工具提供更詳細的資訊，可協助偵測及診斷應用程式中各種配置類型的流失：</span><span class="sxs-lookup"><span data-stu-id="2f072-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="2f072-127">效能監視器和資源監視器是 Windows 7 的一部分，而且可以監視和繪製一段時間的資源使用方式</span><span class="sxs-lookup"><span data-stu-id="2f072-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="2f072-128">最新版本的應用程式驗證器可以在 Windows 7 上診斷堆積流失</span><span class="sxs-lookup"><span data-stu-id="2f072-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="2f072-129">UMDH 是適用于 Windows 的偵錯工具的一部分，會分析指定進程的堆積記憶體配置，並有助於找出遺漏和其他不尋常的使用模式</span><span class="sxs-lookup"><span data-stu-id="2f072-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="2f072-130">Xperf 是精密的效能分析工具，可支援堆積配置追蹤</span><span class="sxs-lookup"><span data-stu-id="2f072-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="2f072-131">CRT Debug 堆積會追蹤堆積配置，並可協助建立您自己的堆積偵錯工具功能</span><span class="sxs-lookup"><span data-stu-id="2f072-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="2f072-132">某些編碼和設計實務可能會限制程式碼中的流失數目。</span><span class="sxs-lookup"><span data-stu-id="2f072-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="2f072-133">在 c + + 程式碼中，同時針對堆積配置以及 Win32 資源（例如核心 **控制碼** s）使用智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="2f072-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="2f072-134">C + + 標準程式庫提供堆積配置的 **自動 \_ ptr** 類別。</span><span class="sxs-lookup"><span data-stu-id="2f072-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="2f072-135">針對其他配置類型，您將需要撰寫自己的類別。</span><span class="sxs-lookup"><span data-stu-id="2f072-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="2f072-136">ATL 程式庫提供一組豐富的類別來自動管理堆積物件和核心控制碼的資源</span><span class="sxs-lookup"><span data-stu-id="2f072-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="2f072-137">使用編譯器內建功能（例如 **\_ com \_ ptr \_ t** ）將您的 com 介面指標封裝到「智慧型指標」中，並協助參考計數。</span><span class="sxs-lookup"><span data-stu-id="2f072-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="2f072-138">其他 COM 資料類型有類似的類別： **\_ bstr \_ t** 和 **\_ variant \_ t**</span><span class="sxs-lookup"><span data-stu-id="2f072-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="2f072-139">監視您的 .NET 程式碼不尋常的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="2f072-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="2f072-140">Managed 程式碼不會受到記憶體流失的漏洞。</span><span class="sxs-lookup"><span data-stu-id="2f072-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="2f072-141">請參閱如何尋找 GC 流失的「 [追蹤受控記憶體](/archive/blogs/ricom/) 流失」</span><span class="sxs-lookup"><span data-stu-id="2f072-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="2f072-142">請留意 web 用戶端程式代碼中的遺漏模式。</span><span class="sxs-lookup"><span data-stu-id="2f072-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="2f072-143">COM 物件和 JScript 之類的腳本引擎之間的迴圈參考，可能會造成 web 應用程式的大量洩漏。</span><span class="sxs-lookup"><span data-stu-id="2f072-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="2f072-144">「[瞭解和解決 Internet Explorer 流失模式](/previous-versions/ms976398(v=msdn.10))」有關于這類流失的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="2f072-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="2f072-145">您可以使用 JavaScript 記憶體流失偵測器來偵測程式碼中的記憶體流失。</span><span class="sxs-lookup"><span data-stu-id="2f072-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="2f072-146">雖然 Windows Internet Explorer 8 （隨附于 Windows 7 的 Windows 7）可減少這些問題，但較舊的瀏覽器仍會受到這些錯誤的影響。</span><span class="sxs-lookup"><span data-stu-id="2f072-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="2f072-147">避免使用來自函式的多個結束路徑。</span><span class="sxs-lookup"><span data-stu-id="2f072-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="2f072-148">在函式範圍中指派給變數的配置應該在函式結尾的一個特定區塊中釋放</span><span class="sxs-lookup"><span data-stu-id="2f072-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="2f072-149">請勿在您的程式碼中使用例外狀況，而不需要釋放函式中的所有區域變數。</span><span class="sxs-lookup"><span data-stu-id="2f072-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="2f072-150">如果您使用原生例外狀況，請釋放 finally 區塊內的所有配置 \_ \_ 。</span><span class="sxs-lookup"><span data-stu-id="2f072-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="2f072-151">如果您使用 c + + 例外狀況，則所有堆積和處理配置都必須包裝在智慧型指標中</span><span class="sxs-lookup"><span data-stu-id="2f072-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="2f072-152">請勿捨棄或重新初始化 [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) 物件，而不呼叫 [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) 函數</span><span class="sxs-lookup"><span data-stu-id="2f072-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="2f072-153">資源的連結</span><span class="sxs-lookup"><span data-stu-id="2f072-153">Links to Resources</span></span>

<span data-ttu-id="2f072-154">*常見配置模式：*</span><span class="sxs-lookup"><span data-stu-id="2f072-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="2f072-155">**堆積配置函數**</span><span class="sxs-lookup"><span data-stu-id="2f072-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="2f072-156">[**記憶體配置函數**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="2f072-157">[**New 運算子 (c + +)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="2f072-158">**虛擬配置函數**</span><span class="sxs-lookup"><span data-stu-id="2f072-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="2f072-159">核心物件</span><span class="sxs-lookup"><span data-stu-id="2f072-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="2f072-160">GDI 物件控制碼</span><span class="sxs-lookup"><span data-stu-id="2f072-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="2f072-161">消費者介面的物件控制碼</span><span class="sxs-lookup"><span data-stu-id="2f072-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="2f072-162">*Microsoft 工具：*</span><span class="sxs-lookup"><span data-stu-id="2f072-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="2f072-163">應用程式驗證器</span><span class="sxs-lookup"><span data-stu-id="2f072-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="2f072-164">Windows 的偵錯工具</span><span class="sxs-lookup"><span data-stu-id="2f072-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="2f072-165">使用者模式傾印堆積</span><span class="sxs-lookup"><span data-stu-id="2f072-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="2f072-166">追蹤捕捉、處理和分析工具</span><span class="sxs-lookup"><span data-stu-id="2f072-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="2f072-167">CRT Debug 堆積</span><span class="sxs-lookup"><span data-stu-id="2f072-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="2f072-168">*其他連結：*</span><span class="sxs-lookup"><span data-stu-id="2f072-168">*Additional Links:*</span></span>

-   <span data-ttu-id="2f072-169">[**自動 \_ Ptr 類別**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="2f072-170">[Active Template Library (ATL) 記憶體類別](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="2f072-171">[**\_com \_ ptr \_ t 物件**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="2f072-172">[**\_bstr \_ t 類別**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="2f072-173">[**\_variant \_ Yt 類別**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="2f072-174">「追蹤受控記憶體流失」</span><span class="sxs-lookup"><span data-stu-id="2f072-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="2f072-175">[「瞭解和解決 Internet Explorer 流失模式」](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="2f072-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="2f072-176">「JavaScript 記憶體洩漏偵測器」</span><span class="sxs-lookup"><span data-stu-id="2f072-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="2f072-177">[瀏覽器中的迴圈記憶體流失緩和 () ：](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="2f072-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="2f072-178">[**try-finally 陳述式**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="2f072-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="2f072-179">**PROPVARIANT 結構**</span><span class="sxs-lookup"><span data-stu-id="2f072-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="2f072-180">**PropVariantClear 函式**</span><span class="sxs-lookup"><span data-stu-id="2f072-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
