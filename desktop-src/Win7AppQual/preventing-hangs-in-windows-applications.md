---
description: 瞭解如何防止 windows 7 和 Windows Server 2008 R2 平臺的 Windows 應用程式停止回應。
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: 防止 Windows 應用程式停止回應
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35a2d8fac95039f20c8c684c50138933c54750c3
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/06/2021
ms.locfileid: "104027624"
---
# <a name="preventing-hangs-in-windows-applications"></a><span data-ttu-id="ce8bb-103">防止 Windows 應用程式停止回應</span><span class="sxs-lookup"><span data-stu-id="ce8bb-103">Preventing Hangs in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="ce8bb-104">受影響的平臺</span><span class="sxs-lookup"><span data-stu-id="ce8bb-104">Affected Platforms</span></span>

<span data-ttu-id="ce8bb-105">**客戶** 端-Windows 7</span><span class="sxs-lookup"><span data-stu-id="ce8bb-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="ce8bb-106">**伺服器** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="ce8bb-106">**Servers** - Windows Server 2008 R2</span></span>  









## <a name="description"></a><span data-ttu-id="ce8bb-107">Description</span><span class="sxs-lookup"><span data-stu-id="ce8bb-107">Description</span></span>

<span data-ttu-id="ce8bb-108">**停止回應-使用者的觀點**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-108">**Hangs - User Perspective**</span></span>

<span data-ttu-id="ce8bb-109">像是回應式應用程式的使用者。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-109">Users like responsive applications.</span></span> <span data-ttu-id="ce8bb-110">當他們按下功能表時，他們想要讓應用程式立即回應，即使它目前正在列印工作也一樣。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-110">When they click a menu, they want the application to react instantly, even if it is currently printing their work.</span></span> <span data-ttu-id="ce8bb-111">當他們將冗長的檔儲存在最愛的字處理器時，他們想要在磁片仍在旋轉時繼續輸入。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-111">When they save a lengthy document in their favorite word processor, they want to continue typing while the disk is still spinning.</span></span> <span data-ttu-id="ce8bb-112">當應用程式不會及時回應其輸入時，使用者會取得不耐，而不是快速回應。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-112">Users get impatient rather quickly when the application does not react in a timely fashion to their input.</span></span>

<span data-ttu-id="ce8bb-113">程式設計師可能會辨識出應用程式不會立即回應使用者輸入的許多合法原因。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-113">A programmer might recognize many legitimate reasons for an application not to instantly respond to user input.</span></span> <span data-ttu-id="ce8bb-114">應用程式可能忙於重新計算一些資料，或只是等候其磁片 i/o 完成。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-114">The application might be busy recalculating some data, or simply waiting for its disk I/O to complete.</span></span> <span data-ttu-id="ce8bb-115">不過，從使用者研究中，我們知道使用者只需要幾秒鐘的時間無回應，就能感到苦惱並感到挫折。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-115">However, from user research, we know that users get annoyed and frustrated after just a couple of seconds of unresponsiveness.</span></span> <span data-ttu-id="ce8bb-116">在5秒後，他們會嘗試終止無回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-116">After 5 seconds, they will try to terminate a hung application.</span></span> <span data-ttu-id="ce8bb-117">在損毀的情況下，應用程式停止回應是使用 Win32 應用程式時最常見的使用者中斷來源。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-117">Next to crashes, application hangs are the most common source of user disruption when working with Win32 applications.</span></span>

<span data-ttu-id="ce8bb-118">應用程式停止回應有許多不同的根本原因，而且並非所有的根本原因都在沒有回應的 UI 中。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-118">There are many different root causes for application hangs, and not all of them manifest themselves in an unresponsive UI.</span></span> <span data-ttu-id="ce8bb-119">不過，沒有回應的 UI 是最常見的停止回應體驗之一，而此案例目前會獲得偵測和復原的大部分作業系統支援。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-119">However, an unresponsive UI is one of the most common hang experiences, and this scenario currently receives the most operating system support for both detection as well as recovery.</span></span> <span data-ttu-id="ce8bb-120">Windows 會自動偵測、收集偵錯工具資訊，並選擇性地終止或重新開機無回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-120">Windows automatically detects, collects debug information, and optionally terminates or restarts hung applications.</span></span> <span data-ttu-id="ce8bb-121">否則，使用者可能必須重新開機電腦，才能復原無回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-121">Otherwise, the user might have to restart the machine in order to recover a hung application.</span></span>

<span data-ttu-id="ce8bb-122">**停止回應-作業系統透視圖**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-122">**Hangs - Operating System Perspective**</span></span>

<span data-ttu-id="ce8bb-123">當應用程式 (或更精確時，執行緒) 會在桌面上建立視窗，並使用桌面視窗管理員 (DWM) 進入隱含合約，以及時處理視窗訊息。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-123">When an application (or more accurately, a thread) creates a window on the desktop, it enters into an implicit contract with the Desktop Window Manager (DWM) to process window messages in a timely fashion.</span></span> <span data-ttu-id="ce8bb-124">DWM 會將訊息張貼 (鍵盤/滑鼠輸入和其他視窗中的訊息，也) 到執行緒特定的訊息佇列中。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-124">The DWM posts messages (keyboard/mouse input and messages from other windows, as well as itself) into the thread-specific message queue.</span></span> <span data-ttu-id="ce8bb-125">執行緒會透過它的訊息佇列來抓取和分派這些訊息。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-125">The thread retrieves and dispatches those messages via its message queue.</span></span> <span data-ttu-id="ce8bb-126">如果執行緒未藉由呼叫 GetMessage () 來服務佇列，則不會處理訊息，而且視窗會停止回應：它無法重繪，也無法接受使用者的輸入。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-126">If the thread does not service the queue by calling GetMessage(), messages are not processed, and the window hangs: it can neither redraw nor can it accept input from the user.</span></span> <span data-ttu-id="ce8bb-127">作業系統會藉由將計時器附加到訊息佇列中的擱置中訊息來偵測此狀態。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-127">The operating system detects this state by attaching a timer to pending messages in the message queue.</span></span> <span data-ttu-id="ce8bb-128">如果訊息未在5秒內被抓取，DWM 會將視窗宣告為無反應。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-128">If a message has not been retrieved within 5 seconds, the DWM declares the window to be hung.</span></span> <span data-ttu-id="ce8bb-129">您可以透過 IsHungAppWindow () API 查詢這個特定的視窗狀態。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-129">You can query this particular window state via the IsHungAppWindow() API.</span></span>

<span data-ttu-id="ce8bb-130">偵測只是第一個步驟。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-130">Detection is only the first step.</span></span> <span data-ttu-id="ce8bb-131">此時，使用者仍然無法終止應用程式-按一下 [X (關閉]) 按鈕會導致 WM \_ 關閉訊息，而這會在訊息佇列中停滯，就像任何其他訊息一樣。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-131">At this point, the user still cannot even terminate the application - clicking the X (Close) button would result in a WM\_CLOSE message, which would be stuck in the message queue just like any other message.</span></span> <span data-ttu-id="ce8bb-132">桌面視窗管理員可透過以「准刪除」複本來顯示原始視窗先前工作 (區的點陣圖，並將「沒有回應」新增至標題列) ，以協助您順利隱藏和取代無反應視窗。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-132">The Desktop Window Manager assists by seamlessly hiding and then replacing the hung window with a 'ghost' copy displaying a bitmap of the original window's previous client area (and adding "Not Responding" to the title bar).</span></span> <span data-ttu-id="ce8bb-133">只要原始視窗的執行緒不會取得訊息，DWM 就會同時管理這兩個視窗，但只允許使用者與准刪除複製進行互動。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-133">As long as the original window's thread does not retrieve messages, the DWM manages both windows simultaneously, but allows the user to interact only with the ghost copy.</span></span> <span data-ttu-id="ce8bb-134">使用此准刪除視窗，使用者只能移動、最小化和-最重要的是關閉沒有回應的應用程式，但不會變更其內部狀態。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-134">Using this ghost window, the user can only move, minimize, and - most importantly - close the unresponsive application, but not change its internal state.</span></span>

<span data-ttu-id="ce8bb-135">整個 ghost 體驗看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="ce8bb-135">The whole ghost experience looks like this:</span></span>

![顯示 [記事本未回應] 對話方塊的螢幕擷取畫面。](images/preventinghangs-ghostwindow.gif)

<span data-ttu-id="ce8bb-137">桌面視窗管理員會進行最後一件事;它會與 Windows 錯誤報告整合，讓使用者不僅能關閉並選擇性地重新開機應用程式，還可以將寶貴的調試資料傳送回 Microsoft。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-137">The Desktop Window Manager does one last thing; it integrates with Windows Error Reporting, allowing the user to not only close and optionally restart the application, but also send valuable debugging data back to Microsoft.</span></span> <span data-ttu-id="ce8bb-138">您可以在 Winqual 網站上註冊，為自己的應用程式取得這項停止回應資料。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-138">You can get this hang data for your own applications by signing up at the Winqual website.</span></span>

<span data-ttu-id="ce8bb-139">Windows 7 在此體驗中新增了一項新功能。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-139">Windows 7 added one new feature to this experience.</span></span> <span data-ttu-id="ce8bb-140">作業系統會分析無回應的應用程式，而且在某些情況下，會提供使用者取消封鎖作業的選項，並讓應用程式再次回應。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-140">The operating system analyzes the hung application and, under certain circumstances, gives the user the option to cancel a blocking operation and make the application responsive again.</span></span> <span data-ttu-id="ce8bb-141">目前的實值支援取消封鎖通訊端呼叫;未來的版本將會有更多的作業可供使用者取消。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-141">The current implementation supports cancellation of blocking Socket calls; more operations will be user-cancelable in future releases.</span></span>

<span data-ttu-id="ce8bb-142">若要整合您的應用程式與無回應復原體驗，並充分利用可用的資料，請遵循下列步驟：</span><span class="sxs-lookup"><span data-stu-id="ce8bb-142">To integrate your application with the hang recovery experience and to make the most out of the available data, follow these steps:</span></span>

-   <span data-ttu-id="ce8bb-143">確定您的應用程式已註冊重新開機和復原，讓您可以放心地將其停止回應給使用者。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-143">Ensure that your application registers for restart and recovery, making a hang as pain-free as possible to the user.</span></span> <span data-ttu-id="ce8bb-144">已正確註冊的應用程式可能會自動重新開機，而不會有大部分未儲存的資料。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-144">A properly registered application can automatically restart with most of its unsaved data intact.</span></span> <span data-ttu-id="ce8bb-145">這適用于應用程式停止回應和當機。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-145">This works for both application hangs and crashes.</span></span>
-   <span data-ttu-id="ce8bb-146">取得頻率資訊，以及針對您的無回應和當機的應用程式，從 Winqual 網站進行資料的偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-146">Get frequency information as well as debugging data for your hung and crashed applications from the Winqual website.</span></span> <span data-ttu-id="ce8bb-147">即使在測試期間也可以使用此資訊來改善您的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-147">You can use this information even during your Beta to improve your code.</span></span> <span data-ttu-id="ce8bb-148">如需簡短的總覽，請參閱「簡介 Windows 錯誤報告」。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-148">See "Introducing Windows Error Reporting" for a brief overview.</span></span>
-   <span data-ttu-id="ce8bb-149">您可以透過呼叫 DisableProcessWindowsGhosting () ，在您的應用程式中停用重設功能。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-149">You can disable the ghosting feature in your application via a call to DisableProcessWindowsGhosting ().</span></span> <span data-ttu-id="ce8bb-150">不過，這可防止一般使用者關閉和重新開機無回應的應用程式，而且通常會在重新開機時結束。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-150">However, this prevents the average user from closing and restarting a hung application and often ends in a reboot.</span></span>

<span data-ttu-id="ce8bb-151">**停止回應-開發人員觀點**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-151">**Hangs - Developer Perspective**</span></span>

<span data-ttu-id="ce8bb-152">作業系統會將應用程式停止回應為至少有5秒未處理訊息的 UI 執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-152">The operating system defines an application hang as a UI thread that has not processed messages for at least 5 seconds.</span></span> <span data-ttu-id="ce8bb-153">明顯的錯誤會導致一些停止回應，例如，等候從未收到信號的事件的執行緒，以及兩個執行緒，每個執行緒都持有鎖定並嘗試取得其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-153">Obvious bugs cause some hangs, for example, a thread waiting for an event that is never signaled, and two threads each holding a lock and trying to acquire the others.</span></span> <span data-ttu-id="ce8bb-154">您可以修正這些 bug，而不需要太多精力。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-154">You can fix those bugs without too much effort.</span></span> <span data-ttu-id="ce8bb-155">但是，許多停止回應並不是那麼明顯。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-155">However, many hangs are not so clear.</span></span> <span data-ttu-id="ce8bb-156">是，UI 執行緒不會抓取訊息，但它同樣忙於執行其他「重要」工作，且最終會回到處理訊息。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-156">Yes, the UI thread is not retrieving messages - but it is equally busy doing other 'important' work and will eventually come back to processing messages.</span></span>

<span data-ttu-id="ce8bb-157">但是，使用者會將此視為錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-157">However, the user perceives this as a bug.</span></span> <span data-ttu-id="ce8bb-158">設計應該符合使用者的期望。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-158">The design should match the user's expectations.</span></span> <span data-ttu-id="ce8bb-159">如果應用程式的設計會導致沒有回應的應用程式，則設計將必須變更。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-159">If the application's design leads to an unresponsive application, the design will have to change.</span></span> <span data-ttu-id="ce8bb-160">最後，這是很重要的，無回應不能像程式碼錯誤一樣修正;它需要在設計階段進行提前工作。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-160">Finally, and this is important, unresponsiveness cannot be fixed like a code bug; it requires upfront work during the design phase.</span></span> <span data-ttu-id="ce8bb-161">嘗試改建應用程式的現有程式碼基底，讓 UI 更具回應性，通常太昂貴。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-161">Trying to retrofit an application's existing code base to make the UI more responsive is often too expensive.</span></span> <span data-ttu-id="ce8bb-162">下列設計指導方針可能有所説明。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-162">The following design guidelines might help.</span></span>

-   <span data-ttu-id="ce8bb-163">讓 UI 回應性成為最上層需求;使用者應隨時掌控您的應用程式</span><span class="sxs-lookup"><span data-stu-id="ce8bb-163">Make UI responsiveness a top-level requirement; the user should always feel in control of your application</span></span>
-   <span data-ttu-id="ce8bb-164">確定使用者可以取消花費超過一秒的作業完成，並（或）該作業可以在背景中完成;視需要提供適當的進度 UI</span><span class="sxs-lookup"><span data-stu-id="ce8bb-164">Ensure that users can cancel operations that take longer than one second to complete and/or that operations can complete in the background; provide appropriate progress UI if necessary</span></span>

![顯示 [正在複製專案] 對話方塊的螢幕擷取畫面。](images/preventinghangs-progressbar.gif)

-   <span data-ttu-id="ce8bb-166">將長時間執行或封鎖作業排入佇列，以做為背景工作 (這需要經過妥善考慮的訊息機制，在工作完成時通知 UI 執行緒) </span><span class="sxs-lookup"><span data-stu-id="ce8bb-166">Queue long-running or blocking operations as background tasks (this requires a well-thought out messaging mechanism to inform the UI thread when work has been completed)</span></span>
-   <span data-ttu-id="ce8bb-167">讓 UI 執行緒的程式碼保持簡單;盡可能移除最多封鎖的 API 呼叫</span><span class="sxs-lookup"><span data-stu-id="ce8bb-167">Keep the code for UI threads simple; remove as many blocking API calls as possible</span></span>
-   <span data-ttu-id="ce8bb-168">只有在已就緒且可完全運作時，才會顯示視窗和對話方塊。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-168">Show windows and dialogs only when they are ready and fully operational.</span></span> <span data-ttu-id="ce8bb-169">如果對話方塊需要顯示太過資源而無法計算的資訊，請先顯示一些一般資訊，並且在有更多資料可供使用時，即時更新它。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-169">If the dialog needs to display information that is too resource-intensive to calculate, show some generic information first and update it on the fly when more data becomes available.</span></span> <span data-ttu-id="ce8bb-170">Windows 檔案總管的 [資料夾屬性] 對話方塊就是一個很好的例子。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-170">A good example is the folder properties dialog from Windows Explorer.</span></span> <span data-ttu-id="ce8bb-171">它必須顯示資料夾的總大小，也就是檔案系統中未提供的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-171">It needs to display the folder's total size, information that is not readily available from the file system.</span></span> <span data-ttu-id="ce8bb-172">對話方塊會立即顯示，而 [大小] 欄位則會從背景工作執行緒更新：</span><span class="sxs-lookup"><span data-stu-id="ce8bb-172">The dialog shows up right away and the "size" field is updated from a worker thread:</span></span>

![螢幕擷取畫面，顯示 [大小]、[磁片大小] 和 [包含] 文字的 Windows 屬性 [一般] 頁面。](images/preventinghangs-updatingdialog.gif)

<span data-ttu-id="ce8bb-174">可惜的是，沒有簡單的方法可以設計及撰寫回應式應用程式。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-174">Unfortunately, there is no simple way to design and write a responsive application.</span></span> <span data-ttu-id="ce8bb-175">Windows 未提供簡單的非同步架構，可讓您輕鬆地排程封鎖或長時間執行的作業。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-175">Windows does not provide a simple asynchronous framework that would allow for easy scheduling of blocking or long-running operations.</span></span> <span data-ttu-id="ce8bb-176">下列各節介紹一些預防停止回應的最佳作法，並強調一些常見的陷阱。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-176">The following sections introduce some of the best practices in preventing hangs and highlight some of the common pitfalls.</span></span>

## <a name="best-practices"></a><span data-ttu-id="ce8bb-177">最佳做法</span><span class="sxs-lookup"><span data-stu-id="ce8bb-177">Best Practices</span></span>

<span data-ttu-id="ce8bb-178">**讓 UI 執行緒保持簡單**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-178">**Keep the UI Thread Simple**</span></span>

<span data-ttu-id="ce8bb-179">UI 執行緒的主要責任是取得和分派訊息。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-179">The UI thread's primary responsibility is to retrieve and dispatch messages.</span></span> <span data-ttu-id="ce8bb-180">任何其他類型的工作都有可能會造成這個執行緒所擁有的 windows 中止。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-180">Any other kind of work introduces the risk of hanging the windows owned by this thread.</span></span>

<span data-ttu-id="ce8bb-181">**任務**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-181">**Do:**</span></span>

-   <span data-ttu-id="ce8bb-182">移動耗用大量資源或未系結的演算法，以產生長時間執行的背景工作執行緒作業</span><span class="sxs-lookup"><span data-stu-id="ce8bb-182">Move resource-intensive or unbounded algorithms that result in long-running operations to worker threads</span></span>
-   <span data-ttu-id="ce8bb-183">盡可能找出多個封鎖函式呼叫，並嘗試將它們移至背景工作執行緒;任何呼叫另一個 DLL 的函式都應該是可疑的</span><span class="sxs-lookup"><span data-stu-id="ce8bb-183">Identify as many blocking function calls as possible and try to move them to worker threads; any function calling into another DLL should be suspicious</span></span>
-   <span data-ttu-id="ce8bb-184">進行額外的工作，以從您的背景工作執行緒移除所有檔案 i/o 和網路 API 呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-184">Make an extra effort to remove all file I/O and networking API calls from your worker thread.</span></span> <span data-ttu-id="ce8bb-185">如果不是幾分鐘的時間，這些函式可能會封鎖數秒鐘。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-185">These functions can block for many seconds if not minutes.</span></span> <span data-ttu-id="ce8bb-186">如果您需要在 UI 執行緒中進行任何類型的 i/o，請考慮使用非同步 i/o</span><span class="sxs-lookup"><span data-stu-id="ce8bb-186">If you need to do any kind of I/O in the UI thread, consider using asynchronous I/O</span></span>
-   <span data-ttu-id="ce8bb-187">請注意，您的 UI 執行緒也會提供處理常式所裝載之所有單一執行緒的單元 (STA) COM 伺服器;如果您進行封鎖通話，則在您再次服務訊息佇列之前，這些 COM 伺服器將會沒有回應</span><span class="sxs-lookup"><span data-stu-id="ce8bb-187">Be aware that your UI thread is also servicing all single-threaded apartment (STA) COM servers hosted by your process; if you make a blocking call, these COM servers will be unresponsive until you service the message queue again</span></span>

<span data-ttu-id="ce8bb-188">**請勿：**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-188">**Do not:**</span></span>

-   <span data-ttu-id="ce8bb-189">等候任何核心物件 (例如事件或 Mutex) 超過一段非常短的時間;如果您必須等待，請考慮使用 MsgWaitForMultipleObjects () ，這會在新訊息抵達時解除封鎖</span><span class="sxs-lookup"><span data-stu-id="ce8bb-189">Wait on any kernel object (like Event or Mutex) for more than a very short amount of time; if you have to wait at all, consider using MsgWaitForMultipleObjects(), which will unblock when a new message arrives</span></span>
-   <span data-ttu-id="ce8bb-190">使用 AttachThreadInput () 函式，與另一個執行緒共用執行緒的視窗訊息佇列。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-190">Share a thread's window message queue with another thread by using the AttachThreadInput() function.</span></span> <span data-ttu-id="ce8bb-191">若要正確地同步處理佇列的存取權並不容易，也可以防止 Windows 作業系統正確地偵測到無回應視窗</span><span class="sxs-lookup"><span data-stu-id="ce8bb-191">It is not only extremely difficult to properly synchronize access to the queue, it also can prevent the Windows operating system from properly detecting a hung window</span></span>
-   <span data-ttu-id="ce8bb-192">在任何背景工作執行緒上使用 TerminateThread () 。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-192">Use TerminateThread() on any of your worker threads.</span></span> <span data-ttu-id="ce8bb-193">以這種方式終止執行緒將不會允許它釋放鎖定或發出訊號事件，並可輕鬆地產生孤立的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-193">Terminating a thread in this way will not allow it to release locks or signal events and can easily result in orphaned synchronization objects</span></span>
-   <span data-ttu-id="ce8bb-194">從 UI 執行緒呼叫任何「未知的」程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-194">Call into any 'unknown' code from your UI thread.</span></span> <span data-ttu-id="ce8bb-195">如果您的應用程式具有擴充性模型，則更是如此。不保證協力廠商程式碼遵循您的回應性指導方針</span><span class="sxs-lookup"><span data-stu-id="ce8bb-195">This is especially true if your application has an extensibility model; there is no guarantee that 3rd-party code follows your responsiveness guidelines</span></span>
-   <span data-ttu-id="ce8bb-196">進行任何種類的封鎖廣播通話;SendMessage (HWND \_ 廣播) 可讓您 mercy 目前執行的每個未撰寫錯誤的應用程式</span><span class="sxs-lookup"><span data-stu-id="ce8bb-196">Make any kind of blocking broadcast call; SendMessage(HWND\_BROADCAST) puts you at the mercy of every ill-written application currently running</span></span>

<span data-ttu-id="ce8bb-197">**執行非同步模式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-197">**Implement Asynchronous Patterns**</span></span>

<span data-ttu-id="ce8bb-198">從 UI 執行緒中移除長時間執行或封鎖的作業需要執行可將這些作業卸載至背景工作執行緒的非同步架構。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-198">Removing long-running or blocking operations from the UI thread requires implementing an asynchronous framework that allows offloading those operations to worker threads.</span></span>

<span data-ttu-id="ce8bb-199">**任務**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-199">**Do:**</span></span>

-   <span data-ttu-id="ce8bb-200">在 UI 執行緒中使用非同步視窗訊息 Api，特別是將 SendMessage 取代為其中一個非封鎖對等： PostMessage、SendNotifyMessage 或 SendMessageCallback</span><span class="sxs-lookup"><span data-stu-id="ce8bb-200">Use asynchronous window message APIs in your UI thread, especially by replacing SendMessage with one of its non-blocking peers: PostMessage, SendNotifyMessage, or SendMessageCallback</span></span>
-   <span data-ttu-id="ce8bb-201">使用背景執行緒來執行長時間執行或封鎖的工作。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-201">Use background threads to execute long-running or blocking tasks.</span></span> <span data-ttu-id="ce8bb-202">使用新的執行緒集區 API 來執行您的背景工作執行緒</span><span class="sxs-lookup"><span data-stu-id="ce8bb-202">Use the new thread pool API to implement your worker threads</span></span>
-   <span data-ttu-id="ce8bb-203">針對長時間執行的背景工作提供取消支援。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-203">Provide cancellation support for long-running background tasks.</span></span> <span data-ttu-id="ce8bb-204">若為封鎖 i/o 作業，請使用 i/o 取消，但僅做為最後的手段;取消 ' right ' 作業並不容易</span><span class="sxs-lookup"><span data-stu-id="ce8bb-204">For blocking I/O operations, use I/O cancellation, but only as a last resort; it's not easy to cancel the 'right' operation</span></span>
-   <span data-ttu-id="ce8bb-205">使用 IAsyncResult 模式或使用事件來執行 managed 程式碼的非同步設計</span><span class="sxs-lookup"><span data-stu-id="ce8bb-205">Implement an asynchronous design for managed code by using the IAsyncResult pattern or by using Events</span></span>

<span data-ttu-id="ce8bb-206">**明智地使用鎖定**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-206">**Use Locks Wisely**</span></span>

<span data-ttu-id="ce8bb-207">您的應用程式或 DLL 需要鎖定，以同步處理其內部資料結構的存取。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-207">Your application or DLL needs locks to synchronize access to its internal data structures.</span></span> <span data-ttu-id="ce8bb-208">使用多個鎖定可增加平行處理，並讓您的應用程式更具回應性。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-208">Using multiple locks increases parallelism and makes your application more responsive.</span></span> <span data-ttu-id="ce8bb-209">不過，使用多個鎖定也會增加以不同順序取得這些鎖定，並導致您的執行緒鎖死的機會。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-209">However, using multiple locks also increases the chance of acquiring those locks in different orders and causing your threads to deadlock.</span></span> <span data-ttu-id="ce8bb-210">如果兩個執行緒各自持有鎖定，然後嘗試取得其他執行緒的鎖定，其作業會形成迴圈等候，以封鎖這些執行緒的任何轉寄進度。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-210">If two threads each hold a lock and then try to acquire the other thread's lock, their operations will form a circular wait that blocks any forward progress for these threads.</span></span> <span data-ttu-id="ce8bb-211">您只能藉由確保應用程式中的所有線程一律取得相同順序的所有鎖定，來避免此鎖死。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-211">You can avoid this deadlock only by ensuring that all threads in the application always acquire all locks in the same order.</span></span> <span data-ttu-id="ce8bb-212">不過，以「右方」順序取得鎖定並不容易。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-212">However, it isn't always easy to acquire locks in the 'right' order.</span></span> <span data-ttu-id="ce8bb-213">您可以撰寫軟體元件，但不能進行鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-213">Software components can be composed, but lock acquisitions cannot.</span></span> <span data-ttu-id="ce8bb-214">如果您的程式碼呼叫其他元件，則該元件的鎖定現在會變成隱含鎖定順序的一部分，即使您沒有這些鎖定的可見度。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-214">If your code calls some other component, that component's locks now become part of your implicit lock order - even if you have no visibility into those locks.</span></span>

<span data-ttu-id="ce8bb-215">因為鎖定作業所包含的功能遠超過重要區段、Mutex 和其他傳統鎖定的一般功能，所以會變得更困難。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-215">Things get even harder because locking operations include far more than the usual functions for Critical Sections, Mutexes, and other traditional locks.</span></span> <span data-ttu-id="ce8bb-216">跨越執行緒界限的任何封鎖呼叫都有可能導致鎖死的同步處理屬性。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-216">Any blocking call that crosses thread boundaries has synchronization properties that can result in a deadlock.</span></span> <span data-ttu-id="ce8bb-217">呼叫執行緒會執行具有「取得」語義的作業，而且無法解除封鎖，直到呼叫的目標執行緒「釋放」為止。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-217">The calling thread performs an operation with 'acquire' semantics and cannot unblock until the target thread 'releases' that call.</span></span> <span data-ttu-id="ce8bb-218">有很多的 User32 函式 (例如 SendMessage) ，而且許多封鎖的 COM 呼叫都屬於此類別。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-218">Quite a few User32 functions (for example SendMessage), as well as many blocking COM calls fall into this category.</span></span>

<span data-ttu-id="ce8bb-219">更糟的是，作業系統有自己的內部進程特定鎖定，有時在您的程式碼執行時仍會保留。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-219">Worse yet, the operating system has its own internal process-specific lock that sometimes is held while your code executes.</span></span> <span data-ttu-id="ce8bb-220">當 Dll 載入至進程時，就會取得此鎖定，因此稱為「載入器鎖定」。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-220">This lock is acquired when DLLs are loaded into the process, and is therefore called the 'loader lock.'</span></span> <span data-ttu-id="ce8bb-221">DllMain 函式一律會在載入器鎖定下執行;如果您在 DllMain (中取得任何鎖定，而且不應該) ，您必須讓載入器鎖定鎖定順序的一部分。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-221">The DllMain function always executes under the loader lock; if you acquire any locks in DllMain (and you should not), you need to make the loader lock part of your lock order.</span></span> <span data-ttu-id="ce8bb-222">呼叫特定的 Win32 Api 也可能會對您的函式（例如 LoadLibraryEx、GetModuleHandle，特別是 CoCreateInstance）取得載入器鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-222">Calling certain Win32 APIs might also acquire the loader lock on your behalf - functions like LoadLibraryEx, GetModuleHandle, and especially CoCreateInstance.</span></span>

<span data-ttu-id="ce8bb-223">若要結合上述所有程式碼，請參閱下列範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-223">To tie all of this together, look at the sample code below.</span></span> <span data-ttu-id="ce8bb-224">此函式會取得多個同步處理物件，並隱含地定義鎖定順序，在粗略檢查時不一定很明顯。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-224">This function acquires multiple synchronization objects and implicitly defines a lock order, something that is not necessarily obvious on cursory inspection.</span></span> <span data-ttu-id="ce8bb-225">在函式專案中，程式碼會取得重要區段，而不會在函式結束之前釋出它，藉此使其成為鎖定階層中的最上層節點。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-225">On function entry, the code acquires a Critical Section and does not release it until function exit, thereby making it the top node in our lock hierarchy.</span></span> <span data-ttu-id="ce8bb-226">然後，此程式碼會呼叫 Win32 函式 LoadIcon () ，其中的背後可能會呼叫作業系統載入器來載入此二進位檔。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-226">The code then calls the Win32 function LoadIcon(), which under the covers might call into the Operating System Loader to load this binary.</span></span> <span data-ttu-id="ce8bb-227">這項作業會取得載入器鎖定，現在也會成為這個鎖定階層的一部分 (請確定 DllMain 函式未取得 g \_ cs 鎖定) 。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-227">This operation would acquire the loader lock, which now also becomes part of this lock hierarchy (make sure the DllMain function does not acquire the g\_cs lock).</span></span> <span data-ttu-id="ce8bb-228">接下來，程式碼會呼叫 SendMessage () ，這是封鎖的跨執行緒操作，除非 UI 執行緒回應，否則不會傳回。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-228">Next the code calls SendMessage(), a blocking cross-thread operation, which will not return unless the UI thread responds.</span></span> <span data-ttu-id="ce8bb-229">同樣地，請確定 UI 執行緒永遠不會取得 g \_ cs。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-229">Again, make sure that the UI thread never acquires g\_cs.</span></span>

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

<span data-ttu-id="ce8bb-230">查看這段程式碼看起來似乎是因為我們 \_ 只想要同步存取類別成員變數，所以我們會在鎖定階層中隱含地將 g cs 設為最上層鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-230">Looking at this code it seems clear that we implicitly made g\_cs the top-level lock in our lock hierarchy, even if we only wanted to synchronize access to the class member variables.</span></span>

<span data-ttu-id="ce8bb-231">**任務**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-231">**Do:**</span></span>

-   <span data-ttu-id="ce8bb-232">設計鎖定階層，並遵循它。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-232">Design a lock hierarchy and obey it.</span></span> <span data-ttu-id="ce8bb-233">新增所有必要的鎖定。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-233">Add all the necessary locks.</span></span> <span data-ttu-id="ce8bb-234">比起 Mutex 和 CriticalSections，有更多的同步處理原始物件;這些都必須包含在內。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-234">There are many more synchronization primitives than just Mutex and CriticalSections; they all need to be included.</span></span> <span data-ttu-id="ce8bb-235">如果您在 DllMain 中採用任何鎖定，請在階層中包含載入器鎖定 () </span><span class="sxs-lookup"><span data-stu-id="ce8bb-235">Include the loader lock in your hierarchy if you take any locks in DllMain()</span></span>
-   <span data-ttu-id="ce8bb-236">同意您的相依性鎖定通訊協定。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-236">Agree on locking protocol with your dependencies.</span></span> <span data-ttu-id="ce8bb-237">您的應用程式所呼叫或可能呼叫應用程式的任何程式碼都必須共用相同的鎖定階層</span><span class="sxs-lookup"><span data-stu-id="ce8bb-237">Any code your application calls or that might call your application needs to share the same lock hierarchy</span></span>
-   <span data-ttu-id="ce8bb-238">鎖定資料結構不是函數。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-238">Lock data structures not functions.</span></span> <span data-ttu-id="ce8bb-239">從函式進入點移離鎖定，並只防護鎖定的資料存取。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-239">Move lock acquisitions away from function entry points and guard only data access with locks.</span></span> <span data-ttu-id="ce8bb-240">如果較少的程式碼在鎖定下運作，可能會有鎖死的機率</span><span class="sxs-lookup"><span data-stu-id="ce8bb-240">If less code operates under a lock, there is less of a chance for deadlocks</span></span>
-   <span data-ttu-id="ce8bb-241">分析您的錯誤處理常式代碼中的鎖定取得和釋放。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-241">Analyze lock acquisitions and releases in your error handling code.</span></span> <span data-ttu-id="ce8bb-242">如果嘗試從錯誤狀況中復原時，通常會忽略鎖定階層</span><span class="sxs-lookup"><span data-stu-id="ce8bb-242">Often the lock hierarchy if forgotten when trying to recover from an error condition</span></span>
-   <span data-ttu-id="ce8bb-243">將嵌套鎖定取代為參考計數器-它們不能鎖死。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-243">Replace nested locks with reference counters - they cannot deadlock.</span></span> <span data-ttu-id="ce8bb-244">清單和資料表中個別鎖定的元素是理想的候選項目</span><span class="sxs-lookup"><span data-stu-id="ce8bb-244">Individually locked elements in lists and tables are good candidates</span></span>
-   <span data-ttu-id="ce8bb-245">從 DLL 等候執行緒控制碼時，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-245">Be careful when waiting on a thread handle from a DLL.</span></span> <span data-ttu-id="ce8bb-246">一律假設您的程式碼可能會在載入器鎖定下呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-246">Always assume that your code could be called under the loader lock.</span></span> <span data-ttu-id="ce8bb-247">最好參考計數您的資源，讓背景工作執行緒自行進行清除 (然後使用 FreeLibraryAndExitThread 來完全終止) </span><span class="sxs-lookup"><span data-stu-id="ce8bb-247">It's better to reference-count your resources and let the worker thread do its own cleanup (and then use FreeLibraryAndExitThread to terminate cleanly)</span></span>
-   <span data-ttu-id="ce8bb-248">如果您想要診斷自己的鎖死，請使用 Wait Chain 遍歷 API</span><span class="sxs-lookup"><span data-stu-id="ce8bb-248">Use the Wait Chain Traversal API if you want to diagnose your own deadlocks</span></span>

<span data-ttu-id="ce8bb-249">**請勿：**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-249">**Do not:**</span></span>

-   <span data-ttu-id="ce8bb-250">在您的 DllMain () 函式中執行非常簡單的初始化工作。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-250">Do anything other than very simple initialization work in your DllMain() function.</span></span> <span data-ttu-id="ce8bb-251">如需詳細資訊，請參閱 DllMain 回呼函數。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-251">See DllMain Callback Function for more details.</span></span> <span data-ttu-id="ce8bb-252">尤其不要呼叫 LoadLibraryEx 或 CoCreateInstance</span><span class="sxs-lookup"><span data-stu-id="ce8bb-252">Especially do not call LoadLibraryEx or CoCreateInstance</span></span>
-   <span data-ttu-id="ce8bb-253">撰寫您自己的鎖定基本專案。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-253">Write your own locking primitives.</span></span> <span data-ttu-id="ce8bb-254">自訂同步處理常式代碼可以輕鬆地在程式碼基底中引進微妙的錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-254">Custom synchronization code can easily introduce subtle bugs into your code base.</span></span> <span data-ttu-id="ce8bb-255">改為使用豐富的作業系統同步處理物件選項</span><span class="sxs-lookup"><span data-stu-id="ce8bb-255">Use the rich selection of operating system synchronization objects instead</span></span>
-   <span data-ttu-id="ce8bb-256">針對全域變數在函式和析構函式中執行任何工作，這些都是在載入器鎖定下執行</span><span class="sxs-lookup"><span data-stu-id="ce8bb-256">Do any work in the constructors and destructors for global variables, they are executed under the loader lock</span></span>

<span data-ttu-id="ce8bb-257">**注意例外狀況**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-257">**Be Careful with Exceptions**</span></span>

<span data-ttu-id="ce8bb-258">例外狀況允許分隔一般程式流程和錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-258">Exceptions allow the separation of normal program flow and error handling.</span></span> <span data-ttu-id="ce8bb-259">由於這種分隔，在例外狀況發生之前，可能很難知道程式的精確狀態，而且例外狀況處理常式可能會錯過還原有效狀態的重要步驟。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-259">Because of this separation, it can be difficult to know the precise state of the program prior to the exception and the exception handler might miss crucial steps in restoring a valid state.</span></span> <span data-ttu-id="ce8bb-260">這特別適用于需要在處理常式中釋出的鎖定，以避免未來的鎖死。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-260">This is especially true for lock acquisitions that need to be released in the handler to prevent future deadlocks.</span></span>

<span data-ttu-id="ce8bb-261">下列範例程式碼說明此問題。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-261">The sample code below illustrates this issue.</span></span> <span data-ttu-id="ce8bb-262">「緩衝區」變數的無限制存取有時候會導致 (AV) 發生存取違規。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-262">The unbounded access to the "buffer" variable will occasionally result in an access violation (AV).</span></span> <span data-ttu-id="ce8bb-263">原生例外狀況處理常式會攔截此 AV，但它並沒有簡單的方法可以判斷是否已在例外狀況發生時取得重要區段， (AV 甚至可能在 EnterCriticalSection 程式碼) 的某處發生。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-263">This AV is caught by the native exception handler, but it has no easy way of determining if the critical section was already acquired at the time of the exception (the AV could even have taken place somewhere in the EnterCriticalSection code).</span></span>

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

<span data-ttu-id="ce8bb-264">**任務**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-264">**Do:**</span></span>

-   <span data-ttu-id="ce8bb-265">\_ \_ 請盡可能移除 try/ \_ \_ Except; 請勿使用 SetUnhandledExceptionFilter</span><span class="sxs-lookup"><span data-stu-id="ce8bb-265">Remove \_\_try/\_\_except whenever possible; do not use SetUnhandledExceptionFilter</span></span>
-   <span data-ttu-id="ce8bb-266">如果您使用 c + + 例外狀況，請將鎖定包裝在自訂的自動 \_ ptr 範本中。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-266">Wrap your locks in custom auto\_ptr-like templates if you use C++ exceptions.</span></span> <span data-ttu-id="ce8bb-267">鎖定應該在函式中釋放。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-267">The lock should be released in the destructor.</span></span> <span data-ttu-id="ce8bb-268">若為原生例外狀況，請釋放 \_ \_ finally 語句中的鎖定</span><span class="sxs-lookup"><span data-stu-id="ce8bb-268">For native exceptions release the locks in your \_\_finally statement</span></span>
-   <span data-ttu-id="ce8bb-269">請小心使用在原生例外狀況處理常式中執行的程式碼;例外狀況可能已洩漏許多鎖定，因此您的處理常式不應該取得任何</span><span class="sxs-lookup"><span data-stu-id="ce8bb-269">Be careful with the code executing in a native exception handler; the exception might have leaked many locks, so your handler should not acquire any</span></span>

<span data-ttu-id="ce8bb-270">**請勿：**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-270">**Do not:**</span></span>

-   <span data-ttu-id="ce8bb-271">如果 Win32 Api 不需要或不需要，請處理原生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-271">Handle native exceptions if not necessary or required by the Win32 APIs.</span></span> <span data-ttu-id="ce8bb-272">如果您在發生嚴重錯誤後，使用原生例外狀況處理常式進行報告或資料復原，請考慮改為使用預設的作業系統機制 Windows 錯誤報告</span><span class="sxs-lookup"><span data-stu-id="ce8bb-272">If you use native exception handlers for reporting or data recovery after catastrophic failures, consider using the default operating system mechanism of Windows Error Reporting instead</span></span>
-   <span data-ttu-id="ce8bb-273">使用 c + + 例外狀況搭配任何類型的 UI (user32) 程式碼;回呼中擲回的例外狀況將會流經作業系統所提供的 C 程式碼層。</span><span class="sxs-lookup"><span data-stu-id="ce8bb-273">Use C++ exceptions with any kind of UI (user32) code; an exception thrown in a callback will travel through layers of C code provided by the operating system.</span></span> <span data-ttu-id="ce8bb-274">該程式碼不知道 c + + 展開語義</span><span class="sxs-lookup"><span data-stu-id="ce8bb-274">That code does not know about C++ unroll semantics</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="ce8bb-275">資源的連結</span><span class="sxs-lookup"><span data-stu-id="ce8bb-275">Links to Resources</span></span>

-   [<span data-ttu-id="ce8bb-276">Windows 錯誤報告</span><span class="sxs-lookup"><span data-stu-id="ce8bb-276">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   <span data-ttu-id="ce8bb-277">[非同步設計](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="ce8bb-277">[Asynchronous Design](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="ce8bb-278">非同步 i/o</span><span class="sxs-lookup"><span data-stu-id="ce8bb-278">Asynchronous I/O</span></span>](../fileio/synchronous-and-asynchronous-i-o.md)
-   [<span data-ttu-id="ce8bb-279">**AttachThreadInput 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-279">**AttachThreadInput Function**</span></span>](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   <span data-ttu-id="ce8bb-280">[**自動 \_ Ptr 類別**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="ce8bb-280">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="ce8bb-281">**DisableProcessWindowsGhosting 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-281">**DisableProcessWindowsGhosting Function**</span></span>](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [<span data-ttu-id="ce8bb-282">**DllMain 回呼函數**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-282">**DllMain Callback Function**</span></span>](../dlls/dllmain.md)
-   <span data-ttu-id="ce8bb-283">[事件](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="ce8bb-283">[Events](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="ce8bb-284">**GetMessage 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-284">**GetMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [<span data-ttu-id="ce8bb-285">I/o 取消</span><span class="sxs-lookup"><span data-stu-id="ce8bb-285">I/O cancellation</span></span>](../fileio/canceling-pending-i-o-operations.md)
-   [<span data-ttu-id="ce8bb-286">**IsHungAppWindow 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-286">**IsHungAppWindow Function**</span></span>](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [<span data-ttu-id="ce8bb-287">訊息佇列</span><span class="sxs-lookup"><span data-stu-id="ce8bb-287">Message Queue</span></span>](../winmsg/using-messages-and-message-queues.md)
-   [<span data-ttu-id="ce8bb-288">**MsgWaitForMultipleObjects 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-288">**MsgWaitForMultipleObjects Function**</span></span>](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [<span data-ttu-id="ce8bb-289">新的執行緒集區 API</span><span class="sxs-lookup"><span data-stu-id="ce8bb-289">New Thread Pool API</span></span>](../procthread/thread-pool-api.md)
-   [<span data-ttu-id="ce8bb-290">**PostMessage 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-290">**PostMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [<span data-ttu-id="ce8bb-291">重新開機和復原</span><span class="sxs-lookup"><span data-stu-id="ce8bb-291">Restart and Recovery</span></span>](../recovery/registering-for-application-restart.md)
-   [<span data-ttu-id="ce8bb-292">**SendMessageCallback 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-292">**SendMessageCallback Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [<span data-ttu-id="ce8bb-293">**SendNotifyMessage 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-293">**SendNotifyMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [<span data-ttu-id="ce8bb-294">同步處理物件</span><span class="sxs-lookup"><span data-stu-id="ce8bb-294">Synchronization Objects</span></span>](../sync/about-synchronization.md)
-   [<span data-ttu-id="ce8bb-295">**TerminateThread 函式**</span><span class="sxs-lookup"><span data-stu-id="ce8bb-295">**TerminateThread Function**</span></span>](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [<span data-ttu-id="ce8bb-296">Windows 錯誤報告</span><span class="sxs-lookup"><span data-stu-id="ce8bb-296">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   [<span data-ttu-id="ce8bb-297">Winqual</span><span class="sxs-lookup"><span data-stu-id="ce8bb-297">Winqual</span></span>](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
