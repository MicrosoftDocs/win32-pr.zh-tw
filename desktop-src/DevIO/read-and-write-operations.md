---
description: Windows 支援對序列通訊資源上的同步和非同步 (重迭) 檔案 i/o 作業。
ms.assetid: cee44596-ad73-4afb-b86a-744b0b46d9d5
title: 讀取和寫入作業
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a26cc53dbe8c52286fe53c81202ab3828808b1aa
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104110592"
---
# <a name="read-and-write-operations"></a><span data-ttu-id="4e2ee-103">讀取和寫入作業</span><span class="sxs-lookup"><span data-stu-id="4e2ee-103">Read and Write Operations</span></span>

<span data-ttu-id="4e2ee-104">Windows 支援對序列通訊資源上的同步和非同步 (重迭) 檔案 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-104">Windows supports both synchronous and asynchronous (overlapped) file I/O operations on serial communications resources.</span></span> <span data-ttu-id="4e2ee-105">當作業在背景中執行時，重迭作業可讓呼叫執行緒執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-105">Overlapped operations enable the calling thread to perform other tasks while the operation executes in the background.</span></span> <span data-ttu-id="4e2ee-106">執行緒使用 [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) 或 [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) 函式來讀取通訊資源，並使用 [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) 或 [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) 函式來寫入通訊資源。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-106">A thread uses the [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) or [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) function to read from a communications resource, and the [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) or [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) function to write to a communications resource.</span></span> <span data-ttu-id="4e2ee-107">**ReadFile** 和 **WriteFile** 可以同步或非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-107">**ReadFile** and **WriteFile** can be performed synchronously or asynchronously.</span></span> <span data-ttu-id="4e2ee-108">**ReadFileEx** 和 **WriteFileEx** 只能以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-108">**ReadFileEx** and **WriteFileEx** can only be performed asynchronously.</span></span>

<span data-ttu-id="4e2ee-109">這些讀取和寫入函式的行為會受到是否以重迭的作業來執行、超時參數是否與控制碼相關聯，以及流程式控制制參數是否與控制碼相關聯，而受到影響。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-109">The behavior of these read and write functions is affected by whether the function is executed as an overlapped operation, whether the time-out parameters are associated with the handle, and whether flow control parameters are associated with the handle.</span></span>

<span data-ttu-id="4e2ee-110">執行緒也可以使用 [**TransmitCommChar**](/windows/desktop/api/Winbase/nf-winbase-transmitcommchar) 函式來寫入通訊資源，此函式會在輸出緩衝區中的任何暫止資料之前傳輸指定的字元。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-110">A thread can also write to a communications resource by using the [**TransmitCommChar**](/windows/desktop/api/Winbase/nf-winbase-transmitcommchar) function, which transmits a specified character ahead of any pending data in the output buffer.</span></span> <span data-ttu-id="4e2ee-111">此函式適用于將高優先順序的信號字元傳送至接收系統。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-111">This function is useful for transmitting a high priority signal character to the receiving system.</span></span> <span data-ttu-id="4e2ee-112">高優先順序字元的傳輸仍會受到流量控制和寫入超時，而且會以同步的方式執行操作。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-112">Transmission of the high priority character is still subject to flow control and write time-outs, and the operation is performed synchronously.</span></span>

<span data-ttu-id="4e2ee-113">執行緒可以使用 [**PurgeComm**](/windows/desktop/api/Winbase/nf-winbase-purgecomm) 函數來捨棄裝置輸出或輸入緩衝區中的所有字元。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-113">A thread can use the [**PurgeComm**](/windows/desktop/api/Winbase/nf-winbase-purgecomm) function to discard all characters in a device's output or input buffer.</span></span> <span data-ttu-id="4e2ee-114">**PurgeComm** 也可以終止暫止的讀取或寫入作業，即使作業尚未完成。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-114">**PurgeComm** can also terminate pending read or write operations, even if the operations have not been completed.</span></span> <span data-ttu-id="4e2ee-115">如果執行緒使用 **PurgeComm** 來清除輸出緩衝區，則不會傳送已刪除的字元。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-115">If a thread uses **PurgeComm** to flush an output buffer, the deleted characters are not transmitted.</span></span> <span data-ttu-id="4e2ee-116">若要在確定傳輸內容時清空輸出緩衝區，執行緒可以呼叫 [**FlushFileBuffers**](/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers) 函式 () 的同步作業。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-116">To empty the output buffer while ensuring that the contents are transmitted, a thread can call the [**FlushFileBuffers**](/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers) function (a synchronous operation).</span></span> <span data-ttu-id="4e2ee-117">不過，請注意， **FlushFileBuffers** 會受限於流量控制，但無法寫入超時時間，而且必須等到所有暫止的寫入作業都經過傳輸之後，才會返回。</span><span class="sxs-lookup"><span data-stu-id="4e2ee-117">Note, however, that **FlushFileBuffers** is subject to flow control but not to write time-outs, and it will not return until all pending write operations have been transmitted.</span></span>

 

 
