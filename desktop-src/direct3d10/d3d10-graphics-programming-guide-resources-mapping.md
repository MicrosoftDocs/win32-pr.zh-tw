---
description: 複製及存取 (Direct3D 10) 的資源資料
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: 複製及存取 (Direct3D 10) 的資源資料
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103688936"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="36366-103">複製及存取 (Direct3D 10) 的資源資料</span><span class="sxs-lookup"><span data-stu-id="36366-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="36366-104">您不再需要考慮在影片記憶體或系統記憶體中建立的資源。</span><span class="sxs-lookup"><span data-stu-id="36366-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="36366-105">或執行時間是否應該管理記憶體。</span><span class="sxs-lookup"><span data-stu-id="36366-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="36366-106">由於新的 WDDM (Windows 顯示驅動程式模型) 的架構，應用程式現在會使用不同的 [**使用**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) 方式旗標來建立 Direct3D 10 資源，以指出應用程式如何使用資源資料。</span><span class="sxs-lookup"><span data-stu-id="36366-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="36366-107">新的驅動程式模型會虛擬化資源所使用的記憶體;然後，作業系統/驅動程式/記憶體管理員會負責將資源放在最具效能的記憶體區域中，以提供預期的使用量。</span><span class="sxs-lookup"><span data-stu-id="36366-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="36366-108">在預設案例下，資源可供 GPU 使用。</span><span class="sxs-lookup"><span data-stu-id="36366-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="36366-109">當然，在某些情況下，CPU 的資源資料必須可供使用。</span><span class="sxs-lookup"><span data-stu-id="36366-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="36366-110">若要將資源予以複製，使適當的處理器可在不影響效能的情況下進行存取，您需要具備 API 方法運作方式的基本知識。</span><span class="sxs-lookup"><span data-stu-id="36366-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="36366-111">複製資源資料</span><span class="sxs-lookup"><span data-stu-id="36366-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="36366-112">存取資源資料</span><span class="sxs-lookup"><span data-stu-id="36366-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="36366-113">複製資源資料</span><span class="sxs-lookup"><span data-stu-id="36366-113">Copying Resource Data</span></span>

<span data-ttu-id="36366-114">Direct3D 執行建立呼叫時，會在記憶體中建立資源。</span><span class="sxs-lookup"><span data-stu-id="36366-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="36366-115">他們可以在視訊記憶體、系統記憶體，或任何其他類型的記憶體之中建立。</span><span class="sxs-lookup"><span data-stu-id="36366-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="36366-116">由於 WDDM 驅動程式模型會把此記憶體虛擬化，應用程式不再需要追蹤資源究竟是建立於哪一種記憶體之中。</span><span class="sxs-lookup"><span data-stu-id="36366-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="36366-117">理想中，所有資源最好都位於視訊記憶體之中，以供 GPU 立即存取。</span><span class="sxs-lookup"><span data-stu-id="36366-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="36366-118">然而，有時候資源資料必須供 CPU 進行讀取，或是讓 CPU 已寫入的資源資料供 GPU 進行存取。</span><span class="sxs-lookup"><span data-stu-id="36366-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="36366-119">Direct3D 10 會要求應用程式指定使用方式來處理這些不同的情況，然後在必要時提供數個方法來複製資源資料。</span><span class="sxs-lookup"><span data-stu-id="36366-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="36366-120">根據建立資源的方式，並不一定都可以直接存取基礎資料。</span><span class="sxs-lookup"><span data-stu-id="36366-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="36366-121">這表示資源資料必須從來源資源中複製到另一個可供適當處理器進行存取的資源。</span><span class="sxs-lookup"><span data-stu-id="36366-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="36366-122">就 Direct3D 10 而言，GPU 可以直接存取預設資源，CPU 可直接存取動態和暫存資源。</span><span class="sxs-lookup"><span data-stu-id="36366-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="36366-123">一旦建立資源之後，就無法變更其 [**使用**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) 方式。</span><span class="sxs-lookup"><span data-stu-id="36366-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="36366-124">但您可以將一個資源的內容複製到另一個被指定為不同使用方式的資源之中。</span><span class="sxs-lookup"><span data-stu-id="36366-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="36366-125">Direct3D 10 以三種不同的方法提供這項功能。</span><span class="sxs-lookup"><span data-stu-id="36366-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="36366-126">前兩個方法 ( [**ID3D10Device：： CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) 和 [**ID3D10Device：： CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) 是設計用來將資源資料從某個資源複製到另一個資源。</span><span class="sxs-lookup"><span data-stu-id="36366-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="36366-127">第三種方法 ([**ID3D10Device：： UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) 設計來將資料從記憶體複製到資源。</span><span class="sxs-lookup"><span data-stu-id="36366-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="36366-128">資源可分為兩種︰可對應與不可對應。</span><span class="sxs-lookup"><span data-stu-id="36366-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="36366-129">以動態或暫存使用方式建立的資源為可對應資源，而以預設或不可變動使用方式建立的資源為不可對應資源。</span><span class="sxs-lookup"><span data-stu-id="36366-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="36366-130">在不可對應資源之間複製資料非常迅速，因為這是最常見的案例，其執行也已最佳化。</span><span class="sxs-lookup"><span data-stu-id="36366-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="36366-131">由於這些資源無法由 CPU 直接存取，因此其已進行最佳化，使 GPU 可以快速地對其進行操作。</span><span class="sxs-lookup"><span data-stu-id="36366-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="36366-132">在可對應資源之間複製資料則可能較容易發生問題，因為其效能將會取決於資源建立時指定的使用方式。</span><span class="sxs-lookup"><span data-stu-id="36366-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="36366-133">例如：GPU 可以快速地讀取動態資源，但卻無法對其進行寫入，並且 GPU 無法直接地讀取或寫入暫存資源。</span><span class="sxs-lookup"><span data-stu-id="36366-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="36366-134">如果應用程式想要將資料從具有預設使用量的資源複製到具有暫存使用量的資源 (以允許 CPU 讀取資料（亦即，GPU readback 問題) 必須小心執行此動作。</span><span class="sxs-lookup"><span data-stu-id="36366-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="36366-135">如需此最後一個案例的詳細資訊，請參閱 [存取資源資料](#copying-and-accessing-resource-data-direct3d-10) 。</span><span class="sxs-lookup"><span data-stu-id="36366-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="36366-136">存取資源資料</span><span class="sxs-lookup"><span data-stu-id="36366-136">Accessing Resource Data</span></span>

<span data-ttu-id="36366-137">存取資源需必須先對應該資源。基本上，「對應」即表示應用程式正在嘗試讓 CPU 對記憶體進行存取。</span><span class="sxs-lookup"><span data-stu-id="36366-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="36366-138">為使 CPU 能存取基本記憶體而對資源進行對應的程序，可能會導致某些效能瓶頸。基於這個原因，應注意如何及何時執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="36366-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="36366-139">若應用程式嘗試在錯誤的時間點進行對應資源，其執行效能可能會降低到停止的程度。</span><span class="sxs-lookup"><span data-stu-id="36366-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="36366-140">若應用程式嘗試在作業完成之前對其結果進行存取，將可能導致管線停頓。</span><span class="sxs-lookup"><span data-stu-id="36366-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="36366-141">若在錯誤的時間點進行對應作業，可能會因為強制 GPU 與 CPU 互相同步而導致效能嚴重下降 。</span><span class="sxs-lookup"><span data-stu-id="36366-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="36366-142">此同步動作會在應用程式嘗試在 GPU 完成將資源複製到另一個 CPU 可以對應的資源前對其進行存取時發生。</span><span class="sxs-lookup"><span data-stu-id="36366-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="36366-143">CPU 只能從使用 D3D10 \_ 使用量暫存旗標建立的資源讀取 \_ 。</span><span class="sxs-lookup"><span data-stu-id="36366-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="36366-144">由於使用此旗標建立的資源無法設定為管線的輸出，因此，如果 CPU 想要讀取 GPU 所產生之資源中的資料，則必須將資料複製到以預備旗標建立的資源。</span><span class="sxs-lookup"><span data-stu-id="36366-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="36366-145">應用程式可以使用 [**ID3D10Device：： CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) 或 [**ID3D10Device：： CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) 方法將某個資源的內容複寫到另一個資源。</span><span class="sxs-lookup"><span data-stu-id="36366-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="36366-146">然後，應用程式可以藉由呼叫適當的 Map 方法來取得此資源的存取權。</span><span class="sxs-lookup"><span data-stu-id="36366-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="36366-147">當不再需要存取資源時，應用程式應該呼叫對應的取消對應方法。</span><span class="sxs-lookup"><span data-stu-id="36366-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="36366-148">例如， [**ID3D10Texture2D：： Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) 和 [**ID3D10Texture2D：：**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap)Map。</span><span class="sxs-lookup"><span data-stu-id="36366-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="36366-149">不同的對應方法會根據輸入旗標傳回一些特定的值。</span><span class="sxs-lookup"><span data-stu-id="36366-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="36366-150">如需詳細資訊，請參閱 [**地圖備註一節**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) 。</span><span class="sxs-lookup"><span data-stu-id="36366-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="36366-151">當應用程式呼叫 Map 方法時，它會接收要存取的資源資料指標。</span><span class="sxs-lookup"><span data-stu-id="36366-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="36366-152">執行時間可確保指標具有特定的對齊方式，視 [功能等級](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md)而定。</span><span class="sxs-lookup"><span data-stu-id="36366-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="36366-153">針對 [**D3D \_ 功能 \_ 層級 \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) 和更高，指標會對齊16個位元組。</span><span class="sxs-lookup"><span data-stu-id="36366-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="36366-154">若低於 [**D3D \_ 功能 \_ 層級 \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level)，指標會對齊4個位元組。</span><span class="sxs-lookup"><span data-stu-id="36366-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="36366-155">16位元組的對齊可讓應用程式以原生方式對資料執行 [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))優化的作業，而不需要重做或複製。</span><span class="sxs-lookup"><span data-stu-id="36366-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="36366-156">效能考量</span><span class="sxs-lookup"><span data-stu-id="36366-156">Performance Considerations</span></span>

<span data-ttu-id="36366-157">建議您將您的電腦視為一台以兩種不同類型處理器構成的平行結構運作的機器︰一個或多個 CPU，以及一個或多個 GPU。</span><span class="sxs-lookup"><span data-stu-id="36366-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="36366-158">如同任何平行結構一樣，當每個處理器都排程了足夠的工作，以避免其進入閒置狀態或等待別的處理器完成工作時，運作才可達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="36366-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="36366-159">GPU/CPU 平行處理原則中最糟的情況，就是強制一個處理器等候另一個處理器工作完成的結果。</span><span class="sxs-lookup"><span data-stu-id="36366-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="36366-160">Direct3D 10 會嘗試將 [**ID3D10Device：： CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) 和 [**ID3D10Device：： CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) 方法設為非同步，以移除這項成本;在方法傳回時，不一定會執行複製。</span><span class="sxs-lookup"><span data-stu-id="36366-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="36366-161">其優點在於應用程式不需要在 CPU 存取資料時才付出效能降低的成本，即呼叫 Map 方法時。</span><span class="sxs-lookup"><span data-stu-id="36366-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="36366-162">若 Map 方法在資料確實複製後才被呼叫，便不會造成任何效能上的損失。</span><span class="sxs-lookup"><span data-stu-id="36366-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="36366-163">另一方面，若 Map 方法在資料複製之前就被呼叫，便會發生管線停頓。</span><span class="sxs-lookup"><span data-stu-id="36366-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="36366-164">Direct3D 10 中的非同步呼叫 (是大部分的方法，尤其是轉譯呼叫) 會儲存在所謂的命令緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="36366-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="36366-165">這個緩衝區位於圖形驅動程式的內部，並用來對基礎硬體進行批次呼叫，使 Microsoft Windows 從使用者模式切換至核心模式這種極為耗費成本狀況的發生能夠盡量減少。</span><span class="sxs-lookup"><span data-stu-id="36366-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="36366-166">命令緩衝區在下列四種情況下會被排清，並造成使用者/核心模式的切換。</span><span class="sxs-lookup"><span data-stu-id="36366-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="36366-167">會呼叫 [**目前**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present)的。</span><span class="sxs-lookup"><span data-stu-id="36366-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="36366-168">呼叫 [**ID3D10Device：： Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) 。</span><span class="sxs-lookup"><span data-stu-id="36366-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="36366-169">命令緩衝區已滿。其大小為動態且由作業系統及圖形驅動程式控制。</span><span class="sxs-lookup"><span data-stu-id="36366-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="36366-170">CPU 需要存取命令緩衝區中一個尚待執行命令的結果。</span><span class="sxs-lookup"><span data-stu-id="36366-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="36366-171">在以上四種情況中，第四種情況會對效能造成最嚴重的影響。</span><span class="sxs-lookup"><span data-stu-id="36366-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="36366-172">如果應用程式發出 [**ID3D10Device：： CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) 或 [**ID3D10Device：： CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) 呼叫，此呼叫會在命令緩衝區中排入佇列。</span><span class="sxs-lookup"><span data-stu-id="36366-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="36366-173">如果應用程式接著在清除命令緩衝區之前，嘗試對應做為複製呼叫目標的預備資源，將會發生管線延遲，因為不僅需要執行複製方法呼叫，還必須執行命令緩衝區中所有其他已緩衝處理的命令。</span><span class="sxs-lookup"><span data-stu-id="36366-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="36366-174">這將會導致 GPU 與 CPU 進行同步，因為 CPU 將會等待 GPU 清空命令緩衝區並填滿 CPU 需要的資源後，才能存取暫存資源。</span><span class="sxs-lookup"><span data-stu-id="36366-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="36366-175">當 GPU 完成複製之後，CPU 才會開始存取暫存資源，然而此期間 GPU 就會進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="36366-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="36366-176">若經常性地在執行階段進行此動作，將會大幅降低效能。</span><span class="sxs-lookup"><span data-stu-id="36366-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="36366-177">基於這個原因，對應以預設使用方式建立的資源時，應小心謹慎。</span><span class="sxs-lookup"><span data-stu-id="36366-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="36366-178">應用程式必須等候夠長的時間，讓命令緩衝區被清空並且完成執行佇列中所有的命令，才能嘗試對應相對應的暫存資源。</span><span class="sxs-lookup"><span data-stu-id="36366-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="36366-179">應用程式應該等候多久才行？</span><span class="sxs-lookup"><span data-stu-id="36366-179">How long should the application wait?</span></span> <span data-ttu-id="36366-180">至少需要等待兩個影格的時間，因為這樣才能使 CPU 和 GPU 之間的平行處理原則得到最大且有效率的調控。</span><span class="sxs-lookup"><span data-stu-id="36366-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="36366-181">GPU 的運作方式，是當應用程式藉由送出呼叫到命令緩衝區中以處理第 N 個影格時，GPU 正忙碌於執行前一個影格 (N-1) 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="36366-182">因此，如果應用程式想要對應源自于影片記憶體的資源，並在畫面格 N 呼叫 [**ID3D10Device：： CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) 或 [**ID3D10Device：： CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) ，則當應用程式提交下一個框架的呼叫時，此呼叫實際上會開始在畫面格 n + 1 上執行。</span><span class="sxs-lookup"><span data-stu-id="36366-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="36366-183">複製應會在應用程式正在處理第 N+2 個影格時完成。</span><span class="sxs-lookup"><span data-stu-id="36366-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="36366-184">Frame</span><span class="sxs-lookup"><span data-stu-id="36366-184">Frame</span></span></th>
<th><span data-ttu-id="36366-185">GPU/CPU 狀態</span><span class="sxs-lookup"><span data-stu-id="36366-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="36366-186">N</span><span class="sxs-lookup"><span data-stu-id="36366-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="36366-187">CPU 為目前的影格送出轉譯呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="36366-188">N+1</span><span class="sxs-lookup"><span data-stu-id="36366-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="36366-189">GPU 執行 CPU 在第 N 個影格時送出的呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="36366-190">CPU 為目前的影格送出轉譯呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="36366-191">N+2</span><span class="sxs-lookup"><span data-stu-id="36366-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="36366-192">GPU 完成執行 CPU 在第 N 個影格時送出的呼叫。結果準備就緒。</span><span class="sxs-lookup"><span data-stu-id="36366-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="36366-193">GPU 執行 CPU 在第 N+1 個影格時送出的呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="36366-194">CPU 為目前的影格送出轉譯呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="36366-195">N+3</span><span class="sxs-lookup"><span data-stu-id="36366-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="36366-196">GPU 完成執行 CPU 在第 N+1 個影格時送出的呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="36366-197">結果準備就緒。</span><span class="sxs-lookup"><span data-stu-id="36366-197">Results ready.</span></span></li>
<li><span data-ttu-id="36366-198">GPU 執行 CPU 在第 N+2 個影格時送出的呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="36366-199">CPU 為目前的影格送出轉譯呼叫。</span><span class="sxs-lookup"><span data-stu-id="36366-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="36366-200">N+4</span><span class="sxs-lookup"><span data-stu-id="36366-200">N+4</span></span></td>
<td><span data-ttu-id="36366-201">...</span><span class="sxs-lookup"><span data-stu-id="36366-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="36366-202">相關主題</span><span class="sxs-lookup"><span data-stu-id="36366-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="36366-203"> (Direct3D 10) 的資源 </span><span class="sxs-lookup"><span data-stu-id="36366-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
