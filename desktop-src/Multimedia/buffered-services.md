---
title: 緩衝的服務
description: 緩衝的服務
ms.assetid: 4816ab05-42fc-4c22-b753-8fd153d88c27
keywords:
- 多媒體檔案 i/o、緩衝的服務
- 檔案 i/o，緩衝服務
- 輸入和輸出 (i/o) 、緩衝的服務
- I/o (輸入和輸出) 、緩衝的服務
- 緩衝的 i/o
- mmioOpen 函式
- 內部 i/o 緩衝區
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d014ed765609dd43886cc7b33987f8fd5ac7e65a
ms.sourcegitcommit: 7ef31bf778e76ce4196205d4c4c632fbdc649805
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2021
ms.locfileid: "103945543"
---
# <a name="buffered-services"></a><span data-ttu-id="bd2dc-110">緩衝的服務</span><span class="sxs-lookup"><span data-stu-id="bd2dc-110">Buffered Services</span></span>

<span data-ttu-id="bd2dc-111">存取媒體裝置時，大部分的檔案 i/o 額外負荷都會發生。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-111">Most of the overhead in file I/O occurs when accessing the media device.</span></span> <span data-ttu-id="bd2dc-112">如果您正在讀取或寫入許多小部分的資訊，裝置可能會花很多時間移至媒體上的實體位置，以進行每個讀取或寫入操作。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-112">If you are reading or writing many small blocks of information, the device can spend a lot of time moving to the physical location on the media for each read or write operation.</span></span> <span data-ttu-id="bd2dc-113">在此情況下，您可以使用緩衝的檔案 i/o 服務來達到更佳的效能。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-113">In this case, you can achieve better performance by using buffered file I/O services.</span></span> <span data-ttu-id="bd2dc-114">使用緩衝的 i/o 時，檔案 i/o 管理員會維護一個大於您正在讀取或寫入之資訊區塊的中繼緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-114">With buffered I/O, the file I/O manager maintains an intermediate buffer larger than the blocks of information you are reading or writing.</span></span> <span data-ttu-id="bd2dc-115">只有當緩衝區必須填滿或寫入磁片時，才會存取裝置。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-115">It accesses the device only when the buffer must be filled from or written to the disk.</span></span>

<span data-ttu-id="bd2dc-116">在您設定和使用緩衝的檔案 i/o 之前，您必須決定是否要檔案 i/o 管理員或應用程式佈建緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-116">Before you set up and use buffered file I/O, you must decide whether you want the file I/O manager or the application to allocate the buffer.</span></span> <span data-ttu-id="bd2dc-117">更簡單的方式是讓檔案 i/o 管理員配置緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-117">It is simpler to let the file I/O manager allocate the buffer.</span></span> <span data-ttu-id="bd2dc-118">但是，如果您想要直接存取緩衝區或開啟記憶體檔案，您可以讓應用程式佈建緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-118">However, you can let the application allocate the buffer if you want to directly access the buffer or open a memory file.</span></span> <span data-ttu-id="bd2dc-119">如需使用記憶體檔案的詳細資訊，請參閱 [執行記憶體檔 i/o](performing-memory-file-i-o.md)。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-119">For more information about using memory files, see [Performing Memory File I/O](performing-memory-file-i-o.md).</span></span> <span data-ttu-id="bd2dc-120">如需直接存取 i/o 緩衝區的範例，請參閱存取檔案 [I/o 緩衝區](accessing-a-file-i-o-buffer.md)</span><span class="sxs-lookup"><span data-stu-id="bd2dc-120">For an example of directly accessing an I/O buffer, see [Accessing a File I/O Buffer](accessing-a-file-i-o-buffer.md)</span></span>

<span data-ttu-id="bd2dc-121">檔案 i/o 管理員所配置的緩衝區稱為內部 i/o 緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-121">A buffer allocated by the file I/O manager is called an internal I/O buffer.</span></span> <span data-ttu-id="bd2dc-122">若要使用內部緩衝區開啟已緩衝處理之 i/o 的檔案，請 \_ 在使用 [**mmioOpen**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioopen) 函數開啟檔案時，指定 MMIO ALLOCBUF 旗標。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-122">To open a file for buffered I/O using an internal buffer, specify the MMIO\_ALLOCBUF flag when you open the file with the [**mmioOpen**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioopen) function.</span></span> <span data-ttu-id="bd2dc-123">下圖顯示在開啟檔案以進行緩衝讀取作業之後，檔案 i/o 緩衝區的初始狀態。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-123">The following illustration shows the initial state of the file I/O buffer after a file is opened for a buffered read operation.</span></span> <span data-ttu-id="bd2dc-124">緩衝是透明的; 您可以讀取和搜尋，就像是使用未緩衝處理的 i/o 一樣。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-124">The buffering is transparent — you read and seek as if you were using unbuffered I/O.</span></span> <span data-ttu-id="bd2dc-125">**MmioOpen** 函式已設定 PchNext 和 *pchEndRead* ，以指向檔案 i/o 緩衝區的開頭。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-125">The **mmioOpen** function has set pchNext and *pchEndRead* to point to the beginning of the file I/O buffer.</span></span>

![顯示「pchEndRead」和「pchNext」指向檔案 i/o 緩衝區開頭的螢幕擷取畫面。](images/mmio7.gif)

<span data-ttu-id="bd2dc-127">下圖顯示檔案開啟以進行緩衝寫入作業之後，檔案 i/o 緩衝區的初始狀態。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-127">The following illustration shows the initial state of the file I/O buffer after a file is opened for a buffered write operation.</span></span> <span data-ttu-id="bd2dc-128">**MmioOpen** 函式已設定 **pchNext** 指向檔案 i/o 緩衝區的開頭，而 **pchEndWrite** 指向緩衝區的結尾。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-128">The **mmioOpen** function has set **pchNext** to point to the beginning of the file I/O buffer and **pchEndWrite** to point to the end of the buffer.</span></span>

![在檔案 i/o 緩衝區開頭顯示 ' pchNext '，並在結尾顯示 ' pchEndWrite ' 的螢幕擷取畫面。](images/mmio11.gif)

<span data-ttu-id="bd2dc-130">內部 i/o 緩衝區的預設大小為8K。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-130">The default size of the internal I/O buffer is 8K.</span></span> <span data-ttu-id="bd2dc-131">如果這個大小不適當，您可以使用 [**mmioSetBuffer**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetbuffer) 函數來變更緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-131">If this size is not adequate, you can use the [**mmioSetBuffer**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetbuffer) function to change the buffer size.</span></span> <span data-ttu-id="bd2dc-132">您也可以使用此函式，在針對未緩衝處理的 i/o 開啟的檔案上啟用緩衝處理，或是提供您自己的緩衝區作為記憶體檔案使用。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-132">You can also use this function to enable buffering on a file opened for unbuffered I/O, or to supply your own buffer for use as a memory file.</span></span>

<span data-ttu-id="bd2dc-133">您可以使用 [**mmioFlush**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioflush) 函式，將 i/o 緩衝區的內容強制寫入磁片。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-133">You can force the contents of an I/O buffer to be written to disk by using the [**mmioFlush**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioflush) function.</span></span> <span data-ttu-id="bd2dc-134">但是，當您使用 [**mmioClose**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioclose) 函式來關閉檔案時，不需要呼叫 **mmioFlush** 來排清 I/o 緩衝區，而 **mmioClose** 函式會自動將其清除。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-134">However, when you close a file by using the [**mmioClose**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioclose) function, you do not have to call **mmioFlush** to flush an I/O buffer — the **mmioClose** function automatically flushes it.</span></span> <span data-ttu-id="bd2dc-135">如果您用盡磁碟空間， **mmioFlush** 可能會失敗，即使先前對 [**mmioWrite**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiowrite) 函式的呼叫成功。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-135">If you run out of disk space, **mmioFlush** could fail, even if the preceding calls to the [**mmioWrite**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiowrite) function were successful.</span></span> <span data-ttu-id="bd2dc-136">同樣地， **mmioClose** 可能會在清除其 i/o 緩衝區時失敗。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-136">Similarly, **mmioClose** could fail when it is flushing its I/O buffer.</span></span>

<span data-ttu-id="bd2dc-137">與效能相關的應用程式（例如從 CD-ROM 即時串流資料的應用程式）可以直接存取 i/o 緩衝區來優化檔案 i/o 效能。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-137">Applications that are performance-sensitive, such as those that stream data in real time from a CD-ROM, can optimize file I/O performance by directly accessing the I/O buffer.</span></span> <span data-ttu-id="bd2dc-138">如果您選擇這麼做，您應該要特別小心，因為您略過檔案 i/o 管理員所提供的一些保護和錯誤檢查。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-138">You should be careful if you choose to do this, because you bypass some of the safeguards and error checking provided by the file I/O manager.</span></span>

<span data-ttu-id="bd2dc-139">多媒體檔案 i/o 管理員會使用 [**MMIOINFO**](/previous-versions//dd757322(v=vs.85)) 結構來維護開啟檔案的相關狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-139">The multimedia file I/O manager uses the [**MMIOINFO**](/previous-versions//dd757322(v=vs.85)) structure to maintain state information about an open file.</span></span> <span data-ttu-id="bd2dc-140">您可以使用此結構中的三個成員來讀取和寫入 i/o 緩衝區： **pchNext**、 **pchEndRead** 和 **pchEndWrite**。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-140">You use three members in this structure to read and write the I/O buffer: **pchNext**, **pchEndRead**, and **pchEndWrite**.</span></span> <span data-ttu-id="bd2dc-141">**PchNext** 成員指向緩衝區中要讀取或寫入的下一個位置。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-141">The **pchNext** member points to the next location in the buffer to read or write.</span></span> <span data-ttu-id="bd2dc-142">您必須在讀取和寫入緩衝區時，遞增這個成員。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-142">You must increment this member as you read and write the buffer.</span></span> <span data-ttu-id="bd2dc-143">**PchEndRead** 成員會識別您可以從緩衝區讀取的最後一個有效字元。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-143">The **pchEndRead** member identifies the last valid character you can read from the buffer.</span></span> <span data-ttu-id="bd2dc-144">同樣地，這個成員會識別緩衝區中您可以寫入的最後一個位置。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-144">Likewise, this member identifies the last location in the buffer you can write.</span></span> <span data-ttu-id="bd2dc-145">更精確地說， **pchEndRead** 和 **pchEndWrite** 會指向緩衝區中最後一個有效資料之後的記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-145">More precisely, both **pchEndRead** and **pchEndWrite** point to the memory location that follows the last valid data in the buffer.</span></span> <span data-ttu-id="bd2dc-146">您可以使用 [**mmioGetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiogetinfo) 和 [**mmioSetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetinfo) 函數來取得和設定有關檔案 i/o 緩衝區的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-146">Use the [**mmioGetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiogetinfo) and [**mmioSetInfo**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmiosetinfo) functions to retrieve and set state information about the file I/O buffer.</span></span> <span data-ttu-id="bd2dc-147">下圖顯示在讀取作業期間，應用程式呼叫 **mmioAdvance** 之後 i/o 緩衝區的狀態。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-147">The following illustration shows the state of the I/O buffer after the application calls **mmioAdvance** during a read operation.</span></span> <span data-ttu-id="bd2dc-148">**MmioAdvance** 函式會填滿緩衝區，並將 **pchEndRead** 指標設定為緩衝區的結尾。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-148">The **mmioAdvance** function fills the buffer and sets the **pchEndRead** pointer to the end of the buffer.</span></span>

![在檔案 i/o 緩衝區開頭顯示 ' pchNext '，並在結尾顯示 ' pchEndRead ' 的螢幕擷取畫面。](images/mmio8.gif)

<span data-ttu-id="bd2dc-150">在下圖中，應用程式會在 **pchNext** 所指定的位置從 i/o 緩衝區讀取，並將指標前進。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-150">In the following illustration, the application reads from the I/O buffer at the location specified by **pchNext**, and advances the pointer.</span></span>

![在檔案 i/o 緩衝區中間顯示 ' pchNext '，並在結尾顯示 ' pchEndRead ' 的螢幕擷取畫面。](images/mmio9.gif)

<span data-ttu-id="bd2dc-152">同樣地，在寫入作業中，應用程式會寫入 i/o 緩衝區，並將 **pchNext** 指標前進，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-152">Similarly, for a write operation, the application writes to the I/O buffer and advances the **pchNext** pointer, as shown in the following illustration.</span></span>

![在檔案 i/o 緩衝區中間顯示 ' pchNext '，並在結尾顯示 ' pchEndWrite ' 的螢幕擷取畫面。](images/mmio12.gif)

<span data-ttu-id="bd2dc-154">應用程式填滿緩衝區之後，它會呼叫 **mmioAdvance** 將緩衝區排清到磁片。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-154">After the application fills the buffer, it calls **mmioAdvance** to flush the buffer to disk.</span></span> <span data-ttu-id="bd2dc-155">**MmioAdvance** 函式會將 **pchNext** 重設為指向緩衝區的開頭，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-155">The **mmioAdvance** function resets **pchNext** to point to the beginning of the buffer, as shown in the following illustration.</span></span>

![在檔案 i/o 緩衝區開頭顯示 ' pchNext ' 的螢幕擷取畫面、E O F 中間的緩衝區，以及緩衝區結尾的 ' pchEndWrite '。](images/mmio13.gif)

<span data-ttu-id="bd2dc-157">當您到達 i/o 緩衝區的結尾時，如果您正在進行寫入，則必須將緩衝區前移以從磁片填滿磁片（如果您正在讀取）或將它排清至磁片。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-157">When you reach the end of the I/O buffer, you must advance the buffer to fill it from the disk, if you are reading, or flush it to the disk, if you are writing.</span></span> <span data-ttu-id="bd2dc-158">使用 [**mmioAdvance**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioadvance) 函式來推進 i/o 緩衝區。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-158">Use the [**mmioAdvance**](/windows/win32/api/mmiscapi/nf-mmiscapi-mmioadvance) function to advance an I/O buffer.</span></span> <span data-ttu-id="bd2dc-159">若要從磁片填入 i/o 緩衝區，請使用 **mmioAdvance** 搭配 MMIO \_ READ 旗標。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-159">To fill an I/O buffer from disk, use **mmioAdvance** with the MMIO\_READ flag.</span></span> <span data-ttu-id="bd2dc-160">如果檔案中沒有足夠的資料來填滿緩衝區， **MMIOINFO** 結構的 **pchEndRead** 成員會指向緩衝區中最後一個有效位元組後面的位置。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-160">If there is not enough data remaining in the file to fill the buffer, the **pchEndRead** member of the **MMIOINFO** structure points to the location following the last valid byte in the buffer.</span></span> <span data-ttu-id="bd2dc-161">若要將緩衝區排清到磁片，請 \_ 在 **MMIOINFO** 結構的 **DWFLAGS** 成員中設定 mmio DIRTY 旗標，然後使用 MMIO WRITE 旗標來呼叫 **mmioAdvance** \_ 。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-161">To flush a buffer to disk, set the MMIO\_DIRTY flag in the **dwFlags** member of the **MMIOINFO** structure and then call **mmioAdvance** with the MMIO\_WRITE flag.</span></span>

<span data-ttu-id="bd2dc-162">例如，在讀取作業期間， **mmioAdvance** 函式會設定 **pchEndRead** 以指向緩衝區中有效資料的結尾，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-162">For example, during a read operation, the **mmioAdvance** function sets **pchEndRead** to point to the end of valid data in the buffer, as shown in the following illustration.</span></span>

![在檔案 i/o 緩衝區開頭顯示 ' pchNext ' 的螢幕擷取畫面、E O F 結尾的緩衝區，以及緩衝區結尾的 ' pchEndRead '。](images/mmio10.gif)

<span data-ttu-id="bd2dc-164">同樣地，在寫入作業期間，應用程式會呼叫 **mmioAdvance** 來排清緩衝區，並將 **pchNext** 前移至緩衝區中有效資料的結尾，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="bd2dc-164">Similarly, during a write operation, the application calls **mmioAdvance** to flush the buffer and advance **pchNext** to the end of valid data in the buffer, as shown in the following illustration.</span></span>

![檔案 i/o 緩衝區映射](images/mmio14.gif)

 

 