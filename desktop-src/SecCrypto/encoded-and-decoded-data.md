---
description: 若要透過通訊媒體（例如電話線路）傳送資料，則必須將資料序列化&\# 8212; 也就是轉換成字串，以及在行上以序列方式傳送的零。
ms.assetid: ef8982dc-bbbc-466a-9afe-dd0425c23f1d
title: 編碼和解碼的資料
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 063f18a4f58f2989e2bd0b890fd11a7ab6022a3de255385b1cf529afb5493485
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "119874941"
---
# <a name="encoded-and-decoded-data"></a>編碼和解碼的資料

若要透過通訊媒體（例如電話線路）傳送資料，則必須將資料 [*序列化*](../secgloss/s-gly.md)，也就是轉換成字串，而在行上以序列方式傳送的零。 序列化的完成方式是讓接收資料的電腦能夠將資料轉換回其原始格式。 序列化的完成方式稱為 [*通訊協定*](../secgloss/c-gly.md)，它是由軟體和資料傳輸硬體所控制。 轉換資料的層級有數種。 下圖顯示以大幅簡化的通訊協定層觀點。

![通訊協定層](images/layer.png)

上圖顯示電腦1上的應用層 \# 傳送要傳輸的資料 (這通常是由一些文字字元和數位的組合) 至編碼/解碼層。 編碼/解碼層會將資料編碼成電腦位元組資料流程。 在最低層級的硬體層，硬體會將資料位元組轉換成一系列的序列資料流程，而零則會在一行傳輸到電腦 \# 2。 電腦2的硬體層會 \# 將一和零轉換回電腦的位元組，並將它們傳遞至編碼/解碼層以進行解碼。 編碼/解碼層會將位元組解碼回其原始格式，然後將資料傳遞至應用層。

接受的軟體設計原則是使用 *抽象概念*，也就是以一般參數描述問題或物件的程式，而不是描述解決問題所需的所有詳細資料，或是描述物件的所有詳細資料。 使用抽象，設計工具可以指定具有特定品質的軟體物件，而不需要考慮如何在軟體程式碼中實際執行物件。 這種作法會讓執行保持開啟。 它也會簡化規格，並讓您能夠陳述可在物件執行時證明的物件通則。 然後，當物件是在另一個較高層級的物件中採用時，就可以假設這些通則。 「抽象」（特徵）是指最現代的軟體規格。

大部分的 [*通訊協定*](../secgloss/c-gly.md) 都牽涉到許多抽象概念。 較高層級的物件定義為以抽象方式，而且是要使用較低層的物件來執行。 比方說，某一層的服務可能需要在電腦之間傳送某些抽象物件。 較低層級層可以使用編碼規則，將抽象物件轉換成一和零的字串。

指定要以序列方式傳送之抽象物件的其中一個常見方法，稱為 [*抽象語法標記法 (一)*](../secgloss/a-gly.md) (asn.1) 。 Asn.1 是以 CCITT 建議的 [*x.x.x.x*](../secgloss/x-gly.md)來定義。 一組 asn.1 規則，可將這類物件表示為一組和零的字串，並將 [*可辨別編碼規則*](../secgloss/d-gly.md) (DER) ，並在 [*x.509*](../secgloss/x-gly.md)，第8.7 節中定義。 這些是 CryptoAPI 目前使用的編碼方法。

如需編碼/解碼函式的詳細資訊，請參閱 [物件編碼和解碼函數](cryptography-functions.md)。

 

 
