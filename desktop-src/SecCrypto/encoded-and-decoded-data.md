---
description: 若要透過通訊媒體（例如電話線路）傳送資料，則必須將資料序列化&\# 8212; 也就是轉換成字串，以及在行上以序列方式傳送的零。
ms.assetid: ef8982dc-bbbc-466a-9afe-dd0425c23f1d
title: 編碼和解碼的資料
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c8b130232ac67503c6a20835c4c9b4e728b36f8b
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103943332"
---
# <a name="encoded-and-decoded-data"></a><span data-ttu-id="3dcc8-103">編碼和解碼的資料</span><span class="sxs-lookup"><span data-stu-id="3dcc8-103">Encoded and Decoded Data</span></span>

<span data-ttu-id="3dcc8-104">若要透過通訊媒體（例如電話線路）傳送資料，則必須將資料 [*序列化*](../secgloss/s-gly.md)，也就是轉換成字串，而在行上以序列方式傳送的零。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-104">To send data over a communication medium such as a phone line, the data must be [*serialized*](../secgloss/s-gly.md)— that is, converted into a string of ones and zeros that are transmitted serially over the line.</span></span> <span data-ttu-id="3dcc8-105">序列化的完成方式是讓接收資料的電腦能夠將資料轉換回其原始格式。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-105">Serialization must be done in such a way that the computer receiving the data can convert the data back into its original format.</span></span> <span data-ttu-id="3dcc8-106">序列化的完成方式稱為 [*通訊協定*](../secgloss/c-gly.md)，它是由軟體和資料傳輸硬體所控制。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-106">How serialization is accomplished is called a [*communication protocol*](../secgloss/c-gly.md), and is controlled by both software and data-transmission hardware.</span></span> <span data-ttu-id="3dcc8-107">轉換資料的層級有數種。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-107">There are several levels at which the data is converted.</span></span> <span data-ttu-id="3dcc8-108">下圖顯示以大幅簡化的通訊協定層觀點。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-108">The following illustration shows a greatly simplified view of communication protocol layers.</span></span>

![通訊協定層](images/layer.png)

<span data-ttu-id="3dcc8-110">上圖顯示電腦1上的應用層 \# 傳送要傳輸的資料 (這通常是由一些文字字元和數位的組合) 至編碼/解碼層。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-110">The preceding illustration shows the application layer on Computer \#1 sending the data to be transmitted (which usually consists of some combination of textual characters and numbers) to the encode/decode layer.</span></span> <span data-ttu-id="3dcc8-111">編碼/解碼層會將資料編碼成電腦位元組資料流程。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-111">The encode/decode layer encodes the data into a stream of computer bytes.</span></span> <span data-ttu-id="3dcc8-112">在最低層級的硬體層，硬體會將資料位元組轉換成一系列的序列資料流程，而零則會在一行傳輸到電腦 \# 2。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-112">At the lowest level, the hardware layer, the hardware converts the bytes of data into a serial stream of ones and zeros that is transmitted over the line to Computer \#2.</span></span> <span data-ttu-id="3dcc8-113">電腦2的硬體層會 \# 將一和零轉換回電腦的位元組，並將它們傳遞至編碼/解碼層以進行解碼。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-113">The hardware layer of Computer \#2 converts the ones and zeros back into computer bytes, and passes them up to the encode/decode layer for decoding.</span></span> <span data-ttu-id="3dcc8-114">編碼/解碼層會將位元組解碼回其原始格式，然後將資料傳遞至應用層。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-114">The encode/decode layer decodes the bytes back into their original format and passes the data up to the application layer.</span></span>

<span data-ttu-id="3dcc8-115">接受的軟體設計原則是使用 *抽象概念*，也就是以一般參數描述問題或物件的程式，而不是描述解決問題所需的所有詳細資料，或是描述物件的所有詳細資料。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-115">An accepted software design principle is to use *abstraction*, that is, the process of describing a problem or object in terms of its general parameters rather than describing all the details necessary to solve the problem, or describing all the details of an object.</span></span> <span data-ttu-id="3dcc8-116">使用抽象，設計工具可以指定具有特定品質的軟體物件，而不需要考慮如何在軟體程式碼中實際執行物件。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-116">Using abstraction, a designer can specify a software object that has specific qualities without concern for how the object is actually implemented in the software code.</span></span> <span data-ttu-id="3dcc8-117">這種作法會讓執行保持開啟。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-117">Such a practice leaves the implementation open.</span></span> <span data-ttu-id="3dcc8-118">它也會簡化規格，並讓您能夠陳述可在物件執行時證明的物件通則。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-118">It also simplifies the specification and makes it possible to state axioms about the object that can be proved when the object is implemented.</span></span> <span data-ttu-id="3dcc8-119">然後，當物件是在另一個較高層級的物件中採用時，就可以假設這些通則。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-119">These axioms can then be assumed when the object is employed in another, higher-level object.</span></span> <span data-ttu-id="3dcc8-120">「抽象」（特徵）是指最現代的軟體規格。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-120">Abstraction is the hallmark of most contemporary software specifications.</span></span>

<span data-ttu-id="3dcc8-121">大部分的 [*通訊協定*](../secgloss/c-gly.md) 都牽涉到許多抽象概念。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-121">Most [*communication protocols*](../secgloss/c-gly.md) involve a good deal of abstraction.</span></span> <span data-ttu-id="3dcc8-122">較高層級的物件定義為以抽象方式，而且是要使用較低層的物件來執行。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-122">Objects at higher layers are defined abstractly and are intended to be implemented using objects at lower layers.</span></span> <span data-ttu-id="3dcc8-123">比方說，某一層的服務可能需要在電腦之間傳送某些抽象物件。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-123">For instance, a service at one layer might require transferring certain abstract objects between computers.</span></span> <span data-ttu-id="3dcc8-124">較低層級層可以使用編碼規則，將抽象物件轉換成一和零的字串。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-124">A lower level layer can use encoding rules to transform the abstract objects into strings of ones and zeros.</span></span>

<span data-ttu-id="3dcc8-125">指定要以序列方式傳送之抽象物件的其中一個常見方法，稱為 [*抽象語法標記法 (一)*](../secgloss/a-gly.md) (asn.1) 。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-125">One common method of specifying abstract objects intended to be serially transmitted is called [*Abstract Syntax Notation One*](../secgloss/a-gly.md) (ASN.1).</span></span> <span data-ttu-id="3dcc8-126">Asn.1 是以 CCITT 建議的 [*x.x.x.x*](../secgloss/x-gly.md)來定義。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-126">ASN.1 is defined in CCITT Recommendation [*X.208*](../secgloss/x-gly.md).</span></span> <span data-ttu-id="3dcc8-127">一組 asn.1 規則，可將這類物件表示為一組和零的字串，並將 [*可辨別編碼規則*](../secgloss/d-gly.md) (DER) ，並在 [*x.509*](../secgloss/x-gly.md)，第8.7 節中定義。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-127">One set of ASN.1 rules for representing such objects as strings of ones and zeros is called the [*Distinguished Encoding Rules*](../secgloss/d-gly.md) (DER), and is defined in CCITT Recommendation [*X.509*](../secgloss/x-gly.md), Section 8.7.</span></span> <span data-ttu-id="3dcc8-128">這些是 CryptoAPI 目前使用的編碼方法。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-128">These are the encoding methods currently used by CryptoAPI.</span></span>

<span data-ttu-id="3dcc8-129">如需編碼/解碼函式的詳細資訊，請參閱 [物件編碼和解碼函數](cryptography-functions.md)。</span><span class="sxs-lookup"><span data-stu-id="3dcc8-129">For more information about encode/decode functions, see [Object Encoding and Decoding Functions](cryptography-functions.md).</span></span>

 

 
