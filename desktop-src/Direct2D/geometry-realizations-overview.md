---
title: 幾何實現概觀
description: 本主題說明如何使用 Direct2D geometry 實踐，在某些案例中改善應用程式的幾何呈現效能。
ms.assetid: E8C4C4E5-3102-4F53-847E-A4C2D12A6921
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b903e047ee58a803a7584aaca407281fc803e30
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106968287"
---
# <a name="geometry-realizations-overview"></a><span data-ttu-id="da90e-103">幾何實現概觀</span><span class="sxs-lookup"><span data-stu-id="da90e-103">Geometry Realizations Overview</span></span>

<span data-ttu-id="da90e-104">本主題說明如何使用 [Direct2D](direct2d-portal.md) geometry 實踐，在某些案例中改善應用程式的幾何呈現效能。</span><span class="sxs-lookup"><span data-stu-id="da90e-104">This topic describes how to use [Direct2D](direct2d-portal.md) geometry realizations to improve your app’s geometry rendering performance in certain scenarios.</span></span>

<span data-ttu-id="da90e-105">它包含下列區段：</span><span class="sxs-lookup"><span data-stu-id="da90e-105">It contains the following sections:</span></span>

-   [<span data-ttu-id="da90e-106">什麼是幾何實踐？</span><span class="sxs-lookup"><span data-stu-id="da90e-106">What are geometry realizations?</span></span>](#what-are-geometry-realizations)
-   [<span data-ttu-id="da90e-107">為何要使用 geometry 實踐？</span><span class="sxs-lookup"><span data-stu-id="da90e-107">Why use geometry realizations?</span></span>](#why-use-geometry-realizations)
-   [<span data-ttu-id="da90e-108">使用 geometry 的時機實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-108">When to use geometry realizations</span></span>](#when-to-use-geometry-realizations)
-   [<span data-ttu-id="da90e-109">建立幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-109">Creating geometry realizations</span></span>](#creating-geometry-realizations)
-   [<span data-ttu-id="da90e-110">繪製幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-110">Drawing geometry realizations</span></span>](#drawing-geometry-realizations)
-   [<span data-ttu-id="da90e-111">調整幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-111">Scaling geometry realizations</span></span>](#scaling-geometry-realizations)
    -   [<span data-ttu-id="da90e-112">在無法調整的應用程式中使用 geometry 實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-112">Using geometry realizations in apps that do not scale</span></span>](#using-geometry-realizations-in-apps-that-do-not-scale)
    -   [<span data-ttu-id="da90e-113">在以小規模調整規模的應用程式中使用幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-113">Using geometry realizations in apps that scale by a small amount</span></span>](#using-geometry-realizations-in-apps-that-scale-by-a-small-amount)
    -   [<span data-ttu-id="da90e-114">在以大量規模調整的應用程式中使用幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-114">Using geometry realizations in apps that scale by a large amount</span></span>](#using-geometry-realizations-in-apps-that-scale-by-a-large-amount)
-   [<span data-ttu-id="da90e-115">相關主題</span><span class="sxs-lookup"><span data-stu-id="da90e-115">Related topics</span></span>](#related-topics)

## <a name="what-are-geometry-realizations"></a><span data-ttu-id="da90e-116">什麼是幾何實踐？</span><span class="sxs-lookup"><span data-stu-id="da90e-116">What are geometry realizations?</span></span>

<span data-ttu-id="da90e-117">幾何實踐（Windows 8.1 中引進）是一種新的繪圖基本類型，可讓 [Direct2D](direct2d-portal.md) 應用程式在某些情況下輕鬆地改善幾何轉譯效能。</span><span class="sxs-lookup"><span data-stu-id="da90e-117">Geometry realizations, introduced in Windows 8.1, are a new type of drawing primitive that make it easy for [Direct2D](direct2d-portal.md) apps to improve geometry rendering performance in certain cases.</span></span> <span data-ttu-id="da90e-118">幾何實踐是以 [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization) 介面表示。</span><span class="sxs-lookup"><span data-stu-id="da90e-118">Geometry realizations are represented by the [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization) interface.</span></span>

## <a name="why-use-geometry-realizations"></a><span data-ttu-id="da90e-119">為何要使用 geometry 實踐？</span><span class="sxs-lookup"><span data-stu-id="da90e-119">Why use geometry realizations?</span></span>

<span data-ttu-id="da90e-120">當 [Direct2D](direct2d-portal.md) 轉譯 [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry) 物件時，它必須將該幾何轉換成圖形硬體透過稱為鑲嵌的程式來理解的表單。</span><span class="sxs-lookup"><span data-stu-id="da90e-120">When [Direct2D](direct2d-portal.md) renders an [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry) object, it must convert that geometry to a form the graphics hardware understands through a process called tessellation.</span></span> <span data-ttu-id="da90e-121">一般而言，Direct2D 必須 tessellate 繪圖的每個框架，即使幾何未變更也是一樣。</span><span class="sxs-lookup"><span data-stu-id="da90e-121">Typically, Direct2D must tessellate geometry every frame it is drawn, even if the geometry does not change.</span></span> <span data-ttu-id="da90e-122">如果您的應用程式會在每個畫面格呈現相同的幾何，則重複的鑲嵌表示浪費的計算工作。</span><span class="sxs-lookup"><span data-stu-id="da90e-122">If your app renders the same geometry every frame, then the repeated re-tessellation represents wasted computational effort.</span></span> <span data-ttu-id="da90e-123">快取鑲嵌（甚至是完整的點陣化幾何），以及繪製該快取的標記法，而不是重複鑲嵌，會比較有效率。</span><span class="sxs-lookup"><span data-stu-id="da90e-123">It is more computationally efficient to cache the tessellation, or even the full rasterization, of the geometry, and to draw that cached representation each frame instead of repeatedly re-tessellating.</span></span>

<span data-ttu-id="da90e-124">開發人員解決此問題的常見方式是快取幾何的完整光柵。</span><span class="sxs-lookup"><span data-stu-id="da90e-124">A common way that developers solve this problem is to cache the full rasterization of the geometry.</span></span> <span data-ttu-id="da90e-125">尤其是建立新的點陣圖、將幾何柵格化至該點陣圖，然後視需要將該點陣圖繪製到場景的一般。</span><span class="sxs-lookup"><span data-stu-id="da90e-125">In particular, it is common to create a new bitmap, rasterize the geometry to that bitmap, and then draw that bitmap to the scene as needed.</span></span> <span data-ttu-id="da90e-126"> (這種方法會在改善 Direct2D 應用程式效能的 [幾何](improving-direct2d-performance.md) 轉譯區段中說明。 ) 雖然此方法的運算效率很高，但卻有一些缺點：</span><span class="sxs-lookup"><span data-stu-id="da90e-126">(This approach is described in the [Geometry rendering](improving-direct2d-performance.md) section of Improving the performance of Direct2D apps.) While this approach is very computationally efficient, it has some drawbacks:</span></span>

-   <span data-ttu-id="da90e-127">快取點陣圖對套用至場景的轉換變更很敏感。</span><span class="sxs-lookup"><span data-stu-id="da90e-127">The cached bitmap is sensitive to changes in the transform applied to the scene.</span></span> <span data-ttu-id="da90e-128">例如，調整點陣化可能會導致明顯的調整構件。</span><span class="sxs-lookup"><span data-stu-id="da90e-128">For example, scaling the rasterization can result in a noticeable scaling artifacts.</span></span> <span data-ttu-id="da90e-129">使用高品質的調整演算法來緩和這些構件可能會耗用大量運算資源。</span><span class="sxs-lookup"><span data-stu-id="da90e-129">Mitigating these artifacts with high-quality scaling algorithms can be computationally expensive.</span></span>
-   <span data-ttu-id="da90e-130">快取的點陣圖會耗用大量的記憶體，特別是在高解析度上進行柵格化時。</span><span class="sxs-lookup"><span data-stu-id="da90e-130">The cached bitmap consumes a significant amount of memory, especially if it is rasterized at a high resolution.</span></span>

<span data-ttu-id="da90e-131">幾何實踐提供另一種方式來快取幾何，以避免發生上述缺點。</span><span class="sxs-lookup"><span data-stu-id="da90e-131">Geometry realizations provide an alternative way to cache geometry that avoids the above drawbacks.</span></span> <span data-ttu-id="da90e-132">幾何實踐是以圖元為單位來表示 (，就像是完整的點陣化) ，而不是透過數學平面的點。</span><span class="sxs-lookup"><span data-stu-id="da90e-132">Geometry realizations are represented not by pixels (as is the case with a full rasterization) but instead by points on a mathematical plane.</span></span> <span data-ttu-id="da90e-133">基於這個理由，它們的機密性與調整和其他操作的完整 rasterizations 較不敏感，而且會耗用明顯較少的記憶體。</span><span class="sxs-lookup"><span data-stu-id="da90e-133">For this reason they are less sensitive than full rasterizations to scaling and other manipulation, and they consume significantly less memory.</span></span>

## <a name="when-to-use-geometry-realizations"></a><span data-ttu-id="da90e-134">使用 geometry 的時機實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-134">When to use geometry realizations</span></span>

<span data-ttu-id="da90e-135">當您的應用程式呈現不常變更但可能受限於變更轉換的複雜幾何時，請考慮使用幾何實踐。</span><span class="sxs-lookup"><span data-stu-id="da90e-135">Consider using geometry realizations when your app renders complex geometries whose shapes change infrequently but which may be subject to changing transforms.</span></span>

<span data-ttu-id="da90e-136">例如，假設有一個對應應用程式會顯示靜態地圖，但是可讓使用者放大和縮小。此應用程式可受益于使用幾何實踐。</span><span class="sxs-lookup"><span data-stu-id="da90e-136">For example, consider a mapping application that shows a static map but which allows the user to zoom in and out. This app can benefit from using geometry realizations.</span></span> <span data-ttu-id="da90e-137">由於正在轉譯的幾何會保持靜態，因此快取這些幾何有助於節省鑲嵌式工作的目的。</span><span class="sxs-lookup"><span data-stu-id="da90e-137">Since the geometries being rendered remain static, it is useful to cache them in order to save tessellation work.</span></span> <span data-ttu-id="da90e-138">但由於地圖是在使用者縮放時進行調整，因此因為調整成品，所以快取完整的點陣化並不理想。</span><span class="sxs-lookup"><span data-stu-id="da90e-138">But because the maps are scaled when the user zooms, caching a full rasterization is not ideal, due to scaling artifacts.</span></span> <span data-ttu-id="da90e-139">快取幾何實踐可讓應用程式避免重新分割的工作，同時在調整期間維持高視覺品質。</span><span class="sxs-lookup"><span data-stu-id="da90e-139">Caching geometry realizations would allow the app to avoid re-tessellation work while maintaining high visual quality during scaling.</span></span>

<span data-ttu-id="da90e-140">另一方面，請考慮具有會持續變更之動畫幾何的 kaleidoscope 應用程式。</span><span class="sxs-lookup"><span data-stu-id="da90e-140">On the other hand, consider a kaleidoscope app with animated geometry that continually changes.</span></span> <span data-ttu-id="da90e-141">此應用程式可能不會受益于使用幾何實踐。</span><span class="sxs-lookup"><span data-stu-id="da90e-141">This app would probably not benefit from using geometry realizations.</span></span> <span data-ttu-id="da90e-142">因為圖形本身會從框架變更為框架，所以快取其鑲嵌並不有用。</span><span class="sxs-lookup"><span data-stu-id="da90e-142">Since the shapes themselves change from frame to frame, it is not useful to cache their tessellations.</span></span> <span data-ttu-id="da90e-143">此應用程式的最佳方法是直接繪製 [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry) 物件。</span><span class="sxs-lookup"><span data-stu-id="da90e-143">The best approach for this app is to draw [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry) objects directly.</span></span>

## <a name="creating-geometry-realizations"></a><span data-ttu-id="da90e-144">建立幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-144">Creating geometry realizations</span></span>

<span data-ttu-id="da90e-145">必須從現有的 [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry)物件建立 [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization)物件。</span><span class="sxs-lookup"><span data-stu-id="da90e-145">An [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization) object must be created from an existing [**ID2D1Geometry**](/windows/win32/api/d2d1/nn-d2d1-id2d1geometry) object.</span></span> <span data-ttu-id="da90e-146">若要建立幾何實現，請呼叫 [**CreateFilledGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createfilledgeometryrealization) 方法或 [**CreateStrokedGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createstrokedgeometryrealization) 方法，並傳入要實現的 **ID2D1Geometry** 。</span><span class="sxs-lookup"><span data-stu-id="da90e-146">To create a geometry realization, call the [**CreateFilledGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createfilledgeometryrealization) method or the [**CreateStrokedGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createstrokedgeometryrealization) method and pass in the **ID2D1Geometry** to be realized.</span></span>

-   <span data-ttu-id="da90e-147">[**CreateFilledGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createfilledgeometryrealization) 會建立圖形內部的實現：要藉由呼叫 [**FillGeometry**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-fillgeometry)繪製的區域。</span><span class="sxs-lookup"><span data-stu-id="da90e-147">[**CreateFilledGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createfilledgeometryrealization) creates a realization of the interior of the shape: the region that would be drawn by calling [**FillGeometry**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-fillgeometry).</span></span>
-   <span data-ttu-id="da90e-148">[**CreateStrokedGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createstrokedgeometryrealization) 會建立圖形筆劃的實現：要藉由呼叫 [**DrawGeometry**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawgeometry)繪製的區域。</span><span class="sxs-lookup"><span data-stu-id="da90e-148">[**CreateStrokedGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-createstrokedgeometryrealization) creates a realization of the stroke of the shape: the region that would be drawn by calling [**DrawGeometry**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawgeometry).</span></span>

<span data-ttu-id="da90e-149">這兩種類型的幾何實現都會以 [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization) 介面表示。</span><span class="sxs-lookup"><span data-stu-id="da90e-149">Both kinds of geometry realization are represented by the [**ID2D1GeometryRealization**](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization) interface.</span></span>

<span data-ttu-id="da90e-150">建立幾何實現時， [Direct2D](direct2d-portal.md) 必須將所提供幾何中的任何曲線壓平合併成多邊形近似值。</span><span class="sxs-lookup"><span data-stu-id="da90e-150">When creating a geometry realization, [Direct2D](direct2d-portal.md) must flatten any curves in the provided geometry to polygonal approximations.</span></span> <span data-ttu-id="da90e-151">您必須將簡維容錯參數提供給建立方法，這會指定幾何的真正曲線與其多邊形近似值之間的最大距離（以與裝置無關的圖元為單位） (Dip) 。</span><span class="sxs-lookup"><span data-stu-id="da90e-151">You must provide a flattening tolerance parameter to the creation method—this specifies the maximum distance, in device-independent pixels (DIPs), between the geometry’s true curve and its polygonal approximation.</span></span> <span data-ttu-id="da90e-152">您提供的簡維容限越低，所產生之幾何實現物件的精確度就愈高。</span><span class="sxs-lookup"><span data-stu-id="da90e-152">The lower the flattening tolerance you provide, the higher the fidelity of the resulting geometry realization object.</span></span> <span data-ttu-id="da90e-153">同樣地，提供較高的簡維公差會產生較低精確度的幾何實現。</span><span class="sxs-lookup"><span data-stu-id="da90e-153">Similarly, providing a higher flattening tolerance yields a lower-fidelity geometry realization.</span></span> <span data-ttu-id="da90e-154">請注意，更高精確度幾何實踐的繪製成本比較低的精確度更高，但可以在引進可見成品之前進一步調整。</span><span class="sxs-lookup"><span data-stu-id="da90e-154">Note that higher-fidelity geometry realizations are more expensive to draw than lower-fidelity ones, but they can be scaled further before introducing visible artifacts.</span></span> <span data-ttu-id="da90e-155">如需使用簡維容限的指引，請參閱下方的 [縮放幾何實踐](#scaling-geometry-realizations) 。</span><span class="sxs-lookup"><span data-stu-id="da90e-155">For guidance on using flattening tolerances, see [Scaling geometry realizations](#scaling-geometry-realizations) below.</span></span>

> [!Note]  
> <span data-ttu-id="da90e-156">幾何實現物件與特定圖形裝置相關聯：它們是與裝置相關的資源。</span><span class="sxs-lookup"><span data-stu-id="da90e-156">Geometry realization objects are associated with a particular graphics device: they are device-dependent resources.</span></span>

 

## <a name="drawing-geometry-realizations"></a><span data-ttu-id="da90e-157">繪製幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-157">Drawing geometry realizations</span></span>

<span data-ttu-id="da90e-158">繪製幾何實踐類似于繪製其他 [Direct2D](direct2d-portal.md) 基本專案，例如點陣圖。</span><span class="sxs-lookup"><span data-stu-id="da90e-158">Drawing geometry realizations is similar to drawing other [Direct2D](direct2d-portal.md) primitives, like bitmaps.</span></span> <span data-ttu-id="da90e-159">若要這樣做，請呼叫 [**DrawGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-drawgeometryrealization) 方法，並將要繪製的幾何實現物件和要使用的筆刷傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="da90e-159">To do so, call the [**DrawGeometryRealization**](/windows/win32/api/d2d1_2/nf-d2d1_2-id2d1devicecontext1-drawgeometryrealization) method and pass it the geometry realization object to be drawn and the brush to use.</span></span> <span data-ttu-id="da90e-160">如同其他 Direct2D 繪圖方法，您必須在對 [**BeginDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-begindraw)和 [**EndDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-enddraw)的呼叫之間呼叫 **DrawGeometryRealization** 。</span><span class="sxs-lookup"><span data-stu-id="da90e-160">As with other Direct2D drawing methods, you must call **DrawGeometryRealization** between calls to [**BeginDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-begindraw) and [**EndDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-enddraw).</span></span>

## <a name="scaling-geometry-realizations"></a><span data-ttu-id="da90e-161">調整幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-161">Scaling geometry realizations</span></span>

<span data-ttu-id="da90e-162">幾何實踐就像其他 [Direct2D](direct2d-portal.md) 基本專案一樣，會遵循裝置內容上的轉換集。</span><span class="sxs-lookup"><span data-stu-id="da90e-162">Geometry realizations, like other [Direct2D](direct2d-portal.md) primitives, respect the transform set on the device context.</span></span> <span data-ttu-id="da90e-163">雖然平移和旋轉轉換對幾何實踐的視覺品質沒有任何影響，但調整規模轉換可以產生視覺構件。</span><span class="sxs-lookup"><span data-stu-id="da90e-163">Although translation and rotation transforms have no effect on the visual quality of geometry realizations, scale transforms can produce visual artifacts.</span></span>

<span data-ttu-id="da90e-164">尤其是，將夠大的小數位數套用至任何幾何實現可以顯示真正曲線的多邊形近似值。</span><span class="sxs-lookup"><span data-stu-id="da90e-164">In particular, applying a large enough scale to any geometry realization can reveal the polygonal approximation of the true curves.</span></span> <span data-ttu-id="da90e-165">此處的影像顯示一組橢圓形幾何實踐 (填滿和筆劃) 已相應放大。</span><span class="sxs-lookup"><span data-stu-id="da90e-165">The image here shows a pair of elliptical geometry realizations (fill and stroke) that have been scaled up too far.</span></span> <span data-ttu-id="da90e-166">曲線-簡維構件是可見的。</span><span class="sxs-lookup"><span data-stu-id="da90e-166">Curve-flattening artifacts are visible.</span></span>

![一組橢圓形幾何實踐 (填滿和筆劃) ，已相應放大。](images/zoomed-in.png)

<span data-ttu-id="da90e-169">區分視覺品質的應用程式應該採取措施來確保不會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="da90e-169">Apps that are sensitive to visual quality should take measures to ensure this does not happen.</span></span> <span data-ttu-id="da90e-170">您處理調整的方式取決於您的應用程式需求。</span><span class="sxs-lookup"><span data-stu-id="da90e-170">How you handle scaling depends on the needs of your app.</span></span> <span data-ttu-id="da90e-171">以下是數種不同類型應用程式的幾個建議方法。</span><span class="sxs-lookup"><span data-stu-id="da90e-171">Following are several recommended approaches for several different types of app.</span></span>

### <a name="using-geometry-realizations-in-apps-that-do-not-scale"></a><span data-ttu-id="da90e-172">在無法調整的應用程式中使用 geometry 實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-172">Using geometry realizations in apps that do not scale</span></span>

<span data-ttu-id="da90e-173">如果您的應用程式不會在幾何實踐上執行任何調整，則可以使用單一簡維容錯來安全地建立實踐一次。</span><span class="sxs-lookup"><span data-stu-id="da90e-173">If your app does not perform any scaling on the geometry realizations, then it is safe to create the realizations only once, using a single flattening tolerance.</span></span> <span data-ttu-id="da90e-174"> (非縮放轉換並不會影響呈現幾何實踐的視覺品質。 ) 使用 [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)) 函式來計算 DPI 的適當簡維容限：</span><span class="sxs-lookup"><span data-stu-id="da90e-174">(Non-scaling transforms do not affect the visual quality of rendered geometry realizations.) Use the [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)) function to calculate the appropriate flattening tolerance for the DPI:</span></span>


```C++
    float dpiX, dpiY;
    deviceContext->GetDpi(&dpiX, &dpiY);

    float flatteningTolerance = D2D1::ComputeFlatteningTolerance(
        D2D1::Matrix3x2F::Identity(),   // apply no additional scaling transform
        dpiX,                           // horizontal DPI
        dpiY                            // vertical DPI
        );
```



### <a name="using-geometry-realizations-in-apps-that-scale-by-a-small-amount"></a><span data-ttu-id="da90e-175">在以小規模調整規模的應用程式中使用幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-175">Using geometry realizations in apps that scale by a small amount</span></span>

<span data-ttu-id="da90e-176">如果您的應用程式只能以少量的 (（例如，最多2x 或 3) 倍）來調整幾何的實現，則最好只以比例較低的簡維容限來建立幾何實現一次，而不是預設值。</span><span class="sxs-lookup"><span data-stu-id="da90e-176">If your app can scale a geometry realization up by only a small amount (for example, up to 2x or 3x), then it may be appropriate simply to create the geometry realization once, at a proportionally lower flattening tolerance than the default.</span></span> <span data-ttu-id="da90e-177">這會建立更高精確度的實現，可在產生調整構件之前大幅相應增加;權衡代價是，繪製更高精確度的實現需要更多工作。</span><span class="sxs-lookup"><span data-stu-id="da90e-177">This creates a higher-fidelity realization that can be scaled up significantly before incurring scaling artifacts; the trade-off is that drawing the higher-fidelity realization requires more work.</span></span>

<span data-ttu-id="da90e-178">例如，假設您知道您的應用程式永遠不會將幾何實現調整為超過2倍。</span><span class="sxs-lookup"><span data-stu-id="da90e-178">For example, suppose you know that your app will never scale a geometry realization by more than 2x.</span></span> <span data-ttu-id="da90e-179">您的應用程式可以使用預設值一半的簡維容錯來建立幾何實現，並視需要調整實現，最多可達2倍。</span><span class="sxs-lookup"><span data-stu-id="da90e-179">Your app can create the geometry realization using a flattening tolerance that’s half the default value and simply scale the realization as needed, up to 2x.</span></span> <span data-ttu-id="da90e-180">使用 [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)) 函式來計算適當的簡維容限，方法是將2.0 傳遞為 *maxZoomFactor* 參數：</span><span class="sxs-lookup"><span data-stu-id="da90e-180">Use the [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)) function to calculate the appropriate flattening tolerance by passing 2.0 as the *maxZoomFactor* parameter:</span></span>


```C++
    float dpiX, dpiY;
    deviceContext->GetDpi(&dpiX, &dpiY);
    
    float flatteningTolerance = D2D1::ComputeFlatteningTolerance(
        D2D1::Matrix3x2F::Identity(),   // apply no additional scaling transform
        dpiX,                           // horizontal DPI
        dpiY,                           // vertical DPI
        2.0f                            // realization can be scaled by an additional 2x
        );
```



### <a name="using-geometry-realizations-in-apps-that-scale-by-a-large-amount"></a><span data-ttu-id="da90e-181">在以大量規模調整的應用程式中使用幾何實踐</span><span class="sxs-lookup"><span data-stu-id="da90e-181">Using geometry realizations in apps that scale by a large amount</span></span>

<span data-ttu-id="da90e-182">如果您的應用程式可以將幾何的數量調整為大量 (例如10倍以上的) ，則適當地處理調整會更複雜。</span><span class="sxs-lookup"><span data-stu-id="da90e-182">If your app can scale a geometry realization up or down by large amounts (for example, by 10x or more), then handling scaling appropriately is more complicated.</span></span>

<span data-ttu-id="da90e-183">針對大部分的應用程式，建議的方法是在場景相應增加時，以逐漸較低的簡維公差重新建立幾何實現，以維持視覺效果的精確度，並避免調整成品。</span><span class="sxs-lookup"><span data-stu-id="da90e-183">For most of these apps, the recommended approach is to recreate the geometry realization at progressively lower flattening tolerances as the scene is scaled up, in order to maintain visual fidelity and avoid scaling artifacts.</span></span> <span data-ttu-id="da90e-184">同樣地，當場景縮小時，應用程式應該以逐漸較高的簡維公差重新建立幾何實踐，以避免 wastefully 無法顯示的呈現詳細資料。</span><span class="sxs-lookup"><span data-stu-id="da90e-184">Similarly, as the scene is scaled down, the app should recreate the geometry realizations at progressively higher flattening tolerances, in order to avoid wastefully rendering details that aren’t visible.</span></span> <span data-ttu-id="da90e-185">應用程式不應該在每次調整規模時重新建立幾何實踐，因為這樣做會使您無法快取鑲嵌式工作的目的。</span><span class="sxs-lookup"><span data-stu-id="da90e-185">The app shouldn’t recreate the geometry realizations every time the scale changes, because doing so defeats the purpose of caching the tessellation work.</span></span> <span data-ttu-id="da90e-186">相反地，應用程式應該不常重新建立幾何實踐：例如，每隔2倍增加或減少尺規。</span><span class="sxs-lookup"><span data-stu-id="da90e-186">Instead, the app should recreate the geometry realizations less frequently: for example, after every 2x increase or decrease in scale.</span></span>

<span data-ttu-id="da90e-187">每次調整應用程式中的規模，以回應使用者互動時，應用程式可以將新的規模與上次建立幾何實踐的尺規做比較 (儲存，例如，在 **m \_ lastScale** 成員) 中。</span><span class="sxs-lookup"><span data-stu-id="da90e-187">Each time the scale changes in an app in response to user interaction, the app could compare the new scale against the scale at which the geometry realizations were last created (stored, for example, in an **m\_lastScale** member).</span></span> <span data-ttu-id="da90e-188">如果兩個值都是 close (在此案例中，在 2) 的因數內，則不會採取進一步的動作。</span><span class="sxs-lookup"><span data-stu-id="da90e-188">If the two values are close (in this case, within a factor of 2), then no further action is taken.</span></span> <span data-ttu-id="da90e-189">但是，如果這兩個值不是關閉的，則會重新建立幾何實踐。</span><span class="sxs-lookup"><span data-stu-id="da90e-189">But if the two values are not close, then the geometry realizations are re-created.</span></span> <span data-ttu-id="da90e-190">[**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85))函式可用來計算適用于新尺規的簡維容限，而 **m \_ lastScale** 會更新為新的尺規。</span><span class="sxs-lookup"><span data-stu-id="da90e-190">The [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)) function is used to compute a flattening tolerance appropriate for the new scale, and **m\_lastScale** is updated to the new scale.</span></span>

<span data-ttu-id="da90e-191">此外，應用程式一律會使用較小的容錯來建立實踐，其使用方式會比通常用於新的小數位數還要小，方法是將2的值當做 *maxZoomFactor* 參數傳遞至 [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="da90e-191">In addition, the app always creates realizations using a smaller tolerance than what would normally be used for the new scale, by passing a value of 2 as the *maxZoomFactor* parameter to [**ComputeFlatteningTolerance**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85)).</span></span> <span data-ttu-id="da90e-192">這可讓新的幾何實踐以額外的因數2來相應增加，而不會產生調整成品。</span><span class="sxs-lookup"><span data-stu-id="da90e-192">This allows the new geometry realizations to be scaled up by an additional factor of 2 without incurring scaling artifacts.</span></span>

> [!Note]  
> <span data-ttu-id="da90e-193">此處所述的方法可能不適合所有的應用程式。</span><span class="sxs-lookup"><span data-stu-id="da90e-193">The approach described here may not be appropriate for all apps.</span></span> <span data-ttu-id="da90e-194">比方說，如果您的應用程式允許以非常大的因素來調整場景 (例如，如果它包含可從100% 移至1000000% 的「縮放」滑杆（在幾個) 框架的範圍內），則這種方法可能會藉由重新建立每個畫面格的幾何實踐來產生過度的工作。</span><span class="sxs-lookup"><span data-stu-id="da90e-194">For example, if your app allows the scene to be scaled by very large factors very quickly (for example, if it contains a “zoom” slider that can be moved from 100% to 1,000,000% in the span of a few frames) then this approach may result in excess work by recreating the geometry realizations every frame.</span></span> <span data-ttu-id="da90e-195">替代方法是在每次完成場景規模的操作之後，才重新建立幾何實踐，例如，在使用者完成縮小手勢) 之後 (。</span><span class="sxs-lookup"><span data-stu-id="da90e-195">An alternative approach is to recreate the geometry realizations only after each manipulation of the scene’s scale has been completed (for example, after the user has completed a pinch gesture).</span></span>

 

## <a name="related-topics"></a><span data-ttu-id="da90e-196">相關主題</span><span class="sxs-lookup"><span data-stu-id="da90e-196">Related topics</span></span>

[<span data-ttu-id="da90e-197">幾何概觀</span><span class="sxs-lookup"><span data-stu-id="da90e-197">Geometries Overview</span></span>](direct2d-geometries-overview.md)

[<span data-ttu-id="da90e-198">改善 Direct2D 應用程式的效能</span><span class="sxs-lookup"><span data-stu-id="da90e-198">Improving the performance of Direct2D apps</span></span>](improving-direct2d-performance.md)

[<span data-ttu-id="da90e-199">呈現複雜靜態內容的一般指導方針</span><span class="sxs-lookup"><span data-stu-id="da90e-199">General guidelines for rendering complex static content</span></span>](improving-direct2d-performance.md)

[<span data-ttu-id="da90e-200">**ID2D1DeviceCoNtext1**</span><span class="sxs-lookup"><span data-stu-id="da90e-200">**ID2D1DeviceContext1**</span></span>](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1devicecontext1)

[<span data-ttu-id="da90e-201">**ID2D1GeometryRealization**</span><span class="sxs-lookup"><span data-stu-id="da90e-201">**ID2D1GeometryRealization**</span></span>](/windows/win32/api/d2d1_2/nn-d2d1_2-id2d1geometryrealization)

<span data-ttu-id="da90e-202">[**ComputeFlatteningTolerance 函式**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="da90e-202">[**ComputeFlatteningTolerance function**](/previous-versions/windows/desktop/legacy/dn280327(v=vs.85))</span></span>