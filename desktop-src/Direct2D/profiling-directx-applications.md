---
title: 分析 DirectX 應用程式
description: 示範如何使用隨附于 Windows 效能工具組一部分的 XPerf 和 GPUView 工具，測量 DirectX 應用程式的一些最重要效能時間度量。
ms.assetid: 4B2F7273-C9B0-4DD3-B559-6220CDE62129
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c923f2917dbb8695bcd624f4d998043e7218cf2f976b19b24ab4cff2bc65f398
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "118665363"
---
# <a name="profiling-directx-apps"></a>分析 DirectX 應用程式

這會示範如何使用隨附于 Windows 效能工具組一部分的 **XPerf** 和 **GPUView** 工具，測量 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10))應用程式的一些最重要效能時間度量。 這不是瞭解工具的完整指南，而是用來分析 DirectX 應用程式效能的特定適用性。 雖然這裡討論的大部分技巧都與所有 DirectX 應用程式有關，但它最適用于使用交換鏈的應用程式，而不是使用 SIS/VSI 和 XAML 動畫的 XAML 上建的 DirectX 應用程式。 我們會逐步引導您進行關鍵效能時間測量、如何取得及安裝工具，以及採取效能測量追蹤，然後加以分析以瞭解應用程式的瓶頸。

## <a name="about-the-tools"></a>關於工具

### <a name="xperf"></a>**XPerf**

**XPerf** 是一組以 Windows (ETW) 為基礎的效能分析工具，其設計目的是用來測量和分析詳細的系統和應用程式效能和資源使用量。 從 Windows 8 開始，此命令列工具具有圖形化使用者介面，稱為 Windows Performance Recorder (WPR) 和 Windows Performance Analyzer (WPA) 。 如需這些工具的詳細資訊，請參閱[Windows 效能](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10))工具組的網頁 (WPT) ： [Windows 效能工具](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10))組。

ETW 會收集要求的核心事件，並將它們儲存到稱為事件追蹤記錄檔的檔案中， (ETL) 檔。 這些核心事件可在執行應用程式時提供有關應用程式和系統特性的廣泛資訊。 資料的收集方式是啟用追蹤捕捉，執行需要分析的所需應用程式案例，並停止將資料儲存在 ETL 檔案中的捕捉。 然後，您可以使用命令列工具 **xperf.exe** 或視覺化追蹤分析工具 **xperfview.exe**，在相同或不同的電腦上分析檔案。

### <a name="gpuview"></a>GPUView

**GPUView** 是一種開發工具，可判斷圖形處理器 (GPU) 和 CPU 的效能。 它會查看 (DMA) 緩衝區處理和影片硬體上所有其他影片處理方面的直接記憶體存取相關效能。

針對依賴 GPU 的 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) 應用程式， **GPUView** 是一項功能強大的工具，可瞭解在 CPU 與 gpu 上完成的工作之間的關聯性。 如需 **GPUView** 的詳細資訊，請參閱 [使用 GPUView](/windows-hardware/drivers/display/using-gpuview)。

類似于 **XPerf**，會先啟動追蹤服務來執行 ETW 追蹤，演練需要考慮的應用程式的案例，以停止服務並將資訊儲存在 ETL 檔案中。 **GPUView** 會以圖形格式呈現 ETL 檔案中的資料。

安裝 **GPUView** 工具之後，建議您閱讀 [**GPUView** 說明] 功能表下的「**GPUView** 的主顯示器」主題。 其中包含有關如何解讀 **GPUView** UI 的實用資訊。

## <a name="installing-the-tools"></a>安裝工具

**XPerf** 和 **GPUView** 都包含在 Windows 效能工具組中 (WPT) 。

**XPerf** 隨附于 Windows Windows 軟體開發套件 (SDK) 的一部分。 [下載 Windows SDK](https://dev.windows.com/downloads)。

**GPUView** 可在 Windows 評定及部署套件中取得 (Windows ADK) 。 [下載 Windows ADK](/windows-hardware/get-started/adk-install)。

安裝之後，您必須將包含 **XPerf** 和 **GPUView** 的目錄新增至系統 "Path" 變數。

按一下 [[開始] 按鈕]，然後輸入「系統變數」。 系統屬性視窗隨即開啟。 按一下 [編輯系統內容變數]。 從 [系統屬性] 對話方塊中選取 [環境變數]。 "Path" 變數位於「系統變數」下。 將包含 **xperf.exe** 和 **GPUView.exe** 的目錄附加至路徑。 這些可執行檔可在「Windows 套件」內的「Windows 效能工具組」目錄中找到。 預設位置是： **C： \\ Program Files (x86) \\ Windows 套件 \\ 10 \\ Windows 效能工具** 組。

## <a name="performance-time-measurements"></a>效能時間度量

大部分的應用程式預期會順暢地執行，並回應使用者輸入。 不過，根據您想要的案例，效能的一個層面可能比另一個層面更重要。 比方說，對於在觸控式平板電腦上執行的新聞讀取器應用程式，最重要的層面是一次查看單一文章，並透過相同或不同的文章來平移/縮放/滾動。 在此情況下，不需要每個畫面格轉譯所有內容的能力。 不過，在觸控手勢上順暢地滾動文章的功能非常重要。

在另一個實例中，如果已卸載框架，則會使用大量動畫的遊戲或影片轉譯應用程式。 在此情況下，若要在螢幕上顯示內容而不中斷使用者輸入，這項功能非常重要。

為了瞭解應用程式的哪個部分有問題，第一個步驟是決定最重要的案例。 一旦瞭解應用程式的核心層面，以及它們的運用方式，使用工具來尋找問題就變得更容易。

其中一些最常見的效能時間計量如下：

### <a name="startup-time"></a>啟動時間

從進程啟動到第一次出現畫面所測量的時間。 當系統暖表示在應用程式啟動幾次之後進行測量時，此測量會更有用。

### <a name="cpu-time-per-frame"></a>每一畫面的 CPU 時間

CPU 針對一個畫面格主動處理應用程式工作負載的時間。 如果應用程式順利執行，則一個畫面格所需的所有處理都會在一個 v 同步間隔內發生。 由於監視器的重新整理頻率為60Hz，因此每個框架16毫秒。 如果 CPU 時間/框架大於16毫秒，可能需要 CPU 優化才能產生無問題的免費應用程式體驗。

### <a name="gpu-time-per-frame"></a>每個畫面的 GPU 時間

GPU 主動處理一個畫面格的應用程式工作負載的時間。 當處理資料框架所需的時間超過16毫秒時，應用程式會受到 GPU 系結。

能夠瞭解應用程式是否為 CPU 或 GPU 系結，將會縮小程式代碼的問題部分。

## <a name="taking-performance-time-measurement-trace"></a>採用效能時間測量追蹤

執行下列步驟以進行追蹤：

1.  以系統管理員身分開啟命令視窗。
2.  如果應用程式已在執行中，請加以關閉。
3.  將目錄變更為 Windows 效能工具組資料夾內的 *gpuview* 目錄。
4.  輸入 "log .cmd" 以啟動事件追蹤。 此選項會記錄最感興趣的事件。 其他可用的選項會記錄不同的事件範圍。 例如，' v ' 或詳細資訊記錄模式會捕捉 **GPUView** 感知的所有事件。
5.  啟動範例，並以涵蓋您需要分析之效能路徑的方式來練習範例。
6.  返回至命令視窗，然後再次輸入 "log .cmd" 以停止記錄。
7.  這會在 *gpuview* 資料夾中輸出稱為「已合併的 etl」的檔案。 您可以將此檔案儲存到另一個位置，也可以在相同或不同的電腦上進行分析。 若要查看堆疊捕捉的詳細資料，請將符號檔儲存 ( .pdb) 與應用程式相關聯。

## <a name="measurements"></a>量測


> [!Note]  
> 幾何實現範例的度量是在具有整合式 DirectX11 圖形配接器的四核心電腦上執行。 度量會根據電腦設定而有所不同。

 

本節示範如何測量每一框架測量的啟動時間、CPU 和 GPU 時間。 您可以在電腦上為相同的範例捕捉效能追蹤，並查看各種度量的差異。

若要在 **GPUView** 中分析追蹤，請使用 **GPUView.exe** 開啟「合併的 elt」檔案。

### <a name="startup-time"></a>啟動時間

啟動時間是以應用程式啟動所花費的總時間來測量，直到內容先顯示在畫面上為止。

您可以依照上一節中所列的步驟，使用這些變化來執行啟動時間測量：

-   如果您在第一次啟動應用程式時開始測量，就稱為「冷啟動」。 這可能與您在短時間內啟動應用程式數次之後所採取的測量不同。 這稱為「暖開機」。 視應用程式在啟動時所建立的資源數量而定，這兩個啟動時間之間可能會有很大的差異。 視應用程式目標而定，可能會需要測量其中一個。
-   當您記錄效能資訊時，只要畫面上出現第一個框架，就會終止應用程式。

### <a name="calculating-start-up-time-using-gpuview"></a>使用 **GPUView** 計算啟動時間

1.  在 **GPUView** 中，向下滾動至相關的程式，在此案例中 GeometryRealization.exe。

    ![顯示 GPUView 中進程範例的螢幕擷取畫面。](images/profile1.png)

2.  內容 CPU 佇列代表將圖形工作負載排入硬體佇列，但不一定是由硬體處理。 開啟追蹤檔案時，它會顯示在追蹤進行期間所記錄的所有事件。 若要計算啟動時間，請選取感興趣的區域，並放大第一個內容 CPU 佇列的初始部分 (這是使用 Ctrl + Z 顯示活動) 的部分。 如需有關 **GPUView** 控制項的詳細資訊，請參閱 **GPUView** 說明檔區段「 **GPUView** 控制項的摘要」。 下圖只會顯示放大至內容 CPU 佇列第一個部分的 GeometryRealization.exe 進程。 內容 CPU 佇列的色彩是由佇列下方的矩形表示，而佇列中的相同色彩資料封包會顯示在硬體上排入佇列的 GPU 工作。 內容佇列中的影線模式封包會顯示目前的封包，這表示應用程式希望硬體能在螢幕上呈現內容。

    ![顯示「內容 C P U 佇列」範例的螢幕擷取畫面。](images/profile2.png)

3.  啟動時間是應用程式第一次啟動的時間 (在此案例中，UI 執行緒進入點模組 SHCORE.dll) 到內容第一次出現 (以影線封包) 標記的時間為止。 這裡的圖表強調顯示感興趣的區域。

    > [!Note]  
    > 實際的顯示資訊會顯示在 flip 佇列中，因此會延長所花費的時間，直到目前的封包在翻轉佇列中實際完成為止。

     

    下圖中看不到完整的狀態列，也會顯示反白顯示部分之間的經過時間。 這是應用程式的啟動時間。 在此案例中，這是關於上述電腦的240ms。

    ![顯示有關「內容 C P U 佇列」中啟動時間的相關區域的螢幕擷取畫面。](images/profile3.png)

### <a name="cpu-and-gpu-time-per-frame"></a>每個畫面的 CPU 和 GPU 時間

在測量 CPU 時間時，有幾件事需要考慮。 尋找追蹤中您已執行案例分析的區域。 例如，在幾何實現範例中，已分析的其中一個案例是轉譯2048和8192基本專案之間的轉換，所有未實現的 (如中所示，幾何都不會鑲嵌每個畫面格) 。 此追蹤會清楚顯示在轉換的基本專案數前後的 CPU 和 GPU 活動差異。

分析兩個案例，以計算每個畫面的 CPU 和 GPU 時間。 它們如下所示。

-   從轉譯2048未實現的基本專案轉換為8192個未實現的基本型別。
-   從轉譯8192已實現的基本專案轉換為8192的已實現基本專案。

在這兩種情況下，觀察到的畫面播放速率會大幅下降。 測量 CPU 和 GPU 時間，追蹤兩者之間的關聯性和其他幾個模式之間的關聯性，可提供應用程式中有問題區域的有用資訊。

### <a name="calculating-cpu-and-gpu-time-when-2048-primitives-are-being-rendered-unrealized"></a>計算未實現2048基本型別時的 CPU 和 GPU 時間

1.  使用 **GPUView.exe** 開啟追蹤檔案。
2.  向下滾動至 GeometryRealization.exe 進程。
3.  選取用來計算 CPU 時間的區域，並使用 CTRL + Z 來放大。

    ![螢幕擷取畫面，顯示已選取的區域，可在「內容 CPU 佇列」中計算 C P U 時間。](images/profile4.png)

4.  在 F8 之間切換，以顯示 v 同步資訊。 一直放大，直到很容易就能清楚看到一個 vsync 的資料。 藍線是 v 同步處理時間。 通常，這些會在每16毫秒 (60 fps) 發生一次，但如果 DWM 遇到效能問題，則會以較慢的速度執行，因此每 32 ms (30 fps) 會發生一次。 若要瞭解時間，請選取下一個藍色橫條，然後查看 [ **GPUView** ] 視窗右下角所報告的 ms 數目。

    ![顯示 v 同步時間範例的螢幕擷取畫面。](images/profile5.png)

5.  若要測量每個畫面格的 CPU 時間，請測量所有涉及轉譯的執行緒所花費的時間長度。 從效能的觀點來看，可能會讓預期最相關的執行緒縮小。 例如，在幾何實現範例中，內容會製作動畫，而且必須在每個畫面格上轉譯，讓 UI 執行緒成為重要的畫面格。 一旦您決定要查看哪一個執行緒，請測量這個執行緒上的橫條長度。 每個畫面的平均 CPU 時間數平均。 下圖顯示 UI 執行緒所花的時間。 它也會顯示這段時間在兩個連續的雙同步處理（亦即60FPS）之間非常適合。

    ![顯示 U I 執行緒所花費時間的螢幕擷取畫面。](images/profile6.png)

    您也可以查看相對應時間範圍的翻轉佇列來進行驗證，這會顯示 DWM 可以呈現每個畫面格。

    ![顯示「翻轉佇列」範例的螢幕擷取畫面。](images/profile7.png)

6.  您可以用與 CPU 時間相同的方式來測量 GPU 時間。 在測量 CPU 時間的情況下，放大相關區域。 使用與內容 CPU 佇列色彩相同的色彩，測量 GPU 硬體佇列中的橫條長度。 只要橫條符合連續的雙同步處理，應用程式就會在60FPS 中順利執行。

    ![顯示「GPU 硬體佇列」範例的螢幕擷取畫面，其中顯示應用程式正在 60 F P S 執行的資訊。](images/profile8.png)

### <a name="calculating-cpu-and-gpu-time-when-8192-primitives-are-being-rendered-unrealized"></a>計算未實現8192基本型別時的 CPU 和 GPU 時間

1.  如果您再次遵循相同的步驟，追蹤會顯示一個畫面格的所有 CPU 工作都不符合一個 v 同步與下一個畫面。 這表示應用程式已受 CPU 限制。 UI 執行緒會將 CPU 飽和。

    ![顯示 UI 執行緒的範例會使 C P U 飽和的螢幕擷取畫面。](images/profile9.png)

    查看翻轉佇列，也可以清楚地指出 DWM 無法顯示每個畫面格。

    ![顯示 D W M 無法顯示每個畫面格範例的螢幕擷取畫面。](images/profile10.png)

2.  為了分析花費時間的時間，請在 **XPerf** 中開啟追蹤。 若要分析 **XPerf** 中的啟動時間，請先找出 **GPUView** 中的時間間隔。 將滑鼠移到間隔左邊和右邊，並記下 [ **GPUView** ] 視窗底部所顯示的絕對時間。 然後，在 **XPerf** 中開啟相同的 .etl 檔案，並向下滾動至 [cpu 取樣（依 cpu）] 圖形，以滑鼠右鍵按一下並選取 [選取間隔 ...]這可讓您輸入感興趣的間隔，也就是查看 GPU 追蹤所發現的。

    ![螢幕擷取畫面，顯示「Windows 效能分析」中的「c p u 依 c p u 取樣」。](images/profile11.png)

3.  移至追蹤功能表，並確認已核取 [載入符號]。 此外，請移至追蹤 > 設定符號路徑，然後輸入應用程式符號路徑。 符號檔包含有關個別資料庫中已編譯之可執行檔的偵錯工具 ( .pdb) 。 這個檔案通常稱為 PDB。 您可以在這裡找到符號檔的詳細資訊： [符號](/windows/desktop/Debug/symbol-files)檔。 您可以在應用程式目錄的 "Debug" 資料夾中找到這個檔案。

4.  若要取得應用程式中花費時間的明細，請以滑鼠右鍵按一下上一個步驟中選取的間隔，然後按一下 [摘要資料表]。 若要深入瞭解每個 dll 花費了多少時間，請從 [資料行] 功能表取消核取 [堆疊]。 請注意，此處的 [計數] 資料行會顯示指定的 dll/函式內有多少樣本。 因為每毫秒大約會採用一個樣本，所以這個數位可以用來做為每個 dll/函式中花費多少時間的最佳猜測。 核取 [從資料行] 功能表中的 [堆疊]，將會提供在呼叫圖形中的每個函式中花費的時間。 這將有助於進一步細分問題點。

5.  2048未取得基本專案的堆疊追蹤資訊會顯示 CPU 時間的30% 花費在幾何實現進程中。 大約36% 的時間會花在幾何鑲嵌和筆劃中。

6.  8192的原始基本專案的堆疊追蹤資訊會顯示大約60% 的 CPU 時間 (4 個核心) 用於幾何實現。

    ![顯示 C P U 時間堆疊追蹤資訊的螢幕擷取畫面。](images/profile12.png)

### <a name="calculating-cpu-time-when-8192-primitives-are-being-rendered-realized"></a>在轉譯8192基本專案時計算 CPU 時間

您可以從設定檔中清楚知道應用程式是受 CPU 限制的。 為了減少 CPU 花費的時間，您可以建立一次並快取幾何。 快取的內容可以在每個畫面格轉譯，而不會產生每個畫面的幾何鑲嵌成本。 當您在 **GPUView** 中查看應用程式已實現部分的追蹤時，您可以清楚讓 DWM 呈現每個畫面格，而且 CPU 時間已大幅降低。

![顯示 GPUView 中的追蹤範例的螢幕擷取畫面，其中顯示 D W M 可以顯示每個畫面格。](images/profile13.png)

圖形的第一個部分顯示已實現的8192基本專案。 每個畫面的對應 CPU 時間可以容納在兩個連續的雙同步處理中。 在圖的稍後部分中，這不是正確的。

在 **XPerf** 中，cpu 處於閒置狀態的最長時間，只有大約25% 的 cpu 時間花在幾何實現應用程式上。

![gpuview 螢幕擷取畫面。](images/profile14.png)

## <a name="summary"></a>摘要

**GPUView** 和 **XPerf** ，以及用來分析 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10))應用程式效能的強大工具。 本文是使用這些工具，以及瞭解基本效能度量和應用程式特性的入門。 除了瞭解工具的使用方式，您必須先瞭解正在分析的應用程式。 開始找出問題的答案，例如應用程式嘗試達成什麼目標？ 系統中的哪些執行緒最重要？ 您願意做出哪些取捨？ 分析效能追蹤時，請先查看明顯有問題的地方。 應用程式 CPU 或 GPU 是否受限制？ 應用程式是否能夠呈現每個畫面格？ 工具以及對應用程式的瞭解，可以提供非常實用的資訊來瞭解、尋找並最後解決效能問題。

 

 