---
title: 分析 DirectX 應用程式
description: 說明如何使用 Windows 效能工具組隨附的 XPerf 和 GPUView 工具，測量 DirectX 應用程式的一些最重要效能時間測量。
ms.assetid: 4B2F7273-C9B0-4DD3-B559-6220CDE62129
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0280389d4f8f2161e5e07f8906df7ea0484ad458
ms.sourcegitcommit: 37f276b5d887a3aad04b1ba86e390dea9d87e591
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/04/2021
ms.locfileid: "104568735"
---
# <a name="profiling-directx-apps"></a><span data-ttu-id="468e7-103">分析 DirectX 應用程式</span><span class="sxs-lookup"><span data-stu-id="468e7-103">Profiling DirectX Apps</span></span>

<span data-ttu-id="468e7-104">這會示範如何使用隨附于 Windows 效能工具組中的 **XPerf** 和 **GPUView** 工具，測量 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10))應用程式的一些最重要效能時間測量。</span><span class="sxs-lookup"><span data-stu-id="468e7-104">This shows you how to measure some of the most important performance time measurements for a [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) app using the **XPerf** and **GPUView** tools that ship as part of the Windows Performance Toolkit.</span></span> <span data-ttu-id="468e7-105">這不是瞭解工具的完整指南，而是用來分析 DirectX 應用程式效能的特定適用性。</span><span class="sxs-lookup"><span data-stu-id="468e7-105">This is not a comprehensive guide for understanding the tools, rather their specific applicability for analyzing DirectX app performance.</span></span> <span data-ttu-id="468e7-106">雖然這裡討論的大部分技巧都與所有 DirectX 應用程式有關，但它最適用于使用交換鏈的應用程式，而不是使用 SIS/VSI 和 XAML 動畫的 XAML 上建的 DirectX 應用程式。</span><span class="sxs-lookup"><span data-stu-id="468e7-106">While most of the techniques discussed here are relevant to all DirectX apps, it is most relevant to apps that use swap chains and not to DirectX applications built on XAML that use SIS/VSIS and XAML animations.</span></span> <span data-ttu-id="468e7-107">我們會逐步引導您進行關鍵效能時間測量、如何取得及安裝工具，以及採取效能測量追蹤，然後加以分析以瞭解應用程式的瓶頸。</span><span class="sxs-lookup"><span data-stu-id="468e7-107">We walk you through key performance time measurements, how to acquire and install the tools, and take performance measurement traces then analyze them to understand app bottlenecks.</span></span>

## <a name="about-the-tools"></a><span data-ttu-id="468e7-108">關於工具</span><span class="sxs-lookup"><span data-stu-id="468e7-108">About the Tools</span></span>

### <a name="xperf"></a><span data-ttu-id="468e7-109">**XPerf**</span><span class="sxs-lookup"><span data-stu-id="468e7-109">**XPerf**</span></span>

<span data-ttu-id="468e7-110">**XPerf** 是一組以 Windows 事件追蹤為基礎所建立的效能分析工具， (ETW) 設計來測量和分析詳細的系統和應用程式效能和資源使用量。</span><span class="sxs-lookup"><span data-stu-id="468e7-110">**XPerf** is a set of performance analysis tools built on top of Event Tracing for Windows (ETW) designed for measuring and analyzing detailed system and app performance and resource usage.</span></span> <span data-ttu-id="468e7-111">從 Windows 8 開始，此命令列工具具有圖形化使用者介面，稱為 Windows Performance Recorder (WPR) 和 Windows Performance Analyzer (WPA) 。</span><span class="sxs-lookup"><span data-stu-id="468e7-111">Starting in Windows 8 this command line tool has a graphical user interface and is called the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA).</span></span> <span data-ttu-id="468e7-112">如需這些工具的詳細資訊，請參閱 [Windows 效能](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10)) 工具組的網頁 (WPT) ： [windows 效能工具](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10))組。</span><span class="sxs-lookup"><span data-stu-id="468e7-112">More information about these tools can be found at the web page for [Windows Performance Toolkit](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10)) (WPT): [Windows Performance Toolkit](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10)).</span></span>

<span data-ttu-id="468e7-113">ETW 會收集要求的核心事件，並將它們儲存到稱為事件追蹤記錄檔的檔案中， (ETL) 檔。</span><span class="sxs-lookup"><span data-stu-id="468e7-113">An ETW collects requested kernel events and saves them into a file called an event trace log (ETL) file.</span></span> <span data-ttu-id="468e7-114">這些核心事件可在執行應用程式時提供有關應用程式和系統特性的廣泛資訊。</span><span class="sxs-lookup"><span data-stu-id="468e7-114">These kernel events provide extensive information about an app and system characteristics when running the app.</span></span> <span data-ttu-id="468e7-115">資料的收集方式是啟用追蹤捕捉，執行需要分析的所需應用程式案例，並停止將資料儲存在 ETL 檔案中的捕捉。</span><span class="sxs-lookup"><span data-stu-id="468e7-115">Data is collected by enabling trace capture, performing the desired app scenario that needs analysis, stopping the capture which saves the data in an ETL file.</span></span> <span data-ttu-id="468e7-116">然後，您可以使用命令列工具 **xperf.exe** 或視覺化追蹤分析工具 **xperfview.exe**，在相同或不同的電腦上分析檔案。</span><span class="sxs-lookup"><span data-stu-id="468e7-116">You can then analyze the file on the same or a different machine using either the command line tool **xperf.exe** or the visual trace analysis tool **xperfview.exe**.</span></span>

### <a name="gpuview"></a><span data-ttu-id="468e7-117">GPUView</span><span class="sxs-lookup"><span data-stu-id="468e7-117">GPUView</span></span>

<span data-ttu-id="468e7-118">**GPUView** 是一種開發工具，可判斷圖形處理器 (GPU) 和 CPU 的效能。</span><span class="sxs-lookup"><span data-stu-id="468e7-118">**GPUView** is a development tool for determining the performance of the graphics processing unit (GPU) and CPU.</span></span> <span data-ttu-id="468e7-119">它會查看 (DMA) 緩衝區處理和影片硬體上所有其他影片處理方面的直接記憶體存取相關效能。</span><span class="sxs-lookup"><span data-stu-id="468e7-119">It looks at performance with regard to direct memory access (DMA) buffer processing and all other video processing on the video hardware.</span></span>

<span data-ttu-id="468e7-120">針對依賴 GPU 的 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) 應用程式， **GPUView** 是一項功能強大的工具，可瞭解在 CPU 與 gpu 上完成的工作之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="468e7-120">For [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) apps that rely heavily on the GPU, **GPUView** is a powerful tool for understanding the relationship between work done on the CPU vs. GPU.</span></span> <span data-ttu-id="468e7-121">如需 **GPUView** 的詳細資訊，請參閱 [使用 GPUView](/windows-hardware/drivers/display/using-gpuview)。</span><span class="sxs-lookup"><span data-stu-id="468e7-121">For more info about **GPUView** see [Using GPUView](/windows-hardware/drivers/display/using-gpuview).</span></span>

<span data-ttu-id="468e7-122">類似于 **XPerf**，會先啟動追蹤服務來執行 ETW 追蹤，演練需要考慮的應用程式的案例，以停止服務並將資訊儲存在 ETL 檔案中。</span><span class="sxs-lookup"><span data-stu-id="468e7-122">Similar to **XPerf**, an ETW trace is first taken by starting the tracing service, exercising the scenario that needs analysis for the app under consideration, stopping the service and saving the information in an ETL file.</span></span> <span data-ttu-id="468e7-123">**GPUView** 會以圖形格式呈現 ETL 檔案中的資料。</span><span class="sxs-lookup"><span data-stu-id="468e7-123">**GPUView** presents the data present in the ETL file in a graphical format.</span></span>

<span data-ttu-id="468e7-124">安裝 **GPUView** 工具之後，建議您閱讀 [**GPUView** 說明] 功能表下的「**GPUView** 的主顯示器」主題。</span><span class="sxs-lookup"><span data-stu-id="468e7-124">After installing the **GPUView** tool, it is we recommend you read the "**GPUView**’s Main Display" topic under the "**GPUView** Help" menu.</span></span> <span data-ttu-id="468e7-125">其中包含有關如何解讀 **GPUView** UI 的實用資訊。</span><span class="sxs-lookup"><span data-stu-id="468e7-125">It contains useful information about how to interpret the **GPUView** UI.</span></span>

## <a name="installing-the-tools"></a><span data-ttu-id="468e7-126">安裝工具</span><span class="sxs-lookup"><span data-stu-id="468e7-126">Installing the Tools</span></span>

<span data-ttu-id="468e7-127">**XPerf** 和 **GPUView** 都包含在 Windows 效能工具組 (WPT) 。</span><span class="sxs-lookup"><span data-stu-id="468e7-127">Both **XPerf** and **GPUView** are included in the Windows Performance Toolkit (WPT).</span></span>

<span data-ttu-id="468e7-128">**XPerf** 隨附于 Windows 的 WINDOWS 軟體開發套件 (SDK) 的一部分。</span><span class="sxs-lookup"><span data-stu-id="468e7-128">**XPerf** ships as part of the Windows Software Development Kit (SDK) for Windows.</span></span> <span data-ttu-id="468e7-129">[下載 Windows SDK](https://dev.windows.com/downloads)。</span><span class="sxs-lookup"><span data-stu-id="468e7-129">[Download the Windows SDK](https://dev.windows.com/downloads).</span></span>

<span data-ttu-id="468e7-130">**GPUView** 可在 windows ADK)  (windows 評定及部署套件中取得。</span><span class="sxs-lookup"><span data-stu-id="468e7-130">**GPUView** is available in the Windows Assessment and Deployment Kit (Windows ADK).</span></span> <span data-ttu-id="468e7-131">[下載 WINDOWS ADK](/windows-hardware/get-started/adk-install)。</span><span class="sxs-lookup"><span data-stu-id="468e7-131">[Download the Windows ADK](/windows-hardware/get-started/adk-install).</span></span>

<span data-ttu-id="468e7-132">安裝之後，您必須將包含 **XPerf** 和 **GPUView** 的目錄新增至系統 "Path" 變數。</span><span class="sxs-lookup"><span data-stu-id="468e7-132">After installation, you must add the directories that contain **XPerf** and **GPUView** to the system "Path" variable.</span></span>

<span data-ttu-id="468e7-133">按一下 [[開始] 按鈕]，然後輸入「系統變數」。</span><span class="sxs-lookup"><span data-stu-id="468e7-133">Click the Start button and type "System Variables".</span></span> <span data-ttu-id="468e7-134">系統屬性視窗隨即開啟。</span><span class="sxs-lookup"><span data-stu-id="468e7-134">The System Properties window opens.</span></span> <span data-ttu-id="468e7-135">按一下 [編輯系統內容變數]。</span><span class="sxs-lookup"><span data-stu-id="468e7-135">Click "Edit the system environment variables".</span></span> <span data-ttu-id="468e7-136">從 [系統屬性] 對話方塊中選取 [環境變數]。</span><span class="sxs-lookup"><span data-stu-id="468e7-136">Select "Environment Variables" from the "System Properties" dialog box.</span></span> <span data-ttu-id="468e7-137">"Path" 變數位於「系統變數」下。</span><span class="sxs-lookup"><span data-stu-id="468e7-137">The "Path" variable is found under "System variables".</span></span> <span data-ttu-id="468e7-138">將包含 **xperf.exe** 和 **GPUView.exe** 的目錄附加至路徑。</span><span class="sxs-lookup"><span data-stu-id="468e7-138">Append the directory containing **xperf.exe** and **GPUView.exe** to the path.</span></span> <span data-ttu-id="468e7-139">您可以在「windows 套件」內的「Windows 效能工具組」目錄中找到這些可執行檔。</span><span class="sxs-lookup"><span data-stu-id="468e7-139">These executables are found in the "Windows Performance Toolkit" directory inside the "Windows Kits".</span></span> <span data-ttu-id="468e7-140">預設位置是： **C： \\ Program Files (x86) \\ windows 套件 \\ 10 \\ windows 效能工具** 組。</span><span class="sxs-lookup"><span data-stu-id="468e7-140">The default location is: **C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit**.</span></span>

## <a name="performance-time-measurements"></a><span data-ttu-id="468e7-141">效能時間度量</span><span class="sxs-lookup"><span data-stu-id="468e7-141">Performance Time Measurements</span></span>

<span data-ttu-id="468e7-142">大部分的應用程式預期會順暢地執行，並回應使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="468e7-142">Most apps expect to run smoothly and be responsive to user input.</span></span> <span data-ttu-id="468e7-143">不過，根據您想要的案例，效能的一個層面可能比另一個層面更重要。</span><span class="sxs-lookup"><span data-stu-id="468e7-143">However, depending upon the scenario the you want, one aspect of performance might be more important than another.</span></span> <span data-ttu-id="468e7-144">比方說，對於在觸控式平板電腦上執行的新聞讀取器應用程式，最重要的層面是一次查看單一文章，並透過相同或不同的文章來平移/縮放/滾動。</span><span class="sxs-lookup"><span data-stu-id="468e7-144">For instance, for a news reader app running on a touch tablet PC, the most important aspect is to view a single article at a time and to pan/zoom/scroll through the same or a different article.</span></span> <span data-ttu-id="468e7-145">在此情況下，不需要每個畫面格轉譯所有內容的能力。</span><span class="sxs-lookup"><span data-stu-id="468e7-145">In this scenario the ability to render all the content every frame is not necessary.</span></span> <span data-ttu-id="468e7-146">不過，在觸控手勢上順暢地滾動文章的功能非常重要。</span><span class="sxs-lookup"><span data-stu-id="468e7-146">However, the ability to scroll through the article smoothly upon a touch gesture is extremely important.</span></span>

<span data-ttu-id="468e7-147">在另一個實例中，如果已卸載框架，則會使用大量動畫的遊戲或影片轉譯應用程式。</span><span class="sxs-lookup"><span data-stu-id="468e7-147">In another instance, a game or a video rendering app that uses lots of animations glitches if frames are dropped.</span></span> <span data-ttu-id="468e7-148">在此情況下，若要在螢幕上顯示內容而不中斷使用者輸入，這項功能非常重要。</span><span class="sxs-lookup"><span data-stu-id="468e7-148">In this case, the ability to present content on the screen without interuption from user input is extremely important.</span></span>

<span data-ttu-id="468e7-149">為了瞭解應用程式的哪個部分有問題，第一個步驟是決定最重要的案例。</span><span class="sxs-lookup"><span data-stu-id="468e7-149">In order to understand which part of the app is problematic, the first step is to decide on the most important scenarios.</span></span> <span data-ttu-id="468e7-150">一旦瞭解應用程式的核心層面，以及它們的運用方式，使用工具來尋找問題就變得更容易。</span><span class="sxs-lookup"><span data-stu-id="468e7-150">Once the core aspects of the app are understood and how they will be exercised, looking for problems using the tools becomes easier.</span></span>

<span data-ttu-id="468e7-151">其中一些最常見的效能時間計量如下：</span><span class="sxs-lookup"><span data-stu-id="468e7-151">Some of the most common performance time metrics are as follows:</span></span>

### <a name="startup-time"></a><span data-ttu-id="468e7-152">啟動時間</span><span class="sxs-lookup"><span data-stu-id="468e7-152">Startup-time</span></span>

<span data-ttu-id="468e7-153">從進程啟動到第一次出現畫面所測量的時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-153">Time measured from process launch to first present hitting the screen.</span></span> <span data-ttu-id="468e7-154">當系統暖表示在應用程式啟動幾次之後進行測量時，此測量會更有用。</span><span class="sxs-lookup"><span data-stu-id="468e7-154">This measurement is more useful when the system is warm meaning the measurement is taken after the app is launched a few times.</span></span>

### <a name="cpu-time-per-frame"></a><span data-ttu-id="468e7-155">每一畫面的 CPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-155">CPU time per frame</span></span>

<span data-ttu-id="468e7-156">CPU 針對一個畫面格主動處理應用程式工作負載的時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-156">The time for which CPU actively processes the app workload for one frame.</span></span> <span data-ttu-id="468e7-157">如果應用程式順利執行，則一個畫面格所需的所有處理都會在一個 v 同步間隔內發生。</span><span class="sxs-lookup"><span data-stu-id="468e7-157">If the app is running smoothly, all the processing required for one frame happens within one v-sync interval.</span></span> <span data-ttu-id="468e7-158">由於監視器的重新整理頻率為60Hz，因此每個框架16毫秒。</span><span class="sxs-lookup"><span data-stu-id="468e7-158">With the monitor refresh rate of 60Hz, this comes to 16ms per frame.</span></span> <span data-ttu-id="468e7-159">如果 CPU 時間/框架大於16毫秒，可能需要 CPU 優化才能產生無問題的免費應用程式體驗。</span><span class="sxs-lookup"><span data-stu-id="468e7-159">If CPU time/frame is greater than 16ms, CPU optimizations might be needed to produce a glitch free app experience.</span></span>

### <a name="gpu-time-per-frame"></a><span data-ttu-id="468e7-160">每個畫面的 GPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-160">GPU time per frame</span></span>

<span data-ttu-id="468e7-161">GPU 主動處理一個畫面格的應用程式工作負載的時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-161">The time for which GPU actively processes the app workload for one frame.</span></span> <span data-ttu-id="468e7-162">當處理資料框架所需的時間超過16毫秒時，應用程式會受到 GPU 系結。</span><span class="sxs-lookup"><span data-stu-id="468e7-162">An app is GPU bound when the time taken to process a frame worth of data is more than 16ms.</span></span>

<span data-ttu-id="468e7-163">能夠瞭解應用程式是否為 CPU 或 GPU 系結，將會縮小程式代碼的問題部分。</span><span class="sxs-lookup"><span data-stu-id="468e7-163">Being able to understand whether an app is CPU or GPU bound will narrow the problematic part of the code.</span></span>

## <a name="taking-performance-time-measurement-trace"></a><span data-ttu-id="468e7-164">採用效能時間測量追蹤</span><span class="sxs-lookup"><span data-stu-id="468e7-164">Taking performance time measurement trace</span></span>

<span data-ttu-id="468e7-165">執行下列步驟以進行追蹤：</span><span class="sxs-lookup"><span data-stu-id="468e7-165">Perform these steps to take a trace:</span></span>

1.  <span data-ttu-id="468e7-166">以系統管理員身分開啟命令視窗。</span><span class="sxs-lookup"><span data-stu-id="468e7-166">Open a command window as an administrator.</span></span>
2.  <span data-ttu-id="468e7-167">如果應用程式已在執行中，請加以關閉。</span><span class="sxs-lookup"><span data-stu-id="468e7-167">Close the app if it is already running.</span></span>
3.  <span data-ttu-id="468e7-168">將目錄變更為 Windows 效能工具組資料夾內的 *gpuview* 目錄。</span><span class="sxs-lookup"><span data-stu-id="468e7-168">Change directories to the *gpuview* directory inside the Windows Performance Toolkit folder.</span></span>
4.  <span data-ttu-id="468e7-169">輸入 "log .cmd" 以啟動事件追蹤。</span><span class="sxs-lookup"><span data-stu-id="468e7-169">Type "log.cmd" to start event tracing.</span></span> <span data-ttu-id="468e7-170">此選項會記錄最感興趣的事件。</span><span class="sxs-lookup"><span data-stu-id="468e7-170">This option logs the most interesting events.</span></span> <span data-ttu-id="468e7-171">其他可用的選項會記錄不同的事件範圍。</span><span class="sxs-lookup"><span data-stu-id="468e7-171">Other available options log different scope of the events.</span></span> <span data-ttu-id="468e7-172">例如，' v ' 或詳細資訊記錄模式會捕捉 **GPUView** 感知的所有事件。</span><span class="sxs-lookup"><span data-stu-id="468e7-172">For instance ‘v’ or verbose log mode captures all events that the **GPUView** is aware of.</span></span>
5.  <span data-ttu-id="468e7-173">啟動範例，並以涵蓋您需要分析之效能路徑的方式來練習範例。</span><span class="sxs-lookup"><span data-stu-id="468e7-173">Launch the sample, and exercise the sample in a manner that covers the performance path that you need to analyze.</span></span>
6.  <span data-ttu-id="468e7-174">返回至命令視窗，然後再次輸入 "log .cmd" 以停止記錄。</span><span class="sxs-lookup"><span data-stu-id="468e7-174">Go back to the command windows and type "log.cmd" again to stop logging.</span></span>
7.  <span data-ttu-id="468e7-175">這會在 *gpuview* 資料夾中輸出稱為「已合併的 etl」的檔案。</span><span class="sxs-lookup"><span data-stu-id="468e7-175">This outputs a file called "merged.etl" in the *gpuview* folder.</span></span> <span data-ttu-id="468e7-176">您可以將此檔案儲存到另一個位置，也可以在相同或不同的電腦上進行分析。</span><span class="sxs-lookup"><span data-stu-id="468e7-176">You can save this file to another location and you can analyze it on the same or a different machine.</span></span> <span data-ttu-id="468e7-177">若要查看堆疊捕捉的詳細資料，請將符號檔儲存 ( .pdb) 與應用程式相關聯。</span><span class="sxs-lookup"><span data-stu-id="468e7-177">In order to view stack capture details, save the symbol file (.pdb) associated with the app.</span></span>

## <a name="measurements"></a><span data-ttu-id="468e7-178">量測</span><span class="sxs-lookup"><span data-stu-id="468e7-178">Measurements</span></span>


> [!Note]  
> <span data-ttu-id="468e7-179">幾何實現範例的度量是在具有整合式 DirectX11 圖形配接器的四核心電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="468e7-179">The measurements for geometry realization sample are taken on a Quad Core machine with an integrated DirectX11 graphics card.</span></span> <span data-ttu-id="468e7-180">度量會根據電腦設定而有所不同。</span><span class="sxs-lookup"><span data-stu-id="468e7-180">The measurements vary depending upon the machine configuration.</span></span>

 

<span data-ttu-id="468e7-181">本節示範如何測量每一框架測量的啟動時間、CPU 和 GPU 時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-181">This section demonstrates how to measure the startup-time, CPU and GPU time per frame measurements.</span></span> <span data-ttu-id="468e7-182">您可以在電腦上為相同的範例捕捉效能追蹤，並查看各種度量的差異。</span><span class="sxs-lookup"><span data-stu-id="468e7-182">You can capture a performance trace for the same sample on your machine and see the differences in the various measurements.</span></span>

<span data-ttu-id="468e7-183">若要在 **GPUView** 中分析追蹤，請使用 **GPUView.exe** 開啟「合併的 elt」檔案。</span><span class="sxs-lookup"><span data-stu-id="468e7-183">To analyze the trace in **GPUView**, open the "merged.elt" file using **GPUView.exe**.</span></span>

### <a name="startup-time"></a><span data-ttu-id="468e7-184">啟動時間</span><span class="sxs-lookup"><span data-stu-id="468e7-184">Startup-time</span></span>

<span data-ttu-id="468e7-185">啟動時間是以應用程式啟動所花費的總時間來測量，直到內容先顯示在畫面上為止。</span><span class="sxs-lookup"><span data-stu-id="468e7-185">The startup time is measured by the total time spent from the app start until the content first appears on the screen.</span></span>

<span data-ttu-id="468e7-186">您可以依照上一節中所列的步驟，使用這些變化來執行啟動時間測量：</span><span class="sxs-lookup"><span data-stu-id="468e7-186">The startup-time measurement is best taken by following the steps listed in the previous section with these variations:</span></span>

-   <span data-ttu-id="468e7-187">如果您在第一次啟動應用程式時開始測量，就稱為「冷啟動」。</span><span class="sxs-lookup"><span data-stu-id="468e7-187">If the you take the start-up measurements the very first time you launch the app, it is called cold startup.</span></span> <span data-ttu-id="468e7-188">這可能與您在短時間內啟動應用程式數次之後所採取的測量不同。</span><span class="sxs-lookup"><span data-stu-id="468e7-188">This may vary from measurements taken after you launch the app a few times over in a small duration of time.</span></span> <span data-ttu-id="468e7-189">這稱為「暖開機」。</span><span class="sxs-lookup"><span data-stu-id="468e7-189">This is called warm startup.</span></span> <span data-ttu-id="468e7-190">視應用程式在啟動時所建立的資源數量而定，這兩個啟動時間之間可能會有很大的差異。</span><span class="sxs-lookup"><span data-stu-id="468e7-190">Depending upon how many resources an app creates at launch, there can be a big difference between the two startup times.</span></span> <span data-ttu-id="468e7-191">視應用程式目標而定，可能會需要測量其中一個。</span><span class="sxs-lookup"><span data-stu-id="468e7-191">Depending upon app goals, measuring one or the other might be desirable.</span></span>
-   <span data-ttu-id="468e7-192">當您記錄效能資訊時，只要畫面上出現第一個框架，就會終止應用程式。</span><span class="sxs-lookup"><span data-stu-id="468e7-192">When you log performance information, terminate the app as soon as the first frame shows up on the screen.</span></span>

### <a name="calculating-start-up-time-using-gpuview"></a><span data-ttu-id="468e7-193">使用 **GPUView** 計算啟動時間</span><span class="sxs-lookup"><span data-stu-id="468e7-193">Calculating start-up time using **GPUView**</span></span>

1.  <span data-ttu-id="468e7-194">在 **GPUView** 中，向下滾動至相關的程式，在此案例中 GeometryRealization.exe。</span><span class="sxs-lookup"><span data-stu-id="468e7-194">In **GPUView**, scroll down to the relevant process, in this case GeometryRealization.exe.</span></span>

    ![顯示 GPUView 中進程範例的螢幕擷取畫面。](images/profile1.png)

2.  <span data-ttu-id="468e7-196">內容 CPU 佇列代表將圖形工作負載排入硬體佇列，但不一定是由硬體處理。</span><span class="sxs-lookup"><span data-stu-id="468e7-196">The context CPU queue represents the graphics workload queued to the hardware, but not necessarily being processed by the hardware.</span></span> <span data-ttu-id="468e7-197">開啟追蹤檔案時，它會顯示在追蹤進行期間所記錄的所有事件。</span><span class="sxs-lookup"><span data-stu-id="468e7-197">When the trace file is opened, it shows all the events logged between the time the trace was taken.</span></span> <span data-ttu-id="468e7-198">若要計算啟動時間，請選取感興趣的區域，並放大第一個內容 CPU 佇列的初始部分 (這是使用 Ctrl + Z 顯示活動) 的部分。</span><span class="sxs-lookup"><span data-stu-id="468e7-198">In order to calculate the startup-time, select the region of interest, zoom into the initial portion of the first Context CPU Queue (this is the one that shows activity) using Ctrl +Z.</span></span> <span data-ttu-id="468e7-199">如需有關 **GPUView** 控制項的詳細資訊，請參閱 **GPUView** 說明檔區段「 **GPUView** 控制項的摘要」。</span><span class="sxs-lookup"><span data-stu-id="468e7-199">More information about **GPUView** Controls can be found in the **GPUView** Help file section "Summary of **GPUView** Controls".</span></span> <span data-ttu-id="468e7-200">下圖只會顯示放大至內容 CPU 佇列第一個部分的 GeometryRealization.exe 進程。</span><span class="sxs-lookup"><span data-stu-id="468e7-200">The figure below only shows the GeometryRealization.exe process zoomed in to the first part of the Context CPU Queue.</span></span> <span data-ttu-id="468e7-201">內容 CPU 佇列的色彩是由佇列下方的矩形表示，而佇列中的相同色彩資料封包會顯示在硬體上排入佇列的 GPU 工作。</span><span class="sxs-lookup"><span data-stu-id="468e7-201">The color of the Context CPU Queue is denoted by the rectangle right below the queue and same color data packets in the queue show GPU work queued up on the hardware.</span></span> <span data-ttu-id="468e7-202">內容佇列中的影線模式封包會顯示目前的封包，這表示應用程式希望硬體能在螢幕上呈現內容。</span><span class="sxs-lookup"><span data-stu-id="468e7-202">The hatch pattern packet in the context queue shows the present packet which means that the app wants the hardware to present the content on the screen.</span></span>

    ![顯示「內容 C P U 佇列」範例的螢幕擷取畫面。](images/profile2.png)

3.  <span data-ttu-id="468e7-204">啟動時間是應用程式第一次啟動的時間 (在此案例中，UI 執行緒進入點模組 SHCORE.dll) 到內容第一次出現 (以影線封包) 標記的時間為止。</span><span class="sxs-lookup"><span data-stu-id="468e7-204">The startup-time is the time when the app first starts (in this case UI thread entry point module SHCORE.dll) till the time the context first appears (marked by a hatch packet).</span></span> <span data-ttu-id="468e7-205">這裡的圖表強調顯示感興趣的區域。</span><span class="sxs-lookup"><span data-stu-id="468e7-205">The figure here highlights the area of interest.</span></span>

    > [!Note]  
    > <span data-ttu-id="468e7-206">實際的顯示資訊會顯示在 flip 佇列中，因此會延長所花費的時間，直到目前的封包在翻轉佇列中實際完成為止。</span><span class="sxs-lookup"><span data-stu-id="468e7-206">The actual present info is represented in the flip queue and thus the time take is extended till the present packet actually completes in the flip queue.</span></span>

     

    <span data-ttu-id="468e7-207">下圖中看不到完整的狀態列，也會顯示反白顯示部分之間的經過時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-207">The complete status bar is not visible in the figure below which also shows the elapsed time between the highlighted portions.</span></span> <span data-ttu-id="468e7-208">這是應用程式的啟動時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-208">This is the startup-time of the app.</span></span> <span data-ttu-id="468e7-209">在此案例中，這是關於上述電腦的240ms。</span><span class="sxs-lookup"><span data-stu-id="468e7-209">In this case for the machine mentioned above, it came out to be around 240ms.</span></span>

    ![顯示有關「內容 C P U 佇列」中啟動時間的相關區域的螢幕擷取畫面。](images/profile3.png)

### <a name="cpu-and-gpu-time-per-frame"></a><span data-ttu-id="468e7-211">每個畫面的 CPU 和 GPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-211">CPU and GPU Time per frame</span></span>

<span data-ttu-id="468e7-212">在測量 CPU 時間時，有幾件事需要考慮。</span><span class="sxs-lookup"><span data-stu-id="468e7-212">There are a few things to think about when measuring CPU time.</span></span> <span data-ttu-id="468e7-213">尋找追蹤中您已執行案例分析的區域。</span><span class="sxs-lookup"><span data-stu-id="468e7-213">Look for the areas in the trace where you have exercised the scenario to be analyzed.</span></span> <span data-ttu-id="468e7-214">例如，在幾何實現範例中，已分析的其中一個案例是轉譯2048和8192基本專案之間的轉換，所有未實現的 (如中所示，幾何都不會鑲嵌每個畫面格) 。</span><span class="sxs-lookup"><span data-stu-id="468e7-214">For instance, in the geometry realization sample one of the scenarios that has been analyzed is the transition between rendering 2048 and 8192 primitives, all unrealized (as in, geometry is not tessellated every frame).</span></span> <span data-ttu-id="468e7-215">此追蹤會清楚顯示在轉換的基本專案數前後的 CPU 和 GPU 活動差異。</span><span class="sxs-lookup"><span data-stu-id="468e7-215">The trace clearly shows difference in CPU and GPU activity before and after the transition in the number of primitives.</span></span>

<span data-ttu-id="468e7-216">分析兩個案例，以計算每個畫面的 CPU 和 GPU 時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-216">Two scenarios are being analyzed to calculate CPU and GPU time per frame.</span></span> <span data-ttu-id="468e7-217">它們如下所示。</span><span class="sxs-lookup"><span data-stu-id="468e7-217">They are as follows.</span></span>

-   <span data-ttu-id="468e7-218">從轉譯2048未實現的基本專案轉換為8192個未實現的基本型別。</span><span class="sxs-lookup"><span data-stu-id="468e7-218">Transitioning from rendering 2048 unrealized primitives to 8192 unrealized primitives.</span></span>
-   <span data-ttu-id="468e7-219">從轉譯8192已實現的基本專案轉換為8192的已實現基本專案。</span><span class="sxs-lookup"><span data-stu-id="468e7-219">Transitioning from rendering 8192 realized primitives to 8192 unrealized primitives.</span></span>

<span data-ttu-id="468e7-220">在這兩種情況下，觀察到的畫面播放速率會大幅下降。</span><span class="sxs-lookup"><span data-stu-id="468e7-220">In both the cases, it was observed that the frame rate dropped drastically.</span></span> <span data-ttu-id="468e7-221">測量 CPU 和 GPU 時間，追蹤兩者之間的關聯性和其他幾個模式之間的關聯性，可提供應用程式中有問題區域的有用資訊。</span><span class="sxs-lookup"><span data-stu-id="468e7-221">Measuring CPU and GPU time, the relationship between the two as well as a few other patterns in the trace can give useful info about problematic areas in the app.</span></span>

### <a name="calculating-cpu-and-gpu-time-when-2048-primitives-are-being-rendered-unrealized"></a><span data-ttu-id="468e7-222">計算未實現2048基本型別時的 CPU 和 GPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-222">Calculating CPU and GPU time when 2048 primitives are being rendered unrealized</span></span>

1.  <span data-ttu-id="468e7-223">使用 **GPUView.exe** 開啟追蹤檔案。</span><span class="sxs-lookup"><span data-stu-id="468e7-223">Open the trace file using **GPUView.exe**.</span></span>
2.  <span data-ttu-id="468e7-224">向下滾動至 GeometryRealization.exe 進程。</span><span class="sxs-lookup"><span data-stu-id="468e7-224">Scroll down to the GeometryRealization.exe process.</span></span>
3.  <span data-ttu-id="468e7-225">選取用來計算 CPU 時間的區域，並使用 CTRL + Z 來放大。</span><span class="sxs-lookup"><span data-stu-id="468e7-225">Select an area for calculating CPU time and zoom into it using CTRL + Z.</span></span>

    ![螢幕擷取畫面，顯示已選取的區域，可在「內容 CPU 佇列」中計算 C P U 時間。](images/profile4.png)

4.  <span data-ttu-id="468e7-227">在 F8 之間切換，以顯示 v 同步資訊。</span><span class="sxs-lookup"><span data-stu-id="468e7-227">Show v-sync information by toggling between F8.</span></span> <span data-ttu-id="468e7-228">一直放大，直到很容易就能清楚看到一個 vsync 的資料。</span><span class="sxs-lookup"><span data-stu-id="468e7-228">Keeping zooming in till it is easy to see one vsync worth of data clearly.</span></span> <span data-ttu-id="468e7-229">藍線是 v 同步處理時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-229">The blue lines are where the v-sync times.</span></span> <span data-ttu-id="468e7-230">通常，這些會在每16毫秒 (60 fps) 發生一次，但如果 DWM 遇到效能問題，則會以較慢的速度執行，因此每 32 ms (30 fps) 會發生一次。</span><span class="sxs-lookup"><span data-stu-id="468e7-230">Usually, these occur once every 16 ms (60 fps), but if DWM is encountering a performance problem, it runs slower so they will occur once every 32 ms (30 fps).</span></span> <span data-ttu-id="468e7-231">若要瞭解時間，請選取下一個藍色橫條，然後查看 [ **GPUView** ] 視窗右下角所報告的 ms 數目。</span><span class="sxs-lookup"><span data-stu-id="468e7-231">To get a sense of time, select from one blue bar to the next and then look at the number of ms reported in the lower right hand corner of the **GPUView** window.</span></span>

    ![顯示 v 同步時間範例的螢幕擷取畫面。](images/profile5.png)

5.  <span data-ttu-id="468e7-233">若要測量每個畫面格的 CPU 時間，請測量所有涉及轉譯的執行緒所花費的時間長度。</span><span class="sxs-lookup"><span data-stu-id="468e7-233">To measure the CPU time per frame, measure the length of time taken by all the threads involved in rendering.</span></span> <span data-ttu-id="468e7-234">從效能的觀點來看，可能會讓預期最相關的執行緒縮小。</span><span class="sxs-lookup"><span data-stu-id="468e7-234">It might be worthwhile to narrow down the thread that is expected to be most relevant from a performance standpoint.</span></span> <span data-ttu-id="468e7-235">例如，在幾何實現範例中，內容會製作動畫，而且必須在每個畫面格上轉譯，讓 UI 執行緒成為重要的畫面格。</span><span class="sxs-lookup"><span data-stu-id="468e7-235">For instance in the geometry realization sample, the content is animating and needs to be rendered on the screen every frame making the UI thread the important one.</span></span> <span data-ttu-id="468e7-236">一旦您決定要查看哪一個執行緒，請測量這個執行緒上的橫條長度。</span><span class="sxs-lookup"><span data-stu-id="468e7-236">Once you determine which thread to look at, measure the length of the bars on this thread.</span></span> <span data-ttu-id="468e7-237">每個畫面的平均 CPU 時間數平均。</span><span class="sxs-lookup"><span data-stu-id="468e7-237">Averaging a few of these yields CPU time per frame.</span></span> <span data-ttu-id="468e7-238">下圖顯示 UI 執行緒所花的時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-238">The figure below shows time taken up on the UI thread.</span></span> <span data-ttu-id="468e7-239">它也會顯示這段時間在兩個連續的雙同步處理（亦即60FPS）之間非常適合。</span><span class="sxs-lookup"><span data-stu-id="468e7-239">It also shows that this time fits well between two consecutive v-syncs which mean that it is hitting 60FPS.</span></span>

    ![顯示 U I 執行緒所花費時間的螢幕擷取畫面。](images/profile6.png)

    <span data-ttu-id="468e7-241">您也可以查看相對應時間範圍的翻轉佇列來進行驗證，這會顯示 DWM 可以呈現每個畫面格。</span><span class="sxs-lookup"><span data-stu-id="468e7-241">You can also verify by looking at the flip queue for the corresponding time frame which shows that DWM is able to present every frame.</span></span>

    ![顯示「翻轉佇列」範例的螢幕擷取畫面。](images/profile7.png)

6.  <span data-ttu-id="468e7-243">您可以用與 CPU 時間相同的方式來測量 GPU 時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-243">The GPU time can be measured in the same way as the CPU time.</span></span> <span data-ttu-id="468e7-244">在測量 CPU 時間的情況下，放大相關區域。</span><span class="sxs-lookup"><span data-stu-id="468e7-244">Zoom into the relevant area as in the case of measuring CPU time.</span></span> <span data-ttu-id="468e7-245">使用與內容 CPU 佇列色彩相同的色彩，測量 GPU 硬體佇列中的橫條長度。</span><span class="sxs-lookup"><span data-stu-id="468e7-245">Measure the length of the bars in the GPU hardware Queue with the same color as the color of the Context CPU Queue.</span></span> <span data-ttu-id="468e7-246">只要橫條符合連續的雙同步處理，應用程式就會在60FPS 中順利執行。</span><span class="sxs-lookup"><span data-stu-id="468e7-246">As long as the bars fit within consecutive v-syncs, the app is running smoothly at 60FPS.</span></span>

    ![顯示「GPU 硬體佇列」範例的螢幕擷取畫面，其中顯示應用程式正在 60 F P S 執行的資訊。](images/profile8.png)

### <a name="calculating-cpu-and-gpu-time-when-8192-primitives-are-being-rendered-unrealized"></a><span data-ttu-id="468e7-248">計算未實現8192基本型別時的 CPU 和 GPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-248">Calculating CPU and GPU time when 8192 primitives are being rendered unrealized</span></span>

1.  <span data-ttu-id="468e7-249">如果您再次遵循相同的步驟，追蹤會顯示一個畫面格的所有 CPU 工作都不符合一個 v 同步與下一個畫面。</span><span class="sxs-lookup"><span data-stu-id="468e7-249">If you follow the same steps again, the trace shows that all the CPU work for one frame does not fit between one v-sync and the next.</span></span> <span data-ttu-id="468e7-250">這表示應用程式已受 CPU 限制。</span><span class="sxs-lookup"><span data-stu-id="468e7-250">This means that the app is CPU bound.</span></span> <span data-ttu-id="468e7-251">UI 執行緒會將 CPU 飽和。</span><span class="sxs-lookup"><span data-stu-id="468e7-251">The UI thread is saturating the CPU.</span></span>

    ![顯示 UI 執行緒的範例會使 C P U 飽和的螢幕擷取畫面。](images/profile9.png)

    <span data-ttu-id="468e7-253">查看翻轉佇列，也可以清楚地指出 DWM 無法顯示每個畫面格。</span><span class="sxs-lookup"><span data-stu-id="468e7-253">Looking at the flip queue, it is also clear that DWM is not able to present every frame.</span></span>

    ![顯示 D W M 無法顯示每個畫面格範例的螢幕擷取畫面。](images/profile10.png)

2.  <span data-ttu-id="468e7-255">為了分析花費時間的時間，請在 **XPerf** 中開啟追蹤。</span><span class="sxs-lookup"><span data-stu-id="468e7-255">In order to analyze where the time is getting spent, open the trace in **XPerf**.</span></span> <span data-ttu-id="468e7-256">若要分析 **XPerf** 中的啟動時間，請先找出 **GPUView** 中的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="468e7-256">To analyze startup time in **XPerf**, first find the time interval in **GPUView**.</span></span> <span data-ttu-id="468e7-257">將滑鼠移到間隔左邊和右邊，並記下 [ **GPUView** ] 視窗底部所顯示的絕對時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-257">Mouse over the left of the interval and the right and take note of the absolute time shown in the bottom of the **GPUView** window.</span></span> <span data-ttu-id="468e7-258">然後，在 **XPerf** 中開啟相同的 .etl 檔案，並向下滾動至 [cpu 取樣（依 cpu）] 圖形，以滑鼠右鍵按一下並選取 [選取間隔 ...]這可讓您輸入感興趣的間隔，也就是查看 GPU 追蹤所發現的。</span><span class="sxs-lookup"><span data-stu-id="468e7-258">Then open the same .etl file in **XPerf** and, scroll down to the "CPU Sampling by CPU" graph, right click and select "Select Interval…" This allows for typing in the interval of interest which was discovered by looking at the GPU trace.</span></span>

    ![螢幕擷取畫面，顯示 [Windows 效能分析] 中的 [c p U 依 C P U 取樣]。](images/profile11.png)

3.  <span data-ttu-id="468e7-260">移至追蹤功能表，並確認已核取 [載入符號]。</span><span class="sxs-lookup"><span data-stu-id="468e7-260">Go to the Trace menu, and make sure "Load Symbols" is checked.</span></span> <span data-ttu-id="468e7-261">此外，請移至追蹤 > 設定符號路徑，然後輸入應用程式符號路徑。</span><span class="sxs-lookup"><span data-stu-id="468e7-261">Also, go to Trace -> Configure Symbol Paths, and type in the app symbol path.</span></span> <span data-ttu-id="468e7-262">符號檔包含有關個別資料庫中已編譯之可執行檔的偵錯工具 ( .pdb) 。</span><span class="sxs-lookup"><span data-stu-id="468e7-262">A symbol file contains debugging information about a compiled executable in a separate database (.pdb).</span></span> <span data-ttu-id="468e7-263">這個檔案通常稱為 PDB。</span><span class="sxs-lookup"><span data-stu-id="468e7-263">This file is commonly referred to as a PDB.</span></span> <span data-ttu-id="468e7-264">您可以在這裡找到符號檔的詳細資訊： [符號](/windows/desktop/Debug/symbol-files)檔。</span><span class="sxs-lookup"><span data-stu-id="468e7-264">More on symbol files can be found here: [Symbol Files](/windows/desktop/Debug/symbol-files).</span></span> <span data-ttu-id="468e7-265">您可以在應用程式目錄的 "Debug" 資料夾中找到這個檔案。</span><span class="sxs-lookup"><span data-stu-id="468e7-265">This file can be located in the "Debug" folder of the app directory.</span></span>

4.  <span data-ttu-id="468e7-266">若要取得應用程式中花費時間的明細，請以滑鼠右鍵按一下上一個步驟中選取的間隔，然後按一下 [摘要資料表]。</span><span class="sxs-lookup"><span data-stu-id="468e7-266">In order to get the breakdown of where the time is being spent in the app, right click on the interval selected in the previous step and click Summary Table.</span></span> <span data-ttu-id="468e7-267">若要深入瞭解每個 dll 花費了多少時間，請從 [資料行] 功能表取消核取 [堆疊]。</span><span class="sxs-lookup"><span data-stu-id="468e7-267">To get an overview of how much time is spent in each dll, uncheck "Stack" from the "Columns" menu.</span></span> <span data-ttu-id="468e7-268">請注意，此處的 [計數] 資料行會顯示指定的 dll/函式內有多少樣本。</span><span class="sxs-lookup"><span data-stu-id="468e7-268">Note that the "Count" column here shows how many samples are within the given dll/function.</span></span> <span data-ttu-id="468e7-269">因為每毫秒大約會採用一個樣本，所以這個數位可以用來做為每個 dll/函式中花費多少時間的最佳猜測。</span><span class="sxs-lookup"><span data-stu-id="468e7-269">Because approximately one sample is taken per ms, this number can be used as a best guess for how much time is spent in each dll/function.</span></span> <span data-ttu-id="468e7-270">核取 [從資料行] 功能表中的 [堆疊]，將會提供在呼叫圖形中的每個函式中花費的時間。</span><span class="sxs-lookup"><span data-stu-id="468e7-270">Checking the "Stack" from Columns menu will give the inclusive time spent in each function in the call graph.</span></span> <span data-ttu-id="468e7-271">這將有助於進一步細分問題點。</span><span class="sxs-lookup"><span data-stu-id="468e7-271">This will help to break down the problem points further.</span></span>

5.  <span data-ttu-id="468e7-272">2048未取得基本專案的堆疊追蹤資訊會顯示 CPU 時間的30% 花費在幾何實現進程中。</span><span class="sxs-lookup"><span data-stu-id="468e7-272">Stack trace information for 2048 unrealized primitives reveals that 30% of CPU time is spent in geometry realization process.</span></span> <span data-ttu-id="468e7-273">大約36% 的時間會花在幾何鑲嵌和筆劃中。</span><span class="sxs-lookup"><span data-stu-id="468e7-273">Of that around 36% of the time is being spent in geometry tessellation and stroking.</span></span>

6.  <span data-ttu-id="468e7-274">8192的原始基本專案的堆疊追蹤資訊會顯示大約60% 的 CPU 時間 (4 個核心) 用於幾何實現。</span><span class="sxs-lookup"><span data-stu-id="468e7-274">Stack trace information for 8192 unrealized primitives reveals that around 60% of the CPU time (4 cores) is spent in the geometry realization.</span></span>

    ![顯示 C P U 時間堆疊追蹤資訊的螢幕擷取畫面。](images/profile12.png)

### <a name="calculating-cpu-time-when-8192-primitives-are-being-rendered-realized"></a><span data-ttu-id="468e7-276">在轉譯8192基本專案時計算 CPU 時間</span><span class="sxs-lookup"><span data-stu-id="468e7-276">Calculating CPU time when 8192 primitives are being rendered realized</span></span>

<span data-ttu-id="468e7-277">您可以從設定檔中清楚知道應用程式是受 CPU 限制的。</span><span class="sxs-lookup"><span data-stu-id="468e7-277">It is clear from the profiles that the app is CPU bound.</span></span> <span data-ttu-id="468e7-278">為了減少 CPU 花費的時間，您可以建立一次並快取幾何。</span><span class="sxs-lookup"><span data-stu-id="468e7-278">In order to reduce the time spent by the CPU, geometries can be created once and cached.</span></span> <span data-ttu-id="468e7-279">快取的內容可以在每個畫面格轉譯，而不會產生每個畫面的幾何鑲嵌成本。</span><span class="sxs-lookup"><span data-stu-id="468e7-279">The cached content can be rendered every frame without incurring the geometry tessellation cost per frame.</span></span> <span data-ttu-id="468e7-280">當您在 **GPUView** 中查看應用程式已實現部分的追蹤時，您可以清楚讓 DWM 呈現每個畫面格，而且 CPU 時間已大幅降低。</span><span class="sxs-lookup"><span data-stu-id="468e7-280">When looking at the trace in **GPUView** for the realized part of the app, it is clear that DWM is able to present every frame and the CPU time has reduced drastically.</span></span>

![顯示 GPUView 中的追蹤範例的螢幕擷取畫面，其中顯示 D W M 可以顯示每個畫面格。](images/profile13.png)

<span data-ttu-id="468e7-282">圖形的第一個部分顯示已實現的8192基本專案。</span><span class="sxs-lookup"><span data-stu-id="468e7-282">The first part of the graph shows realized 8192 primitives.</span></span> <span data-ttu-id="468e7-283">每個畫面的對應 CPU 時間可以容納在兩個連續的雙同步處理中。</span><span class="sxs-lookup"><span data-stu-id="468e7-283">The corresponding CPU time per frame is able to fit within two consecutive v-syncs.</span></span> <span data-ttu-id="468e7-284">在圖的稍後部分中，這不是正確的。</span><span class="sxs-lookup"><span data-stu-id="468e7-284">In the later part of the graph this is not true.</span></span>

<span data-ttu-id="468e7-285">在 **XPerf** 中，cpu 處於閒置狀態的最長時間，只有大約25% 的 cpu 時間花在幾何實現應用程式上。</span><span class="sxs-lookup"><span data-stu-id="468e7-285">Looking in **XPerf**, CPU is sitting idle for the longest time with only about 25% of the CPU time being spent on the geometry realization app.</span></span>

![gpuview 螢幕擷取畫面。](images/profile14.png)

## <a name="summary"></a><span data-ttu-id="468e7-287">總結</span><span class="sxs-lookup"><span data-stu-id="468e7-287">Summary</span></span>

<span data-ttu-id="468e7-288">**GPUView** 和 **XPerf** ，以及用來分析 [DirectX](/previous-versions/windows/apps/jj262109(v=win.10))應用程式效能的強大工具。</span><span class="sxs-lookup"><span data-stu-id="468e7-288">Both **GPUView** and **XPerf** and powerful tools for analyzing performance of [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) apps.</span></span> <span data-ttu-id="468e7-289">本文是使用這些工具，以及瞭解基本效能度量和應用程式特性的入門。</span><span class="sxs-lookup"><span data-stu-id="468e7-289">This article is a primer for using these tools and understanding basic performance measurements and app characteristics.</span></span> <span data-ttu-id="468e7-290">除了瞭解工具的使用方式，您必須先瞭解正在分析的應用程式。</span><span class="sxs-lookup"><span data-stu-id="468e7-290">Apart from understanding usage of tools, it is first important to understand the app being analyzed.</span></span> <span data-ttu-id="468e7-291">開始找出問題的答案，例如應用程式嘗試達成什麼目標？</span><span class="sxs-lookup"><span data-stu-id="468e7-291">Start with finding answers to questions like what is the app trying to achieve?</span></span> <span data-ttu-id="468e7-292">系統中的哪些執行緒最重要？</span><span class="sxs-lookup"><span data-stu-id="468e7-292">Which threads in the system are most important?</span></span> <span data-ttu-id="468e7-293">您願意做出哪些取捨？</span><span class="sxs-lookup"><span data-stu-id="468e7-293">What trade-offs are you willing to make?</span></span> <span data-ttu-id="468e7-294">分析效能追蹤時，請先查看明顯有問題的地方。</span><span class="sxs-lookup"><span data-stu-id="468e7-294">When analyzing performance traces, start by looking at obvious problematic places.</span></span> <span data-ttu-id="468e7-295">應用程式 CPU 或 GPU 是否受限制？</span><span class="sxs-lookup"><span data-stu-id="468e7-295">Is the app CPU or GPU bound?</span></span> <span data-ttu-id="468e7-296">應用程式是否能夠呈現每個畫面格？</span><span class="sxs-lookup"><span data-stu-id="468e7-296">Is the app able to present every frame?</span></span> <span data-ttu-id="468e7-297">工具以及對應用程式的瞭解，可以提供非常實用的資訊來瞭解、尋找並最後解決效能問題。</span><span class="sxs-lookup"><span data-stu-id="468e7-297">Tools together with an understanding of the app can give very useful information in understanding, finding and finally solving performance problems.</span></span>

 

 