---
description: 本主題說明如何建立、識別、設定和刪除計時器。
ms.assetid: 509a6fc4-ddee-4ff4-88a2-25dad4c48c2f
title: 關於計時器
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b3163dbfd5357de516e0202665cd76d017335593
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103945347"
---
# <a name="about-timers"></a><span data-ttu-id="96dbf-103">關於計時器</span><span class="sxs-lookup"><span data-stu-id="96dbf-103">About Timers</span></span>

<span data-ttu-id="96dbf-104">本主題說明如何建立、識別、設定和刪除計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-104">This topic describes how to create, identify, set, and delete timers.</span></span> <span data-ttu-id="96dbf-105">應用程式會在經過指定的時間之後，使用計時器來排程視窗的事件。</span><span class="sxs-lookup"><span data-stu-id="96dbf-105">An application uses a timer to schedule an event for a window after a specified time has elapsed.</span></span> <span data-ttu-id="96dbf-106">每次指定的間隔 (或超時時間值) 用於計時器時，系統會通知與計時器相關聯的視窗。</span><span class="sxs-lookup"><span data-stu-id="96dbf-106">Each time the specified interval (or time-out value) for a timer elapses, the system notifies the window associated with the timer.</span></span> <span data-ttu-id="96dbf-107">因為計時器的精確度取決於系統時鐘率，以及應用程式從訊息佇列中抓取訊息的頻率，所以超時值只是近似。</span><span class="sxs-lookup"><span data-stu-id="96dbf-107">Because a timer's accuracy depends on the system clock rate and how often the application retrieves messages from the message queue, the time-out value is only approximate.</span></span>

<span data-ttu-id="96dbf-108">本主題包含下列各節。</span><span class="sxs-lookup"><span data-stu-id="96dbf-108">This topic includes the following sections.</span></span>

-   [<span data-ttu-id="96dbf-109">計時器作業</span><span class="sxs-lookup"><span data-stu-id="96dbf-109">Timer Operations</span></span>](#timer-operations)
-   [<span data-ttu-id="96dbf-110">高解析度計時器</span><span class="sxs-lookup"><span data-stu-id="96dbf-110">High-Resolution Timer</span></span>](#high-resolution-timer)
-   [<span data-ttu-id="96dbf-111">可等候計時器物件</span><span class="sxs-lookup"><span data-stu-id="96dbf-111">Waitable Timer Objects</span></span>](#waitable-timer-objects)
-   [<span data-ttu-id="96dbf-112">相關主題</span><span class="sxs-lookup"><span data-stu-id="96dbf-112">Related topics</span></span>](#related-topics)

## <a name="timer-operations"></a><span data-ttu-id="96dbf-113">計時器作業</span><span class="sxs-lookup"><span data-stu-id="96dbf-113">Timer Operations</span></span>

<span data-ttu-id="96dbf-114">應用程式會使用 [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) 函數來建立計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-114">Applications create timers by using the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function.</span></span> <span data-ttu-id="96dbf-115">新的計時器會在建立間隔時立即開始計時。</span><span class="sxs-lookup"><span data-stu-id="96dbf-115">A new timer starts timing the interval as soon as it is created.</span></span> <span data-ttu-id="96dbf-116">應用程式可以使用 **SetTimer** 來變更計時器的超時值，而且可以使用 [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) 函數來終結計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-116">An application can change a timer's time-out value by using **SetTimer** and can destroy a timer by using the [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) function.</span></span> <span data-ttu-id="96dbf-117">若要有效率地使用系統資源，應用程式應該銷毀不再需要的計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-117">To use system resources efficiently, applications should destroy timers that are no longer necessary.</span></span>

<span data-ttu-id="96dbf-118">每個計時器都有唯一的識別碼。</span><span class="sxs-lookup"><span data-stu-id="96dbf-118">Each timer has a unique identifier.</span></span> <span data-ttu-id="96dbf-119">建立計時器時，應用程式可以指定識別碼或讓系統建立唯一值。</span><span class="sxs-lookup"><span data-stu-id="96dbf-119">When creating a timer, an application can either specify an identifier or have the system create a unique value.</span></span> <span data-ttu-id="96dbf-120">[**WM \_ 計時器**](wm-timer.md)訊息的第一個參數包含張貼訊息之計時器的識別碼。</span><span class="sxs-lookup"><span data-stu-id="96dbf-120">The first parameter of a [**WM\_TIMER**](wm-timer.md) message contains the identifier of the timer that posted the message.</span></span>

<span data-ttu-id="96dbf-121">如果您在呼叫 [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer)時指定視窗控制碼，則應用程式會將計時器與該視窗產生關聯。</span><span class="sxs-lookup"><span data-stu-id="96dbf-121">If you specify a window handle in the call to [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer), the application associates the timer with that window.</span></span> <span data-ttu-id="96dbf-122">每當計時器的超時值過期時，系統會將 [**WM \_ 計時器**](wm-timer.md) 訊息張貼至與計時器相關聯的視窗。</span><span class="sxs-lookup"><span data-stu-id="96dbf-122">Whenever the time-out value for the timer elapses, the system posts a [**WM\_TIMER**](wm-timer.md) message to the window associated with the timer.</span></span> <span data-ttu-id="96dbf-123">如果未在 **SetTimer** 的呼叫中指定視窗控制碼，則建立計時器的應用程式必須監視其 **WM \_ 計時器** 訊息的訊息佇列，並將其分派至適當的視窗。</span><span class="sxs-lookup"><span data-stu-id="96dbf-123">If no window handle is specified in the call to **SetTimer**, the application that created the timer must monitor its message queue for **WM\_TIMER** messages and dispatch them to the appropriate window.</span></span> <span data-ttu-id="96dbf-124">如果您指定 [**TimerProc**](/windows/win32/api/winuser/nc-winuser-timerproc) 回呼函式，則預設視窗程式會在處理 **WM \_ 計時器** 時呼叫回呼函式。</span><span class="sxs-lookup"><span data-stu-id="96dbf-124">If you specify a [**TimerProc**](/windows/win32/api/winuser/nc-winuser-timerproc) callback function, the default window procedure calls the callback function when it processes **WM\_TIMER**.</span></span> <span data-ttu-id="96dbf-125">因此，即使您使用 **TimerProc** 而不是處理 **WM \_ 計時器**，也必須在呼叫執行緒中分派訊息。</span><span class="sxs-lookup"><span data-stu-id="96dbf-125">Therefore, you need to dispatch messages in the calling thread, even when you use **TimerProc** instead of processing **WM\_TIMER**.</span></span>

<span data-ttu-id="96dbf-126">如果您需要在計時器過期時收到通知，請使用可等候計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-126">If you need to be notified when a timer elapses, use a waitable timer.</span></span> <span data-ttu-id="96dbf-127">如需詳細資訊，請參閱 [可等候計時器物件](/windows/desktop/Sync/waitable-timer-objects)。</span><span class="sxs-lookup"><span data-stu-id="96dbf-127">For more information, see [Waitable Timer Objects](/windows/desktop/Sync/waitable-timer-objects).</span></span>

## <a name="high-resolution-timer"></a><span data-ttu-id="96dbf-128">High-Resolution 計時器</span><span class="sxs-lookup"><span data-stu-id="96dbf-128">High-Resolution Timer</span></span>

<span data-ttu-id="96dbf-129">計數器是在程式設計中用來參考遞增變數的一般詞彙。</span><span class="sxs-lookup"><span data-stu-id="96dbf-129">A counter is a general term used in programming to refer to an incrementing variable.</span></span> <span data-ttu-id="96dbf-130">某些系統包含高解析度效能計數器，可提供高解析度的經過時間。</span><span class="sxs-lookup"><span data-stu-id="96dbf-130">Some systems include a high-resolution performance counter that provides high-resolution elapsed times.</span></span>

<span data-ttu-id="96dbf-131">如果系統上有高解析度的效能計數器，您可以使用 [**QueryPerformanceFrequency**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancefrequency) 函式來表示頻率（以每秒計數）。</span><span class="sxs-lookup"><span data-stu-id="96dbf-131">If a high-resolution performance counter exists on the system, you can use the [**QueryPerformanceFrequency**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancefrequency) function to express the frequency, in counts per second.</span></span> <span data-ttu-id="96dbf-132">計數的值與處理器相依。</span><span class="sxs-lookup"><span data-stu-id="96dbf-132">The value of the count is processor dependent.</span></span> <span data-ttu-id="96dbf-133">例如，在某些處理器上，計數可能是處理器時鐘的迴圈速率。</span><span class="sxs-lookup"><span data-stu-id="96dbf-133">On some processors, for example, the count might be the cycle rate of the processor clock.</span></span>

<span data-ttu-id="96dbf-134">[**QueryPerformanceCounter**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter)函式會捕獲高解析度效能計數器的目前值。</span><span class="sxs-lookup"><span data-stu-id="96dbf-134">The [**QueryPerformanceCounter**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter) function retrieves the current value of the high-resolution performance counter.</span></span> <span data-ttu-id="96dbf-135">藉由在程式碼區段的開頭和結尾呼叫這個函數，應用程式基本上會使用計數器作為高解析度計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-135">By calling this function at the beginning and end of a section of code, an application essentially uses the counter as a high-resolution timer.</span></span> <span data-ttu-id="96dbf-136">例如，假設 [**QueryPerformanceFrequency**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancefrequency) 指出高解析度效能計數器的頻率是每秒50000個計數。</span><span class="sxs-lookup"><span data-stu-id="96dbf-136">For example, suppose that [**QueryPerformanceFrequency**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancefrequency) indicates that the frequency of the high-resolution performance counter is 50,000 counts per second.</span></span> <span data-ttu-id="96dbf-137">如果應用程式在程式碼區段之前和之後立即呼叫 **QueryPerformanceCounter** ，則計數器值可能分別為1500計數和3500計數。</span><span class="sxs-lookup"><span data-stu-id="96dbf-137">If the application calls **QueryPerformanceCounter** immediately before and immediately after the section of code to be timed, the counter values might be 1500 counts and 3500 counts, respectively.</span></span> <span data-ttu-id="96dbf-138">這些值會指出在程式碼執行期間，.04 的秒數 (2000) 經過的時間。</span><span class="sxs-lookup"><span data-stu-id="96dbf-138">These values would indicate that .04 seconds (2000 counts) elapsed while the code executed.</span></span>

## <a name="waitable-timer-objects"></a><span data-ttu-id="96dbf-139">可等候計時器物件</span><span class="sxs-lookup"><span data-stu-id="96dbf-139">Waitable Timer Objects</span></span>

<span data-ttu-id="96dbf-140">可等候計時器物件是一種同步處理物件，其狀態會在指定的到期時間到達時設為已發出信號。</span><span class="sxs-lookup"><span data-stu-id="96dbf-140">A waitable timer object is a synchronization object whose state is set to signaled when the specified due time arrives.</span></span> <span data-ttu-id="96dbf-141">您可以建立兩種類型的可等候計時器：手動重設和同步處理。</span><span class="sxs-lookup"><span data-stu-id="96dbf-141">There are two types of waitable timers that can be created: manual-reset and synchronization.</span></span> <span data-ttu-id="96dbf-142">這兩種類型的計時器也可以是週期性計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-142">A timer of either type can also be a periodic timer.</span></span>

<span data-ttu-id="96dbf-143">執行緒使用 [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) 或 [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) 函數來建立計時器物件。</span><span class="sxs-lookup"><span data-stu-id="96dbf-143">A thread uses the [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) or [**CreateWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) function to create a timer object.</span></span> <span data-ttu-id="96dbf-144">建立執行緒會指定計時器是手動重設計時器或同步處理計時器。</span><span class="sxs-lookup"><span data-stu-id="96dbf-144">The creating thread specifies whether the timer is a manual-reset timer or a synchronization timer.</span></span> <span data-ttu-id="96dbf-145">建立執行緒可以指定計時器物件的名稱。</span><span class="sxs-lookup"><span data-stu-id="96dbf-145">The creating thread can specify a name for the timer object.</span></span> <span data-ttu-id="96dbf-146">其他進程中的執行緒可以藉由在 [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) 函式的呼叫中指定其名稱，來開啟現有計時器的控制碼。</span><span class="sxs-lookup"><span data-stu-id="96dbf-146">Threads in other processes can open a handle to an existing timer by specifying its name in a call to the [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) function.</span></span> <span data-ttu-id="96dbf-147">任何具有計時器物件之控制碼的執行緒都可以使用其中一個等候函式來等候計時器狀態設定為已發出信號。</span><span class="sxs-lookup"><span data-stu-id="96dbf-147">Any thread with a handle to a timer object can use one of the wait functions to wait for the timer state to be set to signaled.</span></span>

<span data-ttu-id="96dbf-148">如需有關使用可等候計時器物件進行執行緒同步處理的詳細資訊，請參閱 [可等候計時器物件](/windows/desktop/Sync/waitable-timer-objects)。</span><span class="sxs-lookup"><span data-stu-id="96dbf-148">For more information about using waitable timer objects for thread synchronization, see [Waitable Timer Objects](/windows/desktop/Sync/waitable-timer-objects).</span></span>

## <a name="related-topics"></a><span data-ttu-id="96dbf-149">相關主題</span><span class="sxs-lookup"><span data-stu-id="96dbf-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="96dbf-150">使用計時器</span><span class="sxs-lookup"><span data-stu-id="96dbf-150">Using Timers</span></span>](using-timers.md)
</dt> </dl>

 

 
