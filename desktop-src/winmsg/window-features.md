---
description: 本總覽討論視窗的功能，例如視窗類型、狀態、大小和位置。
ms.assetid: 8318c22f-85a2-490e-8233-ee1e234890d9
title: 視窗功能
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 228c6b4ab59102cae38a248935fbbad32198f2e0
ms.sourcegitcommit: 8755905962e156f29203705d09d6df8b7d0e2fca
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/25/2021
ms.locfileid: "106995113"
---
# <a name="window-features"></a><span data-ttu-id="aa509-103">視窗功能</span><span class="sxs-lookup"><span data-stu-id="aa509-103">Window Features</span></span>

<span data-ttu-id="aa509-104">本總覽討論視窗的功能，例如視窗類型、狀態、大小和位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-104">This overview discusses features of windows such as window types, states, size, and position.</span></span>

-   [<span data-ttu-id="aa509-105">視窗類型</span><span class="sxs-lookup"><span data-stu-id="aa509-105">Window Types</span></span>](#window-types)
    -   [<span data-ttu-id="aa509-106">重迭視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-106">Overlapped Windows</span></span>](#overlapped-windows)
    -   [<span data-ttu-id="aa509-107">快顯視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-107">Pop-up Windows</span></span>](#pop-up-windows)
    -   [<span data-ttu-id="aa509-108">子視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-108">Child Windows</span></span>](#child-windows)
        -   [<span data-ttu-id="aa509-109">定位</span><span class="sxs-lookup"><span data-stu-id="aa509-109">Positioning</span></span>](#positioning)
        -   [<span data-ttu-id="aa509-110">裁剪</span><span class="sxs-lookup"><span data-stu-id="aa509-110">Clipping</span></span>](#clipping)
        -   [<span data-ttu-id="aa509-111">父視窗的關聯性</span><span class="sxs-lookup"><span data-stu-id="aa509-111">Relationship to Parent Window</span></span>](#relationship-to-parent-window)
        -   [<span data-ttu-id="aa509-112">訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-112">Messages</span></span>](#size-and-position-messages)
    -   [<span data-ttu-id="aa509-113">分層視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-113">Layered Windows</span></span>](#layered-windows)
    -   [<span data-ttu-id="aa509-114">僅限訊息的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-114">Message-Only Windows</span></span>](#message-only-windows)
-   [<span data-ttu-id="aa509-115">視窗關聯性</span><span class="sxs-lookup"><span data-stu-id="aa509-115">Window Relationships</span></span>](#window-relationships)
    -   [<span data-ttu-id="aa509-116">前景和背景視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-116">Foreground and Background Windows</span></span>](#foreground-and-background-windows)
    -   [<span data-ttu-id="aa509-117">擁有的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-117">Owned Windows</span></span>](#owned-windows)
    -   [<span data-ttu-id="aa509-118">Z 順序</span><span class="sxs-lookup"><span data-stu-id="aa509-118">Z-Order</span></span>](#z-order)
-   [<span data-ttu-id="aa509-119">視窗顯示狀態</span><span class="sxs-lookup"><span data-stu-id="aa509-119">Window Show State</span></span>](#window-show-state)
    -   [<span data-ttu-id="aa509-120">使用中視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-120">Active Window</span></span>](#active-window)
    -   [<span data-ttu-id="aa509-121">停用的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-121">Disabled Windows</span></span>](#disabled-windows)
    -   [<span data-ttu-id="aa509-122">視窗可見度</span><span class="sxs-lookup"><span data-stu-id="aa509-122">Window Visibility</span></span>](#window-visibility)
    -   [<span data-ttu-id="aa509-123">最小化、最大化和還原的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-123">Minimized, Maximized, and Restored Windows</span></span>](#minimized-maximized-and-restored-windows)
-   [<span data-ttu-id="aa509-124">視窗大小和位置</span><span class="sxs-lookup"><span data-stu-id="aa509-124">Window Size and Position</span></span>](#window-size-and-position)
    -   [<span data-ttu-id="aa509-125">預設大小和位置</span><span class="sxs-lookup"><span data-stu-id="aa509-125">Default Size and Position</span></span>](#default-size-and-position)
    -   [<span data-ttu-id="aa509-126">追蹤大小</span><span class="sxs-lookup"><span data-stu-id="aa509-126">Tracking Size</span></span>](#tracking-size)
    -   [<span data-ttu-id="aa509-127">系統命令</span><span class="sxs-lookup"><span data-stu-id="aa509-127">System Commands</span></span>](#system-commands)
    -   [<span data-ttu-id="aa509-128">大小和位置函式</span><span class="sxs-lookup"><span data-stu-id="aa509-128">Size and Position Functions</span></span>](#size-and-position-functions)
    -   [<span data-ttu-id="aa509-129">大小和位置訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-129">Size and Position Messages</span></span>](#size-and-position-messages)
-   [<span data-ttu-id="aa509-130">視窗動畫</span><span class="sxs-lookup"><span data-stu-id="aa509-130">Window Animation</span></span>](#window-animation)
-   [<span data-ttu-id="aa509-131">視窗版面配置和鏡像</span><span class="sxs-lookup"><span data-stu-id="aa509-131">Window Layout and Mirroring</span></span>](#window-layout-and-mirroring)
    -   [<span data-ttu-id="aa509-132">鏡像對話方塊和訊息方塊</span><span class="sxs-lookup"><span data-stu-id="aa509-132">Mirroring Dialog Boxes and Message Boxes</span></span>](#mirroring-dialog-boxes-and-message-boxes)
    -   [<span data-ttu-id="aa509-133">未與視窗相關聯的鏡像裝置內容</span><span class="sxs-lookup"><span data-stu-id="aa509-133">Mirroring Device Contexts Not Associated with a Window</span></span>](#mirroring-device-contexts-not-associated-with-a-window)
-   [<span data-ttu-id="aa509-134">視窗損毀</span><span class="sxs-lookup"><span data-stu-id="aa509-134">Window Destruction</span></span>](#window-destruction)

## <a name="window-types"></a><span data-ttu-id="aa509-135">視窗類型</span><span class="sxs-lookup"><span data-stu-id="aa509-135">Window Types</span></span>

<span data-ttu-id="aa509-136">本節包含描述視窗類型的下列主題。</span><span class="sxs-lookup"><span data-stu-id="aa509-136">This section contains the following topics that describe window types.</span></span>

-   [<span data-ttu-id="aa509-137">重迭視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-137">Overlapped Windows</span></span>](#overlapped-windows)
-   [<span data-ttu-id="aa509-138">快顯視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-138">Pop-up Windows</span></span>](#pop-up-windows)
-   [<span data-ttu-id="aa509-139">子視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-139">Child Windows</span></span>](#child-windows)
-   [<span data-ttu-id="aa509-140">分層視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-140">Layered Windows</span></span>](#layered-windows)
-   [<span data-ttu-id="aa509-141">僅限訊息的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-141">Message-Only Windows</span></span>](#message-only-windows)

### <a name="overlapped-windows"></a><span data-ttu-id="aa509-142">重迭視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-142">Overlapped Windows</span></span>

<span data-ttu-id="aa509-143">重迭 *視窗* 是最上層視窗， (具有標題列、框線和工作區的非子視窗) ;它是作為應用程式的主視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-143">An *overlapped window* is a top-level window (non-child window) that has a title bar, border, and client area; it is meant to serve as an application's main window.</span></span> <span data-ttu-id="aa509-144">它也可以有視窗功能表、最小化和最大化按鈕，以及捲軸。</span><span class="sxs-lookup"><span data-stu-id="aa509-144">It can also have a window menu, minimize and maximize buttons, and scroll bars.</span></span> <span data-ttu-id="aa509-145">當做主視窗使用的重迭視窗通常包含所有這些元件。</span><span class="sxs-lookup"><span data-stu-id="aa509-145">An overlapped window used as a main window typically includes all of these components.</span></span>

<span data-ttu-id="aa509-146">藉由在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函式中指定 ws 重迭或 **ws \_ OVERLAPPEDWINDOW** 樣式，應用程式會建立一個重迭的視窗。 [**\_**](window-styles.md)</span><span class="sxs-lookup"><span data-stu-id="aa509-146">By specifying the [**WS\_OVERLAPPED**](window-styles.md) or **WS\_OVERLAPPEDWINDOW** style in the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function, an application creates an overlapped window.</span></span> <span data-ttu-id="aa509-147">如果您使用 **WS 重 \_** 迭樣式，則視窗具有標題列和框線。</span><span class="sxs-lookup"><span data-stu-id="aa509-147">If you use the **WS\_OVERLAPPED** style, the window has a title bar and border.</span></span> <span data-ttu-id="aa509-148">如果您使用 **WS \_ OVERLAPPEDWINDOW** 樣式，則視窗具有標題列、調整大小框線、視窗功能表，以及最小化和最大化按鈕。</span><span class="sxs-lookup"><span data-stu-id="aa509-148">If you use the **WS\_OVERLAPPEDWINDOW** style, the window has a title bar, sizing border, window menu, and minimize and maximize buttons.</span></span>

### <a name="pop-up-windows"></a><span data-ttu-id="aa509-149">快顯視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-149">Pop-up Windows</span></span>

<span data-ttu-id="aa509-150">*快顯視窗* 是一種特殊類型的重迭視窗，用於對話方塊、訊息方塊，以及顯示在應用程式主視窗外部的其他暫存視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-150">A *pop-up window* is a special type of overlapped window used for dialog boxes, message boxes, and other temporary windows that appear outside an application's main window.</span></span> <span data-ttu-id="aa509-151">標題列是快顯視窗的選擇性專案;否則，快顯視窗與 WS 重迭樣式的重迭視窗相同 [**。 \_**](window-styles.md)</span><span class="sxs-lookup"><span data-stu-id="aa509-151">Title bars are optional for pop-up windows; otherwise, pop-up windows are the same as overlapped windows of the [**WS\_OVERLAPPED**](window-styles.md) style.</span></span>

<span data-ttu-id="aa509-152">您可以藉由在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)中指定 [**WS \_ 彈出**](window-styles.md)視窗樣式來建立快顯視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-152">You create a pop-up window by specifying the [**WS\_POPUP**](window-styles.md) style in [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa).</span></span> <span data-ttu-id="aa509-153">若要包含標題列，請指定 **WS \_ 標題** 樣式。</span><span class="sxs-lookup"><span data-stu-id="aa509-153">To include a title bar, specify the **WS\_CAPTION** style.</span></span> <span data-ttu-id="aa509-154">使用 **WS \_ POPUPWINDOW** 樣式，建立具有框線和視窗功能表的快顯視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-154">Use the **WS\_POPUPWINDOW** style to create a pop-up window that has a border and a window menu.</span></span> <span data-ttu-id="aa509-155">**Ws \_ 標題** 樣式必須與 **ws \_ POPUPWINDOW** 樣式結合，才能讓視窗功能表顯示。</span><span class="sxs-lookup"><span data-stu-id="aa509-155">The **WS\_CAPTION** style must be combined with the **WS\_POPUPWINDOW** style to make the window menu visible.</span></span>

### <a name="child-windows"></a><span data-ttu-id="aa509-156">子視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-156">Child Windows</span></span>

<span data-ttu-id="aa509-157">*子視窗* 具有 [**WS \_ 子**](window-styles.md)樣式，且受限於其父視窗的工作區。</span><span class="sxs-lookup"><span data-stu-id="aa509-157">A *child window* has the [**WS\_CHILD**](window-styles.md) style and is confined to the client area of its parent window.</span></span> <span data-ttu-id="aa509-158">應用程式通常會使用子視窗將父視窗的工作區分割成功能區域。</span><span class="sxs-lookup"><span data-stu-id="aa509-158">An application typically uses child windows to divide the client area of a parent window into functional areas.</span></span> <span data-ttu-id="aa509-159">您可以藉由在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函式中指定 **WS \_ 子** 系樣式來建立子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-159">You create a child window by specifying the **WS\_CHILD** style in the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function.</span></span>

<span data-ttu-id="aa509-160">子視窗必須有父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-160">A child window must have a parent window.</span></span> <span data-ttu-id="aa509-161">父視窗可以是重迭的視窗、快顯視窗，甚至是另一個子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-161">The parent window can be an overlapped window, a pop-up window, or even another child window.</span></span> <span data-ttu-id="aa509-162">當您呼叫 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)時，請指定父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-162">You specify the parent window when you call [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa).</span></span> <span data-ttu-id="aa509-163">如果您在 **CreateWindowEx** 中指定 [**WS \_ 子**](window-styles.md)樣式，但是未指定父視窗，系統就不會建立視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-163">If you specify the [**WS\_CHILD**](window-styles.md) style in **CreateWindowEx** but do not specify a parent window, the system does not create the window.</span></span>

<span data-ttu-id="aa509-164">子視窗具有工作區，但沒有其他功能，除非明確要求它們。</span><span class="sxs-lookup"><span data-stu-id="aa509-164">A child window has a client area but no other features, unless they are explicitly requested.</span></span> <span data-ttu-id="aa509-165">應用程式可以要求標題列、視窗功能表、最小化和最大化按鈕、框線和子視窗捲軸，但是子視窗不能有功能表。</span><span class="sxs-lookup"><span data-stu-id="aa509-165">An application can request a title bar, a window menu, minimize and maximize buttons, a border, and scroll bars for a child window, but a child window cannot have a menu.</span></span> <span data-ttu-id="aa509-166">如果應用程式指定功能表控制碼，則在註冊子視窗類別或建立子視窗時，會忽略功能表控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-166">If the application specifies a menu handle, either when it registers the child's window class or creates the child window, the menu handle is ignored.</span></span> <span data-ttu-id="aa509-167">如果未指定框線樣式，系統會建立無邊框的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-167">If no border style is specified, the system creates a borderless window.</span></span> <span data-ttu-id="aa509-168">應用程式可以使用無邊框的子視窗來分割父視窗的工作區，同時讓使用者看不到這些片段。</span><span class="sxs-lookup"><span data-stu-id="aa509-168">An application can use borderless child windows to divide a parent window's client area while keeping the divisions invisible to the user.</span></span>

<span data-ttu-id="aa509-169">本節將討論子視窗的下列層面：</span><span class="sxs-lookup"><span data-stu-id="aa509-169">This section discusses the following aspects of child windows:</span></span>

-   [<span data-ttu-id="aa509-170">定位</span><span class="sxs-lookup"><span data-stu-id="aa509-170">Positioning</span></span>](#positioning)
-   [<span data-ttu-id="aa509-171">裁剪</span><span class="sxs-lookup"><span data-stu-id="aa509-171">Clipping</span></span>](#clipping)
-   [<span data-ttu-id="aa509-172">父視窗的關聯性</span><span class="sxs-lookup"><span data-stu-id="aa509-172">Relationship to Parent Window</span></span>](#relationship-to-parent-window)
-   [<span data-ttu-id="aa509-173">訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-173">Messages</span></span>](#size-and-position-messages)

#### <a name="positioning"></a><span data-ttu-id="aa509-174">定位</span><span class="sxs-lookup"><span data-stu-id="aa509-174">Positioning</span></span>

<span data-ttu-id="aa509-175">系統一律會將子視窗相對於其父視窗工作區的左上角。</span><span class="sxs-lookup"><span data-stu-id="aa509-175">The system always positions a child window relative to the upper left corner of its parent window's client area.</span></span> <span data-ttu-id="aa509-176">子視窗的任何部分，都不會出現在其父視窗的框線之外。</span><span class="sxs-lookup"><span data-stu-id="aa509-176">No part of a child window ever appears outside the borders of its parent window.</span></span> <span data-ttu-id="aa509-177">如果應用程式建立的子視窗大於父視窗，或將子視窗放置於子視窗之外，使部分或全部的子視窗延伸超過父系的框線，系統就會裁剪子視窗;也就是說，不會顯示父視窗工作區外的部分。</span><span class="sxs-lookup"><span data-stu-id="aa509-177">If an application creates a child window that is larger than the parent window or positions a child window so that some or all of the child window extends beyond the borders of the parent, the system clips the child window; that is, the portion outside the parent window's client area is not displayed.</span></span> <span data-ttu-id="aa509-178">影響父視窗的動作也會影響子視窗，如下所示。</span><span class="sxs-lookup"><span data-stu-id="aa509-178">Actions that affect the parent window can also affect the child window, as follows.</span></span>



| <span data-ttu-id="aa509-179">父視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-179">Parent Window</span></span> | <span data-ttu-id="aa509-180">子視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-180">Child Window</span></span>                                                                                                             |
|---------------|--------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="aa509-181">終結</span><span class="sxs-lookup"><span data-stu-id="aa509-181">Destroyed</span></span>     | <span data-ttu-id="aa509-182">在父視窗損毀之前終結。</span><span class="sxs-lookup"><span data-stu-id="aa509-182">Destroyed before the parent window is destroyed.</span></span>                                                                         |
| <span data-ttu-id="aa509-183">Hidden</span><span class="sxs-lookup"><span data-stu-id="aa509-183">Hidden</span></span>        | <span data-ttu-id="aa509-184">隱藏之前隱藏的父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-184">Hidden before the parent window is hidden.</span></span> <span data-ttu-id="aa509-185">只有當父視窗可見時，才會顯示子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-185">A child window is visible only when the parent window is visible.</span></span>             |
| <span data-ttu-id="aa509-186">搬</span><span class="sxs-lookup"><span data-stu-id="aa509-186">Moved</span></span>         | <span data-ttu-id="aa509-187">使用父視窗的工作區移動。</span><span class="sxs-lookup"><span data-stu-id="aa509-187">Moved with the parent window's client area.</span></span> <span data-ttu-id="aa509-188">子視窗負責在移動之後繪製其工作區。</span><span class="sxs-lookup"><span data-stu-id="aa509-188">The child window is responsible for painting its client area after the move.</span></span> |
| <span data-ttu-id="aa509-189">顯示</span><span class="sxs-lookup"><span data-stu-id="aa509-189">Shown</span></span>         | <span data-ttu-id="aa509-190">顯示父視窗之後顯示。</span><span class="sxs-lookup"><span data-stu-id="aa509-190">Shown after the parent window is shown.</span></span>                                                                                  |



 

#### <a name="clipping"></a><span data-ttu-id="aa509-191">裁剪</span><span class="sxs-lookup"><span data-stu-id="aa509-191">Clipping</span></span>

<span data-ttu-id="aa509-192">系統不會自動從父視窗的工作區裁剪子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-192">The system does not automatically clip a child window from the parent window's client area.</span></span> <span data-ttu-id="aa509-193">這表示，如果父視窗在與子視窗相同的位置中執行任何繪圖，則會在子視窗上方繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-193">This means the parent window draws over the child window if it carries out any drawing in the same location as the child window.</span></span> <span data-ttu-id="aa509-194">但是，如果父視窗具有 [**WS \_ CLIPCHILDREN**](window-styles.md) 樣式，系統就會從父視窗的工作區裁剪子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-194">However, the system does clip the child window from the parent window's client area if the parent window has the [**WS\_CLIPCHILDREN**](window-styles.md) style.</span></span> <span data-ttu-id="aa509-195">如果子視窗被裁剪，父視窗就無法在其上繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-195">If the child window is clipped, the parent window cannot draw over it.</span></span>

<span data-ttu-id="aa509-196">子視窗可以與相同工作區中的其他子視窗重迭。</span><span class="sxs-lookup"><span data-stu-id="aa509-196">A child window can overlap other child windows in the same client area.</span></span> <span data-ttu-id="aa509-197">與一或多個其他子視窗共用相同父視窗的子視窗稱為「同級」 *視窗*。</span><span class="sxs-lookup"><span data-stu-id="aa509-197">A child window that shares the same parent window as one or more other child windows is called a *sibling window*.</span></span> <span data-ttu-id="aa509-198">除非其中一個子視窗具有 [**WS \_ CLIPSIBLINGS**](window-styles.md) 樣式，否則同輩視窗可以在彼此的工作區中繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-198">Sibling windows can draw in each other's client area, unless one of the child windows has the [**WS\_CLIPSIBLINGS**](window-styles.md) style.</span></span> <span data-ttu-id="aa509-199">如果子視窗有此樣式，則會裁剪其子視窗內任何其同級視窗的任何部分。</span><span class="sxs-lookup"><span data-stu-id="aa509-199">If a child window does have this style, any portion of its sibling window that lies within the child window is clipped.</span></span>

<span data-ttu-id="aa509-200">如果視窗具有 [**ws \_ CLIPCHILDREN**](window-styles.md) 或 **ws \_ CLIPSIBLINGS** 樣式，效能就會稍微遺失。</span><span class="sxs-lookup"><span data-stu-id="aa509-200">If a window has either the [**WS\_CLIPCHILDREN**](window-styles.md) or **WS\_CLIPSIBLINGS** style, a slight loss in performance occurs.</span></span> <span data-ttu-id="aa509-201">每個視窗都會佔用系統資源，因此應用程式不會有不限的使用子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-201">Each window takes up system resources, so an application should not use child windows indiscriminately.</span></span> <span data-ttu-id="aa509-202">為了達到最佳效能，需要以邏輯方式分割主視窗的應用程式應該在主視窗的視窗程式中執行，而不是使用子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-202">For best performance, an application that needs to logically divide its main window should do so in the window procedure of the main window rather than by using child windows.</span></span>

#### <a name="relationship-to-parent-window"></a><span data-ttu-id="aa509-203">父視窗的關聯性</span><span class="sxs-lookup"><span data-stu-id="aa509-203">Relationship to Parent Window</span></span>

<span data-ttu-id="aa509-204">應用程式可以藉由呼叫 [**SetParent**](/windows/win32/api/winuser/nf-winuser-setparent) 函數來變更現有子視窗的父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-204">An application can change the parent window of an existing child window by calling the [**SetParent**](/windows/win32/api/winuser/nf-winuser-setparent) function.</span></span> <span data-ttu-id="aa509-205">在這種情況下，系統會從舊的父視窗的工作區中移除子視窗，並將它移至新父視窗的工作區。</span><span class="sxs-lookup"><span data-stu-id="aa509-205">In this case, the system removes the child window from the client area of the old parent window and moves it to the client area of the new parent window.</span></span> <span data-ttu-id="aa509-206">如果 **SetParent** 指定 **Null** 控制碼，桌面視窗就會變成新的父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-206">If **SetParent** specifies a **NULL** handle, the desktop window becomes the new parent window.</span></span> <span data-ttu-id="aa509-207">在此情況下，子視窗會在桌面上繪製于任何其他視窗的框線之外。</span><span class="sxs-lookup"><span data-stu-id="aa509-207">In this case, the child window is drawn on the desktop, outside the borders of any other window.</span></span> <span data-ttu-id="aa509-208">[**GetParent**](/windows/win32/api/winuser/nf-winuser-getparent)函式會將控制碼捕獲到子視窗的父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-208">The [**GetParent**](/windows/win32/api/winuser/nf-winuser-getparent) function retrieves a handle to a child window's parent window.</span></span>

<span data-ttu-id="aa509-209">父視窗會將其工作區的一部分會讓出至子視窗，而子視窗則會接收此區域的所有輸入。</span><span class="sxs-lookup"><span data-stu-id="aa509-209">The parent window relinquishes a portion of its client area to a child window, and the child window receives all input from this area.</span></span> <span data-ttu-id="aa509-210">父視窗的每個子視窗的視窗類別都不需要相同的。</span><span class="sxs-lookup"><span data-stu-id="aa509-210">The window class need not be the same for each of the child windows of the parent window.</span></span> <span data-ttu-id="aa509-211">這表示，應用程式可以使用外觀不同的子視窗來填滿父視窗，並執行不同的工作。</span><span class="sxs-lookup"><span data-stu-id="aa509-211">This means that an application can fill a parent window with child windows that look different and carry out different tasks.</span></span> <span data-ttu-id="aa509-212">例如，對話方塊可包含許多類型的控制項，每個都有一個子視窗接受來自使用者的不同資料類型。</span><span class="sxs-lookup"><span data-stu-id="aa509-212">For example, a dialog box can contain many types of controls, each one a child window that accepts different types of data from the user.</span></span>

<span data-ttu-id="aa509-213">子視窗只有一個父視窗，但父系可以有任意數目的子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-213">A child window has only one parent window, but a parent can have any number of child windows.</span></span> <span data-ttu-id="aa509-214">每個子視窗接著都可以有子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-214">Each child window, in turn, can have child windows.</span></span> <span data-ttu-id="aa509-215">在這一系列的 windows 中，每個子視窗稱為原始父視窗的子系視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-215">In this chain of windows, each child window is called a descendant window of the original parent window.</span></span> <span data-ttu-id="aa509-216">應用程式會使用 [**IsChild**](/windows/win32/api/winuser/nf-winuser-ischild) 函式，來探索指定的視窗是否為指定之父視窗的子視窗或子系視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-216">An application uses the [**IsChild**](/windows/win32/api/winuser/nf-winuser-ischild) function to discover whether a given window is a child window or a descendant window of a given parent window.</span></span>

<span data-ttu-id="aa509-217">[**EnumChildWindows**](/windows/win32/api/winuser/nf-winuser-enumchildwindows)函式會列舉父視窗的子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-217">The [**EnumChildWindows**](/windows/win32/api/winuser/nf-winuser-enumchildwindows) function enumerates the child windows of a parent window.</span></span> <span data-ttu-id="aa509-218">然後， **EnumChildWindows** 會將控制碼傳遞至應用程式定義的回呼函數。</span><span class="sxs-lookup"><span data-stu-id="aa509-218">Then, **EnumChildWindows** passes the handle to each child window to an application-defined callback function.</span></span> <span data-ttu-id="aa509-219">也會列舉指定父視窗的子系視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-219">Descendant windows of the given parent window are also enumerated.</span></span>

#### <a name="messages"></a><span data-ttu-id="aa509-220">訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-220">Messages</span></span>

<span data-ttu-id="aa509-221">系統會將子視窗的輸入訊息直接傳遞給子視窗;訊息不會透過父視窗傳遞。</span><span class="sxs-lookup"><span data-stu-id="aa509-221">The system passes a child window's input messages directly to the child window; the messages are not passed through the parent window.</span></span> <span data-ttu-id="aa509-222">唯一的例外狀況是 [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) 函數已停用子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-222">The only exception is if the child window has been disabled by the [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) function.</span></span> <span data-ttu-id="aa509-223">在此情況下，系統會改為將已移至子視窗的任何輸入訊息傳送至父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-223">In this case, the system passes any input messages that would have gone to the child window to the parent window instead.</span></span> <span data-ttu-id="aa509-224">這可讓父視窗檢查輸入訊息並視需要啟用子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-224">This permits the parent window to examine the input messages and enable the child window, if necessary.</span></span>

<span data-ttu-id="aa509-225">子視窗可以有唯一的整數識別碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-225">A child window can have a unique integer identifier.</span></span> <span data-ttu-id="aa509-226">使用控制項視窗時，子視窗識別碼相當重要。</span><span class="sxs-lookup"><span data-stu-id="aa509-226">Child window identifiers are important when working with control windows.</span></span> <span data-ttu-id="aa509-227">應用程式會藉由傳送訊息來導向控制項的活動。</span><span class="sxs-lookup"><span data-stu-id="aa509-227">An application directs a control's activity by sending it messages.</span></span> <span data-ttu-id="aa509-228">應用程式會使用控制項的子視窗識別碼，將訊息導向至控制項。</span><span class="sxs-lookup"><span data-stu-id="aa509-228">The application uses the control's child window identifier to direct the messages to the control.</span></span> <span data-ttu-id="aa509-229">此外，控制項會將通知訊息傳送至其父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-229">In addition, a control sends notification messages to its parent window.</span></span> <span data-ttu-id="aa509-230">通知訊息會包含控制項的子視窗識別碼，父系會使用此識別碼來識別傳送訊息的控制項。</span><span class="sxs-lookup"><span data-stu-id="aa509-230">A notification message includes the control's child window identifier, which the parent uses to identify which control sent the message.</span></span> <span data-ttu-id="aa509-231">應用程式會藉由將 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函式的 *hMenu* 參數設定為值而非功能表控制碼，來指定其他類型之子視窗的子視窗識別碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-231">An application specifies the child-window identifier for other types of child windows by setting the *hMenu* parameter of the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function to a value rather than a menu handle.</span></span>

### <a name="layered-windows"></a><span data-ttu-id="aa509-232">分層視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-232">Layered Windows</span></span>

<span data-ttu-id="aa509-233">使用分層視窗可大幅改善具有複雜圖形、動畫圖形或希望使用 Alpha 混色效果之視窗的效能和視覺效果。</span><span class="sxs-lookup"><span data-stu-id="aa509-233">Using a layered window can significantly improve performance and visual effects for a window that has a complex shape, animates its shape, or wishes to use alpha blending effects.</span></span> <span data-ttu-id="aa509-234">系統會自動撰寫和重新繪製分層視窗和基礎應用程式的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-234">The system automatically composes and repaints layered windows and the windows of underlying applications.</span></span> <span data-ttu-id="aa509-235">如此一來，就能順暢地轉譯分層視窗，而不會有複雜視窗區域的閃爍。</span><span class="sxs-lookup"><span data-stu-id="aa509-235">As a result, layered windows are rendered smoothly, without the flickering typical of complex window regions.</span></span> <span data-ttu-id="aa509-236">此外，分層視窗也可以部分半透明，也就是以 Alpha 混合的方式。</span><span class="sxs-lookup"><span data-stu-id="aa509-236">In addition, layered windows can be partially translucent, that is, alpha-blended.</span></span>

<span data-ttu-id="aa509-237">若要建立多層式視窗，請在呼叫 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函式時指定 **ws \_ ex \_ 分層** 擴充視窗樣式，或呼叫 [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga)函式，以在建立視窗之後設定 **ws \_ ex \_ 分層**。</span><span class="sxs-lookup"><span data-stu-id="aa509-237">To create a layered window, specify the **WS\_EX\_LAYERED** extended window style when calling the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function, or call the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function to set **WS\_EX\_LAYERED** after the window has been created.</span></span> <span data-ttu-id="aa509-238">在 **CreateWindowEx** 呼叫之後，在此視窗中呼叫 [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes) 或 [**UpdateLayeredWindow**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow) 函式之前，不會顯示多層式視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-238">After the **CreateWindowEx** call, the layered window will not become visible until the [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes) or [**UpdateLayeredWindow**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow) function has been called for this window.</span></span>

> [!Note]  
> <span data-ttu-id="aa509-239">從 Windows 8 開始， **WS \_ EX \_ 分層** 可以搭配子視窗和最上層視窗使用。</span><span class="sxs-lookup"><span data-stu-id="aa509-239">Beginning with Windows 8, **WS\_EX\_LAYERED** can be used with child windows and top-level windows.</span></span> <span data-ttu-id="aa509-240">先前的 Windows 版本僅支援最上層視窗的 **WS 範例 \_ \_ 層** 級。</span><span class="sxs-lookup"><span data-stu-id="aa509-240">Previous Windows versions support **WS\_EX\_LAYERED** only for top-level windows.</span></span>

 

<span data-ttu-id="aa509-241">若要為指定的分層視窗設定不透明度層級或透明色彩索引鍵，請呼叫 [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)。</span><span class="sxs-lookup"><span data-stu-id="aa509-241">To set the opacity level or the transparency color key for a given layered window, call [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes).</span></span> <span data-ttu-id="aa509-242">在呼叫之後，系統可能仍會要求視窗在視窗顯示或調整大小時進行繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-242">After the call, the system may still ask the window to paint when the window is shown or resized.</span></span> <span data-ttu-id="aa509-243">不過，由於系統會儲存多層式視窗的影像，因此系統不會要求視窗在顯示時顯示為相對視窗在桌面上移動的結果。</span><span class="sxs-lookup"><span data-stu-id="aa509-243">However, because the system stores the image of a layered window, the system will not ask the window to paint if parts of it are revealed as a result of relative window moves on the desktop.</span></span> <span data-ttu-id="aa509-244">如果繼承應用程式想要為視窗新增半透明度或透明效果，就不需要重新處理其繪製程式碼，因為系統會將呼叫 **SetLayeredWindowAttributes** 的視窗繪製重新導向至非螢幕記憶體，並 recomposes 它以達成所要的效果。</span><span class="sxs-lookup"><span data-stu-id="aa509-244">Legacy applications do not need to restructure their painting code if they want to add translucency or transparency effects for a window, because the system redirects the painting of windows that called **SetLayeredWindowAttributes** into off-screen memory and recomposes it to achieve the desired effect.</span></span>

<span data-ttu-id="aa509-245">如需更快速且更有效率的動畫，或需要每圖元的 Alpha，請呼叫 [**UpdateLayeredWindow**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)。</span><span class="sxs-lookup"><span data-stu-id="aa509-245">For faster and more efficient animation or if per-pixel alpha is needed, call [**UpdateLayeredWindow**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow).</span></span> <span data-ttu-id="aa509-246">當應用程式必須直接提供多層式視窗的圖形和內容時，才應該使用 **UpdateLayeredWindow** ，而不需使用系統透過 [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)提供的重新導向機制。</span><span class="sxs-lookup"><span data-stu-id="aa509-246">**UpdateLayeredWindow** should be used primarily when the application must directly supply the shape and content of a layered window, without using the redirection mechanism the system provides through [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes).</span></span> <span data-ttu-id="aa509-247">此外，使用 **UpdateLayeredWindow** 可讓您更有效率地使用記憶體，因為系統不需要額外的記憶體來儲存重新導向視窗的映射。</span><span class="sxs-lookup"><span data-stu-id="aa509-247">In addition, using **UpdateLayeredWindow** directly uses memory more efficiently, because the system does not need the additional memory required for storing the image of the redirected window.</span></span> <span data-ttu-id="aa509-248">為了在建立視窗動畫的最高效率，請呼叫 **UpdateLayeredWindow** 來變更分層視窗的位置和大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-248">For maximum efficiency in animating windows, call **UpdateLayeredWindow** to change the position and the size of a layered window.</span></span> <span data-ttu-id="aa509-249">請注意，呼叫 **SetLayeredWindowAttributes** 之後，後續的 **UpdateLayeredWindow** 呼叫將會失敗，直到分層樣式位已清除並再次設定為止。</span><span class="sxs-lookup"><span data-stu-id="aa509-249">Please note that after **SetLayeredWindowAttributes** has been called, subsequent **UpdateLayeredWindow** calls will fail until the layering style bit is cleared and set again.</span></span>

<span data-ttu-id="aa509-250">分層視窗的點擊測試是以視窗的圖形和透明度為基礎。</span><span class="sxs-lookup"><span data-stu-id="aa509-250">Hit testing of a layered window is based on the shape and transparency of the window.</span></span> <span data-ttu-id="aa509-251">這表示，以色彩為色彩或其 Alpha 值為零的視窗區域會讓滑鼠訊息通過。</span><span class="sxs-lookup"><span data-stu-id="aa509-251">This means that the areas of the window that are color-keyed or whose alpha value is zero will let the mouse messages through.</span></span> <span data-ttu-id="aa509-252">但是，如果分層視窗具有 [ **WS \_ EX \_ 透明** 擴充] 視窗樣式，則會忽略分層視窗的形狀，並將滑鼠事件傳遞至多層式視窗底下的其他視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-252">However, if the layered window has the **WS\_EX\_TRANSPARENT** extended window style, the shape of the layered window will be ignored and the mouse events will be passed to other windows underneath the layered window.</span></span>

### <a name="message-only-windows"></a><span data-ttu-id="aa509-253">Message-Only Windows</span><span class="sxs-lookup"><span data-stu-id="aa509-253">Message-Only Windows</span></span>

<span data-ttu-id="aa509-254">*僅限訊息的視窗* 可讓您傳送和接收訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-254">A *message-only window* enables you to send and receive messages.</span></span> <span data-ttu-id="aa509-255">它看不見、沒有迭置順序、無法列舉，也不會收到廣播訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-255">It is not visible, has no z-order, cannot be enumerated, and does not receive broadcast messages.</span></span> <span data-ttu-id="aa509-256">此視窗只會分派訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-256">The window simply dispatches messages.</span></span>

<span data-ttu-id="aa509-257">若要建立僅限訊息的視窗，請在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函數的 *hWndParent* 參數中，指定 [HWND \_ 訊息](#message-only-windows)常數或現有純訊息視窗的控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-257">To create a message-only window, specify the [HWND\_MESSAGE](#message-only-windows) constant or a handle to an existing message-only window in the *hWndParent* parameter of the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function.</span></span> <span data-ttu-id="aa509-258">您也可以 \_ 在 [**SetParent**](/windows/win32/api/winuser/nf-winuser-setparent)函數的 *HWNDNEWPARENT* 參數中指定 HWND 訊息，將現有的視窗變更為僅限訊息的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-258">You can also change an existing window to a message-only window by specifying HWND\_MESSAGE in the *hWndNewParent* parameter of the [**SetParent**](/windows/win32/api/winuser/nf-winuser-setparent) function.</span></span>

<span data-ttu-id="aa509-259">若要尋找僅限訊息的視窗，請在 [**FindWindowEx**](/windows/win32/api/winuser/nf-winuser-findwindowexa)函數的 *hwndParent* 參數中指定 [HWND \_ 訊息](#message-only-windows)。</span><span class="sxs-lookup"><span data-stu-id="aa509-259">To find message-only windows, specify [HWND\_MESSAGE](#message-only-windows) in the *hwndParent* parameter of the [**FindWindowEx**](/windows/win32/api/winuser/nf-winuser-findwindowexa) function.</span></span> <span data-ttu-id="aa509-260">此外，如果 *hwndParent* 和 *hwndChildAfter* 參數都是 **Null**，則 **FindWindowEx** 會搜尋僅限訊息的視窗以及最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-260">In addition, **FindWindowEx** searches message-only windows as well as top-level windows if both the *hwndParent* and *hwndChildAfter* parameters are **NULL**.</span></span>

## <a name="window-relationships"></a><span data-ttu-id="aa509-261">視窗關聯性</span><span class="sxs-lookup"><span data-stu-id="aa509-261">Window Relationships</span></span>

<span data-ttu-id="aa509-262">有許多方式可讓視窗與使用者或另一個視窗相關聯。</span><span class="sxs-lookup"><span data-stu-id="aa509-262">There are many ways that a window can relate to the user or another window.</span></span> <span data-ttu-id="aa509-263">視窗可以是擁有的視窗、前景視窗或背景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-263">A window may be an owned window, foreground window, or background window.</span></span> <span data-ttu-id="aa509-264">視窗也有相對於其他視窗的 z 順序。</span><span class="sxs-lookup"><span data-stu-id="aa509-264">A window also has a z-order relative to other windows.</span></span> <span data-ttu-id="aa509-265">如需詳細資訊，請參閱下列主題：</span><span class="sxs-lookup"><span data-stu-id="aa509-265">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="aa509-266">前景和背景視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-266">Foreground and Background Windows</span></span>](#foreground-and-background-windows)
-   [<span data-ttu-id="aa509-267">擁有的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-267">Owned Windows</span></span>](#owned-windows)
-   [<span data-ttu-id="aa509-268">Z 順序</span><span class="sxs-lookup"><span data-stu-id="aa509-268">Z-Order</span></span>](#z-order)

### <a name="foreground-and-background-windows"></a><span data-ttu-id="aa509-269">前景和背景視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-269">Foreground and Background Windows</span></span>

<span data-ttu-id="aa509-270">每個進程都可以有多個執行緒，而且每個執行緒都可以建立視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-270">Each process can have multiple threads of execution, and each thread can create windows.</span></span> <span data-ttu-id="aa509-271">建立使用者目前正在工作之視窗的執行緒稱為「前景執行緒」，而視窗則稱為「 *前景視窗*」。</span><span class="sxs-lookup"><span data-stu-id="aa509-271">The thread that created the window with which the user is currently working is called the foreground thread, and the window is called the *foreground window*.</span></span> <span data-ttu-id="aa509-272">所有其他執行緒都是背景執行緒，而背景執行緒所建立的視窗稱為 *背景視窗*。</span><span class="sxs-lookup"><span data-stu-id="aa509-272">All other threads are background threads, and the windows created by background threads are called *background windows*.</span></span>

<span data-ttu-id="aa509-273">每個執行緒都具有優先權層級，以決定執行緒接收的 CPU 時間量。</span><span class="sxs-lookup"><span data-stu-id="aa509-273">Each thread has a priority level that determines the amount of CPU time the thread receives.</span></span> <span data-ttu-id="aa509-274">雖然應用程式可以設定其執行緒的優先權層級，但通常前景執行緒的優先權層級會比背景執行緒稍微高得多。</span><span class="sxs-lookup"><span data-stu-id="aa509-274">Although an application can set the priority level of its threads, normally the foreground thread has a slightly higher priority level than the background threads.</span></span> <span data-ttu-id="aa509-275">因為它的優先順序較高，所以前景執行緒所接收的 CPU 時間會比背景執行緒更多。</span><span class="sxs-lookup"><span data-stu-id="aa509-275">Because it has a higher priority, the foreground thread receives more CPU time than the background threads.</span></span> <span data-ttu-id="aa509-276">前景執行緒的一般基本優先權為 9;背景執行緒的一般基本優先權為7。</span><span class="sxs-lookup"><span data-stu-id="aa509-276">The foreground thread has a normal base priority of 9; a background thread has a normal base priority of 7.</span></span>

<span data-ttu-id="aa509-277">使用者可以按一下視窗，或使用 ALT + TAB 或 ALT + ESC 鍵組合來設定前景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-277">The user sets the foreground window by clicking a window, or by using the ALT+TAB or ALT+ESC key combination.</span></span> <span data-ttu-id="aa509-278">若要取得前景視窗的控制碼，請使用 [**GetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-getforegroundwindow) 函數。</span><span class="sxs-lookup"><span data-stu-id="aa509-278">To retrieve a handle to the foreground window, use the [**GetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-getforegroundwindow) function.</span></span> <span data-ttu-id="aa509-279">若要檢查您的應用程式視窗是否為前景視窗，請將 **GetForegroundWindow** 傳回的控制碼與您應用程式視窗中的控制碼做比較。</span><span class="sxs-lookup"><span data-stu-id="aa509-279">To check if your application window is the foreground window, compare the handle returned by **GetForegroundWindow** to that of your application window.</span></span>

<span data-ttu-id="aa509-280">應用程式會使用 [**SetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow) 函數來設定前景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-280">An application sets the foreground window by using the [**SetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow) function.</span></span>

<span data-ttu-id="aa509-281">系統會限制哪些進程可以設定前景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-281">The system restricts which processes can set the foreground window.</span></span> <span data-ttu-id="aa509-282">只有在下列情況時，進程才能設定前景視窗：</span><span class="sxs-lookup"><span data-stu-id="aa509-282">A process can set the foreground window only if:</span></span>

- <span data-ttu-id="aa509-283">下列所有條件都成立：</span><span class="sxs-lookup"><span data-stu-id="aa509-283">All of the following conditions are true:</span></span>
  - <span data-ttu-id="aa509-284">呼叫 **SetForegroundWindow** 的程式屬於桌面應用程式，而不是針對 Windows 8 或8.1 所設計的 UWP 應用程式或 Windows Store 應用程式。</span><span class="sxs-lookup"><span data-stu-id="aa509-284">The process calling **SetForegroundWindow** belongs to a desktop application, not a UWP app or a Windows Store app designed for Windows 8 or 8.1.</span></span>
  - <span data-ttu-id="aa509-285">前景進程尚未針對 [**LockSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow)函式的先前呼叫停用對 **SetForegroundWindow** 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="aa509-285">The foreground process has not disabled calls to **SetForegroundWindow** by a previous call to the [**LockSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow) function.</span></span>
  - <span data-ttu-id="aa509-286">前景鎖定超時已過期 (請參閱 SystemParametersInfo) [中的 **SPI_GETFOREGROUNDLOCKTIMEOUT**](/windows/win32/api/winuser/nf-winuser-systemparametersinfoa#SPI_GETFOREGROUNDLOCKTIMEOUT) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-286">The foreground lock time-out has expired (see [**SPI_GETFOREGROUNDLOCKTIMEOUT** in **SystemParametersInfo**](/windows/win32/api/winuser/nf-winuser-systemparametersinfoa#SPI_GETFOREGROUNDLOCKTIMEOUT)).</span></span>
  - <span data-ttu-id="aa509-287">沒有作用中的功能表。</span><span class="sxs-lookup"><span data-stu-id="aa509-287">No menus are active.</span></span>
- <span data-ttu-id="aa509-288">此外，至少下列其中一個條件成立：</span><span class="sxs-lookup"><span data-stu-id="aa509-288">Additionally, at least one of the following conditions is true:</span></span>
  - <span data-ttu-id="aa509-289">呼叫進程是前景進程。</span><span class="sxs-lookup"><span data-stu-id="aa509-289">The calling process is the foreground process.</span></span>
  - <span data-ttu-id="aa509-290">呼叫進程由前景進程啟動。</span><span class="sxs-lookup"><span data-stu-id="aa509-290">The calling process was started by the foreground process.</span></span>
  - <span data-ttu-id="aa509-291">目前沒有前景視窗，因此沒有前景進程。</span><span class="sxs-lookup"><span data-stu-id="aa509-291">There is currently no foreground window, and thus no foreground process.</span></span>
  - <span data-ttu-id="aa509-292">呼叫進程收到最後一個輸入事件。</span><span class="sxs-lookup"><span data-stu-id="aa509-292">The calling process received the last input event.</span></span>
  - <span data-ttu-id="aa509-293">正在調試前景進程或呼叫進程。</span><span class="sxs-lookup"><span data-stu-id="aa509-293">Either the foreground process or the calling process is being debugged.</span></span>

<span data-ttu-id="aa509-294">進程可能會被拒絕設定前景視窗的許可權，即使它符合這些條件也是一樣。</span><span class="sxs-lookup"><span data-stu-id="aa509-294">It is possible for a process to be denied the right to set the foreground window even if it meets these conditions.</span></span>

<span data-ttu-id="aa509-295">可以設定前景視窗的進程，可以藉由呼叫 [**AllowSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-allowsetforegroundwindow) 函式或呼叫 [**BroadcastSystemMessage**](/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage) 函式與 **BSF \_ ALLOWSFW** 旗標，讓另一個進程設定前景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-295">A process that can set the foreground window can enable another process to set the foreground window by calling the [**AllowSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-allowsetforegroundwindow) function, or by calling the [**BroadcastSystemMessage**](/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage) function with the **BSF\_ALLOWSFW** flag.</span></span> <span data-ttu-id="aa509-296">前景進程可以藉由呼叫 [**LockSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow)函數來停用對 [**SetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow)的呼叫。</span><span class="sxs-lookup"><span data-stu-id="aa509-296">The foreground process can disable calls to [**SetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow) by calling the [**LockSetForegroundWindow**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow) function.</span></span>

### <a name="owned-windows"></a><span data-ttu-id="aa509-297">擁有的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-297">Owned Windows</span></span>

<span data-ttu-id="aa509-298">重迭或快顯視窗可以由另一個重迭或快顯視窗所擁有。</span><span class="sxs-lookup"><span data-stu-id="aa509-298">An overlapped or pop-up window can be owned by another overlapped or pop-up window.</span></span> <span data-ttu-id="aa509-299">所擁有的會將數個條件約束放在視窗上。</span><span class="sxs-lookup"><span data-stu-id="aa509-299">Being owned places several constraints on a window.</span></span>

-   <span data-ttu-id="aa509-300">擁有的視窗一律高於其擁有者（以 z 順序排列）。</span><span class="sxs-lookup"><span data-stu-id="aa509-300">An owned window is always above its owner in the z-order.</span></span>
-   <span data-ttu-id="aa509-301">當系統的擁有者損毀時，系統會自動終結擁有的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-301">The system automatically destroys an owned window when its owner is destroyed.</span></span>
-   <span data-ttu-id="aa509-302">當其擁有者最小化時，會隱藏擁有的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-302">An owned window is hidden when its owner is minimized.</span></span>

<span data-ttu-id="aa509-303">只有重迭或快顯視窗可以是擁有者視窗;子視窗不可以是擁有者視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-303">Only an overlapped or pop-up window can be an owner window; a child window cannot be an owner window.</span></span> <span data-ttu-id="aa509-304">應用程式會在建立具有 [**ws \_**](window-styles.md)重迭或 ws 快顯樣式的視窗時，指定擁有者的視窗控制碼做為 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)的 *hwndParent* 參數，以建立所擁有的視窗。 **\_**</span><span class="sxs-lookup"><span data-stu-id="aa509-304">An application creates an owned window by specifying the owner's window handle as the *hwndParent* parameter of [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) when it creates a window with the [**WS\_OVERLAPPED**](window-styles.md) or **WS\_POPUP** style.</span></span> <span data-ttu-id="aa509-305">*HwndParent* 參數必須識別重迭或快顯視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-305">The *hwndParent* parameter must identify an overlapped or pop-up window.</span></span> <span data-ttu-id="aa509-306">如果 *hwndParent* 識別子視窗，系統會將擁有權指派給子視窗的最上層父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-306">If *hwndParent* identifies a child window, the system assigns ownership to the top-level parent window of the child window.</span></span> <span data-ttu-id="aa509-307">建立擁有的視窗之後，應用程式無法將視窗的擁有權轉移到另一個視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-307">After creating an owned window, an application cannot transfer ownership of the window to another window.</span></span>

<span data-ttu-id="aa509-308">對話方塊和訊息方塊預設為 windows 擁有的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-308">Dialog boxes and message boxes are owned windows by default.</span></span> <span data-ttu-id="aa509-309">應用程式會在呼叫建立對話方塊或訊息方塊的函式時，指定擁有者視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-309">An application specifies the owner window when calling a function that creates a dialog box or message box.</span></span>

<span data-ttu-id="aa509-310">應用程式可以搭配 **GW \_ 擁有** 者旗標使用 [**GetWindow**](/windows/win32/api/winuser/nf-winuser-getwindow)函式，以取得視窗擁有者的控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-310">An application can use the [**GetWindow**](/windows/win32/api/winuser/nf-winuser-getwindow) function with the **GW\_OWNER** flag to retrieve a handle to a window's owner.</span></span>

### <a name="z-order"></a><span data-ttu-id="aa509-311">Z 順序</span><span class="sxs-lookup"><span data-stu-id="aa509-311">Z-Order</span></span>

<span data-ttu-id="aa509-312">視窗的迭置 *順序* 表示視窗在重迭視窗堆疊中的位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-312">The *z-order* of a window indicates the window's position in a stack of overlapping windows.</span></span> <span data-ttu-id="aa509-313">此視窗堆疊是沿著虛數軸（Z 軸）導向，從畫面向外擴充。</span><span class="sxs-lookup"><span data-stu-id="aa509-313">This window stack is oriented along an imaginary axis, the z-axis, extending outward from the screen.</span></span> <span data-ttu-id="aa509-314">位於 z 順序頂端的視窗會與所有其他視窗重迭。</span><span class="sxs-lookup"><span data-stu-id="aa509-314">The window at the top of the z-order overlaps all other windows.</span></span> <span data-ttu-id="aa509-315">迭置順序底部的視窗會與所有其他視窗重迭。</span><span class="sxs-lookup"><span data-stu-id="aa509-315">The window at the bottom of the z-order is overlapped by all other windows.</span></span>

<span data-ttu-id="aa509-316">系統會在單一清單中維護 z 順序。</span><span class="sxs-lookup"><span data-stu-id="aa509-316">The system maintains the z-order in a single list.</span></span> <span data-ttu-id="aa509-317">它會根據最上層視窗、最上層視窗或子視窗，將視窗新增至 z 順序。</span><span class="sxs-lookup"><span data-stu-id="aa509-317">It adds windows to the z-order based on whether they are topmost windows, top-level windows, or child windows.</span></span> <span data-ttu-id="aa509-318">*最上層視窗* 會重迭所有其他非最上層視窗，而不論它是作用中或前景視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-318">A *topmost window* overlaps all other non-topmost windows, regardless of whether it is the active or foreground window.</span></span> <span data-ttu-id="aa509-319">最上層的視窗具有 **WS \_ EX \_ 最上層** 的樣式。</span><span class="sxs-lookup"><span data-stu-id="aa509-319">A topmost window has the **WS\_EX\_TOPMOST** style.</span></span> <span data-ttu-id="aa509-320">所有最上層視窗會在任何非最上層視窗之前以 z 順序顯示。</span><span class="sxs-lookup"><span data-stu-id="aa509-320">All topmost windows appear in the z-order before any non-topmost windows.</span></span> <span data-ttu-id="aa509-321">子視窗會以迭置順序與其父系群組。</span><span class="sxs-lookup"><span data-stu-id="aa509-321">A child window is grouped with its parent in z-order.</span></span>

<span data-ttu-id="aa509-322">當應用程式建立視窗時，系統會將它放在相同類型之視窗的 z 順序頂端。</span><span class="sxs-lookup"><span data-stu-id="aa509-322">When an application creates a window, the system puts it at the top of the z-order for windows of the same type.</span></span> <span data-ttu-id="aa509-323">您可以使用 [**BringWindowToTop**](/windows/win32/api/winuser/nf-winuser-bringwindowtotop) 函式，將視窗帶到相同類型之視窗的 z 順序頂端。</span><span class="sxs-lookup"><span data-stu-id="aa509-323">You can use the [**BringWindowToTop**](/windows/win32/api/winuser/nf-winuser-bringwindowtotop) function to bring a window to the top of the z-order for windows of the same type.</span></span> <span data-ttu-id="aa509-324">您可以使用 [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) 和 [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos) 函數來重新排列迭置順序。</span><span class="sxs-lookup"><span data-stu-id="aa509-324">You can rearrange the z-order by using the [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) and [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos) functions.</span></span>

<span data-ttu-id="aa509-325">使用者藉由啟用不同的視窗，來變更 z 順序。</span><span class="sxs-lookup"><span data-stu-id="aa509-325">The user changes the z-order by activating a different window.</span></span> <span data-ttu-id="aa509-326">系統會將使用中視窗置於相同類型之視窗的迭置順序頂端。</span><span class="sxs-lookup"><span data-stu-id="aa509-326">The system positions the active window at the top of the z-order for windows of the same type.</span></span> <span data-ttu-id="aa509-327">當視窗指向迭置順序的上方時，就會進行子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-327">When a window comes to the top of z-order, so do its child windows.</span></span> <span data-ttu-id="aa509-328">您可以使用 [**GetTopWindow**](/windows/win32/api/winuser/nf-winuser-gettopwindow) 函式來搜尋父視窗的所有子視窗，並將控制碼傳回至 z 順序最高的子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-328">You can use the [**GetTopWindow**](/windows/win32/api/winuser/nf-winuser-gettopwindow) function to search all child windows of a parent window and return a handle to the child window that is highest in z-order.</span></span> <span data-ttu-id="aa509-329">[**GetNextWindow**](/windows/win32/api/winuser/nf-winuser-getnextwindow)函式會以 z 順序抓取下一個或上一個視窗的控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-329">The [**GetNextWindow**](/windows/win32/api/winuser/nf-winuser-getnextwindow) function retrieves a handle to the next or previous window in z-order.</span></span>

## <a name="window-show-state"></a><span data-ttu-id="aa509-330">視窗顯示狀態</span><span class="sxs-lookup"><span data-stu-id="aa509-330">Window Show State</span></span>

<span data-ttu-id="aa509-331">在任何指定的時間，視窗可能會處於作用中或非作用中;隱藏或可見;以及最小化、最大化或還原。</span><span class="sxs-lookup"><span data-stu-id="aa509-331">At any one given time, a window may be active or inactive; hidden or visible; and minimized, maximized, or restored.</span></span> <span data-ttu-id="aa509-332">這些品質統稱為 *視窗顯示狀態*。</span><span class="sxs-lookup"><span data-stu-id="aa509-332">These qualities are referred to collectively as the *window show state*.</span></span> <span data-ttu-id="aa509-333">下列主題討論視窗顯示狀態：</span><span class="sxs-lookup"><span data-stu-id="aa509-333">The following topics discuss the window show state:</span></span>

-   [<span data-ttu-id="aa509-334">使用中視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-334">Active Window</span></span>](#active-window)
-   [<span data-ttu-id="aa509-335">停用的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-335">Disabled Windows</span></span>](#disabled-windows)
-   [<span data-ttu-id="aa509-336">視窗可見度</span><span class="sxs-lookup"><span data-stu-id="aa509-336">Window Visibility</span></span>](#window-visibility)
-   [<span data-ttu-id="aa509-337">最小化、最大化和還原的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-337">Minimized, Maximized, and Restored Windows</span></span>](#minimized-maximized-and-restored-windows)

### <a name="active-window"></a><span data-ttu-id="aa509-338">使用中視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-338">Active Window</span></span>

<span data-ttu-id="aa509-339">*使用中視窗* 是使用者目前工作的應用程式最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-339">An *active window* is the top-level window of the application with which the user is currently working.</span></span> <span data-ttu-id="aa509-340">為了讓使用者可以輕鬆地識別使用中視窗，系統會將它放在迭置順序的頂端，並將其標題列和框線的色彩變更為系統定義的使用中視窗色彩。</span><span class="sxs-lookup"><span data-stu-id="aa509-340">To allow the user to easily identify the active window, the system places it at the top of the z-order and changes the color of its title bar and border to the system-defined active window colors.</span></span> <span data-ttu-id="aa509-341">只有最上層視窗可以是使用中視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-341">Only a top-level window can be an active window.</span></span> <span data-ttu-id="aa509-342">當使用者使用子視窗時，系統會啟動與子視窗相關聯的最上層父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-342">When the user is working with a child window, the system activates the top-level parent window associated with the child window.</span></span>

<span data-ttu-id="aa509-343">系統中一次只會有一個最上層視窗處於作用中狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-343">Only one top-level window in the system is active at a time.</span></span> <span data-ttu-id="aa509-344">使用者可以按一下 (或其中一個子視窗) ，或使用 ALT + ESC 或 ALT + TAB 鍵組合來啟動最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-344">The user activates a top-level window by clicking it (or one of its child windows), or by using the ALT+ESC or ALT+TAB key combination.</span></span> <span data-ttu-id="aa509-345">應用程式會藉由呼叫 [**SetActiveWindow**](/windows/win32/api/winuser/nf-winuser-setactivewindow) 函數來啟動最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-345">An application activates a top-level window by calling the [**SetActiveWindow**](/windows/win32/api/winuser/nf-winuser-setactivewindow) function.</span></span> <span data-ttu-id="aa509-346">其他函式可能會導致系統啟用不同的最上層視窗，包括 [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos)、 [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos)、 [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement)和 [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow)。</span><span class="sxs-lookup"><span data-stu-id="aa509-346">Other functions can cause the system to activate a different top-level window, including [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos), [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos), [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement), and [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow).</span></span> <span data-ttu-id="aa509-347">雖然應用程式可以隨時啟用不同的最上層視窗，但為了避免讓使用者感到混淆，它應該只是為了回應使用者動作。</span><span class="sxs-lookup"><span data-stu-id="aa509-347">Although an application can activate a different top-level window at any time, to avoid confusing the user, it should do so only in response to a user action.</span></span> <span data-ttu-id="aa509-348">應用程式會使用 [**GetActiveWindow**](/windows/win32/api/winuser/nf-winuser-getactivewindow) 函式來取得使用中視窗的控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-348">An application uses the [**GetActiveWindow**](/windows/win32/api/winuser/nf-winuser-getactivewindow) function to retrieve a handle to the active window.</span></span>

<span data-ttu-id="aa509-349">當啟用從某個應用程式的最上層視窗變更為另一個應用程式的最上層視窗時，系統會將 [**WM \_ ACTI加值稅EAPP**](wm-activateapp.md) 訊息傳送給這兩個應用程式，以通知變更。</span><span class="sxs-lookup"><span data-stu-id="aa509-349">When the activation changes from a top-level window of one application to the top-level window of another, the system sends a [**WM\_ACTIVATEAPP**](wm-activateapp.md) message to both applications, notifying them of the change.</span></span> <span data-ttu-id="aa509-350">當啟用變更至相同應用程式中不同的最上層視窗時，系統會傳送 [**WM \_ 啟動**](../inputdev/wm-activate.md) 訊息給這兩個視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-350">When the activation changes to a different top-level window in the same application, the system sends both windows a [**WM\_ACTIVATE**](../inputdev/wm-activate.md) message.</span></span>

### <a name="disabled-windows"></a><span data-ttu-id="aa509-351">停用的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-351">Disabled Windows</span></span>

<span data-ttu-id="aa509-352">您可以停用視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-352">A window can be disabled.</span></span> <span data-ttu-id="aa509-353">*停用的視窗* 不會收到使用者的鍵盤或滑鼠輸入，但可以從其他視窗、從其他應用程式和系統接收訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-353">A *disabled window* receives no keyboard or mouse input from the user, but it can receive messages from other windows, from other applications, and from the system.</span></span> <span data-ttu-id="aa509-354">應用程式通常會停用視窗，以防止使用者使用視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-354">An application typically disables a window to prevent the user from using the window.</span></span> <span data-ttu-id="aa509-355">例如，應用程式可能會停用對話方塊中的 [推播] 按鈕，以防止使用者選擇它。</span><span class="sxs-lookup"><span data-stu-id="aa509-355">For example, an application may disable a push button in a dialog box to prevent the user from choosing it.</span></span> <span data-ttu-id="aa509-356">應用程式可以隨時啟用停用的視窗;啟用視窗會還原一般輸入。</span><span class="sxs-lookup"><span data-stu-id="aa509-356">An application can enable a disabled window at any time; enabling a window restores normal input.</span></span>

<span data-ttu-id="aa509-357">根據預設，視窗會在建立時啟用。</span><span class="sxs-lookup"><span data-stu-id="aa509-357">By default, a window is enabled when created.</span></span> <span data-ttu-id="aa509-358">但是，應用程式可以指定 [**WS \_ 停用**](window-styles.md) 的樣式，以停用新的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-358">An application can specify the [**WS\_DISABLED**](window-styles.md) style, however, to disable a new window.</span></span> <span data-ttu-id="aa509-359">應用程式會使用 [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) 函數來啟用或停用現有的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-359">An application enables or disables an existing window by using the [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) function.</span></span> <span data-ttu-id="aa509-360">系統會在啟用狀態即將變更時，將 [**WM \_ 啟用**](wm-enable.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-360">The system sends a [**WM\_ENABLE**](wm-enable.md) message to a window when its enabled state is about to change.</span></span> <span data-ttu-id="aa509-361">應用程式可以使用 [**IsWindowEnabled**](/windows/win32/api/winuser/nf-winuser-iswindowenabled) 函數來判斷是否已啟用視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-361">An application can determine whether a window is enabled by using the [**IsWindowEnabled**](/windows/win32/api/winuser/nf-winuser-iswindowenabled) function.</span></span>

<span data-ttu-id="aa509-362">停用子視窗時，系統會將子系的滑鼠輸入訊息傳遞至父視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-362">When a child window is disabled, the system passes the child's mouse input messages to the parent window.</span></span> <span data-ttu-id="aa509-363">父系會使用訊息來判斷是否要啟用子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-363">The parent uses the messages to determine whether to enable the child window.</span></span> <span data-ttu-id="aa509-364">如需詳細資訊，請參閱 [滑鼠輸入](../inputdev/mouse-input.md)。</span><span class="sxs-lookup"><span data-stu-id="aa509-364">For more information, see [Mouse Input](../inputdev/mouse-input.md).</span></span>

<span data-ttu-id="aa509-365">一次只能有一個視窗可以接收鍵盤輸入;該視窗稱為鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="aa509-365">Only one window at a time can receive keyboard input; that window is said to have the keyboard focus.</span></span> <span data-ttu-id="aa509-366">如果應用程式使用 [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) 函式來停用鍵盤焦點視窗，除了停用外，此視窗也會失去鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="aa509-366">If an application uses the [**EnableWindow**](/windows/win32/api/winuser/nf-winuser-enablewindow) function to disable a keyboard-focus window, the window loses the keyboard focus in addition to being disabled.</span></span> <span data-ttu-id="aa509-367">**EnableWindow** 接著會將鍵盤焦點設為 **Null**，表示沒有視窗具有焦點。</span><span class="sxs-lookup"><span data-stu-id="aa509-367">**EnableWindow** then sets the keyboard focus to **NULL**, meaning no window has the focus.</span></span> <span data-ttu-id="aa509-368">如果子視窗或其他子系視窗具有鍵盤焦點，則停用父視窗時，子系視窗會失去焦點。</span><span class="sxs-lookup"><span data-stu-id="aa509-368">If a child window, or other descendant window, has the keyboard focus, the descendant window loses the focus when the parent window is disabled.</span></span> <span data-ttu-id="aa509-369">如需詳細資訊，請參閱 [鍵盤輸入](../inputdev/keyboard-input.md)。</span><span class="sxs-lookup"><span data-stu-id="aa509-369">For more information, see [Keyboard Input](../inputdev/keyboard-input.md).</span></span>

### <a name="window-visibility"></a><span data-ttu-id="aa509-370">視窗可見度</span><span class="sxs-lookup"><span data-stu-id="aa509-370">Window Visibility</span></span>

<span data-ttu-id="aa509-371">視窗可以顯示或隱藏。</span><span class="sxs-lookup"><span data-stu-id="aa509-371">A window can be either visible or hidden.</span></span> <span data-ttu-id="aa509-372">系統會在螢幕上顯示 *可見的視窗* 。</span><span class="sxs-lookup"><span data-stu-id="aa509-372">The system displays a *visible window* on the screen.</span></span> <span data-ttu-id="aa509-373">它會隱藏 *隱藏的視窗* ，而不會進行繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-373">It hides a *hidden window* by not drawing it.</span></span> <span data-ttu-id="aa509-374">如果視窗是顯示的，則使用者可以提供輸入至視窗，並檢視視窗的輸出。</span><span class="sxs-lookup"><span data-stu-id="aa509-374">If a window is visible, the user can supply input to the window and view the window's output.</span></span> <span data-ttu-id="aa509-375">如果隱藏視窗，等於是停用視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-375">If a window is hidden, it is effectively disabled.</span></span> <span data-ttu-id="aa509-376">隱藏視窗能夠處理來自系統或其他視窗的訊息，但是不能處理來自使用者的輸入或顯示輸出。</span><span class="sxs-lookup"><span data-stu-id="aa509-376">A hidden window can process messages from the system or from other windows, but it cannot process input from the user or display output.</span></span> <span data-ttu-id="aa509-377">應用程式會在建立視窗時設定視窗的可見度狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-377">An application sets a window's visibility state when creating the window.</span></span> <span data-ttu-id="aa509-378">之後，應用程式可以變更可見度狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-378">Later, the application can change the visibility state.</span></span>

<span data-ttu-id="aa509-379">當視窗的 [**WS \_ visible**](window-styles.md) 樣式已設定時，就會顯示視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-379">A window is visible when the [**WS\_VISIBLE**](window-styles.md) style is set for the window.</span></span> <span data-ttu-id="aa509-380">根據預設， [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) 函式會建立隱藏的視窗，除非應用程式指定 **WS \_ 可見** 的樣式。</span><span class="sxs-lookup"><span data-stu-id="aa509-380">By default, the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function creates a hidden window unless the application specifies the **WS\_VISIBLE** style.</span></span> <span data-ttu-id="aa509-381">一般而言，應用程式會在建立視窗之後設定 **WS \_ 可見** 樣式，以保留使用者隱藏的建立程式詳細資料。</span><span class="sxs-lookup"><span data-stu-id="aa509-381">Typically, an application sets the **WS\_VISIBLE** style after it has created a window to keep details of the creation process hidden from the user.</span></span> <span data-ttu-id="aa509-382">例如，應用程式可能會在自訂視窗的外觀時，將新的視窗隱藏起來。</span><span class="sxs-lookup"><span data-stu-id="aa509-382">For example, an application may keep a new window hidden while it customizes the window's appearance.</span></span> <span data-ttu-id="aa509-383">如果在 **CreateWindowEx** 中指定了 **WS \_ VISIBLE** 樣式，系統會在建立視窗之後，但在顯示它之前，將 [**WM \_ SHOWWINDOW**](wm-showwindow.md)訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-383">If the **WS\_VISIBLE** style is specified in **CreateWindowEx**, the system sends the [**WM\_SHOWWINDOW**](wm-showwindow.md) message to the window after creating the window, but before displaying it.</span></span>

<span data-ttu-id="aa509-384">應用程式可以使用 [**IsWindowVisible**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) 函數來判斷視窗是否可見。</span><span class="sxs-lookup"><span data-stu-id="aa509-384">An application can determine whether a window is visible by using the [**IsWindowVisible**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) function.</span></span> <span data-ttu-id="aa509-385">應用程式可以使用 [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow)、 [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos)、 [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos)或 [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) 或 [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) 函數，顯示 (變成可見) 或隱藏視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-385">An application can show (make visible) or hide a window by using the [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow), [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos), [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos), or [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) or [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function.</span></span> <span data-ttu-id="aa509-386">這些函式會藉由設定或移除視窗的 [**WS \_ 可見**](window-styles.md) 樣式來顯示或隱藏視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-386">These functions show or hide a window by setting or removing the [**WS\_VISIBLE**](window-styles.md) style for the window.</span></span> <span data-ttu-id="aa509-387">它們也會在顯示或隱藏它之前，將 [**WM \_ SHOWWINDOW**](wm-showwindow.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-387">They also send the [**WM\_SHOWWINDOW**](wm-showwindow.md) message to the window before showing or hiding it.</span></span>

<span data-ttu-id="aa509-388">當擁有者視窗最小化時，系統會自動隱藏相關聯的擁有視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-388">When an owner window is minimized, the system automatically hides the associated owned windows.</span></span> <span data-ttu-id="aa509-389">同樣地，當擁有者視窗還原時，系統會自動顯示相關聯的擁有視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-389">Similarly, when an owner window is restored, the system automatically shows the associated owned windows.</span></span> <span data-ttu-id="aa509-390">在這兩種情況下，系統會先將 [**WM \_ SHOWWINDOW**](wm-showwindow.md) 訊息傳送給擁有的視窗，然後再加以隱藏或顯示。</span><span class="sxs-lookup"><span data-stu-id="aa509-390">In both cases, the system sends the [**WM\_SHOWWINDOW**](wm-showwindow.md) message to the owned windows before hiding or showing them.</span></span> <span data-ttu-id="aa509-391">有時候，應用程式可能需要隱藏擁有的視窗，而不需要將擁有者最小化或隱藏。</span><span class="sxs-lookup"><span data-stu-id="aa509-391">Occasionally, an application may need to hide the owned windows without having to minimize or hide the owner.</span></span> <span data-ttu-id="aa509-392">在此情況下，應用程式會使用 [**ShowOwnedPopups**](/windows/win32/api/winuser/nf-winuser-showownedpopups) 函數。</span><span class="sxs-lookup"><span data-stu-id="aa509-392">In this case, the application uses the [**ShowOwnedPopups**](/windows/win32/api/winuser/nf-winuser-showownedpopups) function.</span></span> <span data-ttu-id="aa509-393">此函式會設定或移除所有擁有視窗的 [**WS \_ 可見**](window-styles.md) 樣式，並將 **WM \_ SHOWWINDOW** 訊息傳送給擁有的視窗，然後再隱藏或顯示它們。</span><span class="sxs-lookup"><span data-stu-id="aa509-393">This function sets or removes the [**WS\_VISIBLE**](window-styles.md) style for all owned windows and sends the **WM\_SHOWWINDOW** message to the owned windows before hiding or showing them.</span></span> <span data-ttu-id="aa509-394">隱藏擁有者視窗不會影響所擁有視窗的可見度狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-394">Hiding an owner window has no effect on the visibility state of the owned windows.</span></span>

<span data-ttu-id="aa509-395">當父視窗可見時，也會顯示其相關聯的子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-395">When a parent window is visible, its associated child windows are also visible.</span></span> <span data-ttu-id="aa509-396">同樣地，當父視窗隱藏時，也會隱藏其子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-396">Similarly, when the parent window is hidden, its child windows are also hidden.</span></span> <span data-ttu-id="aa509-397">最小化父視窗不會影響子視窗的可見度狀態;亦即，子視窗會與父系最小化，但不會變更 [**WS \_ 可見**](window-styles.md) 樣式。</span><span class="sxs-lookup"><span data-stu-id="aa509-397">Minimizing the parent window has no effect on the visibility state of the child windows; that is, the child windows are minimized along with the parent, but the [**WS\_VISIBLE**](window-styles.md) style is not changed.</span></span>

<span data-ttu-id="aa509-398">即使視窗具有 [**WS \_ 可見**](window-styles.md) 樣式，使用者可能還是看不到畫面上的視窗; 其他視窗可能會完全重迭，或移到螢幕邊緣之外。</span><span class="sxs-lookup"><span data-stu-id="aa509-398">Even if a window has the [**WS\_VISIBLE**](window-styles.md) style, the user may not be able to see the window on the screen; other windows may completely overlap it or it may have been moved beyond the edge of the screen.</span></span> <span data-ttu-id="aa509-399">此外，可見的子視窗會受其父子式關聯性所建立的裁剪規則所規範。</span><span class="sxs-lookup"><span data-stu-id="aa509-399">Also, a visible child window is subject to the clipping rules established by its parent-child relationship.</span></span> <span data-ttu-id="aa509-400">如果看不到視窗的父視窗，也不會顯示它。</span><span class="sxs-lookup"><span data-stu-id="aa509-400">If the window's parent window is not visible, it will also not be visible.</span></span> <span data-ttu-id="aa509-401">如果父視窗移動超過螢幕邊緣，子視窗也會移動，因為相對於父代的左上角繪製了子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-401">If the parent window moves beyond the edge of the screen, the child window also moves because a child window is drawn relative to the parent's upper left corner.</span></span> <span data-ttu-id="aa509-402">例如，使用者可以將包含子視窗的父視窗，從畫面的邊緣移到足夠的範圍，讓使用者看不到子視窗，即使子視窗及其父視窗都具有 **WS \_ 可見** 樣式也一樣。</span><span class="sxs-lookup"><span data-stu-id="aa509-402">For example, a user may move the parent window containing the child window far enough off the edge of the screen that the user may not be able to see the child window, even though the child window and its parent window both have the **WS\_VISIBLE** style.</span></span>

### <a name="minimized-maximized-and-restored-windows"></a><span data-ttu-id="aa509-403">最小化、最大化和還原的視窗</span><span class="sxs-lookup"><span data-stu-id="aa509-403">Minimized, Maximized, and Restored Windows</span></span>

<span data-ttu-id="aa509-404">*最大化的視窗* 是具有 [**WS \_ 最大化**](window-styles.md)樣式的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-404">A *maximized window* is a window that has the [**WS\_MAXIMIZE**](window-styles.md) style.</span></span> <span data-ttu-id="aa509-405">根據預設值，系統會將最大化視窗放大到佔滿畫面，如果是子視窗，則是放大到佔滿父視窗的工作區 (Client Area)。</span><span class="sxs-lookup"><span data-stu-id="aa509-405">By default, the system enlarges a maximized window so that it fills the screen or, in the case of a child window, the parent window's client area.</span></span> <span data-ttu-id="aa509-406">雖然視窗的大小可以設定為最大化視窗的大小，但是最大化的視窗會稍有不同。</span><span class="sxs-lookup"><span data-stu-id="aa509-406">Although a window's size can be set to the same size of a maximized window, a maximized window is slightly different.</span></span> <span data-ttu-id="aa509-407">系統會自動將視窗的標題列移到螢幕頂端，或移至父視窗工作區的頂端。</span><span class="sxs-lookup"><span data-stu-id="aa509-407">The system automatically moves the window's title bar to the top of the screen or to the top of the parent window's client area.</span></span> <span data-ttu-id="aa509-408">此外，系統會停用視窗的大小調整框線以及標題列 (的視窗定位功能，讓使用者無法藉由拖曳標題列) 來移動視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-408">Also, the system disables the window's sizing border and the window-positioning capability of the title bar (so that the user cannot move the window by dragging the title bar).</span></span>

<span data-ttu-id="aa509-409">*最小化視窗* 是具有 [**WS \_ 最小化**](window-styles.md)樣式的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-409">A *minimized window* is a window that has the [**WS\_MINIMIZE**](window-styles.md) style.</span></span> <span data-ttu-id="aa509-410">根據預設值，系統會將最小化的視窗縮小到工作列按鈕的大小，並將最小化的視窗移至工作列。</span><span class="sxs-lookup"><span data-stu-id="aa509-410">By default, the system reduces a minimized window to the size of its taskbar button and moves the minimized window to the taskbar.</span></span> <span data-ttu-id="aa509-411">*還原的視窗* 是已回到先前大小和位置的視窗，也就是最小化或最大化之前的大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-411">A *restored window* is a window that has been returned to its previous size and position, that is, the size it was before it was minimized or maximized.</span></span>

<span data-ttu-id="aa509-412">如果應用程式在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)函式中指定 [**ws \_ 最大化**](window-styles.md)或最 **\_ 小化** 樣式，則會先將視窗最大化或最小化。</span><span class="sxs-lookup"><span data-stu-id="aa509-412">If an application specifies the [**WS\_MAXIMIZE**](window-styles.md) or **WS\_MINIMIZE** style in the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) function, the window is initially maximized or minimized.</span></span> <span data-ttu-id="aa509-413">建立視窗之後，應用程式可以使用 [**closewindowsg**](/windows/win32/api/winuser/nf-winuser-closewindow) 函式，將視窗最小化。</span><span class="sxs-lookup"><span data-stu-id="aa509-413">After creating a window, an application can use the [**CloseWindow**](/windows/win32/api/winuser/nf-winuser-closewindow) function to minimize the window.</span></span> <span data-ttu-id="aa509-414">[**ArrangeIconicWindows**](/windows/win32/api/winuser/nf-winuser-arrangeiconicwindows)函式會將圖示排列在桌面上，或將父視窗的最小化子視窗排列在父視窗中。</span><span class="sxs-lookup"><span data-stu-id="aa509-414">The [**ArrangeIconicWindows**](/windows/win32/api/winuser/nf-winuser-arrangeiconicwindows) function arranges the icons on the desktop, or it arranges a parent window's minimized child windows in the parent window.</span></span> <span data-ttu-id="aa509-415">[**OpenIcon**](/windows/win32/api/winuser/nf-winuser-openicon)函式會將最小化的視窗還原為其先前的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-415">The [**OpenIcon**](/windows/win32/api/winuser/nf-winuser-openicon) function restores a minimized window to its previous size and position.</span></span>

<span data-ttu-id="aa509-416">[**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow)函數可以將視窗最小化、最大化或還原。</span><span class="sxs-lookup"><span data-stu-id="aa509-416">The [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) function can minimize, maximize, or restore a window.</span></span> <span data-ttu-id="aa509-417">它也可以設定視窗的可見度和啟用狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-417">It can also set the window's visibility and activation states.</span></span> <span data-ttu-id="aa509-418">[**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement)函式包含與 **ShowWindow** 相同的功能，但它可以覆寫視窗的預設最小化、最大化和還原的位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-418">The [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) function includes the same functionality as **ShowWindow**, but it can override the window's default minimized, maximized, and restored positions.</span></span>

<span data-ttu-id="aa509-419">[**IsZoomed**](/windows/win32/api/winuser/nf-winuser-iszoomed)和 [**IsIconic**](/windows/win32/api/winuser/nf-winuser-isiconic)函式會判斷指定的視窗是否會分別最大化或最小化。</span><span class="sxs-lookup"><span data-stu-id="aa509-419">The [**IsZoomed**](/windows/win32/api/winuser/nf-winuser-iszoomed) and [**IsIconic**](/windows/win32/api/winuser/nf-winuser-isiconic) functions determine whether a given window is maximized or minimized, respectively.</span></span> <span data-ttu-id="aa509-420">[**GetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-getwindowplacement)函式會抓取視窗的最小化、最大化和還原位置，也會決定視窗的顯示狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-420">The [**GetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-getwindowplacement) function retrieves the minimized, maximized, and restored positions for the window, and also determines the window's show state.</span></span>

<span data-ttu-id="aa509-421">當系統收到命令以最大化或還原最小化的視窗時，會傳送一個 [**WM \_ QUERYOPEN**](wm-queryopen.md) 訊息給視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-421">When the system receives a command to maximize or restore a minimized window, it sends the window a [**WM\_QUERYOPEN**](wm-queryopen.md) message.</span></span> <span data-ttu-id="aa509-422">如果視窗程式傳回 **FALSE**，則系統會忽略最大化或還原命令。</span><span class="sxs-lookup"><span data-stu-id="aa509-422">If the window procedure returns **FALSE**, the system ignores the maximize or restore command.</span></span>

<span data-ttu-id="aa509-423">系統會自動將最大化視窗的大小和位置設定為最大化視窗的系統定義預設值。</span><span class="sxs-lookup"><span data-stu-id="aa509-423">The system automatically sets the size and position of a maximized window to the system-defined defaults for a maximized window.</span></span> <span data-ttu-id="aa509-424">若要覆寫這些預設值，應用程式可以呼叫 [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) 函式，或處理當系統即將將視窗最大化時，由視窗接收的 [**WM \_ GETMINMAXINFO**](wm-getminmaxinfo.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-424">To override these defaults, an application can either call the [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) function or process the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message that is received by a window when the system is about to maximize the window.</span></span> <span data-ttu-id="aa509-425">**WM \_GETMINMAXINFO** 包含 [**MINMAXINFO**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) 結構的指標，其中包含系統用來設定最大值和位置的值。</span><span class="sxs-lookup"><span data-stu-id="aa509-425">**WM\_GETMINMAXINFO** includes a pointer to a [**MINMAXINFO**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) structure containing values the system uses to set the maximized size and position.</span></span> <span data-ttu-id="aa509-426">取代這些值會覆寫預設值。</span><span class="sxs-lookup"><span data-stu-id="aa509-426">Replacing these values overrides the defaults.</span></span>

## <a name="window-size-and-position"></a><span data-ttu-id="aa509-427">視窗大小和位置</span><span class="sxs-lookup"><span data-stu-id="aa509-427">Window Size and Position</span></span>

<span data-ttu-id="aa509-428">視窗的大小和位置會表示為周框，以相對於螢幕或父視窗的座標來表示。</span><span class="sxs-lookup"><span data-stu-id="aa509-428">A window's size and position are expressed as a bounding rectangle, given in coordinates relative to the screen or the parent window.</span></span> <span data-ttu-id="aa509-429">最上層視窗的座標是相對於畫面的左上角;子視窗的座標是相對於父視窗的左上角。</span><span class="sxs-lookup"><span data-stu-id="aa509-429">The coordinates of a top-level window are relative to the upper left corner of the screen; the coordinates of a child window are relative to the upper left corner of the parent window.</span></span> <span data-ttu-id="aa509-430">應用程式會在建立視窗時指定視窗的初始大小和位置，但可以隨時變更視窗的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-430">An application specifies a window's initial size and position when it creates the window, but it can change the window's size and position at any time.</span></span> <span data-ttu-id="aa509-431">如需詳細資訊，請參閱 [填滿的圖形](../gdi/filled-shapes.md)。</span><span class="sxs-lookup"><span data-stu-id="aa509-431">For more information, see [Filled Shapes](../gdi/filled-shapes.md).</span></span>

<span data-ttu-id="aa509-432">本節包含下列主題：</span><span class="sxs-lookup"><span data-stu-id="aa509-432">This section contains the following topics:</span></span>

-   [<span data-ttu-id="aa509-433">預設大小和位置</span><span class="sxs-lookup"><span data-stu-id="aa509-433">Default Size and Position</span></span>](#default-size-and-position)
-   [<span data-ttu-id="aa509-434">追蹤大小</span><span class="sxs-lookup"><span data-stu-id="aa509-434">Tracking Size</span></span>](#tracking-size)
-   [<span data-ttu-id="aa509-435">系統命令</span><span class="sxs-lookup"><span data-stu-id="aa509-435">System Commands</span></span>](#system-commands)
-   [<span data-ttu-id="aa509-436">大小和位置函式</span><span class="sxs-lookup"><span data-stu-id="aa509-436">Size and Position Functions</span></span>](#size-and-position-functions)
-   [<span data-ttu-id="aa509-437">大小和位置訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-437">Size and Position Messages</span></span>](#size-and-position-messages)

### <a name="default-size-and-position"></a><span data-ttu-id="aa509-438">預設大小和位置</span><span class="sxs-lookup"><span data-stu-id="aa509-438">Default Size and Position</span></span>

<span data-ttu-id="aa509-439">應用程式可讓系統藉由 \_ 在 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa)中指定 CW USEDEFAULT 來計算最上層視窗的初始大小或位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-439">An application can allow the system to calculate the initial size or position of a top-level window by specifying CW\_USEDEFAULT in [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa).</span></span> <span data-ttu-id="aa509-440">如果應用程式將視窗的座標設定為 [CW USEDEFAULT]， \_ 而且尚未建立任何其他最上層視窗，系統會設定新視窗相對於螢幕左上角的位置; 否則，它會設定相對於最上層視窗的位置，而該位置是最近建立的應用程式。</span><span class="sxs-lookup"><span data-stu-id="aa509-440">If the application sets the window's coordinates to CW\_USEDEFAULT and has created no other top-level windows, the system sets the new window's position relative to the upper left corner of the screen; otherwise, it sets the position relative to the position of the top-level window that the application created most recently.</span></span> <span data-ttu-id="aa509-441">如果 [寬度] 和 [高度] 參數設定為 [CW \_ USEDEFAULT]，系統就會計算新視窗的大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-441">If the width and height parameters are set to CW\_USEDEFAULT, the system calculates the size of the new window.</span></span> <span data-ttu-id="aa509-442">如果應用程式已建立其他最上層視窗，系統會根據應用程式最近建立之最上層視窗的大小，以新視窗的大小為基礎。</span><span class="sxs-lookup"><span data-stu-id="aa509-442">If the application has created other top-level windows, the system bases the size of the new window on the size of the application's most recently created top-level window.</span></span> <span data-ttu-id="aa509-443">\_在建立子系或快顯視窗時指定 CW USEDEFAULT，會導致系統將視窗的大小設定為預設的最小視窗大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-443">Specifying CW\_USEDEFAULT when creating a child or pop-up window causes the system to set the window's size to the default minimum window size.</span></span>

### <a name="tracking-size"></a><span data-ttu-id="aa509-444">追蹤大小</span><span class="sxs-lookup"><span data-stu-id="aa509-444">Tracking Size</span></span>

<span data-ttu-id="aa509-445">系統會維持 [**WS \_ THICKFRAME**](window-styles.md) 樣式視窗的最小和最大追蹤大小; 此樣式的視窗具有調整大小框線。</span><span class="sxs-lookup"><span data-stu-id="aa509-445">The system maintains a minimum and maximum tracking size for a window of the [**WS\_THICKFRAME**](window-styles.md) style; a window with this style has a sizing border.</span></span> <span data-ttu-id="aa509-446">*最小追蹤大小* 是您可以藉由拖曳視窗的大小調整框線來產生的最小視窗大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-446">The *minimum tracking size* is the smallest window size you can produce by dragging the window's sizing border.</span></span> <span data-ttu-id="aa509-447">同樣地， *追蹤大小上限* 是您可以藉由拖曳調整大小框線來產生的最大視窗大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-447">Similarly, the *maximum tracking size* is the largest window size you can produce by dragging the sizing border.</span></span>

<span data-ttu-id="aa509-448">當系統建立視窗時，視窗的最小和最大追蹤大小會設定為系統定義的預設值。</span><span class="sxs-lookup"><span data-stu-id="aa509-448">A window's minimum and maximum tracking sizes are set to system-defined default values when the system creates the window.</span></span> <span data-ttu-id="aa509-449">應用程式可以藉由處理 [**WM \_ GETMINMAXINFO**](wm-getminmaxinfo.md) 訊息來探索預設值並加以覆寫。</span><span class="sxs-lookup"><span data-stu-id="aa509-449">An application can discover the defaults and override them by processing the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message.</span></span> <span data-ttu-id="aa509-450">如需詳細資訊，請參閱 [大小和位置訊息](#size-and-position-messages)。</span><span class="sxs-lookup"><span data-stu-id="aa509-450">For more information, see [Size and Position Messages](#size-and-position-messages).</span></span>

### <a name="system-commands"></a><span data-ttu-id="aa509-451">系統命令</span><span class="sxs-lookup"><span data-stu-id="aa509-451">System Commands</span></span>

<span data-ttu-id="aa509-452">具有 [視窗] 功能表的應用程式可以藉由傳送系統命令來變更該視窗的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-452">An application that has a window menu can change the size and position of that window by sending system commands.</span></span> <span data-ttu-id="aa509-453">當使用者從 [視窗] 功能表選擇命令時，會產生系統命令。</span><span class="sxs-lookup"><span data-stu-id="aa509-453">System commands are generated when the user chooses commands from the window menu.</span></span> <span data-ttu-id="aa509-454">應用程式可以藉由將 [**WM \_ SYSCOMMAND**](../menurc/wm-syscommand.md) 訊息傳送至視窗，來模擬使用者動作。</span><span class="sxs-lookup"><span data-stu-id="aa509-454">An application can emulate the user action by sending a [**WM\_SYSCOMMAND**](../menurc/wm-syscommand.md) message to the window.</span></span> <span data-ttu-id="aa509-455">下列系統命令會影響視窗的大小和位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-455">The following system commands affect the size and position of a window.</span></span>



| <span data-ttu-id="aa509-456">命令</span><span class="sxs-lookup"><span data-stu-id="aa509-456">Command</span></span>      | <span data-ttu-id="aa509-457">描述</span><span class="sxs-lookup"><span data-stu-id="aa509-457">Description</span></span>                                                                                                                                                          |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="aa509-458">SC \_ CLOSE</span><span class="sxs-lookup"><span data-stu-id="aa509-458">SC\_CLOSE</span></span>    | <span data-ttu-id="aa509-459">關閉視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-459">Closes the window.</span></span> <span data-ttu-id="aa509-460">此命令會將 [**WM \_ 關閉**](wm-close.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-460">This command sends a [**WM\_CLOSE**](wm-close.md) message to the window.</span></span> <span data-ttu-id="aa509-461">視窗會執行清除和終結的任何必要步驟。</span><span class="sxs-lookup"><span data-stu-id="aa509-461">The window carries out any steps needed to clean up and destroy itself.</span></span> |
| <span data-ttu-id="aa509-462">SC \_ 最大化</span><span class="sxs-lookup"><span data-stu-id="aa509-462">SC\_MAXIMIZE</span></span> | <span data-ttu-id="aa509-463">將視窗最大化。</span><span class="sxs-lookup"><span data-stu-id="aa509-463">Maximizes the window.</span></span>                                                                                                                                                |
| <span data-ttu-id="aa509-464">SC \_ 最小化</span><span class="sxs-lookup"><span data-stu-id="aa509-464">SC\_MINIMIZE</span></span> | <span data-ttu-id="aa509-465">將視窗最小化。</span><span class="sxs-lookup"><span data-stu-id="aa509-465">Minimizes the window.</span></span>                                                                                                                                                |
| <span data-ttu-id="aa509-466">SC \_ 移動</span><span class="sxs-lookup"><span data-stu-id="aa509-466">SC\_MOVE</span></span>     | <span data-ttu-id="aa509-467">移動視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-467">Moves the window.</span></span>                                                                                                                                                    |
| <span data-ttu-id="aa509-468">SC \_ 還原</span><span class="sxs-lookup"><span data-stu-id="aa509-468">SC\_RESTORE</span></span>  | <span data-ttu-id="aa509-469">將最小化或最大化的視窗還原為其先前的大小與位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-469">Restores a minimized or maximized window to its previous size and position.</span></span>                                                                                          |
| <span data-ttu-id="aa509-470">SC \_ 大小</span><span class="sxs-lookup"><span data-stu-id="aa509-470">SC\_SIZE</span></span>     | <span data-ttu-id="aa509-471">啟動 size 命令。</span><span class="sxs-lookup"><span data-stu-id="aa509-471">Starts a size command.</span></span> <span data-ttu-id="aa509-472">若要變更視窗的大小，請使用滑鼠或鍵盤。</span><span class="sxs-lookup"><span data-stu-id="aa509-472">To change the size of the window, use the mouse or keyboard.</span></span>                                                                                  |



 

### <a name="size-and-position-functions"></a><span data-ttu-id="aa509-473">大小和位置函式</span><span class="sxs-lookup"><span data-stu-id="aa509-473">Size and Position Functions</span></span>

<span data-ttu-id="aa509-474">建立視窗之後，應用程式可以藉由呼叫數個不同函式的其中一個來設定視窗的大小或位置，包括 [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement)、 [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow)、 [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos)和 [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos)。</span><span class="sxs-lookup"><span data-stu-id="aa509-474">After creating a window, an application can set the window's size or position by calling one of several different functions, including [**SetWindowPlacement**](/windows/win32/api/winuser/nf-winuser-setwindowplacement), [**MoveWindow**](/windows/win32/api/winuser/nf-winuser-movewindow), [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos), and [**DeferWindowPos**](/windows/win32/api/winuser/nf-winuser-deferwindowpos).</span></span> <span data-ttu-id="aa509-475">**SetWindowPlacement** 會設定視窗的最小位置、最大化的位置、還原的大小和位置，以及顯示狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-475">**SetWindowPlacement** sets a window's minimized position, maximized position, restored size and position, and show state.</span></span> <span data-ttu-id="aa509-476">**MoveWindow** 和 **SetWindowPos** 函數很類似;同時設定單一應用程式視窗的大小或位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-476">The **MoveWindow** and **SetWindowPos** functions are similar; both set the size or position of a single application window.</span></span> <span data-ttu-id="aa509-477">**SetWindowPos** 函式包含一組會影響視窗顯示狀態的旗標;**MoveWindow** 不包含這些旗標。</span><span class="sxs-lookup"><span data-stu-id="aa509-477">The **SetWindowPos** function includes a set of flags that affect the window's show state; **MoveWindow** does not include these flags.</span></span> <span data-ttu-id="aa509-478">您可以使用 [**BeginDeferWindowPos**](/windows/win32/api/winuser/nf-winuser-begindeferwindowpos)、 **DeferWindowPos** 和 [**EndDeferWindowPos**](/windows/win32/api/winuser/nf-winuser-enddeferwindowpos) 函式，同時設定許多視窗的位置，包括大小、位置、以 z 順序排列的位置，以及顯示狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-478">Use the [**BeginDeferWindowPos**](/windows/win32/api/winuser/nf-winuser-begindeferwindowpos), **DeferWindowPos**, and [**EndDeferWindowPos**](/windows/win32/api/winuser/nf-winuser-enddeferwindowpos) functions to simultaneously set the position of a number of windows, including the size, position, position in the z-order, and show state.</span></span>

<span data-ttu-id="aa509-479">應用程式可以使用 [**GetWindowRect**](/windows/win32/api/winuser/nf-winuser-getwindowrect) 函式來取得視窗周框矩形的座標。</span><span class="sxs-lookup"><span data-stu-id="aa509-479">An application can retrieve the coordinates of a window's bounding rectangle by using the [**GetWindowRect**](/windows/win32/api/winuser/nf-winuser-getwindowrect) function.</span></span> <span data-ttu-id="aa509-480">**GetWindowRect** 會以視窗左上角和右下角的座標來填滿 [**矩形**](/previous-versions//dd162897(v=vs.85)) 結構。</span><span class="sxs-lookup"><span data-stu-id="aa509-480">**GetWindowRect** fills a [**RECT**](/previous-versions//dd162897(v=vs.85)) structure with the coordinates of the window's upper left and lower right corners.</span></span> <span data-ttu-id="aa509-481">座標是相對於螢幕左上角，甚至是子視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-481">The coordinates are relative to the upper left corner of the screen, even for a child window.</span></span> <span data-ttu-id="aa509-482">[**ScreenToClient**](/windows/win32/api/winuser/nf-winuser-screentoclient)或 [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints)函式會將子視窗周框矩形的螢幕座標，對應至父視窗工作區的相對座標。</span><span class="sxs-lookup"><span data-stu-id="aa509-482">The [**ScreenToClient**](/windows/win32/api/winuser/nf-winuser-screentoclient) or [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) function maps the screen coordinates of a child window's bounding rectangle to coordinates relative to the parent window's client area.</span></span>

<span data-ttu-id="aa509-483">[**GetClientRect**](/windows/win32/api/winuser/nf-winuser-getclientrect)函式會捕獲視窗工作區的座標。</span><span class="sxs-lookup"><span data-stu-id="aa509-483">The [**GetClientRect**](/windows/win32/api/winuser/nf-winuser-getclientrect) function retrieves the coordinates of a window's client area.</span></span> <span data-ttu-id="aa509-484">**GetClientRect** 會使用工作區左上角和右下角的座標來填滿 [**矩形**](/previous-versions//dd162897(v=vs.85)) 結構，但是座標是相對於用戶端區域本身。</span><span class="sxs-lookup"><span data-stu-id="aa509-484">**GetClientRect** fills a [**RECT**](/previous-versions//dd162897(v=vs.85)) structure with the coordinates of the upper left and lower right corners of the client area, but the coordinates are relative to the client area itself.</span></span> <span data-ttu-id="aa509-485">這表示用戶端區域左上角的座標一律是 (0、0) ，而右下角的座標則是工作區的寬度和高度。</span><span class="sxs-lookup"><span data-stu-id="aa509-485">This means the coordinates of a client area's upper left corner are always (0,0), and the coordinates of the lower right corner are the width and height of the client area.</span></span>

<span data-ttu-id="aa509-486">[**CascadeWindows**](/windows/win32/api/winuser/nf-winuser-cascadewindows)函式會將桌面上的視窗進行級聯，或將所指定父視窗的子視窗進行串聯。</span><span class="sxs-lookup"><span data-stu-id="aa509-486">The [**CascadeWindows**](/windows/win32/api/winuser/nf-winuser-cascadewindows) function cascades the windows on the desktop or cascades the child windows of the specified parent window.</span></span> <span data-ttu-id="aa509-487">[**TileWindows**](/windows/win32/api/winuser/nf-winuser-tilewindows)函式會在桌面上並排顯示視窗，或將所指定父視窗的子視窗磚。</span><span class="sxs-lookup"><span data-stu-id="aa509-487">The [**TileWindows**](/windows/win32/api/winuser/nf-winuser-tilewindows) function tiles the windows on the desktop or tiles the child windows of the specified parent window.</span></span>

### <a name="size-and-position-messages"></a><span data-ttu-id="aa509-488">大小和位置訊息</span><span class="sxs-lookup"><span data-stu-id="aa509-488">Size and Position Messages</span></span>

<span data-ttu-id="aa509-489">系統會將 [**WM \_ GETMINMAXINFO**](wm-getminmaxinfo.md) 訊息傳送到其大小或位置即將變更的視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-489">The system sends the [**WM\_GETMINMAXINFO**](wm-getminmaxinfo.md) message to a window whose size or position is about to change.</span></span> <span data-ttu-id="aa509-490">例如，當使用者按一下 [視窗] 功能表中的 [ **移動** ] 或 [ **大小** ]，或按一下調整大小框線或標題列時，就會傳送訊息。當應用程式呼叫 [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) 來移動或調整視窗大小時，也會傳送此訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-490">For example, the message is sent when the user clicks **Move** or **Size** from the window menu or clicks the sizing border or title bar; the message is also sent when an application calls [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) to move or size the window.</span></span> <span data-ttu-id="aa509-491">**WM \_GETMINMAXINFO** 包含 [**MINMAXINFO**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) 結構的指標，其中包含視窗的預設最大大小和位置，以及預設的最小和最大追蹤大小。</span><span class="sxs-lookup"><span data-stu-id="aa509-491">**WM\_GETMINMAXINFO** includes a pointer to a [**MINMAXINFO**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) structure containing the default maximized size and position for the window, as well as the default minimum and maximum tracking sizes.</span></span> <span data-ttu-id="aa509-492">應用程式可以藉由處理 **WM \_ GETMINMAXINFO** 並設定適當的 **MINMAXINFO** 成員，來覆寫預設值。</span><span class="sxs-lookup"><span data-stu-id="aa509-492">An application can override the defaults by processing **WM\_GETMINMAXINFO** and setting the appropriate members of **MINMAXINFO**.</span></span> <span data-ttu-id="aa509-493">視窗必須有 [**ws \_ THICKFRAME**](window-styles.md) 或 **ws \_ 標題** 樣式才能接收 **WM \_ GETMINMAXINFO**。</span><span class="sxs-lookup"><span data-stu-id="aa509-493">A window must have the [**WS\_THICKFRAME**](window-styles.md) or **WS\_CAPTION** style to receive **WM\_GETMINMAXINFO**.</span></span> <span data-ttu-id="aa509-494">具有 **WS \_ THICKFRAME** 樣式的視窗會在視窗建立過程中，以及在移動或調整大小時收到此訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-494">A window with the **WS\_THICKFRAME** style receives this message during the window-creation process, as well as when it is being moved or sized.</span></span>

<span data-ttu-id="aa509-495">系統會將 [**WM \_ WINDOWPOSCHANGING**](wm-windowposchanging.md) 訊息傳送至視窗，該視窗的大小、位置、位置以迭置順序表示，或顯示狀態即將變更。</span><span class="sxs-lookup"><span data-stu-id="aa509-495">The system sends the [**WM\_WINDOWPOSCHANGING**](wm-windowposchanging.md) message to a window whose size, position, position in the z-order, or show state is about to change.</span></span> <span data-ttu-id="aa509-496">此訊息包含 [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) 結構的指標，此結構會指定視窗的新大小、位置、以 z 順序排列的位置，以及顯示狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-496">This message includes a pointer to a [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) structure that specifies the window's new size, position, position in the z-order, and show state.</span></span> <span data-ttu-id="aa509-497">藉由設定 **WINDOWPOS** 的成員，應用程式可能會影響視窗的新大小、位置和外觀。</span><span class="sxs-lookup"><span data-stu-id="aa509-497">By setting the members of **WINDOWPOS**, an application can affect the window's new size, position, and appearance.</span></span>

<span data-ttu-id="aa509-498">以迭置順序變更視窗的大小、位置、位置，或顯示狀態之後，系統會將 [**WM \_ WINDOWPOSCHANGED**](wm-windowposchanged.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-498">After changing a window's size, position, position in the z-order, or show state, the system sends the [**WM\_WINDOWPOSCHANGED**](wm-windowposchanged.md) message to the window.</span></span> <span data-ttu-id="aa509-499">此訊息包含 [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) 的指標，該指標會通知視窗其新的大小、位置、在迭置順序中的位置，並顯示狀態。</span><span class="sxs-lookup"><span data-stu-id="aa509-499">This message includes a pointer to [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) that informs the window of its new size, position, position in the z-order, and show state.</span></span> <span data-ttu-id="aa509-500">設定以 **WM \_ WINDOWPOSCHANGED** 傳遞之 **WINDOWPOS** 結構的成員，對此視窗沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="aa509-500">Setting the members of the **WINDOWPOS** structure that is passed with **WM\_WINDOWPOSCHANGED** has no effect on the window.</span></span> <span data-ttu-id="aa509-501">必須處理 [**wm \_ 大小**](wm-size.md) 和 [**WM \_ 移動**](wm-move.md) 訊息的視窗必須將 **wm \_ WINDOWPOSCHANGED** 傳遞給 [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 函式; 否則，系統不會傳送 **wm \_ 大小** 和 **wm 將訊息 \_ 移** 至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-501">A window that must process [**WM\_SIZE**](wm-size.md) and [**WM\_MOVE**](wm-move.md) messages must pass **WM\_WINDOWPOSCHANGED** to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function; otherwise, the system does not send **WM\_SIZE** and **WM\_MOVE** messages to the window.</span></span>

<span data-ttu-id="aa509-502">當建立或調整視窗大小時，系統會將 [**WM \_ NCCALCSIZE**](wm-nccalcsize.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-502">The system sends the [**WM\_NCCALCSIZE**](wm-nccalcsize.md) message to a window when the window is created or sized.</span></span> <span data-ttu-id="aa509-503">系統會使用訊息來計算視窗工作區的大小，以及相對於視窗左上角的工作區位置。</span><span class="sxs-lookup"><span data-stu-id="aa509-503">The system uses the message to calculate the size of a window's client area and the position of the client area relative to the upper left corner of the window.</span></span> <span data-ttu-id="aa509-504">視窗通常會將此訊息傳遞至預設視窗程式;不過，在調整視窗大小時，在自訂視窗的非工作區或保留部分工作區的應用程式中，此訊息可能很有用。</span><span class="sxs-lookup"><span data-stu-id="aa509-504">A window typically passes this message to the default window procedure; however, this message can be useful in applications that customize a window's nonclient area or preserve portions of the client area when the window is sized.</span></span> <span data-ttu-id="aa509-505">如需詳細資訊，請參閱 [繪製和繪製](../gdi/painting-and-drawing.md)。</span><span class="sxs-lookup"><span data-stu-id="aa509-505">For more information, see [Painting and Drawing](../gdi/painting-and-drawing.md).</span></span>

## <a name="window-animation"></a><span data-ttu-id="aa509-506">視窗動畫</span><span class="sxs-lookup"><span data-stu-id="aa509-506">Window Animation</span></span>

<span data-ttu-id="aa509-507">您可以使用 [**AnimateWindow**](/windows/win32/api/winuser/nf-winuser-animatewindow) 函式，在顯示或隱藏視窗時產生特殊效果。</span><span class="sxs-lookup"><span data-stu-id="aa509-507">You can produce special effects when showing or hiding windows by using the [**AnimateWindow**](/windows/win32/api/winuser/nf-winuser-animatewindow) function.</span></span> <span data-ttu-id="aa509-508">以這種方式繪製視窗動畫時，系統會根據您在 **AnimateWindow** 的呼叫中指定的旗標，來變換、滑動或淡化視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-508">When the window is animated in this manner, the system will either roll, slide, or fade the window, depending on the flags you specify in a call to **AnimateWindow**.</span></span>

<span data-ttu-id="aa509-509">根據預設，系統會使用 *滾動動畫*。</span><span class="sxs-lookup"><span data-stu-id="aa509-509">By default, the system uses *roll animation*.</span></span> <span data-ttu-id="aa509-510">使用此效果時，視窗會顯示為 [已開啟]， (顯示視窗) 或 (隱藏視窗) 的關閉。</span><span class="sxs-lookup"><span data-stu-id="aa509-510">With this effect, the window appears to roll open (showing the window) or roll closed (hiding the window).</span></span> <span data-ttu-id="aa509-511">您可以使用 *dwFlags* 參數來指定視窗是以水準、垂直或對角線方式進行滾動。</span><span class="sxs-lookup"><span data-stu-id="aa509-511">You can use the *dwFlags* parameter to specify whether the window rolls horizontally, vertically, or diagonally.</span></span>

<span data-ttu-id="aa509-512">當您指定 **AW 投影 \_ 片** 旗標時，系統會使用投影 *片動畫*。</span><span class="sxs-lookup"><span data-stu-id="aa509-512">When you specify the **AW\_SLIDE** flag, the system uses *slide animation*.</span></span> <span data-ttu-id="aa509-513">有了這個效果，視窗就會顯示為滑 (顯示視窗) 或滑出視野 (隱藏視窗) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-513">With this effect, the window appears to slide into view (showing the window) or slide out of view (hiding the window).</span></span> <span data-ttu-id="aa509-514">您可以使用 *dwFlags* 參數來指定視窗是否以水準、垂直或對角線方式滑出。</span><span class="sxs-lookup"><span data-stu-id="aa509-514">You can use the *dwFlags* parameter to specify whether the window slides horizontally, vertically, or diagonally.</span></span>

<span data-ttu-id="aa509-515">當您指定 **AW \_ BLEND** 旗標時，系統會使用 *Alpha 混合的淡化*。</span><span class="sxs-lookup"><span data-stu-id="aa509-515">When you specify the **AW\_BLEND** flag, the system uses an *alpha-blended fade*.</span></span>

<span data-ttu-id="aa509-516">您也可以使用 [ **AW \_ CENTER** ] 旗標讓視窗出現，以向外或向外擴充。</span><span class="sxs-lookup"><span data-stu-id="aa509-516">You can also use the **AW\_CENTER** flag to make a window appear to collapse inward or expand outward.</span></span>

## <a name="window-layout-and-mirroring"></a><span data-ttu-id="aa509-517">視窗版面配置和鏡像</span><span class="sxs-lookup"><span data-stu-id="aa509-517">Window Layout and Mirroring</span></span>

<span data-ttu-id="aa509-518">視窗配置會定義文字和 Windows 圖形裝置介面 (GDI) 物件在視窗或裝置內容 (DC) 中的配置方式。</span><span class="sxs-lookup"><span data-stu-id="aa509-518">The window layout defines how text and Windows Graphics Device Interface (GDI) objects are laid out in a window or device context (DC).</span></span> <span data-ttu-id="aa509-519">某些語言（例如英文、法文和德文）需要由左至右 (LTR) 版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-519">Some languages, such as English, French, and German, require a left-to-right (LTR) layout.</span></span> <span data-ttu-id="aa509-520">其他語言（例如阿拉伯文和希伯來文）需要由右至左的 (RTL) 版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-520">Other languages, such as Arabic and Hebrew, require right-to-left (RTL) layout.</span></span> <span data-ttu-id="aa509-521">視窗配置會套用至文字，但也會影響視窗的其他 GDI 元素，包括點陣圖、圖示、原點位置、按鈕、階層式樹狀結構控制項，以及水準座標是否隨著您往左或右增加。</span><span class="sxs-lookup"><span data-stu-id="aa509-521">The window layout applies to text but also affects the other GDI elements of the window, including bitmaps, icons, the location of the origin, buttons, cascading tree controls, and whether the horizontal coordinate increases as you go left or right.</span></span> <span data-ttu-id="aa509-522">例如，在應用程式設定了 RTL 版面配置之後，原點位於視窗或裝置的右邊緣，而代表水準座標的數位會隨著您左移而增加。</span><span class="sxs-lookup"><span data-stu-id="aa509-522">For example, after an application has set RTL layout, the origin is positioned at the right edge of the window or device, and the number representing the horizontal coordinate increases as you move left.</span></span> <span data-ttu-id="aa509-523">但是，並非所有物件都會受到視窗版面配置的影響。</span><span class="sxs-lookup"><span data-stu-id="aa509-523">However, not all objects are affected by the layout of a window.</span></span> <span data-ttu-id="aa509-524">例如，您必須個別處理對話方塊的配置、訊息方塊，以及未與視窗相關聯的裝置內容，例如中繼檔和印表機 Dc。</span><span class="sxs-lookup"><span data-stu-id="aa509-524">For example, the layout for dialog boxes, message boxes, and device contexts that are not associated with a window, such as metafile and printer DCs, must be handled separately.</span></span> <span data-ttu-id="aa509-525">本主題稍後將說明這些細節的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="aa509-525">Specifics for these are mentioned later in this topic.</span></span>

<span data-ttu-id="aa509-526">視窗函式可讓您在阿拉伯文和希伯來文版本的 Windows 中，指定或變更視窗版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-526">The window functions allow you to specify or change the window layout in Arabic and Hebrew versions of Windows.</span></span> <span data-ttu-id="aa509-527">請注意，變更為 RTL 版面配置的 (也稱為鏡像) ，其樣式為 [CS \_ OWNDC](about-window-classes.md) 或具有 GM \_ ADVANCED 圖形模式的 DC 則不支援。</span><span class="sxs-lookup"><span data-stu-id="aa509-527">Note that changing to a RTL layout (also known as mirroring) is not supported for windows that have the style [CS\_OWNDC](about-window-classes.md) or for a DC with the GM\_ADVANCED graphic mode.</span></span>

<span data-ttu-id="aa509-528">根據預設，視窗版面配置是由左至右 (LTR) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-528">By default, the window layout is left-to-right (LTR).</span></span> <span data-ttu-id="aa509-529">若要設定 RTL 視窗版面配置，請使用 " **WS \_ EX \_ LAYOUTRTL**" 的樣式來呼叫 [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-529">To set the RTL window layout, call [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) with the style **WS\_EX\_LAYOUTRTL**.</span></span> <span data-ttu-id="aa509-530">此外，根據預設，子視窗 (也就是，在 [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa)或 **CreateWindowEx**) 的呼叫中，一個以 [**WS \_ 子**](window-styles.md)樣式建立的，且具有有效的父 *hWnd* 參數，其父代具有相同的版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-530">Also by default, a child window (that is, one created with the [**WS\_CHILD**](window-styles.md) style and with a valid parent *hWnd* parameter in the call to [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) or **CreateWindowEx**) has the same layout as its parent.</span></span> <span data-ttu-id="aa509-531">若要停用對所有子視窗的鏡像繼承，請在 **CreateWindowEx** 的呼叫中指定 **WS \_ EX \_ NOINHERITLAYOUT** 。</span><span class="sxs-lookup"><span data-stu-id="aa509-531">To disable inheritance of mirroring to all child windows, specify **WS\_EX\_NOINHERITLAYOUT** in the call to **CreateWindowEx**.</span></span> <span data-ttu-id="aa509-532">請注意，在不使用 **WS \_ 子** 樣式的情況下建立的 windows (不會繼承鏡像，) 或在 **CreateWindowEx** 中以父 *hWnd* 參數建立的不會被設定為 **Null**。</span><span class="sxs-lookup"><span data-stu-id="aa509-532">Note, mirroring is not inherited by owned windows (those created without the **WS\_CHILD** style) or those created with the parent *hWnd* parameter in **CreateWindowEx** set to **NULL**.</span></span> <span data-ttu-id="aa509-533">若要停用個別視窗的鏡像繼承，請使用 [**GetWindowLong**](/windows/win32/api/winuser/nf-winuser-getwindowlonga)和 [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga)來處理 [**WM \_ NCCREATE**](wm-nccreate.md)訊息，以關閉「 **WS \_ EX \_ LAYOUTRTL** 」旗標。</span><span class="sxs-lookup"><span data-stu-id="aa509-533">To disable inheritance of mirroring for an individual window, process the [**WM\_NCCREATE**](wm-nccreate.md) message with [**GetWindowLong**](/windows/win32/api/winuser/nf-winuser-getwindowlonga) and [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) to turn off the **WS\_EX\_LAYOUTRTL** flag.</span></span> <span data-ttu-id="aa509-534">這項處理是除了需要其他任何處理之外。</span><span class="sxs-lookup"><span data-stu-id="aa509-534">This processing is in addition to whatever other processing is needed.</span></span> <span data-ttu-id="aa509-535">下列程式碼片段顯示如何完成這項操作。</span><span class="sxs-lookup"><span data-stu-id="aa509-535">The following code fragment shows how this is done.</span></span>


```
SetWindowLong (hWnd, 
               GWL_EXSTYLE, 
               GetWindowLong(hWnd,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL))
```



<span data-ttu-id="aa509-536">您可以藉由呼叫 [**SetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout) (配置 rtl) ，將預設版面配置設定為 rtl \_ 。</span><span class="sxs-lookup"><span data-stu-id="aa509-536">You can set the default layout to RTL by calling [**SetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout)(LAYOUT\_RTL).</span></span> <span data-ttu-id="aa509-537">在呼叫之後建立的所有 windows 都會進行鏡像，但是現有的視窗不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="aa509-537">All windows created after the call will be mirrored, but existing windows are not affected.</span></span> <span data-ttu-id="aa509-538">若要關閉預設鏡像，請呼叫 **SetProcessDefaultLayout** (0) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-538">To turn off default mirroring, call **SetProcessDefaultLayout**(0).</span></span>

<span data-ttu-id="aa509-539">請注意， [**SetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout) 只會鏡像鏡像視窗的 dc。</span><span class="sxs-lookup"><span data-stu-id="aa509-539">Note, [**SetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout) mirrors the DCs only of mirrored windows.</span></span> <span data-ttu-id="aa509-540">若要鏡像任何 DC，請呼叫 [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) (hdc，以 RTL 的版面配置 \_) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-540">To mirror any DC, call [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout)(hdc, LAYOUT\_RTL).</span></span> <span data-ttu-id="aa509-541">如需詳細資訊，請參閱本主題稍後的鏡像未與 windows 相關聯的鏡像裝置內容討論。</span><span class="sxs-lookup"><span data-stu-id="aa509-541">For more information, see the discussion on mirroring device contexts not associated with windows, which comes later in this topic.</span></span>

<span data-ttu-id="aa509-542">鏡像視窗中的點陣圖和圖示預設也是鏡像的。</span><span class="sxs-lookup"><span data-stu-id="aa509-542">Bitmaps and icons in a mirrored window are also mirrored by default.</span></span> <span data-ttu-id="aa509-543">但是，並非所有這些都應該鏡像。</span><span class="sxs-lookup"><span data-stu-id="aa509-543">However, not all of these should be mirrored.</span></span> <span data-ttu-id="aa509-544">例如，具有文字、商務標誌或類比時鐘的那些應用程式不應該鏡像。</span><span class="sxs-lookup"><span data-stu-id="aa509-544">For example, those with text, a business logo, or an analog clock should not be mirrored.</span></span> <span data-ttu-id="aa509-545">若要停用點陣圖鏡像， [](/windows/win32/api/wingdi/nf-wingdi-setlayout)請使用 \_ *DWLAYOUT* 中設定的版面配置 BITMAPORIENTATIONPRESERVED 位來呼叫 SetLayout。</span><span class="sxs-lookup"><span data-stu-id="aa509-545">To disable mirroring of bitmaps, call [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) with the LAYOUT\_BITMAPORIENTATIONPRESERVED bit set in *dwLayout*.</span></span> <span data-ttu-id="aa509-546">若要停用 DC 中的鏡像，請呼叫 **SetLayout** (hdc，0) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-546">To disable mirroring in a DC, call **SetLayout**(hdc, 0).</span></span>

<span data-ttu-id="aa509-547">若要查詢目前的預設版面配置，請呼叫 [**GetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-getprocessdefaultlayout)。</span><span class="sxs-lookup"><span data-stu-id="aa509-547">To query the current default layout, call [**GetProcessDefaultLayout**](/windows/win32/api/winuser/nf-winuser-getprocessdefaultlayout).</span></span> <span data-ttu-id="aa509-548">在成功傳回時， *pdwDefaultLayout* 會包含 \_ RTL 或0的版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-548">Upon a successful return, *pdwDefaultLayout* contains LAYOUT\_RTL or 0.</span></span> <span data-ttu-id="aa509-549">若要查詢裝置內容的版面配置設定，請呼叫 [**GetLayout**](/windows/win32/api/wingdi/nf-wingdi-getlayout)。</span><span class="sxs-lookup"><span data-stu-id="aa509-549">To query the layout settings of the device context, call [**GetLayout**](/windows/win32/api/wingdi/nf-wingdi-getlayout).</span></span> <span data-ttu-id="aa509-550">在成功傳回時， **GetLayout** 會傳回 **DWORD** ，指出版面配置設定（依 \_ RTL 和版面配置 BITMAPORIENTATIONPRESERVED 位）的版面配置設定 \_ 。</span><span class="sxs-lookup"><span data-stu-id="aa509-550">Upon a successful return, **GetLayout** returns a **DWORD** that indicates the layout settings by the settings of the LAYOUT\_RTL and the LAYOUT\_BITMAPORIENTATIONPRESERVED bits.</span></span>

<span data-ttu-id="aa509-551">建立視窗之後，您可以使用 [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) 函式來變更版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-551">After a window has been created, you change the layout using the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function.</span></span> <span data-ttu-id="aa509-552">例如，當使用者將現有視窗的使用者介面語言從阿拉伯文或希伯來文變更為德文時，這是必要的。</span><span class="sxs-lookup"><span data-stu-id="aa509-552">For example, this is necessary when the user changes the user interface language of an existing window from Arabic or Hebrew to German.</span></span> <span data-ttu-id="aa509-553">不過，在變更現有視窗的配置時，您必須使視窗失效並更新，以確保視窗的內容全都以相同的版面配置繪製。</span><span class="sxs-lookup"><span data-stu-id="aa509-553">However, when changing the layout of an existing window, you must invalidate and update the window to ensure that the contents of the window are all drawn on the same layout.</span></span> <span data-ttu-id="aa509-554">下列程式碼範例是來自視需要變更視窗版面配置的範例程式碼：</span><span class="sxs-lookup"><span data-stu-id="aa509-554">The following code example is from sample code that changes the window layout as needed:</span></span>


```
// Using ANSI versions of GetWindowLong and SetWindowLong because Unicode
// is not needed for these calls

lExStyles = GetWindowLongA(hWnd, GWL_EXSTYLE);

// Check whether new layout is opposite the current layout
if (!!(pLState -> IsRTLLayout) != !!(lExStyles & WS_EX_LAYOUTRTL))
{
    // the following lines will update the window layout

    lExStyles ^= WS_EX_LAYOUTRTL;        // toggle layout
    SetWindowLongA(hWnd, GWL_EXSTYLE, lExStyles);
    InvalidateRect(hWnd, NULL, TRUE);    // to update layout in the client area
}
```



<span data-ttu-id="aa509-555">在鏡像中，您應該考慮「近」和「遠」，而不是「左方」和「右方」。</span><span class="sxs-lookup"><span data-stu-id="aa509-555">In mirroring, you should think in terms of "near" and "far" instead of "left" and "right".</span></span> <span data-ttu-id="aa509-556">如果無法這麼做，可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="aa509-556">Failure to do so can cause problems.</span></span> <span data-ttu-id="aa509-557">在 [螢幕座標] 和 [用戶端座標] 之間進行對應時，會導致鏡像視窗發生問題的一個常見程式碼撰寫做法。</span><span class="sxs-lookup"><span data-stu-id="aa509-557">One common coding practice that causes problems in a mirrored window occurs when mapping between screen coordinates and client coordinates.</span></span> <span data-ttu-id="aa509-558">例如，應用程式通常會使用類似下列的程式碼，將控制項放在視窗中：</span><span class="sxs-lookup"><span data-stu-id="aa509-558">For example, applications often use code similar to the following to position a control in a window:</span></span>


```
// DO NOT USE THIS IF APPLICATION MIRRORS THE WINDOW

// get coordinates of the window in screen coordinates
GetWindowRect(hControl, (LPRECT) &rControlRect);  

// map screen coordinates to client coordinates in dialog
ScreenToClient(hDialog, (LPPOINT) &rControlRect.left); 
ScreenToClient(hDialog, (LPPOINT) &rControlRect.right);
```



<span data-ttu-id="aa509-559">這會導致鏡像中的問題，因為矩形的左邊緣變成鏡像視窗中的右邊緣，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="aa509-559">This causes problems in mirroring because the left edge of the rectangle becomes the right edge in a mirrored window, and vice versa.</span></span> <span data-ttu-id="aa509-560">若要避免這個問題，請將 [**ScreenToClient**](/windows/win32/api/winuser/nf-winuser-screentoclient) 呼叫取代為 [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) 的呼叫，如下所示：</span><span class="sxs-lookup"><span data-stu-id="aa509-560">To avoid this problem, replace the [**ScreenToClient**](/windows/win32/api/winuser/nf-winuser-screentoclient) calls with a call to [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) as follows:</span></span>


```
// USE THIS FOR MIRRORING

GetWindowRect(hControl, (LPRECT) &rControlRect);
MapWindowPoints(NULL, hDialog, (LPPOINT) &rControlRect, 2)
```



<span data-ttu-id="aa509-561">這段程式碼的運作方式是因為在支援鏡像的平臺上， [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) 會在用戶端視窗已鏡像時修改，以交換左邊和右點的座標。</span><span class="sxs-lookup"><span data-stu-id="aa509-561">This code works because, on platforms that support mirroring, [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) is modified to swap the left and right point coordinates when the client window is mirrored.</span></span> <span data-ttu-id="aa509-562">如需詳細資訊，請參閱 **MapWindowPoints** 的「備註」一節。</span><span class="sxs-lookup"><span data-stu-id="aa509-562">For more information, see the Remarks section of **MapWindowPoints**.</span></span>

<span data-ttu-id="aa509-563">另一個可能在鏡像視窗中造成問題的常見做法，是使用螢幕座標中的位移（而非用戶端座標）來定位用戶端視窗中的物件。</span><span class="sxs-lookup"><span data-stu-id="aa509-563">Another common practice that can cause problems in mirrored windows is positioning objects in a client window using offsets in screen coordinates instead of client coordinates.</span></span> <span data-ttu-id="aa509-564">例如，下列程式碼會使用螢幕座標中的差異做為用戶端座標中的 x 位置，以將控制項放置在對話方塊中。</span><span class="sxs-lookup"><span data-stu-id="aa509-564">For example, the following code uses the difference in screen coordinates as the x position in client coordinates to position a control in a dialog box.</span></span>


```
// OK if LTR layout and mapping mode of client is MM_TEXT,
// but WRONG for a mirrored dialog 

RECT rdDialog;
RECT rcControl;

HWND hControl = GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hDlg, &rcDialog);             // gets rect in screen coordinates
GetWindowRect(hControl, &rcControl);
MoveWindow(hControl,
           rcControl.left - rcDialog.left,  // uses x position in client coords
           rcControl.top - rcDialog.top,
           nWidth,
           nHeight,
           FALSE);
```



<span data-ttu-id="aa509-565">當對話方塊視窗具有從左至右 (LTR) 配置，且用戶端的對應模式為 MM TEXT 時，此程式碼就很好用 \_ ，因為用戶端座標中的新 x 位置會對應到控制項左邊緣的差異和螢幕座標中的對話方塊。</span><span class="sxs-lookup"><span data-stu-id="aa509-565">This code is fine when the dialog window has left-to-right (LTR) layout and the mapping mode of the client is MM\_TEXT, because the new x position in client coordinates corresponds to the difference in left edges of the control and the dialog in screen coordinates.</span></span> <span data-ttu-id="aa509-566">不過，在鏡像對話中，left 和 right 會反轉，因此您應該改為使用 [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) ，如下所示：</span><span class="sxs-lookup"><span data-stu-id="aa509-566">However, in a mirrored dialog, left and right are reversed, so instead you should use [**MapWindowPoints**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) as follows:</span></span>


```
RECT rcDialog;
RECT rcControl;

HWND hControl - GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hControl, &rcControl);

// MapWindowPoints works correctly in both mirrored and non-mirrored windows.
MapWindowPoints(NULL, hDlg, (LPPOINT) &rcControl, 2);

// Now rcControl is in client coordinates.
MoveWindow(hControl, rcControl.left, rcControl.top, nWidth, nHeight, FALSE)
```



### <a name="mirroring-dialog-boxes-and-message-boxes"></a><span data-ttu-id="aa509-567">鏡像對話方塊和訊息方塊</span><span class="sxs-lookup"><span data-stu-id="aa509-567">Mirroring Dialog Boxes and Message Boxes</span></span>

<span data-ttu-id="aa509-568">對話方塊和訊息方塊不會繼承版面配置，因此您必須明確地設定版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-568">Dialog boxes and message boxes do not inherit layout, so you must set the layout explicitly.</span></span> <span data-ttu-id="aa509-569">若要建立訊息方塊的鏡像，請使用 **MB \_ RTLREADING** 選項來呼叫 [**MessageBox**](/windows/win32/api/winuser/nf-winuser-messagebox)或 [**MessageBoxEx**](/windows/win32/api/winuser/nf-winuser-messageboxexa) 。</span><span class="sxs-lookup"><span data-stu-id="aa509-569">To mirror a message box, call [**MessageBox**](/windows/win32/api/winuser/nf-winuser-messagebox) or [**MessageBoxEx**](/windows/win32/api/winuser/nf-winuser-messageboxexa) with the **MB\_RTLREADING** option.</span></span> <span data-ttu-id="aa509-570">若要從右至左配置對話方塊，請 \_ \_ 在 [對話方塊範本結構 [**DLGTEMPLATEEX**](../dlgbox/dlgtemplateex.md)] 中使用擴充樣式 WS EX LAYOUTRTL。</span><span class="sxs-lookup"><span data-stu-id="aa509-570">To layout a dialog box right-to-left, use the extended style WS\_EX\_LAYOUTRTL in the dialog template structure [**DLGTEMPLATEEX**](../dlgbox/dlgtemplateex.md).</span></span> <span data-ttu-id="aa509-571">屬性工作表是對話方塊的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="aa509-571">Property sheets are a special case of dialog boxes.</span></span> <span data-ttu-id="aa509-572">每一個索引標籤會被視為個別的對話方塊，所以您需要 \_ 在每個要鏡像的索引標籤中包含 WS EX \_ LAYOUTRTL 樣式。</span><span class="sxs-lookup"><span data-stu-id="aa509-572">Each tab is treated as a separate dialog box, so you need to include the WS\_EX\_LAYOUTRTL style in every tab that you want mirrored.</span></span>

### <a name="mirroring-device-contexts-not-associated-with-a-window"></a><span data-ttu-id="aa509-573">未與視窗相關聯的鏡像裝置內容</span><span class="sxs-lookup"><span data-stu-id="aa509-573">Mirroring Device Contexts Not Associated with a Window</span></span>

<span data-ttu-id="aa509-574">未與視窗相關聯的 Dc （例如，中繼檔或印表機 Dc）不會繼承配置，因此您必須明確地設定版面配置。</span><span class="sxs-lookup"><span data-stu-id="aa509-574">DCs that are not associated with a window, such as metafile or printer DCs, do not inherit layout, so you must set the layout explicitly.</span></span> <span data-ttu-id="aa509-575">若要變更裝置內容版面配置，請使用 [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) 函數。</span><span class="sxs-lookup"><span data-stu-id="aa509-575">To change the device context layout, use the [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) function.</span></span>

<span data-ttu-id="aa509-576">[**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout)函式很少用於 windows。</span><span class="sxs-lookup"><span data-stu-id="aa509-576">The [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) function is rarely used with windows.</span></span> <span data-ttu-id="aa509-577">一般而言，windows 只會在處理 [**WM \_ 油漆**](../gdi/wm-paint.md) 訊息時接收相關聯的 DC。</span><span class="sxs-lookup"><span data-stu-id="aa509-577">Typically, windows receive an associated DC only in processing a [**WM\_PAINT**](../gdi/wm-paint.md) message.</span></span> <span data-ttu-id="aa509-578">有時候，程式會藉由呼叫 [**GetDC**](/windows/win32/api/winuser/nf-winuser-getdc)來建立視窗的 DC。</span><span class="sxs-lookup"><span data-stu-id="aa509-578">Occasionally, a program creates a DC for a window by calling [**GetDC**](/windows/win32/api/winuser/nf-winuser-getdc).</span></span> <span data-ttu-id="aa509-579">無論何種方式，都會根據視窗的 WS [](/windows/win32/api/winuser/nf-winuser-beginpaint) EX  \_ \_ LAYOUTRTL 旗標，設定 DC 的初始配置 BeginPaint 或 GetDC。</span><span class="sxs-lookup"><span data-stu-id="aa509-579">Either way, the initial layout for the DC is set by [**BeginPaint**](/windows/win32/api/winuser/nf-winuser-beginpaint) or **GetDC** according to the window's WS\_EX\_LAYOUTRTL flag.</span></span>

<span data-ttu-id="aa509-580">[**GetWindowOrgEx**](/windows/win32/api/wingdi/nf-wingdi-getwindoworgex)、 [**GetWindowExtEx**](/windows/win32/api/wingdi/nf-wingdi-getwindowextex)、 [**GetViewportOrgEx**](/windows/win32/api/wingdi/nf-wingdi-getviewportorgex)和 [**GetViewportExtEx**](/windows/win32/api/wingdi/nf-wingdi-getviewportextex)所傳回的值不會受到呼叫 [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout)的影響。</span><span class="sxs-lookup"><span data-stu-id="aa509-580">The values returned by [**GetWindowOrgEx**](/windows/win32/api/wingdi/nf-wingdi-getwindoworgex), [**GetWindowExtEx**](/windows/win32/api/wingdi/nf-wingdi-getwindowextex), [**GetViewportOrgEx**](/windows/win32/api/wingdi/nf-wingdi-getviewportorgex) and [**GetViewportExtEx**](/windows/win32/api/wingdi/nf-wingdi-getviewportextex) are not affected by calling [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout).</span></span>

<span data-ttu-id="aa509-581">當版面配置為 RTL 時， [**GetMapMode**](/windows/win32/api/wingdi/nf-wingdi-getmapmode) 會傳回 mm （ \_ 而不是 mm \_ TEXT）。</span><span class="sxs-lookup"><span data-stu-id="aa509-581">When the layout is RTL, [**GetMapMode**](/windows/win32/api/wingdi/nf-wingdi-getmapmode) will return MM\_ANISOTROPIC instead of MM\_TEXT.</span></span> <span data-ttu-id="aa509-582">使用 MM TEXT 呼叫 [**SetMapMode**](/windows/win32/api/wingdi/nf-wingdi-setmapmode) \_ 將會正確運作，只會影響來自 **GetMapMode** 的傳回值。</span><span class="sxs-lookup"><span data-stu-id="aa509-582">Calling [**SetMapMode**](/windows/win32/api/wingdi/nf-wingdi-setmapmode) with MM\_TEXT will function correctly; only the return value from **GetMapMode** is affected.</span></span> <span data-ttu-id="aa509-583">同樣地，呼叫 [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout) (hdc， \_ 當對應模式為 mm TEXT 時，會) 配置 RTL， \_ 以將報告的對應模式變更為 mm \_ 各向異性。</span><span class="sxs-lookup"><span data-stu-id="aa509-583">Similarly, calling [**SetLayout**](/windows/win32/api/wingdi/nf-wingdi-setlayout)(hdc, LAYOUT\_RTL) when the mapping mode is MM\_TEXT causes the reported mapping mode to change to MM\_ANISOTROPIC.</span></span>

## <a name="window-destruction"></a><span data-ttu-id="aa509-584">視窗損毀</span><span class="sxs-lookup"><span data-stu-id="aa509-584">Window Destruction</span></span>

<span data-ttu-id="aa509-585">一般來說，應用程式必須終結它所建立的所有視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-585">In general, an application must destroy all the windows it creates.</span></span> <span data-ttu-id="aa509-586">它會使用 [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) 函式來執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="aa509-586">It does this by using the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function.</span></span> <span data-ttu-id="aa509-587">當視窗損毀時，系統會隱藏視窗（如果有的話），然後移除與視窗相關聯的任何內部資料。</span><span class="sxs-lookup"><span data-stu-id="aa509-587">When a window is destroyed, the system hides the window, if it is visible, and then removes any internal data associated with the window.</span></span> <span data-ttu-id="aa509-588">這會使視窗控制碼失效，應用程式將無法再使用此控制碼。</span><span class="sxs-lookup"><span data-stu-id="aa509-588">This invalidates the window handle, which can no longer be used by the application.</span></span>

<span data-ttu-id="aa509-589">應用程式會在建立應用程式之後，立即終結它所建立的許多視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-589">An application destroys many of the windows it creates soon after creating them.</span></span> <span data-ttu-id="aa509-590">例如，當應用程式有足夠的輸入可繼續其工作時，應用程式通常會立即終結對話方塊視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-590">For example, an application usually destroys a dialog box window as soon as the application has sufficient input from the user to continue its task.</span></span> <span data-ttu-id="aa509-591">應用程式最後會在終止) 之前終結應用程式 (的主視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-591">An application eventually destroys the main window of the application (before terminating).</span></span>

<span data-ttu-id="aa509-592">在終結視窗之前，應用程式應該儲存或移除任何與視窗相關聯的資料，而且它應該釋出任何為視窗配置的系統資源。</span><span class="sxs-lookup"><span data-stu-id="aa509-592">Before destroying a window, an application should save or remove any data associated with the window, and it should release any system resources allocated for the window.</span></span> <span data-ttu-id="aa509-593">如果應用程式未釋出資源，系統將會釋放應用程式未釋放的任何資源。</span><span class="sxs-lookup"><span data-stu-id="aa509-593">If the application does not release the resources, the system will free any resources not freed by the application.</span></span>

<span data-ttu-id="aa509-594">終結視窗並不會影響視窗建立所在的視窗類別。</span><span class="sxs-lookup"><span data-stu-id="aa509-594">Destroying a window does not affect the window class from which the window is created.</span></span> <span data-ttu-id="aa509-595">您仍然可以使用該類別來建立新的視窗，且該類別的任何現有視窗都會繼續運作。</span><span class="sxs-lookup"><span data-stu-id="aa509-595">New windows can still be created using that class, and any existing windows of that class continue to operate.</span></span> <span data-ttu-id="aa509-596">終結視窗也會損毀視窗的子系視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-596">Destroying a window also destroys the window's descendant windows.</span></span> <span data-ttu-id="aa509-597">[**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow)函式會先將 [**WM 損 \_ 毀**](wm-destroy.md)訊息傳送至視窗，然後傳送至其子視窗和子系視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-597">The [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function sends a [**WM\_DESTROY**](wm-destroy.md) message first to the window, then to its child windows and descendant windows.</span></span> <span data-ttu-id="aa509-598">如此一來，已終結之視窗的所有子系視窗也會終結。</span><span class="sxs-lookup"><span data-stu-id="aa509-598">In this way, all descendant windows of the window being destroyed are also destroyed.</span></span>

<span data-ttu-id="aa509-599">當使用者按一下 [**關閉**] 時，具有視窗功能表的視窗就會收到 [**WM \_ 關閉**](wm-close.md)訊息。</span><span class="sxs-lookup"><span data-stu-id="aa509-599">A window with a window menu receives a [**WM\_CLOSE**](wm-close.md) message when the user clicks **Close**.</span></span> <span data-ttu-id="aa509-600">藉由處理此訊息，應用程式可以在終結視窗之前提示使用者進行確認。</span><span class="sxs-lookup"><span data-stu-id="aa509-600">By processing this message, an application can prompt the user for confirmation before destroying the window.</span></span> <span data-ttu-id="aa509-601">如果使用者確認應該終結視窗，應用程式可以呼叫 [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) 函式來終結視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-601">If the user confirms that the window should be destroyed, the application can call the [**DestroyWindow**](/windows/win32/api/winuser/nf-winuser-destroywindow) function to destroy the window.</span></span>

<span data-ttu-id="aa509-602">如果正在終結的視窗是作用中視窗，作用中和焦點狀態都會傳送到另一個視窗。</span><span class="sxs-lookup"><span data-stu-id="aa509-602">If the window being destroyed is the active window, both the active and focus states are transferred to another window.</span></span> <span data-ttu-id="aa509-603">成為使用中視窗的視窗是下一個視窗，由 ALT + ESC 鍵組合所決定。</span><span class="sxs-lookup"><span data-stu-id="aa509-603">The window that becomes the active window is the next window, as determined by the ALT+ESC key combination.</span></span> <span data-ttu-id="aa509-604">新的使用中視窗接著會決定哪個視窗接收到鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="aa509-604">The new active window then determines which window receives the keyboard focus.</span></span>

 

 
