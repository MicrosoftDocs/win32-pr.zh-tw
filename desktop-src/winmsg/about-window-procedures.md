---
description: 每個視窗都是特定視窗類別的成員。 視窗類別會決定個別視窗用來處理其訊息的預設視窗程式。
ms.assetid: 3a8e8f4e-910d-4863-a4a7-dd37c2dfa402
title: 關於視窗程式
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f1f63586b9ca4ac6fe8486ba112316174533b44e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106997988"
---
# <a name="about-window-procedures"></a><span data-ttu-id="6d212-104">關於視窗程式</span><span class="sxs-lookup"><span data-stu-id="6d212-104">About Window Procedures</span></span>

<span data-ttu-id="6d212-105">每個視窗都是特定視窗類別的成員。</span><span class="sxs-lookup"><span data-stu-id="6d212-105">Each window is a member of a particular window class.</span></span> <span data-ttu-id="6d212-106">視窗類別會決定個別視窗用來處理其訊息的預設視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-106">The window class determines the default window procedure that an individual window uses to process its messages.</span></span> <span data-ttu-id="6d212-107">所有屬於相同類別的 windows 都使用相同的預設視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-107">All windows belonging to the same class use the same default window procedure.</span></span> <span data-ttu-id="6d212-108">例如，系統會定義下拉式方塊類別 (**COMBOBOX**) 的視窗程式。然後，所有下拉式方塊都會使用該視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-108">For example, the system defines a window procedure for the combo box class (**COMBOBOX**); all combo boxes then use that window procedure.</span></span>

<span data-ttu-id="6d212-109">應用程式通常會註冊至少一個新視窗類別和其相關聯的視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-109">An application typically registers at least one new window class and its associated window procedure.</span></span> <span data-ttu-id="6d212-110">註冊類別之後，應用程式就可以建立該類別的許多視窗，全都使用相同的視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-110">After registering a class, the application can create many windows of that class, all of which use the same window procedure.</span></span> <span data-ttu-id="6d212-111">因為這表示多個來源可以同時呼叫相同的程式碼，所以從視窗程式修改共用資源時，您必須特別小心。</span><span class="sxs-lookup"><span data-stu-id="6d212-111">Because this means several sources could simultaneously call the same piece of code, you must be careful when modifying shared resources from a window procedure.</span></span> <span data-ttu-id="6d212-112">如需詳細資訊，請參閱 [視窗類別](window-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="6d212-112">For more information, see [Window Classes](window-classes.md).</span></span>

<span data-ttu-id="6d212-113">對話方塊的視窗程式 (呼叫的對話方塊程式) 具有與一般視窗程式類似的結構和功能。</span><span class="sxs-lookup"><span data-stu-id="6d212-113">Window procedures for dialog boxes (called dialog box procedures) have a similar structure and function as regular window procedures.</span></span> <span data-ttu-id="6d212-114">本章節中參考視窗程式的所有點也適用于對話方塊程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-114">All points referring to window procedures in this section also apply to dialog box procedures.</span></span> <span data-ttu-id="6d212-115">如需詳細資訊，請參閱 [對話方塊](/windows/desktop/dlgbox/dialog-boxes)。</span><span class="sxs-lookup"><span data-stu-id="6d212-115">For more information, see [Dialog Boxes](/windows/desktop/dlgbox/dialog-boxes).</span></span>

<span data-ttu-id="6d212-116">本節將討論下列主題。</span><span class="sxs-lookup"><span data-stu-id="6d212-116">This section discusses the following topics.</span></span>

-   [<span data-ttu-id="6d212-117">視窗程式的結構</span><span class="sxs-lookup"><span data-stu-id="6d212-117">Structure of a Window Procedure</span></span>](#structure-of-a-window-procedure)
-   [<span data-ttu-id="6d212-118">預設視窗程式</span><span class="sxs-lookup"><span data-stu-id="6d212-118">Default Window Procedure</span></span>](#default-window-procedure)
-   [<span data-ttu-id="6d212-119">視窗程式子類別化</span><span class="sxs-lookup"><span data-stu-id="6d212-119">Window Procedure Subclassing</span></span>](#window-procedure-subclassing)
    -   [<span data-ttu-id="6d212-120">實例子類別化</span><span class="sxs-lookup"><span data-stu-id="6d212-120">Instance Subclassing</span></span>](#instance-subclassing)
    -   [<span data-ttu-id="6d212-121">全域子類別</span><span class="sxs-lookup"><span data-stu-id="6d212-121">Global Subclassing</span></span>](#global-subclassing)
-   [<span data-ttu-id="6d212-122">視窗程式 Superclassing</span><span class="sxs-lookup"><span data-stu-id="6d212-122">Window Procedure Superclassing</span></span>](#window-procedure-superclassing)

## <a name="structure-of-a-window-procedure"></a><span data-ttu-id="6d212-123">視窗程式的結構</span><span class="sxs-lookup"><span data-stu-id="6d212-123">Structure of a Window Procedure</span></span>

<span data-ttu-id="6d212-124">視窗程式是具有四個參數並傳回帶正負號值的函式。</span><span class="sxs-lookup"><span data-stu-id="6d212-124">A window procedure is a function that has four parameters and returns a signed value.</span></span> <span data-ttu-id="6d212-125">這些參數是由視窗控制碼、 **UINT** 訊息識別碼，以及使用 **WPARAM** 和 **LPARAM** 資料類型宣告的兩個訊息參數所組成。</span><span class="sxs-lookup"><span data-stu-id="6d212-125">The parameters consist of a window handle, a **UINT** message identifier, and two message parameters declared with the **WPARAM** and **LPARAM** data types.</span></span> <span data-ttu-id="6d212-126">如需詳細資訊，請參閱 [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="6d212-126">For more information, see [**WindowProc**](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)).</span></span>

<span data-ttu-id="6d212-127">訊息參數通常會包含其低序位和高序位字組中的資訊。</span><span class="sxs-lookup"><span data-stu-id="6d212-127">Message parameters often contain information in both their low-order and high-order words.</span></span> <span data-ttu-id="6d212-128">有幾個宏可供應用程式用來從訊息參數解壓縮資訊。</span><span class="sxs-lookup"><span data-stu-id="6d212-128">There are several macros an application can use to extract information from the message parameters.</span></span> <span data-ttu-id="6d212-129">例如， [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) 宏會將低序位字組從 message 參數解壓縮 (位0到 15) 。</span><span class="sxs-lookup"><span data-stu-id="6d212-129">The [**LOWORD**](/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)) macro, for example, extracts the low-order word (bits 0 through 15) from a message parameter.</span></span> <span data-ttu-id="6d212-130">其他宏包括 [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85))、 [**LOBYTE**](/previous-versions/windows/desktop/legacy/ms632658(v=vs.85))和 [**HIBYTE**](/previous-versions/windows/desktop/legacy/ms632656(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="6d212-130">Other macros include [**HIWORD**](/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)), [**LOBYTE**](/previous-versions/windows/desktop/legacy/ms632658(v=vs.85)), and [**HIBYTE**](/previous-versions/windows/desktop/legacy/ms632656(v=vs.85)).</span></span>

<span data-ttu-id="6d212-131">傳回值的解釋取決於特定的訊息。</span><span class="sxs-lookup"><span data-stu-id="6d212-131">The interpretation of the return value depends on the particular message.</span></span> <span data-ttu-id="6d212-132">請參閱每個訊息的描述，以判斷適當的傳回值。</span><span class="sxs-lookup"><span data-stu-id="6d212-132">Consult the description of each message to determine the appropriate return value.</span></span>

<span data-ttu-id="6d212-133">因為可能會以遞迴方式呼叫視窗程式，所以請務必將它所使用的區域變數數目降到最低。</span><span class="sxs-lookup"><span data-stu-id="6d212-133">Because it is possible to call a window procedure recursively, it is important to minimize the number of local variables that it uses.</span></span> <span data-ttu-id="6d212-134">處理個別訊息時，應用程式應該呼叫視窗程式之外的函式，以避免過度使用本機變數，可能會導致堆疊在深度遞迴期間溢位。</span><span class="sxs-lookup"><span data-stu-id="6d212-134">When processing individual messages, an application should call functions outside the window procedure to avoid excessive use of local variables, possibly causing the stack to overflow during deep recursion.</span></span>

## <a name="default-window-procedure"></a><span data-ttu-id="6d212-135">預設視窗程式</span><span class="sxs-lookup"><span data-stu-id="6d212-135">Default Window Procedure</span></span>

<span data-ttu-id="6d212-136">預設的視窗程式函式 [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 會定義所有視窗共用的某些基本行為。</span><span class="sxs-lookup"><span data-stu-id="6d212-136">The default window procedure function, [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) defines certain fundamental behavior shared by all windows.</span></span> <span data-ttu-id="6d212-137">預設視窗程式會為視窗提供最基本的功能。</span><span class="sxs-lookup"><span data-stu-id="6d212-137">The default window procedure provides the minimal functionality for a window.</span></span> <span data-ttu-id="6d212-138">應用程式定義的視窗程式應該將它未處理的任何訊息傳遞至 **DefWindowProc** 函式，以進行預設處理。</span><span class="sxs-lookup"><span data-stu-id="6d212-138">An application-defined window procedure should pass any messages that it does not process to the **DefWindowProc** function for default processing.</span></span>

## <a name="window-procedure-subclassing"></a><span data-ttu-id="6d212-139">視窗程式子類別化</span><span class="sxs-lookup"><span data-stu-id="6d212-139">Window Procedure Subclassing</span></span>

<span data-ttu-id="6d212-140">當應用程式建立視窗時，系統會配置記憶體區塊來儲存視窗的特定資訊，包括處理視窗訊息的視窗程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-140">When an application creates a window, the system allocates a block of memory for storing information specific to the window, including the address of the window procedure that processes messages for the window.</span></span> <span data-ttu-id="6d212-141">當系統需要將訊息傳遞至視窗時，會在視窗特定的資訊中搜尋視窗程式的位址，並將訊息傳遞至該程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-141">When the system needs to pass a message to the window, it searches the window-specific information for the address of the window procedure and passes the message to that procedure.</span></span>

<span data-ttu-id="6d212-142">子類別 *化是一* 種技術，可讓應用程式在視窗有機會處理訊息之前，攔截和處理傳送或張貼至特定視窗的訊息。</span><span class="sxs-lookup"><span data-stu-id="6d212-142">*Subclassing* is a technique that allows an application to intercept and process messages sent or posted to a particular window before the window has a chance to process them.</span></span> <span data-ttu-id="6d212-143">藉由子類別化視窗，應用程式可以增強、修改或監看視窗的行為。</span><span class="sxs-lookup"><span data-stu-id="6d212-143">By subclassing a window, an application can augment, modify, or monitor the behavior of the window.</span></span> <span data-ttu-id="6d212-144">應用程式可以子類別屬於系統全域類別的視窗，例如編輯控制項或清單方塊。</span><span class="sxs-lookup"><span data-stu-id="6d212-144">An application can subclass a window belonging to a system global class, such as an edit control or a list box.</span></span> <span data-ttu-id="6d212-145">例如，應用程式可以將編輯控制項設為子類別，以防止控制項接受某些字元。</span><span class="sxs-lookup"><span data-stu-id="6d212-145">For example, an application could subclass an edit control to prevent the control from accepting certain characters.</span></span> <span data-ttu-id="6d212-146">不過，您無法將屬於另一個應用程式的視窗或類別設為子類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-146">However, you cannot subclass a window or class that belongs to another application.</span></span> <span data-ttu-id="6d212-147">所有子類別化都必須在相同的進程中執行。</span><span class="sxs-lookup"><span data-stu-id="6d212-147">All subclassing must be performed within the same process.</span></span>

<span data-ttu-id="6d212-148">應用程式會將視窗的原始視窗程式位址取代為新視窗程式的位址（稱為子 *類別* 程式），以子類別化視窗。</span><span class="sxs-lookup"><span data-stu-id="6d212-148">An application subclasses a window by replacing the address of the window's original window procedure with the address of a new window procedure, called the *subclass procedure*.</span></span> <span data-ttu-id="6d212-149">之後，子類別程式就會收到任何傳送或張貼至視窗的訊息。</span><span class="sxs-lookup"><span data-stu-id="6d212-149">Thereafter, the subclass procedure receives any messages sent or posted to the window.</span></span>

<span data-ttu-id="6d212-150">在接收訊息時，子類別程式可以採取三個動作：它可以將訊息傳遞至原始視窗程式、修改訊息並將它傳遞給原始視窗程式，或處理訊息，而不將它傳遞至原始視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-150">The subclass procedure can take three actions upon receiving a message: it can pass the message to the original window procedure, modify the message and pass it to the original window procedure, or process the message and not pass it to the original window procedure.</span></span> <span data-ttu-id="6d212-151">如果子類別程式處理訊息，它可以在將訊息傳遞至原始視窗程式之前、之後或前後進行。</span><span class="sxs-lookup"><span data-stu-id="6d212-151">If the subclass procedure processes a message, it can do so before, after, or both before and after it passes the message to the original window procedure.</span></span>

<span data-ttu-id="6d212-152">系統提供兩種類型的子類別： [instance](#instance-subclassing) 和 [global](#global-subclassing)。</span><span class="sxs-lookup"><span data-stu-id="6d212-152">The system provides two types of subclassing: [instance](#instance-subclassing) and [global](#global-subclassing).</span></span> <span data-ttu-id="6d212-153">在子類別化的 *實例* 中，應用程式會取代視窗的單一實例的視窗程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-153">In *instance subclassing*, an application replaces the window procedure address of a single instance of a window.</span></span> <span data-ttu-id="6d212-154">應用程式必須使用實例子類別化現有的視窗。</span><span class="sxs-lookup"><span data-stu-id="6d212-154">An application must use instance subclassing to subclass an existing window.</span></span> <span data-ttu-id="6d212-155">在 *全域* 子類別中，應用程式會取代視窗類別的 [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) 結構中的視窗程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-155">In *global subclassing*, an application replaces the address of the window procedure in the [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure of a window class.</span></span> <span data-ttu-id="6d212-156">所有以類別建立的後續視窗都有子類別程式的位址，但是類別的現有視窗則不受影響。</span><span class="sxs-lookup"><span data-stu-id="6d212-156">All subsequent windows created with the class have the address of the subclass procedure, but existing windows of the class are not affected.</span></span>

### <a name="instance-subclassing"></a><span data-ttu-id="6d212-157">實例子類別化</span><span class="sxs-lookup"><span data-stu-id="6d212-157">Instance Subclassing</span></span>

<span data-ttu-id="6d212-158">應用程式會使用 [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) 函數將視窗的實例子類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-158">An application subclasses an instance of a window by using the [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) function.</span></span> <span data-ttu-id="6d212-159">應用程式會將 **GWL \_ WNDPROC** 旗標、視窗的控制碼傳遞給子類別，以及要 **SetWindowLong** 的子類別程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-159">The application passes the **GWL\_WNDPROC** flag, the handle to the window to subclass, and the address of the subclass procedure to **SetWindowLong**.</span></span> <span data-ttu-id="6d212-160">子類別程式可以位於應用程式的可執行檔或 DLL 中。</span><span class="sxs-lookup"><span data-stu-id="6d212-160">The subclass procedure can reside in either the application's executable or a DLL.</span></span>

<span data-ttu-id="6d212-161">[**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) 會傳回視窗的原始視窗程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-161">[**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) returns the address of the window's original window procedure.</span></span> <span data-ttu-id="6d212-162">應用程式必須儲存位址，並在後續呼叫 [**CallWindowProc**](/windows/win32/api/winuser/nf-winuser-callwindowproca) 函式時使用它，以將攔截的訊息傳遞給原始的視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-162">The application must save the address, using it in subsequent calls to the [**CallWindowProc**](/windows/win32/api/winuser/nf-winuser-callwindowproca) function, to pass intercepted messages to the original window procedure.</span></span> <span data-ttu-id="6d212-163">應用程式也必須有原始的視窗程式位址，才能從視窗中移除子類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-163">The application must also have the original window procedure address to remove the subclass from the window.</span></span> <span data-ttu-id="6d212-164">若要移除子類別，應用程式會再次呼叫 **SetWindowLong** ，以 **GWL \_ WNDPROC** 旗標和視窗的控制碼傳遞原始視窗程式的位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-164">To remove the subclass, the application calls **SetWindowLong** again, passing the address of the original window procedure with the **GWL\_WNDPROC** flag and the handle to the window.</span></span>

<span data-ttu-id="6d212-165">系統擁有系統全域類別，而控制項的各個層面可能會從系統的某個版本變更為下一個版本。</span><span class="sxs-lookup"><span data-stu-id="6d212-165">The system owns the system global classes, and aspects of the controls might change from one version of the system to the next.</span></span> <span data-ttu-id="6d212-166">如果應用程式必須將屬於系統全域類別的視窗子類別化，開發人員可能需要在發行新版的系統時更新應用程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-166">If the application must subclass a window that belongs to a system global class, the developer may need to update the application when a new version of the system is released.</span></span>

<span data-ttu-id="6d212-167">因為實例子類別發生在建立視窗之後，所以您無法在視窗中加入任何額外的位元組。</span><span class="sxs-lookup"><span data-stu-id="6d212-167">Because instance subclassing occurs after a window is created, you cannot add any extra bytes to the window.</span></span> <span data-ttu-id="6d212-168">子類別化視窗的應用程式應該使用視窗的屬性清單來儲存子類別化視窗實例所需的任何資料。</span><span class="sxs-lookup"><span data-stu-id="6d212-168">Applications that subclass a window should use the window's property list to store any data needed for an instance of the subclassed window.</span></span> <span data-ttu-id="6d212-169">如需詳細資訊，請參閱 [視窗屬性](window-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="6d212-169">For more information, see [Window Properties](window-properties.md).</span></span>

<span data-ttu-id="6d212-170">當應用程式子類別化的子類別化視窗時，必須以執行的反向順序來移除子類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-170">When an application subclasses a subclassed window, it must remove the subclasses in the reverse order they were performed.</span></span> <span data-ttu-id="6d212-171">如果未反轉移除順序，則可能會發生無法復原的系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="6d212-171">If the removal order is not reversed, an unrecoverable system error may occur.</span></span>

### <a name="global-subclassing"></a><span data-ttu-id="6d212-172">全域子類別</span><span class="sxs-lookup"><span data-stu-id="6d212-172">Global Subclassing</span></span>

<span data-ttu-id="6d212-173">若要全域子類別化視窗類別，應用程式必須具有類別的視窗控制碼。</span><span class="sxs-lookup"><span data-stu-id="6d212-173">To globally subclass a window class, the application must have a handle to a window of the class.</span></span> <span data-ttu-id="6d212-174">應用程式也需要控制碼來移除子類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-174">The application also needs the handle to remove the subclass.</span></span> <span data-ttu-id="6d212-175">若要取得控制碼，應用程式通常會建立要子類別化之類別的隱藏視窗。</span><span class="sxs-lookup"><span data-stu-id="6d212-175">To get the handle, an application typically creates a hidden window of the class to be subclassed.</span></span> <span data-ttu-id="6d212-176">取得控制碼之後，應用程式會呼叫 [**SetClassLong**](/windows/win32/api/winuser/nf-winuser-setclasslonga) 函式，並指定控制碼、 **GCL \_ WNDPROC** 旗標，以及子類別程式的位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-176">After obtaining the handle, the application calls the [**SetClassLong**](/windows/win32/api/winuser/nf-winuser-setclasslonga) function, specifying the handle, the **GCL\_WNDPROC** flag, and the address of the subclass procedure.</span></span> <span data-ttu-id="6d212-177">**SetClassLong** 會傳回類別的原始視窗程式位址。</span><span class="sxs-lookup"><span data-stu-id="6d212-177">**SetClassLong** returns the address of the original window procedure for the class.</span></span>

<span data-ttu-id="6d212-178">原始的視窗程式位址用於全域子類別化，其方式與在實例子類別中使用的方式相同。</span><span class="sxs-lookup"><span data-stu-id="6d212-178">The original window procedure address is used in global subclassing in the same way it is used in instance subclassing.</span></span> <span data-ttu-id="6d212-179">子類別程式會藉由呼叫 [**CallWindowProc**](/windows/win32/api/winuser/nf-winuser-callwindowproca)，將訊息傳遞至原始視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-179">The subclass procedure passes messages to the original window procedure by calling [**CallWindowProc**](/windows/win32/api/winuser/nf-winuser-callwindowproca).</span></span> <span data-ttu-id="6d212-180">應用程式會從視窗類別移除子類別，方法是再次呼叫 [**SetClassLong**](/windows/win32/api/winuser/nf-winuser-setclasslonga) 、指定原始視窗程式的位址、 **GCL \_ WNDPROC** 旗標，以及要子類別化之類別的視窗控制碼。</span><span class="sxs-lookup"><span data-stu-id="6d212-180">The application removes the subclass from the window class by calling [**SetClassLong**](/windows/win32/api/winuser/nf-winuser-setclasslonga) again, specifying the address of the original window procedure, the **GCL\_WNDPROC** flag, and the handle to a window of the class being subclassed.</span></span> <span data-ttu-id="6d212-181">當應用程式終止時，全域子類別化控制項類別的應用程式必須移除子類別。否則，可能會發生無法復原的系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="6d212-181">An application that globally subclasses a control class must remove the subclass when the application terminates; otherwise, an unrecoverable system error may occur.</span></span>

<span data-ttu-id="6d212-182">全域子類別與實例子類別具有相同的限制，加上一些額外的限制。</span><span class="sxs-lookup"><span data-stu-id="6d212-182">Global subclassing has the same limitations as instance subclassing, plus some additional restrictions.</span></span> <span data-ttu-id="6d212-183">應用程式不應該將額外的位元組用於類別或視窗實例，而不需要知道原始視窗程式如何使用它們。</span><span class="sxs-lookup"><span data-stu-id="6d212-183">An application should not use the extra bytes for either the class or the window instance without knowing exactly how the original window procedure uses them.</span></span> <span data-ttu-id="6d212-184">如果應用程式必須將資料與視窗建立關聯，則應該使用視窗屬性。</span><span class="sxs-lookup"><span data-stu-id="6d212-184">If the application must associate data with a window, it should use window properties.</span></span>

## <a name="window-procedure-superclassing"></a><span data-ttu-id="6d212-185">視窗程式 Superclassing</span><span class="sxs-lookup"><span data-stu-id="6d212-185">Window Procedure Superclassing</span></span>

<span data-ttu-id="6d212-186">*Superclassing* 是一種技術，可讓應用程式使用現有類別的基本功能來建立新的視窗類別，加上應用程式所提供的增強功能。</span><span class="sxs-lookup"><span data-stu-id="6d212-186">*Superclassing* is a technique that allows an application to create a new window class with the basic functionality of the existing class, plus enhancements provided by the application.</span></span> <span data-ttu-id="6d212-187">超級類別是以稱為 *基類* 的現有視窗類別為基礎。</span><span class="sxs-lookup"><span data-stu-id="6d212-187">A superclass is based on an existing window class called the *base class*.</span></span> <span data-ttu-id="6d212-188">基類通常是系統全域視窗類別，例如編輯控制項，但可以是任何視窗類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-188">Frequently, the base class is a system global window class such as an edit control, but it can be any window class.</span></span>

<span data-ttu-id="6d212-189">超級類別有自己的視窗程式，稱為「超級類別」程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-189">A superclass has its own window procedure, called the superclass procedure.</span></span> <span data-ttu-id="6d212-190">*超級類別* 程式可以在接收訊息時採取三個動作：它可以將訊息傳遞至原始視窗程式、修改訊息並將它傳遞給原始視窗程式，或處理訊息，而不將它傳遞至原始視窗程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-190">The *superclass procedure* can take three actions upon receiving a message: It can pass the message to the original window procedure, modify the message and pass it to the original window procedure, or process the message and not pass it to the original window procedure.</span></span> <span data-ttu-id="6d212-191">如果超級類別程式處理訊息，它可以在將訊息傳遞至原始視窗程式之前、之後或前後進行。</span><span class="sxs-lookup"><span data-stu-id="6d212-191">If the superclass procedure processes a message, it can do so before, after, or both before and after it passes the message to the original window procedure.</span></span>

<span data-ttu-id="6d212-192">與子類別程式不同的是，超級類別程式可以處理 ([**wm \_ NCCREATE**](wm-nccreate.md)、 [**WM \_ 建立**](wm-create.md)等) 的視窗建立訊息，但它也必須將它們傳遞給原始的基類視窗程式，才能讓基類視窗程式執行其初始化程式。</span><span class="sxs-lookup"><span data-stu-id="6d212-192">Unlike a subclass procedure, a superclass procedure can process window creation messages ([**WM\_NCCREATE**](wm-nccreate.md), [**WM\_CREATE**](wm-create.md), and so on), but it must also pass them to the original base-class window procedure so that the base-class window procedure can perform its initialization procedure.</span></span>

<span data-ttu-id="6d212-193">若要將視窗類別設為超類，應用程式會先呼叫 [**GetClassInfo**](/windows/win32/api/winuser/nf-winuser-getclassinfoa) 函式，以取得基類的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="6d212-193">To superclass a window class, an application first calls the [**GetClassInfo**](/windows/win32/api/winuser/nf-winuser-getclassinfoa) function to retrieve information about the base class.</span></span> <span data-ttu-id="6d212-194">**GetClassInfo** 會以基類的 **WNDCLASS** 結構中的值填滿 [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa)結構。</span><span class="sxs-lookup"><span data-stu-id="6d212-194">**GetClassInfo** fills a [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure with the values from the **WNDCLASS** structure of the base class.</span></span> <span data-ttu-id="6d212-195">接下來，應用程式會將自己的實例控制碼複製到 **WNDCLASS** 結構的 **hInstance** 成員，並將該超類的名稱複製到 **lpszClassName** 成員中。</span><span class="sxs-lookup"><span data-stu-id="6d212-195">Next, the application copies its own instance handle into the **hInstance** member of the **WNDCLASS** structure and copies the name of the superclass into the **lpszClassName** member.</span></span> <span data-ttu-id="6d212-196">如果基底類別具有功能表，則應用程式必須提供具有相同功能表識別碼的新功能表，並將功能表名稱複製到 **lpszMenuName** 成員中。</span><span class="sxs-lookup"><span data-stu-id="6d212-196">If the base class has a menu, the application must provide a new menu with the same menu identifiers and copy the menu name into the **lpszMenuName** member.</span></span> <span data-ttu-id="6d212-197">如果超級類別程式處理了 [**WM \_ 命令**](/windows/desktop/menurc/wm-command) 訊息，但未將它傳遞給基類的視窗程式，則功能表不需要有對應的識別碼。</span><span class="sxs-lookup"><span data-stu-id="6d212-197">If the superclass procedure processes the [**WM\_COMMAND**](/windows/desktop/menurc/wm-command) message and does not pass it to the window procedure of the base class, the menu need not have corresponding identifiers.</span></span> <span data-ttu-id="6d212-198">**GetClassInfo** 不會傳回 **WNDCLASS** 結構的 **lpszMenuName**、 **lpszClassName** 或 **hInstance** 成員。</span><span class="sxs-lookup"><span data-stu-id="6d212-198">**GetClassInfo** does not return the **lpszMenuName**, **lpszClassName**, or **hInstance** member of the **WNDCLASS** structure.</span></span>

<span data-ttu-id="6d212-199">應用程式也必須設定 [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa)結構的 **lpfnWndProc** 成員。</span><span class="sxs-lookup"><span data-stu-id="6d212-199">An application must also set the **lpfnWndProc** member of the [**WNDCLASS**](/windows/win32/api/winuser/ns-winuser-wndclassa) structure.</span></span> <span data-ttu-id="6d212-200">[**GetClassInfo**](/windows/win32/api/winuser/nf-winuser-getclassinfoa)函式會使用類別的原始視窗程式位址來填滿這個成員。</span><span class="sxs-lookup"><span data-stu-id="6d212-200">The [**GetClassInfo**](/windows/win32/api/winuser/nf-winuser-getclassinfoa) function fills this member with the address of the original window procedure for the class.</span></span> <span data-ttu-id="6d212-201">應用程式必須儲存此位址、將訊息傳遞至原始視窗程式，然後將超級類別程式的位址複製到 **lpfnWndProc** 成員中。</span><span class="sxs-lookup"><span data-stu-id="6d212-201">The application must save this address, to pass messages to the original window procedure, and then copy the address of the superclass procedure into the **lpfnWndProc** member.</span></span> <span data-ttu-id="6d212-202">如有必要，應用程式可以修改 **WNDCLASS** 結構的任何其他成員。</span><span class="sxs-lookup"><span data-stu-id="6d212-202">The application can, if necessary, modify any other members of the **WNDCLASS** structure.</span></span> <span data-ttu-id="6d212-203">在填滿 **WNDCLASS** 結構之後，應用程式會將結構的位址傳遞至 [**RegisterClass**](/windows/win32/api/winuser/nf-winuser-registerclassa) 函式，以註冊該類別。</span><span class="sxs-lookup"><span data-stu-id="6d212-203">After it fills the **WNDCLASS** structure, the application registers the superclass by passing the address of the structure to the [**RegisterClass**](/windows/win32/api/winuser/nf-winuser-registerclassa) function.</span></span> <span data-ttu-id="6d212-204">然後可以使用超級類別來建立視窗。</span><span class="sxs-lookup"><span data-stu-id="6d212-204">The superclass can then be used to create windows.</span></span>

<span data-ttu-id="6d212-205">由於 superclassing 會註冊新的視窗類別，因此應用程式可以同時加入額外的類別位元組和額外的視窗位元組。</span><span class="sxs-lookup"><span data-stu-id="6d212-205">Because superclassing registers a new window class, an application can add to both the extra class bytes and the extra window bytes.</span></span> <span data-ttu-id="6d212-206">超級類別不能使用基類或視窗的原始額外位元組，因為實例子類別或全域子類別不應使用它們。</span><span class="sxs-lookup"><span data-stu-id="6d212-206">The superclass must not use the original extra bytes for the base class or the window for the same reasons that an instance subclass or a global subclass should not use them.</span></span> <span data-ttu-id="6d212-207">此外，如果應用程式將額外的位元組用於類別或視窗實例，就必須參考相對於原始基類所使用之額外位元組數的額外位元組數。</span><span class="sxs-lookup"><span data-stu-id="6d212-207">Also, if the application adds extra bytes for its use to either the class or the window instance, it must reference the extra bytes relative to the number of extra bytes used by the original base class.</span></span> <span data-ttu-id="6d212-208">由於基類所使用的位元組數目可能會與基類的某個版本不同，因此，超類別本身的額外位元組起始位移可能也會與下一個基類版本的不同。</span><span class="sxs-lookup"><span data-stu-id="6d212-208">Because the number of bytes used by the base class may vary from one version of the base class to the next, the starting offset for the superclass's own extra bytes may also vary from one version of the base class to the next.</span></span>

 

 
