---
description: 如果您不熟悉數位媒體，本主題將介紹在撰寫媒體基礎的應用程式之前，您必須瞭解的一些概念。
ms.assetid: d76d655e-23f3-407c-97a1-be015b0de37d
title: 媒體基礎：基本概念
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0298a20518df91dab4439770e0f1193802969ae8
ms.sourcegitcommit: c16214e53680dc71d1c07111b51f72b82a4512d8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/03/2021
ms.locfileid: "104386316"
---
# <a name="media-foundation-essential-concepts"></a>媒體基礎：基本概念

如果您不熟悉數位媒體，本主題將介紹在撰寫媒體基礎的應用程式之前，您必須瞭解的一些概念。

-   [串流](#streams)
-   [壓縮](#compression)
-   [媒體容器](#media-containers)
-   [格式](#formats)
-   [相關主題](#related-topics)

## <a name="streams"></a>串流

*資料流程* 是一種具有統一類型的媒體資料序列。 最常見的類型是音訊和影片，但是資料流程幾乎可以包含任何類型的資料，包括文字、指令碼命令和靜止影像。 本檔中的「 *資料流程* 」一詞不表示透過網路傳遞。 適用于本機播放的媒體檔案也包含資料流程。

媒體檔案通常會包含單一音訊串流，或只包含一個影片串流和一個音訊串流。 不過，媒體檔案可能包含多個相同類型的資料流程。 例如，影片檔案可能包含數種不同語言的音訊串流。 應用程式會在執行時間選取要使用的資料流程。

## <a name="compression"></a>壓縮

「*壓縮*」指的是藉由移除多餘的資訊，來減少資料流程大小的任何處理程式。 壓縮演算法分為兩大類：

-   無 *失真壓縮。* 使用無失真演算法時，重建的資料與原始資料相同。
-   *損* 及壓縮。 使用失真演算法時，重建資料是原始的近似值，但不完全相符。

在大部分的其他網域中，無法接受失真的壓縮。  (想像得到試算表的「近似值」！ ) 但因為有幾個原因，所以失真的壓縮配置非常適合音訊和影片。

第一個原因是人們認知的物理。 當我們聆聽很複雜的音效（像是音樂錄音）時，該音效所包含的部分資訊不會可察覺到 ear 中。 有了信號處理理論的協助，就可以分析和分隔無法察覺的頻率。 這些頻率可以移除，而不會有任何感知效果。 雖然重建音訊不會完全符合原始音訊，但與接聽程式的 *音效* 相同。 類似的原則適用于影片。

其次，可能可接受某些音效或影像品質降低的情況，視用途而定。 例如，在電話語音中，音訊通常會高度壓縮。 結果對電話對話而言夠好，但您不想在電話上接聽 symphony 管弦樂團。

壓縮也稱為 *編碼方式*，而編碼的裝置稱為 *編碼器*。 反向程式正在 *解碼*，而裝置則是自然稱為 *解碼器*。 編碼器和解碼器的一般詞彙都是 *編解碼器*。 編解碼器可在硬體或軟體中執行。

從數位媒體的出現以來，壓縮技術的變更很快，而且目前正在使用大量的壓縮配置。 這是數位媒體程式設計的主要挑戰之一。

## <a name="media-containers"></a>媒體容器

很少會將原始音訊或影片串流儲存為電腦檔案，或直接透過網路傳送一次。 其中一件事是無法將這類串流解碼，而不需要事先知道要使用哪個編解碼器。 因此，媒體檔案通常至少包含下列其中一些元素：

-   描述資料流程數目、每個資料流程格式等的檔案標頭。
-   可隨機存取內容的索引。
-   描述內容 (的中繼資料，例如演出者或標題) 。
-   封包標頭，以啟用網路傳輸或隨機存取。

本檔使用「 *容器* 」一詞來描述整個資料流程、標頭、索引、中繼資料等等的封裝。 使用詞彙 *容器* （而非檔案）的 *原因是某些* 容器格式是針對即時廣播所設計。 應用程式可能會即時產生容器，而永遠不會將它儲存至檔案。

媒體容器的早期範例是 AVI 檔案格式。 其他範例包括 [的] 和 [Advanced] 系統格式， (ASF) 。 您可以使用副檔名來識別容器 (例如，將) 或 MIME 類型。

下圖顯示媒體容器的一般結構。 此圖表不代表任何特定的格式;每種格式的詳細資料會有很大的差異。

![顯示一般媒體容器的圖表](images/concepts01.png)

請注意，圖中顯示的結構是階層式的，且標頭資訊會出現在容器的開頭。 此結構通常是許多 (，但並非所有) 容器格式。 另外也請注意，data 區段包含交錯的音訊和影片封包。 這種交錯類型在媒體容器中很常見。

「 *多* 任務處理」一詞是指 packetizing 音訊和影片串流，然後將封包交錯至容器的程式。 從 packetized 資料目的地重組資料流程的反向處理常式稱為 *分離信號*。

## <a name="formats"></a>格式

在數位媒體中，字詞 *格式* 不明確。 格式可以參考 *編碼* 類型，例如 h.264 影片或 *容器*（例如，「數量」）。 這項區別通常會讓一般使用者感到混淆。 提供給媒體格式的名稱不一定會有説明。 例如， *MP3* 指的是編碼格式 (Mpeg-2 音訊第 3) 和檔案格式。

差別是很重要的，因為讀取媒體檔案實際上牽涉到兩個階段：

1.  首先，必須剖析容器。 在大部分情況下，在此步驟完成之前，無法得知資料流程數目和每個資料流程的格式。
2.  接下來，如果資料流程已壓縮，則必須使用適當的解碼器將其解碼。

這種事實很自然地指向軟體設計，其中會使用不同的元件來剖析容器和解碼資料流程。 此外，此方法也適合用於外掛程式模型，讓協力廠商可以提供自己的剖析器和編解碼器。 在 Windows 上，元件物件模型 (COM) 會提供一種標準方式來分隔 API 與其實作為任何外掛程式模型的需求。 基於這個理由， (其他) ，媒體基礎會使用 COM 介面。

下圖顯示用來讀取媒體檔案的元件：

![顯示讀取媒體檔案元件的圖表](images/concepts02.png)

寫入媒體檔案也需要兩個步驟：

1.  編碼未壓縮的音訊/影片資料。
2.  將壓縮的資料放入特定的容器格式。

下圖顯示用來寫入媒體檔案的元件：

![此圖顯示寫入媒體檔案的元件。](images/concepts03.png)

## <a name="related-topics"></a>相關主題

<dl> <dt>

[媒體基礎程式設計指南](media-foundation-programming-guide.md)
</dt> </dl>

 

 



