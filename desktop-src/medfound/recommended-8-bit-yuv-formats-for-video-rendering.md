---
description: 適用于影片轉譯的建議8位 YUV 格式
ms.assetid: 675d4c60-4c58-4f15-9bae-ffb0c389c608
title: 適用于影片轉譯的建議8位 YUV 格式
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cc6e30f33c59bedf9a2e842d2d33328bd97d8078d21bda90ae84af9af00ec113
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "119722079"
---
# <a name="recommended-8-bit-yuv-formats-for-video-rendering"></a>適用于影片轉譯的建議8位 YUV 格式

Gary Sullivan 和 Stephen Estrop

Microsoft Corporation

2002年4月，更新的2008年11月

本主題說明在 Windows 作業系統中針對影片轉譯所建議的8位 YUV 色彩格式。 本文提供在 YUV 和 RGB 格式之間進行轉換的技巧，也提供 upsampling YUV 格式的技巧。 本文適用于在 Windows 中使用 YUV 影片解碼或轉譯的任何人。

## <a name="introduction"></a>簡介

整個影片產業都有定義許多的 YUV 格式。 本文識別 Windows 中的影片轉譯所建議的8位 YUV 格式。 建議您將「解碼器廠商」和「顯示廠商」支援本文中所述的格式。 本文不會解決其他使用的 YUV 色彩，例如靜止攝影。

本文中所述的格式，全都使用8個位的每圖元位置來編碼 Y 通道 (也稱為 luma 通道) ，並使用每個樣本8個位來編碼每個 U 或 V 色度範例。 不過，大部分的 YUV 格式平均都會使用小於24位的每個圖元，因為它們包含的樣本數較少，而 V 小於 Y。本文未涵蓋具有10位或更高 Y 通道的 YUV 格式。

> [!Note]  
> 基於本文的目的，「U」一詞相當於 Cb，而「V」一詞則相當於「Cr」。

 

本文章涵蓋下列主題：

-   [YUV 取樣](#yuv-sampling)。 描述最常見的 YUV 取樣技術。
-   [介面定義](#surface-definitions)。 描述建議的 YUV 格式。
-   [色彩空間和色度取樣率轉換](#color-space-and-chroma-sampling-rate-conversions)。 提供在 YUV 和 RGB 格式之間進行轉換，以及在不同的 YUV 格式之間進行轉換的一些指導方針。
-   [識別媒體基礎中的 YUV 格式](#identifying-yuv-formats-in-media-foundation)。 說明如何在媒體基礎中描述 YUV 格式類型。

## <a name="yuv-sampling"></a>YUV 取樣

色度通道的取樣率可能會比 luma 通道低，而不會大幅喪失感知品質。 稱為 "A:B： C" 標記法的標記法可用來描述取樣的頻率，以及相對於 Y 的取樣頻率：

-   4:4:4 表示不含色度通道的縮減。
-   4:2:2 表示2:1 水準縮小，不含垂直的縮減取樣。 每個掃描行都包含每兩個 U 或 V 範例的四個 Y 樣本。
-   4:2:0 表示2:1 水準縮小取樣，具有2:1 垂直縮減取樣。
-   4:1:1 表示4:1 水準縮小，不含垂直的縮減取樣。 每個掃描行都包含四個適用于您和 V 範例的 Y 範例。 4:1:1 取樣與其他格式較不常見，在本文中不會詳細討論。

下圖顯示如何針對每個縮減取樣率取樣色度。 Luma 範例是以十字線表示，而色度樣本則是以圓圈表示。

![圖1。 色度取樣](images/yuv-sampling-grids.png)

4:2:2 取樣的主要形式定義于 ITU-R 建議 BT. 601。 4:2:0 取樣有兩種常見的變化。 其中一種用於 MPEG-2 影片，而另一種則用於 MPEG-2 和 ITU-T 建議261和 .H 中的。

相較于 MPEG-2 配置，在 MPEG-2 配置和針對4:2:2 和4:4:4 格式定義的取樣方格之間進行轉換比較容易。 基於這個理由，Windows 中偏好 mpeg-2 配置，且應視為4:2:0 格式的預設轉譯。

## <a name="surface-definitions"></a>介面定義

本節說明針對影片轉譯建議的8位 YUV 格式。 這些分為幾個類別：

-   [4:4:4 格式，每圖元32位](#444-formats-32-bits-per-pixel)
-   [4:2:2 格式，每圖元16個位](#422-formats-16-bits-per-pixel)
-   [4:2:0 格式，每圖元16個位](#420-formats-16-bits-per-pixel)
-   [4:2:0 格式，每圖元12個位](#420-formats-12-bits-per-pixel)

首先，您應該注意下列概念，以瞭解如下：

-   *介面原點*。 針對本文所述的 YUV 格式，原點 (0，0) 一律是表面的左上角。
-   *Stride*。 表面的 stride （有時稱為「音調」）是指介面的寬度（以位元組為單位）。 在左上角有一個表面原點，stride 一律是正數。
-   *對齊*。 表面的對齊是由圖形顯示器驅動程式來決定。 介面必須一律對齊 DWORD;也就是說，介面內的個別線條保證是源自32位 (DWORD) 界限。 根據硬體的需求而定，對齊可以大於32位。
-   壓縮格式與平面格式。 YUV 格式分為 *壓縮* 格式和 *平面* 格式。 在封裝格式中，Y、U 和 V 元件會儲存在單一陣列中。 圖元會組織成 macropixels 的群組，其版面配置取決於格式。 在平面格式中，Y、U 和 V 元件會儲存為三個不同的平面。

本文中所述的每個 YUV 格式都有指派的 FOURCC 碼。 FOURCC 程式碼是串連四個 ASCII 字元所建立的32位不帶正負號的整數。

-   4:4:4 (32 bpp) 
    -   [AYUV](#ayuv)
-   4:2:2 (16 bpp) 
    -   [YUY2](#yuy2)
    -   [UYVY](#uyvy)
-   4:2:0 (16 bpp) 
    -   [IMC1](#imc1)
    -   [IMC3](#imc3)
-   4:2:0 (12 bpp) 
    -   [IMC2](#imc2)
    -   [IMC4](#imc4)
    -   [YV12](#yv12)
    -   [NV12](#nv12)

## <a name="444-formats-32-bits-per-pixel"></a>4:4:4 格式，每圖元32位

### <a name="ayuv"></a>AYUV

建議您使用 FOURCC 程式碼 AYUV 的單一4:4:4 格式。 這是一種壓縮格式，其中每個圖元會編碼為四個連續位元組，並依照下圖所示的順序排列。

![[圖 2] ayuv 記憶體配置](images/yuvformats01.gif)

標記為的位元組包含 Alpha 的值。

## <a name="422-formats-16-bits-per-pixel"></a>4:2:2 格式，每圖元16個位

建議採用兩種4:2:2 格式，但有下列 FOURCC 碼：

-   YUY2
-   UYVY

兩者都是封裝格式，其中每個 macropixel 都是以四個連續位元組編碼的兩個圖元。 如此一來，就會以2的因數將色度的水準縮減取樣。

### <a name="yuy2"></a>YUY2

在 YUY2 格式中，資料可視為不帶正負號的 **char** 值陣列，其中第一個位元組包含第一個 Y 樣本、第二個位元組包含第一個 U (Cb) 範例、第三個位元組包含第二個 y 樣本，而第四個位元組包含第一個 V (Cr) 範例，如下圖所示。

![圖3。 yuy2 記憶體配置](images/yuvformats02.gif)

如果影像是以位元組由小到小的 **字** 值陣列來定址，則第一個 **單字** 會包含最不重要的位中的第一個 Y 樣本 (LSBs) 以及最有效位中的第一個 U (Cb) 範例 (MSBs) 。 第二個 **單字** 包含 LSBs 中的第二個 Y 樣本，以及 MSBs 中的第一個 V (Cr) 範例。

YUY2 是 Microsoft DirectX Video 加速 (DirectX VA) 慣用的4:2:2 像素格式。 這應該是支援4:2:2 影片的 DirectX VA 加速器的中繼詞彙需求。

### <a name="uyvy"></a>UYVY

此格式與 YUY2 格式相同，不同之處在于位元組順序是反向的，也就是說，色度和 luma 位元組會翻轉 (圖 4) 。 如果影像是以兩個位元組由小到大的 **單字** 值陣列來定址，則第一個 **單字** 會在 MSBs 中的 LSBs 和 Y0 中包含 U，而第二個 **單字** 則在 MSBs 中的 LSBs 和 Y1 中包含 V。

![[圖 4] uyvy 記憶體配置](images/yuvformats03.gif)

## <a name="420-formats-16-bits-per-pixel"></a>4:2:0 格式，每圖元16個位

建議使用兩個 4:2:0 16 位的每個圖元 (bpp) 格式，但有下列 FOURCC 碼：

-   IMC1
-   IMC3

這兩種 YUV 格式都是平面格式。 在水準和垂直維度中，會以兩個因數來 subsampled 色度通道。

### <a name="imc1"></a>IMC1

所有 Y 範例都會先出現在記憶體中，做為不帶正負號之 **char** 值的陣列。 後面接著所有 V (Cr) 範例，然後所有 U (Cb) 範例。 V 和 U 平面的 stride 與 Y 平面相同，因而產生未使用的記憶體區域（如 [圖 5] 所示）。 您和 V 平面必須在記憶體界限（這是16行的倍數）上啟動。 [圖 5] 顯示 352 x 240 影片框架的您和 V 原點。 您和 V 平面的起始位址計算方式如下：

``` syntax
BYTE* pV = pY + (((Height + 15) & ~15) * Stride);
BYTE* pU = pY + (((((Height * 3) / 2) + 15) & ~15) * Stride);
```

其中， *.py* 是記憶體陣列開頭的位元組指標，如下圖所示。

![[圖 5]。 imc1 記憶體配置 (範例) ](images/yuvformats04.gif)

### <a name="imc3"></a>IMC3

此格式與 IMC1 相同，不同之處在于您和 V 平面會交換，如下圖所示。

![[圖 6]。 imc3 記憶體配置](images/yuvformats05.gif)

## <a name="420-formats-12-bits-per-pixel"></a>4:2:0 格式，每圖元12個位

建議使用四種 4:2:0 12-bpp 格式，但有下列 FOURCC 碼：

-   IMC2
-   IMC4
-   YV12
-   NV12

在這些格式中，會以兩個水準和垂直維度的因數來 subsampled 色度通道。

### <a name="imc2"></a>IMC2

這種格式與 IMC1 相同，但有下列差異： V (Cr) 和 U (Cb) 行會在半跨距界限上交錯。 換句話說，在色度區域中的每個全 stride 線都會以一條 V 範例開始，後面接著一個從下半跨距界限開始的 U 個範例， (圖 7) 。 此配置可讓您更有效率地使用位址空間，而不是 IMC1。 它會將色度位址空間剪下一半，因而將總位址空間減少25%。 在4:2:0 格式中，IMC2 是 NV12 之後第二個最優先的格式。 下圖說明此程式。

![[圖 7]。 imc2 記憶體配置](images/yuvformats07.gif)

### <a name="imc4"></a>IMC4

此格式與 IMC2 相同，不同之處在于 U (Cb) 和 V (Cr) 行已交換，如下圖所示。

![圖8。 imc4 記憶體配置](images/yuvformats06.gif)

### <a name="yv12"></a>YV12

所有 Y 範例都會先出現在記憶體中，做為不帶正負號之 **char** 值的陣列。 這個陣列緊接在所有 V (Cr) 範例中。 V 平面的 stride 是 Y 平面的一半跨距;而且，V 平面所包含的一半與 Y 平面的行數相同。 V 平面緊接在所有 U (Cb) 範例中，並以相同的 stride 和行數作為 V 平面，如下圖所示。

![[圖 9]。 yv12 記憶體配置](images/yuvformats08.gif)

### <a name="nv12"></a>NV12

所有的 Y 範例都會先顯示在記憶體中，做為不帶正負號的 **char** 值陣列，並具有偶數的行數。 Y 平面後面緊接著不帶正負號的 **char** 值陣列，其中包含封裝的 U (Cb) 和 V (Cr) 範例。 當結合的 U-V 陣列定址為位元組由小到小的 **字** 值陣列時，LSBs 會包含 U 值，而 MSBs 則包含 V 值。 NV12 是適用于 DirectX VA 的慣用4:2:0 像素格式。 這應該是支援4:2:0 影片的 DirectX VA 加速器的中繼詞彙需求。 下圖顯示 Y 平面以及包含封裝您和 V 範例的陣列。

![[圖 10] nv12 記憶體配置](images/yuvformats09.gif)

## <a name="color-space-and-chroma-sampling-rate-conversions"></a>色彩空間和色度取樣率轉換

本節提供在 YUV 和 RGB 之間進行轉換的指導方針，以及在某些不同的 YUV 格式之間進行轉換的指導方針。 在本節中，我們會考慮兩種 RGB 編碼配置： *8 位電腦 RGB*，也稱為 sRGB 或「全形」 rgb 和 *studio video rgb*，或「具有前端房間和 toe 房間的 rgb」。 這些定義如下：

-   電腦 RGB 針對紅色、綠色和藍色的每個樣本使用8個位。 黑色由 R = G = B = 0 表示，白色則以 R = G = B = 255 表示。
-   Studio video RGB 會針對紅色、綠色和藍色的每個樣本使用一些位數 N，其中 N 是8個以上的值。 Studio video RGB 使用與電腦 RGB 不同的縮放比例，且具有位移。 黑色是由 R = G = B = 16 \* 2 ^ (n-1) ，而白色則由 r = g = b = 235 \* 2 ^ (N-8) 表示。 不過，實際值可能落在此範圍之外。

Studio video rgb 是 Windows 中適用于影片的慣用 rgb 定義，而電腦 rgb 是適用于非影片應用程式的慣用 rgb 定義。 無論是哪一種形式的 RGB，chromaticity 座標都如同在 [RGB 色彩主要複本] 的定義中，709中所指定。 R、G 和 B 的 (x，y) 座標分別是 (0.64、0.33) 、 (0.30、0.60) 和 (0.15、0.06) 。 參考白色是以座標 (0.3127、0.3290) D65。 名義 gamma 是 1/0.45 (大約 2.2) ，其中包含在 ITU-R BT. 709 中詳細定義精確的 gamma。

**RGB 和 4:4:4 YUV 之間的轉換**

我們會先描述 RGB 和 4:4:4 YUV 之間的轉換。 若要將4:2:0 或 4:2:2 YUV 轉換成 RGB，建議您將 YUV 資料轉換為 4:4:4 YUV，然後從 4:4:4 YUV 轉換為 RGB。 AYUV 格式（4:4:4 格式）在 Y、U 和 V 範例中都會使用8個位。 您也可以針對某些應用程式，使用每個樣本超過8個位來定義 YUV。

已為數位視訊定義了 RGB 的兩個主要 YUV 轉換。 兩者都是以稱為「ITU-R 建議709」的規格為基礎。 第一個轉換是針對709中的 50-Hz 所定義的較舊的 YUV 形式。 它與 ITU-R 建議 BT. 601 中指定的關聯性相同，也就是舊名稱 CCIR 601。 您應將其視為標準定義電視解析度的慣用 YUV 格式 (720 x 576) 和較低解析度的影片。 它是以兩個常數的值為 *Kr* 和 *Kb* 的特性：

``` syntax
Kr = 0.299
Kb = 0.114
```

第二次轉換是針對709中的 60-Hz 所定義的較新的 YUV 格式，應視為 SDTV 上述影片解析度的慣用格式。 這兩個常數的特性具有不同的值：

``` syntax
Kr = 0.2126
Kb = 0.0722
```

從 RGB 轉換成 YUV 的定義方式如下：

``` syntax
L = Kr * R + Kb * B + (1 - Kr - Kb) * G
```

接著會取得 YUV 值，如下所示：

``` syntax
Y =                   floor(2^(M-8) * (219*(L-Z)/S + 16) + 0.5)
U = clip3(0, (2^M)-1, floor(2^(M-8) * (112*(B-L) / ((1-Kb)*S) + 128) + 0.5))
V = clip3(0, (2^M)-1, floor(2^(M-8) * (112*(R-L) / ((1-Kr)*S) + 128) + 0.5))
```

其中

-   M 是每個 YUV 樣本的位數 (M >= 8) 。
-   Z 是黑色層級變數。 若為電腦 RGB，Z 等於0。 針對 studio video RGB，Z 等於 16 \* 2 ^ (N-8) ，其中 N 是每個 RGB 範例的位數， (N >= 8) 。
-   S 是調整變數。 若是電腦 RGB，S 等於255。 針對 studio video RGB，S 等於 219 \* 2 ^ (N-8) 。

函數 floor (x) 傳回小於或等於 x 的最大整數。 函數 clip3 (x，y，z) 的定義如下：

``` syntax
clip3(x, y, z) = ((z < x) ? x : ((z > y) ? y : z))
```

> [!Note]  
> clip3 應該實作為函式，而不是預處理器宏;否則將會發生多個引數評估。

 

Y 範例表示亮度，而您和 V 範例分別代表藍色和紅色的色彩偏差。 Y 的名義範圍是 16 \* 2 ^ (m-8) 至 235 \* 2 ^ (M-8) 。 黑色表示為 16 \* 2 ^ (M-8) ，白色則表示為 235 \* 2 ^ (M-8) 。 您和 V 的名義範圍是 16 \* 2 ^ (m-8) 至 240 \* 2 ^ (M-8) ，值 128 \* 2 ^ (m-8) 表示中性的色度。 不過，實際的值可能落在這些範圍之外。

針對 studio video RGB 形式的輸入資料，必須要有剪輯作業，才能將您和 V 值放在0到 (2 ^ M) -1 的範圍內。 如果輸入是電腦 RGB，則不需要剪切作業，因為轉換公式無法產生此範圍以外的值。

這些是沒有近似值的精確公式。 本檔中的所有內容都是從這些公式所衍生。 本節將描述下列轉換：

-   [將 RGB888 轉換成 YUV 4:4:4](#converting-rgb888-to-yuv-444)
-   [將8位 YUV 轉換成 RGB888](#converting-8-bit-yuv-to-rgb888)
-   [將 4:2:0 YUV 轉換為 4:2:2 YUV](#converting-420-yuv-to-422-yuv)
-   [將 4:2:2 YUV 轉換為 4:4:4 YUV](#converting-422-yuv-to-444-yuv)
-   [將 4:2:0 YUV 轉換為 4:4:4 YUV](#converting-420-yuv-to-444-yuv)

## <a name="converting-rgb888-to-yuv-444"></a>將 RGB888 轉換成 YUV 4:4:4

在電腦 RGB 輸入和8位 BT. 601 YUV 輸出中，我們相信上一節中指定的公式可以合理地近似如下：

``` syntax
Y = ( (  66 * R + 129 * G +  25 * B + 128) >> 8) +  16
U = ( ( -38 * R -  74 * G + 112 * B + 128) >> 8) + 128
V = ( ( 112 * R -  94 * G -  18 * B + 128) >> 8) + 128
```

這些公式會使用不超過8位 (不帶正負號) 精確度的係數來產生8位結果。 中繼結果最多需要16個位的精確度。

## <a name="converting-8-bit-yuv-to-rgb888"></a>將8位 YUV 轉換成 RGB888

從原始的 RGB 到 YUV 公式，可以為 BT. 601 衍生下列關聯性。

``` syntax
Y = round( 0.256788 * R + 0.504129 * G + 0.097906 * B) +  16 
U = round(-0.148223 * R - 0.290993 * G + 0.439216 * B) + 128
V = round( 0.439216 * R - 0.367788 * G - 0.071427 * B) + 128
```

因此，請提供：

``` syntax
C = Y - 16
D = U - 128
E = V - 128
```

將 YUV 轉換成 RGB 的公式可以衍生如下：

``` syntax
R = clip( round( 1.164383 * C                   + 1.596027 * E  ) )
G = clip( round( 1.164383 * C - (0.391762 * D) - (0.812968 * E) ) )
B = clip( round( 1.164383 * C +  2.017232 * D                   ) )
```

其中 `clip()` 表示裁剪至0到255的範圍。 \[ \] 我們相信這些公式可以合理地逼近，如下所示：

``` syntax
R = clip(( 298 * C           + 409 * E + 128) >> 8)
G = clip(( 298 * C - 100 * D - 208 * E + 128) >> 8)
B = clip(( 298 * C + 516 * D           + 128) >> 8)
```

這些公式使用的一些係數需要8個以上的精確度來產生每個8位的結果，而中繼結果將需要16位以上的精確度。

若要將4:2:0 或 4:2:2 YUV 轉換成 RGB，建議您將 YUV 資料轉換為 4:4:4 YUV，然後從 4:4:4 YUV 轉換為 RGB。 接下來的章節會提供將4:2:0 和4:2:2 格式轉換為4:4:4 的一些方法。

## <a name="converting-420-yuv-to-422-yuv"></a>將 4:2:0 YUV 轉換為 4:2:2 YUV

將 4:2:0 YUV 轉換為 4:2:2 YUV 需要以兩個因數的垂直 upconversion。 本節說明執行 upconversion 的範例方法。 方法會假設影片圖片是漸進式掃描。

> [!Note]  
> 4:2:0 到4:2:2 交錯式掃描轉換程式呈現非典型的問題，而且很難實行。 本文無法解決將交錯式掃描從4:2:0 轉換至4:2:2 的問題。

 

讓輸入色度範例的每個垂直線都是 `Cin[]` 範圍從0到 n-1 的陣列。 輸出影像的對應垂直線將會是 `Cout[]` 範圍從0到 2n-1 的陣列。 若要轉換每一條垂直線，請執行下列程式：

``` syntax
Cout[0]     = Cin[0];
Cout[1]     = clip((9 * (Cin[0] + Cin[1]) - (Cin[0] + Cin[2]) + 8) >> 4);
Cout[2]     = Cin[1];
Cout[3]     = clip((9 * (Cin[1] + Cin[2]) - (Cin[0] + Cin[3]) + 8) >> 4);
Cout[4]     = Cin[2]
Cout[5]     = clip((9 * (Cin[2] + Cin[3]) - (Cin[1] + Cin[4]) + 8) >> 4);
...
Cout[2*i]   = Cin[i]
Cout[2*i+1] = clip((9 * (Cin[i] + Cin[i+1]) - (Cin[i-1] + Cin[i+2]) + 8) >> 4);
...
Cout[2*N-3] = clip((9 * (Cin[N-2] + Cin[N-1]) - (Cin[N-3] + Cin[N-1]) + 8) >> 4);
Cout[2*N-2] = Cin[N-1];
Cout[2*N-1] = clip((9 * (Cin[N-1] + Cin[N-1]) - (Cin[N-2] + Cin[N-1]) + 8) >> 4);
```

其中剪輯 () 表示裁剪至0到255的範圍。 \[ \]

> [!Note]  
> 處理邊緣的方程式可透過數學方式簡化。 這會顯示在此表單中，以說明圖片邊緣的固定效果。

 

實際上，這個方法會將曲線插到四個連續的圖元上（加權至兩個最接近圖元的值），以計算每個遺漏值 ([圖 11]) 。 此範例中使用的特定插補方法會使用稱為 Catmull-Rom 插補的已知方法（也稱為三倍整數插補），在半整數位置產生遺漏的範例。

![[圖 11] 顯示4:2:0 至 4:2:2 upsampling 的圖表](images/yuvformats14.gif)

在「信號處理」詞彙中，垂直 upconversion 應該包含階段變換補償，以考慮4:2:0 取樣線的位置與每個其他4:2:2 取樣線的位置之間的輸出4:2:2 取樣方格， (相對於輸出取樣方格的) 。 不過，引入此位移會增加產生範例所需的處理量，並使其無法從 upsampled 4:2:2 映射重建原始的4:2:0 範例。 此外，也無法將影片直接解碼成4:2:2 介面，然後使用這些表面作為參考圖片，以解碼資料流程中的後續圖片。 因此，此處提供的方法不會考慮樣本的精確垂直對齊。 如此一來，在合理的圖片解析度上可能不會有太大的傷害。

如果您從使用261、.H 或 MPEG-2 影片中所定義之取樣方格的4:2:0 影片開始，輸出4:2:2 色度範例的階段也會與 luma 取樣方格上的間距相對的半圖元水準位移， (相對於4:2:2 色度取樣方格) 間距的四分之一圖元位移。 不過，4:2:0 影片的 MPEG-2 格式可能較常用於電腦，而且不會受到此問題的影響。 此外，在合理的圖片解析度上，差別可能不會有太大的傷害。 嘗試修正此問題，將會建立與垂直階段位移相關的相同問題類型。

## <a name="converting-422-yuv-to-444-yuv"></a>將 4:2:2 YUV 轉換為 4:4:4 YUV

將 4:2:2 YUV 轉換為 4:4:4 YUV 需要以兩個因數水準 upconversion。 先前針對垂直 upconversion 所述的方法也可以套用到水準 upconversion。 針對 MPEG-2 和 ITU-R BT. 601 影片，這個方法會產生具有正確階段對齊的範例。

## <a name="converting-420-yuv-to-444-yuv"></a>將 4:2:0 YUV 轉換為 4:4:4 YUV

若要將 4:2:0 YUV 轉換為 4:4:4 YUV，您只要遵循先前所述的兩種方法即可。 將4:2:0 影像轉換為4:2:2，然後將4:2:2 影像轉換為4:4:4。 您也可以切換這兩個 upconversion 程式的順序，因為作業的順序對結果的視覺品質並不重要。

## <a name="other-yuv-formats"></a>其他 YUV 格式

另外還有一些較不常用的 YUV 格式包括下列各項：

-   AI44 是調色盤 YUV 格式，每個樣本8個位。 每個範例都包含4個最重要的位中的索引 (MSBs) ，以及4個最不重要的位中的 Alpha 值 (LSBs) 。 索引指的是 YUV 調色板專案的陣列，這些專案必須在格式的媒體類型中定義。 此格式主要用於子圖片影像。
-   NV11 是4:1:1 平面格式，每圖元12個位。 Y 範例會先出現在記憶體中。 Y 平面後面接著封裝 U (Cb) 和 V (Cr) 範例的陣列。 當結合的 U-V 陣列以位元組由小到大的 **單字** 值陣列來定址時，u 範例會包含在每個 **單字** 的 LSBs 中，而 V 範例會包含在 MSBs 中。  (此記憶體配置類似于 NV12，雖然色度取樣不同。 ) 
-   Y41P 是4:1:1 壓縮格式，每四個圖元的水準取樣。 每個 macropixel 都包含三個位元組的8個圖元，具有下列位元組配置： `U0 Y0 V0 Y1    U4 Y2 V4 Y3    Y4 Y5 Y6 Y7`
-   Y41T 與 Y41P 相同，不同之處在于每個 Y 範例的最小位都指定了色度鍵 (0 = 透明，1 = 不透明) 。
-   Y42T 與 UYVY 相同，不同之處在于每個 Y 範例的最小位都指定了色度鍵 (0 = 透明，1 = 不透明) 。
-   YVYU 相當於 YUYV，但您和 V 範例會交換。

## <a name="identifying-yuv-formats-in-media-foundation"></a>在媒體基礎中識別 YUV 格式

本文中所述的每個 YUV 格式都有指派的 FOURCC 碼。 FOURCC 程式碼是串連四個 ASCII 字元所建立的32位不帶正負號的整數。

有各種 C/c + + 宏，可讓您更輕鬆地在原始程式碼中宣告 FOURCC 值。 例如， **MAKEFOURCC** 宏是在 Mmsystem 中宣告，而 **FCC** 宏則是在 Aviriff 中宣告。 使用方式如下：

``` syntax
DWORD fccYUY2 = MAKEFOURCC('Y','U','Y','2');
DWORD fccYUY2 = FCC('YUY2');
```

您也可以藉由反轉字元順序，直接將 FOURCC 程式碼宣告為字串常值。 例如：

``` syntax
DWORD fccYUY2 = '2YUY';  // Declares the FOURCC 'YUY2'
```

必須反轉順序是必要的，因為 Windows 作業系統使用位元組由大到小的架構。 ' Y ' = 0x59，' U ' = 0x55，' 2 ' = 0x32，因此 ' 2YUY ' 為0x32595559。

在媒體基礎中，格式是以主要類型 GUID 和子類型 GUID 來識別。 電腦影片格式的主要類型一律為 MFMediaType \_ video。 您可以將 FOURCC 程式碼對應至 GUID 來建立子類型，如下所示：

``` syntax
XXXXXXXX-0000-0010-8000-00AA00389B71 
```

其中 `XXXXXXXX` 是 FOURCC 程式碼。 因此，YUY2 的子類型 GUID 為：

``` syntax
32595559-0000-0010-8000-00AA00389B71 
```

最常見的 YUV 格式 Guid 的常數定義于標頭檔 mfapi 中。 如需這些常數的清單，請參閱 [影片子類型 guid](video-subtype-guids.md)。

## <a name="related-topics"></a>相關主題

<dl> <dt>

[關於 YUV 影片](about-yuv-video.md)
</dt> <dt>

[影片媒體類型](video-media-types.md)
</dt> </dl>

 

 



