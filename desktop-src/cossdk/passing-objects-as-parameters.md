---
description: 以參數形式傳遞物件
ms.assetid: 174847c8-4545-4f61-ae13-42bdec1405e7
title: 以參數形式傳遞物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a58e012138bc65cec481f714ac216bb8227fb924
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104510672"
---
# <a name="passing-objects-as-parameters"></a><span data-ttu-id="ca214-103">以參數形式傳遞物件</span><span class="sxs-lookup"><span data-stu-id="ca214-103">Passing Objects as Parameters</span></span>

<span data-ttu-id="ca214-104">COM + 佇列元件服務不會針對每個現有的 COM 元件啟用佇列。</span><span class="sxs-lookup"><span data-stu-id="ca214-104">The COM+ queued components service does not enable queuing for every existing COM component.</span></span> <span data-ttu-id="ca214-105">可以排入佇列的方法類型有一些限制。</span><span class="sxs-lookup"><span data-stu-id="ca214-105">There are restrictions on the types of methods that can be queued.</span></span> <span data-ttu-id="ca214-106">由於訊息條件約束的限制，方法必須遵守下列規則：</span><span class="sxs-lookup"><span data-stu-id="ca214-106">Because of messaging constraints, methods must adhere to the following rules:</span></span>

-   <span data-ttu-id="ca214-107">它們必須只包含輸入參數。</span><span class="sxs-lookup"><span data-stu-id="ca214-107">They must contain input parameters only.</span></span>
-   <span data-ttu-id="ca214-108">它們必須不傳回任何應用程式特定的結果。</span><span class="sxs-lookup"><span data-stu-id="ca214-108">They must return no application-specific result.</span></span>

<span data-ttu-id="ca214-109">此外，可傳遞至已排入佇列之元件的輸入參數類型也有一些限制。</span><span class="sxs-lookup"><span data-stu-id="ca214-109">Additionally, there are restrictions on the types of input parameters that can be passed to a queued component.</span></span> <span data-ttu-id="ca214-110">在執行時間，已排入佇列的元件服務會封裝用戶端的引數，並使用 [訊息佇列](/previous-versions/windows/desktop/legacy/ms711472(v=vs.85))將這些引數傳遞至伺服器元件。</span><span class="sxs-lookup"><span data-stu-id="ca214-110">At run time, the queued components service packages the arguments at the client and passes them to the server component by using [Message Queuing](/previous-versions/windows/desktop/legacy/ms711472(v=vs.85)).</span></span> <span data-ttu-id="ca214-111">簡單類型（例如整數和布林值）可以輕易地封送處理，在沒有協助的情況下，無法封送處理更複雜的類型。</span><span class="sxs-lookup"><span data-stu-id="ca214-111">Simple types, such as integers and Booleans, can be marshaled easily—more complex types cannot be marshaled without help.</span></span>

<span data-ttu-id="ca214-112">如果透過佇列元件的方法呼叫來傳遞物件做為參數，用戶端會將物件傳遞給錄製器。</span><span class="sxs-lookup"><span data-stu-id="ca214-112">In the case of passing an object through a queued component's method call as a parameter, the client passes the object to the recorder.</span></span> <span data-ttu-id="ca214-113">錄製器會將物件封送處理為訊息佇列訊息，並將它傳遞給接聽程式。</span><span class="sxs-lookup"><span data-stu-id="ca214-113">The recorder marshals the object into a Message Queuing message and passes it to the listener.</span></span> <span data-ttu-id="ca214-114">當接聽程式拾取訊息並將它傳遞給播放程式之後，播放程式必須 reinstantiate 物件，以將其分派給用戶端所指定的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="ca214-114">After the listener picks up the message and passes it to the player, the player must reinstantiate the object to dispatch it to the method call specified by the client.</span></span> <span data-ttu-id="ca214-115">根據佇列環境中用戶端和伺服器的存留期，暗示這些物件必須能夠以傳值方式封送處理。</span><span class="sxs-lookup"><span data-stu-id="ca214-115">Based on the lifetimes of the client and server in a queued environment, the implication is that these objects must be able to marshal by value.</span></span> <span data-ttu-id="ca214-116">因為 COM + 並不提供標準 COM 物件的傳遞值語義，所以錄製器和播放機需要元件的協助封送處理和 unmarshal 物件。</span><span class="sxs-lookup"><span data-stu-id="ca214-116">Because COM+ does not provide pass-by-value semantics for standard COM objects, the recorder and player need help from the component to marshal and unmarshal the object.</span></span>

<span data-ttu-id="ca214-117">支援 [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) 的物件參考可用來做為已排入佇列元件上的方法呼叫的參數。</span><span class="sxs-lookup"><span data-stu-id="ca214-117">Object references that support [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) can be used as parameters to method calls on queued components.</span></span> <span data-ttu-id="ca214-118">物件無法進行 reinstantiated 時的假設。</span><span class="sxs-lookup"><span data-stu-id="ca214-118">The object cannot make assumptions about when it will be reinstantiated.</span></span> <span data-ttu-id="ca214-119">例如，伺服器可能無法使用，或伺服器元件可能會在一天之後才啟動。</span><span class="sxs-lookup"><span data-stu-id="ca214-119">For example, the server may be unavailable or the server component may not be started until later in the day.</span></span> <span data-ttu-id="ca214-120">不支援 **IPersistStream** 的物件將會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="ca214-120">Objects that do not support **IPersistStream** will return an error.</span></span>

## <a name="visual-basic-persistable-objects"></a><span data-ttu-id="ca214-121">Visual Basic 永久性物件</span><span class="sxs-lookup"><span data-stu-id="ca214-121">Visual Basic Persistable Objects</span></span>

<span data-ttu-id="ca214-122">Microsoft Visual Basic 6 允許建立永久性物件。</span><span class="sxs-lookup"><span data-stu-id="ca214-122">Microsoft Visual Basic 6 allows persistable objects to be created.</span></span> <span data-ttu-id="ca214-123">這些物件支援 [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) ，並且可以做為參數傳遞至已排入佇列的元件方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="ca214-123">These objects support [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) and can be passed as parameters to queued component method calls.</span></span> <span data-ttu-id="ca214-124">在 Visual Basic 物件可以傳遞至已排入佇列的元件之前，必須先初始化永久性物件。</span><span class="sxs-lookup"><span data-stu-id="ca214-124">Before a Visual Basic object can be passed to a queued component, the persistable object must be initialized.</span></span> <span data-ttu-id="ca214-125">這可以透過下列兩種方式之一來完成：</span><span class="sxs-lookup"><span data-stu-id="ca214-125">This can be done in one of the following two ways:</span></span>

-   <span data-ttu-id="ca214-126">如果建立永久性物件的應用程式是以 Visual Basic 寫入，則 Visual Basic 執行時間會自動處理物件初始化。</span><span class="sxs-lookup"><span data-stu-id="ca214-126">If the application creating the persistable object is written in Visual Basic, the Visual Basic runtime handles the object initialization automatically.</span></span>
-   <span data-ttu-id="ca214-127">如果建立 Visual Basic 永久性物件的應用程式是以 Visual Basic 以外的語言（例如 Microsoft Visual C++）撰寫，則應用程式必須藉由查詢永久性物件的 [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) 介面或呼叫 [**IPersistStreamInit：： InitNew**](/windows/desktop/api/ocidl/nf-ocidl-ipersiststreaminit-initnew)或 [**IPersistStream：： Load**](/windows/desktop/api/objidl/nf-objidl-ipersiststream-load) 方法，明確地初始化元件。</span><span class="sxs-lookup"><span data-stu-id="ca214-127">If the application that creates the Visual Basic persistable object is written in a language other than Visual Basic, such as Microsoft Visual C++, the application must explicitly initialize the component by either querying for the persistable object's [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream) interface or calling the [**IPersistStreamInit::InitNew**](/windows/desktop/api/ocidl/nf-ocidl-ipersiststreaminit-initnew), or [**IPersistStream::Load**](/windows/desktop/api/objidl/nf-objidl-ipersiststream-load) method.</span></span>

## <a name="ado-recordsets-and-ole-db-rowsets"></a><span data-ttu-id="ca214-128">ADO 記錄集和 OLE DB 資料列集</span><span class="sxs-lookup"><span data-stu-id="ca214-128">ADO Recordsets and OLE DB Rowsets</span></span>

<span data-ttu-id="ca214-129">在元件之間傳遞 ADO **記錄集** 或 OLE DB 資料列集物件，可讓一個元件處理由另一個元件所執行之查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="ca214-129">Passing ADO **Recordset** or OLE DB rowset objects between components allows one component to process the results of queries executed by another component.</span></span> <span data-ttu-id="ca214-130">在多部電腦上部署應用程式時，這會很有説明。</span><span class="sxs-lookup"><span data-stu-id="ca214-130">This is helpful when deploying an application across multiple computers.</span></span> <span data-ttu-id="ca214-131">**記錄集** 和資料列集物件可以做為方法參數傳遞至已排入佇列的元件，但有下列限制：</span><span class="sxs-lookup"><span data-stu-id="ca214-131">**Recordset** and rowset objects can be passed as method parameters to queued components, with the following restrictions:</span></span>

-   <span data-ttu-id="ca214-132">伺服器端 **記錄集** 物件無法使用 [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream)進行封送處理。</span><span class="sxs-lookup"><span data-stu-id="ca214-132">Server-side **Recordset** objects cannot be marshaled using [**IPersistStream**](/windows/desktop/api/objidl/nn-objidl-ipersiststream).</span></span> <span data-ttu-id="ca214-133">只有用戶端 **記錄集** 物件可以做為參數傳遞至已排入佇列的元件方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="ca214-133">Only client-side **Recordset** objects can be passed as parameters to a queued component method call.</span></span>
-   <span data-ttu-id="ca214-134">如果您直接使用 OLE DB，OLE DB 資料列集必須定義為用戶端資料列集。</span><span class="sxs-lookup"><span data-stu-id="ca214-134">If you work directly with OLE DB, the OLE DB rowset must be defined as a client-side rowset.</span></span>

 

 
