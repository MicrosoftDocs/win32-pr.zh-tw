---
description: 一般來說，分散式應用程式各層之間的延遲會有很大的差異。
ms.assetid: 4780a9fd-5940-4b10-a596-22214b17c033
title: 將 COM + 商務邏輯層和展示層之間的互動優化
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fe6094cb12cc7875d8a18dea3d28ac55bf8d6ae2
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106972976"
---
# <a name="optimizing-interactions-between-the-com-business-logic-tier-and-the-presentation-tier"></a><span data-ttu-id="f7b76-103">將 COM + 商務邏輯層和展示層之間的互動優化</span><span class="sxs-lookup"><span data-stu-id="f7b76-103">Optimizing Interactions Between the COM+ Business Logic Tier and the Presentation Tier</span></span>

<span data-ttu-id="f7b76-104">一般來說，分散式應用程式各層之間的延遲會有很大的差異。</span><span class="sxs-lookup"><span data-stu-id="f7b76-104">Typically, the latency between tiers of a distributed application differs greatly.</span></span> <span data-ttu-id="f7b76-105">展示層和商務邏輯層之間的呼叫通常會比商務層和資料層之間的呼叫速度慢很多。</span><span class="sxs-lookup"><span data-stu-id="f7b76-105">Calls between the presentation tier and business logic tier are often an order of magnitude slower than calls between the business tier and data tier.</span></span> <span data-ttu-id="f7b76-106">因此，在呼叫商務邏輯層時，保持狀態的成本會更高。</span><span class="sxs-lookup"><span data-stu-id="f7b76-106">As a result, held state is more costly when calling into the business logic tier.</span></span>

<span data-ttu-id="f7b76-107">下列主題討論在簡報和商務邏輯層之間傳遞資料的方式：</span><span class="sxs-lookup"><span data-stu-id="f7b76-107">The following topics discuss ways to pass data between the presentation and business logic tiers:</span></span>

-   [<span data-ttu-id="f7b76-108">傳遞參數</span><span class="sxs-lookup"><span data-stu-id="f7b76-108">Passing Parameters</span></span>](#passing-parameters)
-   [<span data-ttu-id="f7b76-109">資料傳遞選項</span><span class="sxs-lookup"><span data-stu-id="f7b76-109">Data Passing Options</span></span>](#data-passing-options)
-   [<span data-ttu-id="f7b76-110">使用 Factory 模式傳遞資料</span><span class="sxs-lookup"><span data-stu-id="f7b76-110">Using a Factory Pattern to Pass Data</span></span>](#using-a-factory-pattern-to-pass-data)
-   [<span data-ttu-id="f7b76-111">相關主題</span><span class="sxs-lookup"><span data-stu-id="f7b76-111">Related topics</span></span>](#related-topics)

## <a name="passing-parameters"></a><span data-ttu-id="f7b76-112">傳遞參數</span><span class="sxs-lookup"><span data-stu-id="f7b76-112">Passing Parameters</span></span>

<span data-ttu-id="f7b76-113">針對要在展示層和商務邏輯層之間傳遞的一組特定資訊，您可能會有單一資料列、多個資料列或單一資料列的組合 (例如標頭) 和多個詳細資料列的資料。</span><span class="sxs-lookup"><span data-stu-id="f7b76-113">For a given set of information to be passed between the presentation tier and the business logic tier, you may have a single row, multiple rows, or a combination of a single row (such as a header) and multiple detail rows of data.</span></span> <span data-ttu-id="f7b76-114">在各層之間傳遞這項資訊最有效率的方式，就是透過單一方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="f7b76-114">The most efficient way to pass this information between tiers is by a single method call.</span></span> <span data-ttu-id="f7b76-115">此單一呼叫會管理要傳遞的整個資訊集。</span><span class="sxs-lookup"><span data-stu-id="f7b76-115">This single call would manage the entire information set to be passed.</span></span> <span data-ttu-id="f7b76-116">這是必要的，除非您選擇從展示層 (控制交易，並讓展示層中的所有交易處理都與函數) 相同。</span><span class="sxs-lookup"><span data-stu-id="f7b76-116">This is necessary unless you choose to control the transaction from the presentation tier (and make all transaction treatment in the presentation tier identical in function).</span></span> <span data-ttu-id="f7b76-117">Microsoft 不建議從展示層進行交易，因為這一層和商務邏輯層之間的呼叫通常是多層式應用程式中任何呼叫的最慢。</span><span class="sxs-lookup"><span data-stu-id="f7b76-117">Microsoft does not recommend conducting transactions from the presentation tier because calls between this tier and the business logic tier are usually the slowest of any calls in a multi-tier application.</span></span>

<span data-ttu-id="f7b76-118">建立這類方法的其中一種方式，是將單一資料列的資訊當作參數傳遞，並將多個資料列傳遞為 ADO 記錄集。</span><span class="sxs-lookup"><span data-stu-id="f7b76-118">One way to create such a method is to pass single rows of information as parameters and pass multiple rows as ADO recordsets.</span></span> <span data-ttu-id="f7b76-119">記錄集是 Microsoft ADO 資料存取方法的核心，而使用 ADO 記錄集可讓您以單一步驟傳遞與單一交易相關的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="f7b76-119">Recordsets are the core of Microsoft's ADO data access methodology, and using ADO recordsets allows you to pass all the information related to a single transaction in one step.</span></span>

## <a name="data-passing-options"></a><span data-ttu-id="f7b76-120">資料傳遞選項</span><span class="sxs-lookup"><span data-stu-id="f7b76-120">Data Passing Options</span></span>

<span data-ttu-id="f7b76-121">傳遞資料時還有其他要考慮的選項。</span><span class="sxs-lookup"><span data-stu-id="f7b76-121">There are other options to consider when passing data.</span></span> <span data-ttu-id="f7b76-122">這些包括使用參數清單和 ADO 記錄集 (如先前所述) 、ADO 記錄集、XML 編碼字串或結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="f7b76-122">These include using a list of parameters and ADO recordsets (as discussed above), just ADO recordsets, XML encoded strings, or arrays of structures.</span></span> <span data-ttu-id="f7b76-123">本節將討論這些選項。</span><span class="sxs-lookup"><span data-stu-id="f7b76-123">This section discusses each of these options.</span></span>

<span data-ttu-id="f7b76-124">下表顯示使用四種不同的引數傳遞可能性時，需要特別注意的領域。</span><span class="sxs-lookup"><span data-stu-id="f7b76-124">The following table shows areas where extra care needs to be taken when using any of the four different argument-passing possibilities.</span></span> <span data-ttu-id="f7b76-125">「X」代表需要瞭解和權衡各專案需求之取捨的領域。</span><span class="sxs-lookup"><span data-stu-id="f7b76-125">An "X" represents areas where trade-offs need to be understood and weighed against the needs of each project.</span></span> <span data-ttu-id="f7b76-126">請不要針對每個元件進行引數傳遞決策。</span><span class="sxs-lookup"><span data-stu-id="f7b76-126">Try not to make argument-passing decisions on a per-component basis.</span></span> <span data-ttu-id="f7b76-127">在整個專案中，一致程式設計模型的優點，遠遠超過了針對每個方法或每個元件進行優化的優點，但最極端的情況是如此。</span><span class="sxs-lookup"><span data-stu-id="f7b76-127">The benefits of a consistent programming model throughout a project far outweigh any advantage of optimizing on a per-method or per-component basis in all but the most extreme circumstances.</span></span> <span data-ttu-id="f7b76-128">資料表後面的清單中會說明這些資料行。</span><span class="sxs-lookup"><span data-stu-id="f7b76-128">The columns are described in the list that follows the table.</span></span>



|                       | <span data-ttu-id="f7b76-129">並行</span><span class="sxs-lookup"><span data-stu-id="f7b76-129">Concurrency</span></span>  | <span data-ttu-id="f7b76-130">WAN</span><span class="sxs-lookup"><span data-stu-id="f7b76-130">WAN</span></span>          | <span data-ttu-id="f7b76-131">部署</span><span class="sxs-lookup"><span data-stu-id="f7b76-131">Deployment</span></span>   | <span data-ttu-id="f7b76-132">複雜度</span><span class="sxs-lookup"><span data-stu-id="f7b76-132">Complexity</span></span>   |
|-----------------------|--------------|--------------|--------------|--------------|
| <span data-ttu-id="f7b76-133">進入</span><span class="sxs-lookup"><span data-stu-id="f7b76-133">Entry</span></span> | <span data-ttu-id="f7b76-134">值</span><span class="sxs-lookup"><span data-stu-id="f7b76-134">Value</span></span> |
| <span data-ttu-id="f7b76-135">集中</span><span class="sxs-lookup"><span data-stu-id="f7b76-135">Recordsets</span></span><br/> |              | <span data-ttu-id="f7b76-136">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-136">X</span></span><br/> | <span data-ttu-id="f7b76-137">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-137">X</span></span><br/> | <span data-ttu-id="f7b76-138">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-138">X</span></span><br/> |
| <span data-ttu-id="f7b76-139">XML</span><span class="sxs-lookup"><span data-stu-id="f7b76-139">XML</span></span><br/>        | <span data-ttu-id="f7b76-140">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-140">X</span></span><br/> |              | <span data-ttu-id="f7b76-141">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-141">X</span></span><br/> | <span data-ttu-id="f7b76-142">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-142">X</span></span><br/> |
| <span data-ttu-id="f7b76-143">陣列</span><span class="sxs-lookup"><span data-stu-id="f7b76-143">Arrays</span></span><br/>     | <span data-ttu-id="f7b76-144">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-144">X</span></span><br/> |              | <span data-ttu-id="f7b76-145">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-145">X</span></span><br/> | <span data-ttu-id="f7b76-146">X</span><span class="sxs-lookup"><span data-stu-id="f7b76-146">X</span></span><br/> |



 

<span data-ttu-id="f7b76-147">四個數據行定義使用該選項來傳遞參數時要注意的區域。</span><span class="sxs-lookup"><span data-stu-id="f7b76-147">The four columns define areas to watch out for when using that option to pass parameters.</span></span>

-   <span data-ttu-id="f7b76-148">**並行資料行** 代表需要撰寫程式碼或提供機制，以管理更新作業的鎖定條件。</span><span class="sxs-lookup"><span data-stu-id="f7b76-148">**The Concurrency column** represents the need to code or provide a mechanism that manages locking conditions on update operations.</span></span> <span data-ttu-id="f7b76-149">由於執行儲存的方法可以代表更新，因此可能會發生並行問題。</span><span class="sxs-lookup"><span data-stu-id="f7b76-149">Since methods that perform saves can represent updates, concurrency problems can arise.</span></span> <span data-ttu-id="f7b76-150">有兩種類型的鎖定是普遍的開放式和封閉式。</span><span class="sxs-lookup"><span data-stu-id="f7b76-150">Two types of locking are prevalent optimistic and pessimistic.</span></span> <span data-ttu-id="f7b76-151">封閉式鎖定可防止使用者取得資料進行更新，而另一位使用者則有可能執行更新。</span><span class="sxs-lookup"><span data-stu-id="f7b76-151">Pessimistic locks prevent a user from getting data for update while another user has the potential for performing an update.</span></span> <span data-ttu-id="f7b76-152">開放式鎖定可針對任何兩位使用者同時更新相同檔的可能性進行交易，以支援更多使用者。</span><span class="sxs-lookup"><span data-stu-id="f7b76-152">Optimistic locking supports a great many more users by trading against the likelihood that any two users would be updating the same document at the same time.</span></span> <span data-ttu-id="f7b76-153">開放式鎖定呼叫，可檢查儲存的資料是否與存取資料複本以進行修改時的資料相符。</span><span class="sxs-lookup"><span data-stu-id="f7b76-153">Optimistic locking calls for checking to see that the data that is stored matches the data at the point when a copy of the data was accessed for modification.</span></span> <span data-ttu-id="f7b76-154">ADO 記錄集提供自動支援開放式鎖定。</span><span class="sxs-lookup"><span data-stu-id="f7b76-154">ADO recordsets provide automatic support for optimistic locking.</span></span> <span data-ttu-id="f7b76-155">包含單一資料列參數清單的更新案例無法提供足夠的並行檢查支援。</span><span class="sxs-lookup"><span data-stu-id="f7b76-155">Update scenarios involving single row parameter lists do not provide sufficient support for concurrency checking.</span></span> <span data-ttu-id="f7b76-156">XML 有這個相同的問題，因為 XML 資料中沒有鎖定感知。</span><span class="sxs-lookup"><span data-stu-id="f7b76-156">XML suffers from this same problem, in that no locking awareness is present in XML data.</span></span>
-   <span data-ttu-id="f7b76-157">**Wan 資料行** 代表在廣域網路 (WAN ) 上可能會有傳輸爭用的狀況。</span><span class="sxs-lookup"><span data-stu-id="f7b76-157">**The WAN column** represents conditions where there may be transmission contention on a wide area network (WAN ).</span></span> <span data-ttu-id="f7b76-158">當 WAN 沒有足夠的容量來管理任何一次移動的資料時，應用程式使用者會遇到回應時間延遲。</span><span class="sxs-lookup"><span data-stu-id="f7b76-158">When the WAN does not have sufficient capacity to manage all of the data being moved at any one time, application users experience response time delays.</span></span> <span data-ttu-id="f7b76-159">為了支援開放式平行存取，已中斷連線的 ADO 記錄集會將兩份資料複本從伺服器傳遞至用戶端。</span><span class="sxs-lookup"><span data-stu-id="f7b76-159">To support optimistic concurrency, disconnected ADO recordsets pass two copies of the data from the server to the client.</span></span> <span data-ttu-id="f7b76-160">當認可變更時，用戶端會使用第二個複本來決定要傳回的最小更新資料列集。</span><span class="sxs-lookup"><span data-stu-id="f7b76-160">The second copy is used by the client to determine the smallest update rowset to pass back when a change is being committed.</span></span> <span data-ttu-id="f7b76-161">雖然這會減少從展示層到資料的流量，但第二個複本的額外負載可能很重要。</span><span class="sxs-lookup"><span data-stu-id="f7b76-161">While this cuts down on traffic from the presentation tier to the data, the extra load of the second copy can be significant.</span></span> <span data-ttu-id="f7b76-162">使用記錄集作為傳遞所有資訊的唯一方法，因此會導致在各層之間傳遞兩倍的資料（如有需要），除非從展示層將更新資料列集傳回資料層。</span><span class="sxs-lookup"><span data-stu-id="f7b76-162">Using recordsets as the sole means of passing all information therefore causes twice as much data to be passed between tiers as is required, except when the update rowset is being passed back to the data tier from a presentation tier.</span></span>
-   <span data-ttu-id="f7b76-163">**[部署** ] 資料行代表在網路呼叫端和元件端需要特殊技術時，與資料傳遞相關的問題。</span><span class="sxs-lookup"><span data-stu-id="f7b76-163">**The Deployment column** represents issues associated with data passing when special technology is required on both the caller and component side of the network.</span></span> <span data-ttu-id="f7b76-164">例如，使用 ADO 記錄集時，用戶端和伺服器上都需要有 ADO 元件。</span><span class="sxs-lookup"><span data-stu-id="f7b76-164">For example, using ADO recordsets requires ADO components to be present on both client and server.</span></span> <span data-ttu-id="f7b76-165">XML 剖析器也必須同時存在於兩端，以避免必須將剖析器編碼至您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f7b76-165">XML parsers must be present on both sides as well, to avoid having to code parsers into your applications.</span></span>
-   <span data-ttu-id="f7b76-166">**[複雜性** ] 資料行會針對所有四個選項來指出，而且是您的開發組織中可能已建立的喜好設定或先前的程式設計模型體驗。</span><span class="sxs-lookup"><span data-stu-id="f7b76-166">**The Complexity column** is indicated for all four choices, and is a matter of preference or prior programming model experience that may be already established in your development organization.</span></span> <span data-ttu-id="f7b76-167">某些人發現參數傳遞很麻煩，因此會增加太多複雜的程式設計問題。</span><span class="sxs-lookup"><span data-stu-id="f7b76-167">Some people find parameter passing to be cumbersome and feel it adds too much complexity to the programming problem.</span></span> <span data-ttu-id="f7b76-168">追蹤您正在處理的參數，並將它們全部顯示在一個編輯視窗中，可以創造一些開發人員認為無法管理的物流複雜度。</span><span class="sxs-lookup"><span data-stu-id="f7b76-168">Keeping track of which parameter you are handling, and getting them all visible in one editing window, can create a logistical complexity that some developers find unmanageable.</span></span>

<span data-ttu-id="f7b76-169">參數傳遞方法也可以進行取捨，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f7b76-169">The parameter-passing method also can have trade-offs, such as the following:</span></span>

-   <span data-ttu-id="f7b76-170">參數可以管理多個引數和引數類型，也必須決定何時適合讓記錄集成為參數。</span><span class="sxs-lookup"><span data-stu-id="f7b76-170">Parameters can involve managing multiple arguments and argument types as well as having to decide when it is appropriate to make a recordset a parameter.</span></span>
-   <span data-ttu-id="f7b76-171">ADO 記錄集可以將方法參數中的階層式關聯性剪下為一或兩個引數。</span><span class="sxs-lookup"><span data-stu-id="f7b76-171">ADO recordsets can cut hierarchical relationships in method parameters down to one or two arguments.</span></span> <span data-ttu-id="f7b76-172">這可大幅簡化程式設計模型，並支援稍後新增資料行，但它也會隱藏資訊階層。</span><span class="sxs-lookup"><span data-stu-id="f7b76-172">This simplifies the programming model dramatically and supports adding columns at a later time, but it also hides the information hierarchy.</span></span> <span data-ttu-id="f7b76-173">將資訊裝到 ADO 記錄集，並在稍後進行解壓縮，會牽涉到知道每個資料行的名稱，或知道資料行順序。</span><span class="sxs-lookup"><span data-stu-id="f7b76-173">Stuffing information into an ADO recordset and later extracting it involves knowing the names of each column or knowing the column order.</span></span> <span data-ttu-id="f7b76-174">這種情況可能會增加專案上其他元件或應用程式開發人員的複雜度。</span><span class="sxs-lookup"><span data-stu-id="f7b76-174">This situation can add complexity for other component or application developers on the project.</span></span>
-   <span data-ttu-id="f7b76-175">XML 是上面所述隱藏階層複雜的不同微調。</span><span class="sxs-lookup"><span data-stu-id="f7b76-175">XML is a different spin on the hidden hierarchy complication mentioned above.</span></span> <span data-ttu-id="f7b76-176">程式設計人員必須瞭解如何使用 XML 剖析器來取得資訊的存取權，而且通常必須知道資料集中每個專案的名稱，才能找到資料集。</span><span class="sxs-lookup"><span data-stu-id="f7b76-176">The programmer needs to understand the use of an XML parser to gain access to the information and often must know the names of each item in the data set before the data set can be found.</span></span>
-   <span data-ttu-id="f7b76-177">結構的陣列導入了在呼叫端和元件的部分上傳遞資訊的一般需求。</span><span class="sxs-lookup"><span data-stu-id="f7b76-177">Arrays of structures introduce the need for a common understanding of the information being passed on the part of both caller and component.</span></span> <span data-ttu-id="f7b76-178">這需要在兩個系統元素之間共用的對應，在處理不同版本的元件時可能會造成困難。</span><span class="sxs-lookup"><span data-stu-id="f7b76-178">This need for a map that is shared between two system elements can lead to difficulties when dealing with different versions of components.</span></span> <span data-ttu-id="f7b76-179">雖然方法簽章可能不會變更，但對預期資訊的變更可能會導致呼叫程式不相容。</span><span class="sxs-lookup"><span data-stu-id="f7b76-179">While the method signature might not change, changes to the expected information can render calling programs incompatible.</span></span>

<span data-ttu-id="f7b76-180">因為與所有四個參數傳遞方法相關的複雜性問題都很類似，所以爭議有一個明顯的簡化機會與任何選取專案相關聯。</span><span class="sxs-lookup"><span data-stu-id="f7b76-180">Because the complexity issues associated with all four parameter-passing methods are so similar, it is debatable that there is a significant simplification opportunity associated with any one selection.</span></span>

## <a name="using-a-factory-pattern-to-pass-data"></a><span data-ttu-id="f7b76-181">使用 Factory 模式傳遞資料</span><span class="sxs-lookup"><span data-stu-id="f7b76-181">Using a Factory Pattern to Pass Data</span></span>

<span data-ttu-id="f7b76-182">其中一個重要的設計點是很容易使用。</span><span class="sxs-lookup"><span data-stu-id="f7b76-182">One important design point is ease of use.</span></span> <span data-ttu-id="f7b76-183">當您決定使用 ADO 記錄集將一組結構化的詳細資料傳回給展示層時，您會發現複雜性的問題。</span><span class="sxs-lookup"><span data-stu-id="f7b76-183">The moment you decided to use ADO recordsets to pass a structured set of details back to the presentation tier, you introduced a complexity problem.</span></span> <span data-ttu-id="f7b76-184">展示層程式設計人員必須瞭解這些記錄集的結構。</span><span class="sxs-lookup"><span data-stu-id="f7b76-184">Presentation tier programmers need to understand the structure of those recordsets.</span></span> <span data-ttu-id="f7b76-185">當您需要在記錄集中傳遞一組資料的多個詳細資料時，可能會產生更複雜的問題。</span><span class="sxs-lookup"><span data-stu-id="f7b76-185">A greater complexity issue can arise when you require multiple details for a set of data to be passed in a recordset.</span></span> <span data-ttu-id="f7b76-186">若要簡化重要的工作，每當您想要要求以結構化 ADO 記錄集傳遞資料時，您應該考慮建立記錄集 factory 方法。</span><span class="sxs-lookup"><span data-stu-id="f7b76-186">To simplify matters, you should consider creating a recordset factory method whenever you intend to require data to be passed in structured ADO recordsets.</span></span>

<span data-ttu-id="f7b76-187">記錄集 factory 應該會傳回空白但可寫入的已中斷連接記錄集給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f7b76-187">The recordset factory should return an empty but writable disconnected recordset to the caller.</span></span> <span data-ttu-id="f7b76-188">此記錄集應該具有適當的欄位 (名稱和資料類型) 已設定，如此呼叫的用戶端就不需要知道如何製造記錄集。</span><span class="sxs-lookup"><span data-stu-id="f7b76-188">This recordset should have the proper fields (names and data types) already configured so that the calling client does not need to know how to manufacture the recordset.</span></span> <span data-ttu-id="f7b76-189">這種方法通常稱為 *factory 模式* ，是一種常見的解決方案模式，可解決需要建立特定複雜性物件的需求，而不需要知道建立物件的細節。</span><span class="sxs-lookup"><span data-stu-id="f7b76-189">This approach is often referred to as the *factory pattern* and is a common solution pattern that solves the need to create an object of a given complexity without having to know the nuances of creating it.</span></span>

<span data-ttu-id="f7b76-190">簡單的設計選擇，例如在傳遞資訊的每個方法中選擇相同資料片段的相同參數名稱，可讓您輕鬆地查看方法，並瞭解預期的結果。</span><span class="sxs-lookup"><span data-stu-id="f7b76-190">Simple design choices such as choosing the same parameter name for the same piece of data across every method where that information is passed makes it easy to look at a method and know what is expected.</span></span> <span data-ttu-id="f7b76-191">確定傳遞引數的順序在整個方法系列中都是一致的，可提供強制執行一致模型的緩和點。</span><span class="sxs-lookup"><span data-stu-id="f7b76-191">Making sure that the order in which like arguments are passed is consistent across an entire family of methods provides a comfort point that enforces a consistent model.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f7b76-192">相關主題</span><span class="sxs-lookup"><span data-stu-id="f7b76-192">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f7b76-193">優化 COM + 商務邏輯層與資料層之間的互動</span><span class="sxs-lookup"><span data-stu-id="f7b76-193">Optimizing Interactions Between the COM+ Business Logic Tier and the Data Tier</span></span>](optimizing-interactions-between-the-com--business-logic-tier-and-the-data-tier.md)
</dt> </dl>

 

 




