---
description: 在 COM + 中，會使用相關聯的內容來建立每個 COM 物件。
ms.assetid: e5602af2-5852-4c34-a792-6742e90b7d41
title: 內容啟用
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a652615d6c1288887085c857817e32e3a3b4081c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104111033"
---
# <a name="context-activation"></a><span data-ttu-id="a6279-103">內容啟用</span><span class="sxs-lookup"><span data-stu-id="a6279-103">Context Activation</span></span>

<span data-ttu-id="a6279-104">在 COM + 中，會使用相關聯的內容來建立每個 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="a6279-104">In COM+, every COM object is created with an associated context.</span></span> <span data-ttu-id="a6279-105">這表示必須建立和初始化新的內容，或使用適當的現有內容。</span><span class="sxs-lookup"><span data-stu-id="a6279-105">This means that either a new context must be created and initialized or an appropriate existing context is used.</span></span> <span data-ttu-id="a6279-106">此程式稱為「 *啟用*」。</span><span class="sxs-lookup"><span data-stu-id="a6279-106">This process is known as *activation*.</span></span> <span data-ttu-id="a6279-107">在 COM + 中，物件會在自己的內容中啟動，或在其建立者 (已要求啟用物件的物件（例如，藉由呼叫 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)) ）。</span><span class="sxs-lookup"><span data-stu-id="a6279-107">In COM+, an object is activated either in its own context or in that of its creator (an object that has requested that the object be activated—for example, by calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)).</span></span>

<span data-ttu-id="a6279-108">在某些情況下（例如 [物件](com--object-pooling.md)共用），物件會在不需要從頭建立的情況下啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-108">In some circumstances, such as with [object pooling](com--object-pooling.md), an object is activated without being created from scratch.</span></span> <span data-ttu-id="a6279-109">在此情況下，會在內容中啟動正在執行的實例。</span><span class="sxs-lookup"><span data-stu-id="a6279-109">In this case, a running instance is activated within a context.</span></span> <span data-ttu-id="a6279-110">在其存留期內，它可能會在不同的內容中重複啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-110">Over its lifetime, it may be repeatedly activated in different contexts.</span></span>

<span data-ttu-id="a6279-111">在任一種情況下，基本機制都相同：物件與內容相關聯，而且該內容已正確初始化，以代表物件的執行時間需求。</span><span class="sxs-lookup"><span data-stu-id="a6279-111">The basic mechanism is the same in either case—an object is associated with a context and that context is properly initialized to represent the run-time needs of the object.</span></span>

## <a name="flowing-of-context-properties"></a><span data-ttu-id="a6279-112">內容屬性的流動</span><span class="sxs-lookup"><span data-stu-id="a6279-112">Flowing of Context Properties</span></span>

<span data-ttu-id="a6279-113">當啟始物件以回應另一個物件的建立要求時，COM + 必須協調它們，才能適當地啟用下游物件。</span><span class="sxs-lookup"><span data-stu-id="a6279-113">When an object is being activated in response to a creation request from another object, COM+ needs to mediate between them to properly activate the downstream object.</span></span> <span data-ttu-id="a6279-114">COM + 必須將呼叫端的內容與所呼叫元件的設定進行比較，然後決定要在何處啟用下游元件，以及如何將其內容屬性初始化。</span><span class="sxs-lookup"><span data-stu-id="a6279-114">COM+ has to compare the context of the caller with the configuration of the called component and then decide where to activate the downstream component and how to initialize its context properties.</span></span>

<span data-ttu-id="a6279-115">為了探索元件的設定，COM + 會在 COM + 類別註冊資料庫中尋找它，該資料庫已針對極快速的執行時間查閱進行優化。</span><span class="sxs-lookup"><span data-stu-id="a6279-115">To discover the component's configuration, COM+ looks it up in the COM+ class registration database, which is optimized for extremely fast run-time lookups.</span></span> <span data-ttu-id="a6279-116"> (這取決於您在將元件安裝至 COM + 應用程式時，如何設定元件。 ) 元件的設定會根據呼叫端的內容屬性的狀態進行檢查。</span><span class="sxs-lookup"><span data-stu-id="a6279-116">(This is determined by how you configured a component when installing it into a COM+ application.) The component's configuration is then examined against the state of the caller's context properties.</span></span>

<span data-ttu-id="a6279-117">在某些情況下，設定會與呼叫端的內容一致，而且元件可以在呼叫端的內容中啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-117">In some cases, the configuration is consistent with the context of the caller and the component can be activated within the caller's context.</span></span> <span data-ttu-id="a6279-118">只有在呼叫端的內容符合新物件的所有執行時間需求時，才會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="a6279-118">This can happen only if the caller's context satisfies all the run-time requirements of the new object.</span></span>

<span data-ttu-id="a6279-119">當下游元件無法在呼叫端的內容中啟動時，它會在適當的單元中于自己的內容中啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-119">When the downstream component cannot be activated within the caller's context, it is activated in its own context in an appropriate apartment.</span></span> <span data-ttu-id="a6279-120">發生這種情況時，某些內容屬性可能會從呼叫端流向被呼叫端。</span><span class="sxs-lookup"><span data-stu-id="a6279-120">When this occurs, certain context properties may flow from caller to callee.</span></span> <span data-ttu-id="a6279-121">例如，如果呼叫端與交易相關聯，而且被呼叫端支援交易，則新的物件會取得自己的內容 (在交易中進行投票，它必須有自己的一致旗標) 並繼承位於相同交易和同步處理網域) 中的呼叫端交易識別碼和活動識別碼 (。</span><span class="sxs-lookup"><span data-stu-id="a6279-121">For example, if the caller is associated with a transaction and the callee supports transactions, the new object gets its own context (to vote in the transaction, it needs to have its own consistent flag) and inherits the caller's transaction ID and activity ID (which reside within the same transaction and synchronization domain).</span></span>

## <a name="ignored-context-properties"></a><span data-ttu-id="a6279-122">略過的內容屬性</span><span class="sxs-lookup"><span data-stu-id="a6279-122">Ignored Context Properties</span></span>

<span data-ttu-id="a6279-123">視元件的設定方式而定，某些內容屬性在判斷是否會在建立者的內容或本身的內容中啟用時，不會扮演任何角色。</span><span class="sxs-lookup"><span data-stu-id="a6279-123">Depending on how a component is configured, some context properties may play no role in determining whether it is activated in the creator's context or its own context.</span></span> <span data-ttu-id="a6279-124">例如，停用的交易和同步處理停用的設定（指出交易或同步處理網域的存在）在元件啟用時，不會扮演任何角色。</span><span class="sxs-lookup"><span data-stu-id="a6279-124">For example, the Transactions Disabled and Synchronization Disabled settings, indicating the presence of a transaction or a synchronization domain, will play no role whatsoever in the component's activation.</span></span> <span data-ttu-id="a6279-125">當內容流動時，會以根本上忽略這些屬性。</span><span class="sxs-lookup"><span data-stu-id="a6279-125">These properties are fundamentally ignored when context is flowed.</span></span> <span data-ttu-id="a6279-126">或者，如果元件只使用進程層級的存取檢查，則會忽略其資訊安全內容屬性，元件的安全性設定在啟用時永遠不會扮演角色。</span><span class="sxs-lookup"><span data-stu-id="a6279-126">Or if a component uses only process-level access checking, its security context property is ignored—the component's security configuration will never play a role in its activation.</span></span>

## <a name="forcing-activation-in-the-callers-context"></a><span data-ttu-id="a6279-127">在呼叫端的內容中強制啟用</span><span class="sxs-lookup"><span data-stu-id="a6279-127">Forcing Activation in the Caller's Context</span></span>

<span data-ttu-id="a6279-128">在某些情況下，您可能只想在其呼叫端的內容中啟始物件，也就是永遠不會在其本身的內容中啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-128">In some circumstances, you might want an object to be activated only in its caller's context—that is, never activated in its own context.</span></span> <span data-ttu-id="a6279-129">例如，您可能想要控制物件在內容界限上呼叫時的行為。</span><span class="sxs-lookup"><span data-stu-id="a6279-129">For example, you might want to control the object's behavior when it's called across a context boundary.</span></span>

<span data-ttu-id="a6279-130">您可以使用 [元件服務] 系統管理工具，在 [元件 **屬性**]**頁面的 [** 啟動] 索引標籤上選取 [**必須在呼叫者內容中啟用**]，以確保無法在其本身的內容中啟始物件。</span><span class="sxs-lookup"><span data-stu-id="a6279-130">You can ensure that an object cannot be activated in its own context by selecting the **Must be activated in callers context** option on the **Activation** tab of the component **Properties** page, using the Component Services administrative tool.</span></span> <span data-ttu-id="a6279-131"> (請參閱 [在呼叫端的內容中強制啟用](enforcing-activation-in-the-caller-s-context.md) ，以取得逐步指示 ) 。當您選取此選項時，如果無法在呼叫端的內容中啟始物件，則 [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) 會失敗， \_ 並 \_ 傳回 \_ \_ 建立 \_ 外部 \_ 用戶端 \_ 內容的共同 E 嘗試。</span><span class="sxs-lookup"><span data-stu-id="a6279-131">(See [Enforcing Activation in the Caller's Context](enforcing-activation-in-the-caller-s-context.md) for step-by-step instructions.) When you select this option, if the object cannot be activated in the caller's context, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) fails, returning CO\_E\_ATTEMPT\_TO\_CREATE\_OUTSIDE\_CLIENT\_CONTEXT.</span></span>

## <a name="default-context"></a><span data-ttu-id="a6279-132">預設內容</span><span class="sxs-lookup"><span data-stu-id="a6279-132">Default Context</span></span>

<span data-ttu-id="a6279-133">預設內容是為了支援未設定的元件，也就是 com 元件未安裝在 com + 應用程式中，而且未在 COM + 類別註冊資料庫中註冊。</span><span class="sxs-lookup"><span data-stu-id="a6279-133">Default contexts exist to support unconfigured components—that is, COM components not installed in COM+ applications and not registered in the COM+ class registration database.</span></span> <span data-ttu-id="a6279-134">如果未配置的元件具有相容的執行緒模型，則會在呼叫端的內容中啟用它們。</span><span class="sxs-lookup"><span data-stu-id="a6279-134">If unconfigured components have a compatible threading model, they are activated in the caller's context.</span></span> <span data-ttu-id="a6279-135">否則，它們會在適當的單元中的預設內容中啟用。</span><span class="sxs-lookup"><span data-stu-id="a6279-135">Otherwise, they are activated in a default context in the appropriate apartment.</span></span> <span data-ttu-id="a6279-136">每個單元都有預設的內容，以支援不使用 COM + 服務的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="a6279-136">Each apartment has a default context to support COM objects that do not use COM+ services.</span></span>

## <a name="hooking-activation"></a><span data-ttu-id="a6279-137">啟用攔截</span><span class="sxs-lookup"><span data-stu-id="a6279-137">Hooking Activation</span></span>

<span data-ttu-id="a6279-138">藉由執行 [**IObjectControl：： Activate**](/windows/desktop/api/ComSvcs/nf-comsvcs-iobjectcontrol-activate) 和 [**IObjectControl：:D eactivate**](/windows/desktop/api/ComSvcs/nf-comsvcs-iobjectcontrol-deactivate)，您可以將啟用和停用連結在一起，以在新的內容中執行特殊初始化。</span><span class="sxs-lookup"><span data-stu-id="a6279-138">By implementing [**IObjectControl::Activate**](/windows/desktop/api/ComSvcs/nf-comsvcs-iobjectcontrol-activate) and [**IObjectControl::Deactivate**](/windows/desktop/api/ComSvcs/nf-comsvcs-iobjectcontrol-deactivate), you can hook activation and deactivation together to perform special initialization in the new context.</span></span> <span data-ttu-id="a6279-139">當物件設定為使用 JIT 啟用或物件共用時，COM + 會在物件生命週期的特定點呼叫這些方法。</span><span class="sxs-lookup"><span data-stu-id="a6279-139">These methods are called by COM+ at certain points in an object's lifecycle, when the object is configured to use JIT-activation or object pooling.</span></span> <span data-ttu-id="a6279-140">如需詳細資訊，請參閱 [Com + 即時啟用](com--just-in-time-activation.md) 和 [com + 物件](com--object-pooling.md) 共用。</span><span class="sxs-lookup"><span data-stu-id="a6279-140">See [COM+ Just-in-Time Activation](com--just-in-time-activation.md) and [COM+ Object Pooling](com--object-pooling.md) for more detail.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a6279-141">相關主題</span><span class="sxs-lookup"><span data-stu-id="a6279-141">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a6279-142">攔截跨內容呼叫</span><span class="sxs-lookup"><span data-stu-id="a6279-142">Interception of Cross-Context Calls</span></span>](interception-of-cross-context-calls.md)
</dt> </dl>

 

 
