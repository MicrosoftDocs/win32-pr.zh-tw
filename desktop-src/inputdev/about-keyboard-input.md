---
title: 關於鍵盤輸入
description: 本主題討論鍵盤輸入。
ms.assetid: de34727e-e8c7-481d-982d-0e42a02704db
keywords:
- 使用者輸入，鍵盤輸入
- 捕獲使用者輸入，鍵盤輸入
- 鍵盤輸入
- 鍵盤焦點
- 按鍵訊息
- 字元訊息
- 系統按鍵
- 非系統按鍵
- 非系統字元訊息
- 死金鑰
- 死字元訊息
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 65ad481bad6756bb374b98a5510bdc26f1cded6a
ms.sourcegitcommit: ac62be2f60f757f61ea647a95c168c9841ffabac
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/10/2021
ms.locfileid: "104552060"
---
# <a name="about-keyboard-input"></a><span data-ttu-id="cbe1b-114">關於鍵盤輸入</span><span class="sxs-lookup"><span data-stu-id="cbe1b-114">About Keyboard Input</span></span>

<span data-ttu-id="cbe1b-115">應用程式應該接受來自鍵盤以及滑鼠的使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-115">Applications should accept user input from the keyboard as well as from the mouse.</span></span> <span data-ttu-id="cbe1b-116">應用程式會以張貼至其 windows 的訊息形式接收鍵盤輸入。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-116">An application receives keyboard input in the form of messages posted to its windows.</span></span>

<span data-ttu-id="cbe1b-117">本節包含下列主題：</span><span class="sxs-lookup"><span data-stu-id="cbe1b-117">This section covers the following topics:</span></span>

-   [<span data-ttu-id="cbe1b-118">鍵盤輸入模型</span><span class="sxs-lookup"><span data-stu-id="cbe1b-118">Keyboard Input Model</span></span>](#keyboard-input-model)
-   [<span data-ttu-id="cbe1b-119">鍵盤焦點和啟用</span><span class="sxs-lookup"><span data-stu-id="cbe1b-119">Keyboard Focus and Activation</span></span>](#keyboard-focus-and-activation)
-   [<span data-ttu-id="cbe1b-120">按鍵訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-120">Keystroke Messages</span></span>](#keystroke-messages)
    -   [<span data-ttu-id="cbe1b-121">系統和非系統的按鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-121">System and Nonsystem Keystrokes</span></span>](#system-and-nonsystem-keystrokes)
    -   [<span data-ttu-id="cbe1b-122">描述的虛擬金鑰碼</span><span class="sxs-lookup"><span data-stu-id="cbe1b-122">Virtual-Key Codes Described</span></span>](#virtual-key-codes-described)
    -   [<span data-ttu-id="cbe1b-123">按鍵訊息旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-123">Keystroke Message Flags</span></span>](#keystroke-message-flags)
-   [<span data-ttu-id="cbe1b-124">字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-124">Character Messages</span></span>](#character-messages)
    -   [<span data-ttu-id="cbe1b-125">非系統字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-125">Nonsystem Character Messages</span></span>](#nonsystem-character-messages)
    -   [<span data-ttu-id="cbe1b-126">死字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-126">Dead-Character Messages</span></span>](#dead-character-messages)
-   [<span data-ttu-id="cbe1b-127">金鑰狀態</span><span class="sxs-lookup"><span data-stu-id="cbe1b-127">Key Status</span></span>](#key-status)
-   [<span data-ttu-id="cbe1b-128">按鍵和字元翻譯</span><span class="sxs-lookup"><span data-stu-id="cbe1b-128">Keystroke and Character Translations</span></span>](#keystroke-and-character-translations)
-   [<span data-ttu-id="cbe1b-129">支援熱鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-129">Hot-Key Support</span></span>](#hot-key-support)
-   [<span data-ttu-id="cbe1b-130">流覽和其他功能的鍵盤按鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-130">Keyboard Keys for Browsing and Other Functions</span></span>](#keyboard-keys-for-browsing-and-other-functions)
-   [<span data-ttu-id="cbe1b-131">模擬輸入</span><span class="sxs-lookup"><span data-stu-id="cbe1b-131">Simulating Input</span></span>](#simulating-input)
-   [<span data-ttu-id="cbe1b-132">語言、地區設定和鍵盤配置</span><span class="sxs-lookup"><span data-stu-id="cbe1b-132">Languages, Locales, and Keyboard Layouts</span></span>](#languages-locales-and-keyboard-layouts)

## <a name="keyboard-input-model"></a><span data-ttu-id="cbe1b-133">鍵盤輸入模型</span><span class="sxs-lookup"><span data-stu-id="cbe1b-133">Keyboard Input Model</span></span>

<span data-ttu-id="cbe1b-134">系統會安裝適用于目前鍵盤的鍵盤設備磁碟機，為應用程式提供與裝置無關的鍵盤支援。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-134">The system provides device-independent keyboard support for applications by installing a keyboard device driver appropriate for the current keyboard.</span></span> <span data-ttu-id="cbe1b-135">系統會使用使用者或應用程式目前選取的語言特定鍵盤配置，來提供與語言無關的鍵盤支援。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-135">The system provides language-independent keyboard support by using the language-specific keyboard layout currently selected by the user or the application.</span></span> <span data-ttu-id="cbe1b-136">鍵盤設備磁碟機會從鍵盤接收掃描碼，並將其傳送至鍵盤配置，並將其轉譯成電子郵件，並在您的應用程式中張貼至適當的視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-136">The keyboard device driver receives scan codes from the keyboard, which are sent to the keyboard layout where they are translated into messages and posted to the appropriate windows in your application.</span></span>

<span data-ttu-id="cbe1b-137">指派給鍵盤上的每個索引鍵都是唯一值，稱為「 *掃描碼*」（鍵盤上的按鍵裝置相依識別碼）。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-137">Assigned to each key on a keyboard is a unique value called a *scan code*, a device-dependent identifier for the key on the keyboard.</span></span> <span data-ttu-id="cbe1b-138">當使用者輸入金鑰時，鍵盤會產生兩個掃描代碼—一個是在使用者按下按鍵時，另一個是在使用者釋放金鑰時使用。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-138">A keyboard generates two scan codes when the user types a key—one when the user presses the key and another when the user releases the key.</span></span>

<span data-ttu-id="cbe1b-139">鍵盤設備磁碟機會轉譯掃描程式碼，並將 (對應) 它轉譯為 *虛擬按鍵程式碼*，這是由系統定義的裝置獨立值，用以識別金鑰的用途。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-139">The keyboard device driver interprets a scan code and translates (maps) it to a *virtual-key code*, a device-independent value defined by the system that identifies the purpose of a key.</span></span> <span data-ttu-id="cbe1b-140">轉譯掃描碼之後，鍵盤配置會建立一則訊息，其中包含掃描碼、虛擬機器碼和其他有關按鍵的資訊，然後將訊息放在系統訊息佇列中。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-140">After translating a scan code, the keyboard layout creates a message that includes the scan code, the virtual-key code, and other information about the keystroke, and then places the message in the system message queue.</span></span> <span data-ttu-id="cbe1b-141">系統會從系統訊息佇列中移除訊息，並將它張貼到適當執行緒的訊息佇列。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-141">The system removes the message from the system message queue and posts it to the message queue of the appropriate thread.</span></span> <span data-ttu-id="cbe1b-142">最後，執行緒的訊息迴圈會移除訊息，並將訊息傳遞至適當的視窗程式進行處理。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-142">Eventually, the thread's message loop removes the message and passes it to the appropriate window procedure for processing.</span></span> <span data-ttu-id="cbe1b-143">下圖說明鍵盤輸入模型。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-143">The following figure illustrates the keyboard input model.</span></span>

![鍵盤輸入處理模型](images/csinp-01.png)

## <a name="keyboard-focus-and-activation"></a><span data-ttu-id="cbe1b-145">鍵盤焦點和啟用</span><span class="sxs-lookup"><span data-stu-id="cbe1b-145">Keyboard Focus and Activation</span></span>

<span data-ttu-id="cbe1b-146">系統會將鍵盤訊息張貼至使用鍵盤焦點建立視窗之前景執行緒的訊息佇列。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-146">The system posts keyboard messages to the message queue of the foreground thread that created the window with the keyboard focus.</span></span> <span data-ttu-id="cbe1b-147">*鍵盤焦點* 是視窗的暫時屬性。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-147">The *keyboard focus* is a temporary property of a window.</span></span> <span data-ttu-id="cbe1b-148">系統會將鍵盤焦點（以使用者的方向）移至另一個視窗，以在顯示的所有視窗之間共用鍵盤。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-148">The system shares the keyboard among all windows on the display by shifting the keyboard focus, at the user's direction, from one window to another.</span></span> <span data-ttu-id="cbe1b-149">具有鍵盤焦點的視窗會從建立它) 所有鍵盤訊息的執行緒訊息佇列接收 (，直到焦點變更為不同的視窗為止。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-149">The window that has the keyboard focus receives (from the message queue of the thread that created it) all keyboard messages until the focus changes to a different window.</span></span>

<span data-ttu-id="cbe1b-150">如果任何) 目前有鍵盤焦點，執行緒可以呼叫 [**GetFocus**](/windows/win32/api/winuser/nf-winuser-getfocus) 函式來判斷哪個視窗 (。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-150">A thread can call the [**GetFocus**](/windows/win32/api/winuser/nf-winuser-getfocus) function to determine which of its windows (if any) currently has the keyboard focus.</span></span> <span data-ttu-id="cbe1b-151">執行緒可以呼叫 [**SetFocus**](/windows/win32/api/winuser/nf-winuser-setfocus) 函式，將鍵盤焦點提供給其中一個視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-151">A thread can give the keyboard focus to one of its windows by calling the [**SetFocus**](/windows/win32/api/winuser/nf-winuser-setfocus) function.</span></span> <span data-ttu-id="cbe1b-152">當鍵盤焦點從某個視窗變更為另一個視窗時，系統會將 [**wm \_ KILLFOCUS**](wm-killfocus.md) 訊息傳送至已失去焦點的視窗，然後將 [**wm \_ SETFOCUS**](wm-setfocus.md) 訊息傳送至已取得焦點的視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-152">When the keyboard focus changes from one window to another, the system sends a [**WM\_KILLFOCUS**](wm-killfocus.md) message to the window that has lost the focus, and then sends a [**WM\_SETFOCUS**](wm-setfocus.md) message to the window that has gained the focus.</span></span>

<span data-ttu-id="cbe1b-153">鍵盤焦點的概念與使用中視窗的概念有關。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-153">The concept of keyboard focus is related to that of the active window.</span></span> <span data-ttu-id="cbe1b-154">*使用中視窗* 是使用者目前正在處理的最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-154">The *active window* is the top-level window the user is currently working with.</span></span> <span data-ttu-id="cbe1b-155">具有鍵盤焦點的視窗是使用中視窗，或是使用中視窗的子視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-155">The window with the keyboard focus is either the active window, or a child window of the active window.</span></span> <span data-ttu-id="cbe1b-156">為了協助使用者識別使用中視窗，系統會將它放在 Z 順序的頂端，並反白顯示其標題列 (如果有一個) 和框線。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-156">To help the user identify the active window, the system places it at the top of the Z order and highlights its title bar (if it has one) and border.</span></span>

<span data-ttu-id="cbe1b-157">使用者可以藉由按一下來啟動最上層視窗，並使用 ALT + TAB 或 ALT + ESC 鍵組合來選取它，或從工作清單中選取它。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-157">The user can activate a top-level window by clicking it, selecting it using the ALT+TAB or ALT+ESC key combination, or selecting it from the Task List.</span></span> <span data-ttu-id="cbe1b-158">執行緒可以使用 [**SetActiveWindow**](/windows/win32/api/winuser/nf-winuser-setactivewindow) 函數來啟動最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-158">A thread can activate a top-level window by using the [**SetActiveWindow**](/windows/win32/api/winuser/nf-winuser-setactivewindow) function.</span></span> <span data-ttu-id="cbe1b-159">它可以使用 [**GetActiveWindow**](/windows/win32/api/winuser/nf-winuser-getactivewindow) 函式來判斷它所建立的最上層視窗是否作用中。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-159">It can determine whether a top-level window it created is active by using the [**GetActiveWindow**](/windows/win32/api/winuser/nf-winuser-getactivewindow) function.</span></span>

<span data-ttu-id="cbe1b-160">當停用某個視窗並啟用另一個視窗時，系統會傳送 [**WM \_ 啟動**](wm-activate.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-160">When one window is deactivated and another activated, the system sends the [**WM\_ACTIVATE**](wm-activate.md) message.</span></span> <span data-ttu-id="cbe1b-161">如果停用視窗， *wParam* 參數的低序位字組為零，如果正在啟用，則為非零。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-161">The low-order word of the *wParam* parameter is zero if the window is being deactivated and nonzero if it is being activated.</span></span> <span data-ttu-id="cbe1b-162">當預設視窗程式收到 **WM \_ 啟動** 訊息時，它會將鍵盤焦點設定為使用中視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-162">When the default window procedure receives the **WM\_ACTIVATE** message, it sets the keyboard focus to the active window.</span></span>

<span data-ttu-id="cbe1b-163">若要防止鍵盤和滑鼠輸入事件到達應用程式，請使用 [**BlockInput**](/windows/win32/api/winuser/nf-winuser-blockinput)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-163">To block keyboard and mouse input events from reaching applications, use [**BlockInput**](/windows/win32/api/winuser/nf-winuser-blockinput).</span></span> <span data-ttu-id="cbe1b-164">請注意， **BlockInput** 函數不會干擾非同步鍵盤輸入狀態資料表。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-164">Note, the **BlockInput** function will not interfere with the asynchronous keyboard input-state table.</span></span> <span data-ttu-id="cbe1b-165">這表示在封鎖輸入時呼叫 [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) 函式，將會變更非同步鍵盤輸入狀態資料表。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-165">This means that calling the [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) function while input is blocked will change the asynchronous keyboard input-state table.</span></span>

## <a name="keystroke-messages"></a><span data-ttu-id="cbe1b-166">按鍵訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-166">Keystroke Messages</span></span>

<span data-ttu-id="cbe1b-167">按下按鍵會將 [**wm 的 \_ KEYDOWN**](wm-keydown.md) 或 [**WM \_ SYSKEYDOWN**](wm-syskeydown.md) 訊息放置在附加至具有鍵盤焦點之視窗的執行緒訊息佇列中。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-167">Pressing a key causes a [**WM\_KEYDOWN**](wm-keydown.md) or [**WM\_SYSKEYDOWN**](wm-syskeydown.md) message to be placed in the thread message queue attached to the window that has the keyboard focus.</span></span> <span data-ttu-id="cbe1b-168">釋放金鑰會導致將 [**wm 的 \_ KEYUP**](wm-keyup.md) 或 [**wm \_ SYSKEYUP**](wm-syskeyup.md) 訊息放置在佇列中。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-168">Releasing a key causes a [**WM\_KEYUP**](wm-keyup.md) or [**WM\_SYSKEYUP**](wm-syskeyup.md) message to be placed in the queue.</span></span>

<span data-ttu-id="cbe1b-169">索引鍵和索引鍵的訊息通常會成對出現，但如果使用者的金鑰夠長而無法啟動鍵盤的自動重複功能，則系統會在資料列中產生數個 [**WM 的 \_ KEYDOWN**](wm-keydown.md) 或 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-169">Key-up and key-down messages typically occur in pairs, but if the user holds down a key long enough to start the keyboard's automatic repeat feature, the system generates a number of [**WM\_KEYDOWN**](wm-keydown.md) or [**WM\_SYSKEYDOWN**](wm-syskeydown.md) messages in a row.</span></span> <span data-ttu-id="cbe1b-170">然後，它會在使用者釋放金鑰時產生單一 [**wm \_ KEYUP**](wm-keyup.md) 或 [**WM \_ SYSKEYUP**](wm-syskeyup.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-170">It then generates a single [**WM\_KEYUP**](wm-keyup.md) or [**WM\_SYSKEYUP**](wm-syskeyup.md) message when the user releases the key.</span></span>

<span data-ttu-id="cbe1b-171">本節包含下列主題：</span><span class="sxs-lookup"><span data-stu-id="cbe1b-171">This section covers the following topics:</span></span>

-   [<span data-ttu-id="cbe1b-172">系統和非系統的按鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-172">System and Nonsystem Keystrokes</span></span>](#system-and-nonsystem-keystrokes)
-   [<span data-ttu-id="cbe1b-173">描述的虛擬金鑰碼</span><span class="sxs-lookup"><span data-stu-id="cbe1b-173">Virtual-Key Codes Described</span></span>](#virtual-key-codes-described)
-   [<span data-ttu-id="cbe1b-174">按鍵訊息旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-174">Keystroke Message Flags</span></span>](#keystroke-message-flags)

### <a name="system-and-nonsystem-keystrokes"></a><span data-ttu-id="cbe1b-175">系統和非系統的按鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-175">System and Nonsystem Keystrokes</span></span>

<span data-ttu-id="cbe1b-176">系統會區分系統擊鍵和非系統按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-176">The system makes a distinction between system keystrokes and nonsystem keystrokes.</span></span> <span data-ttu-id="cbe1b-177">系統擊鍵會產生系統擊鍵訊息、 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md) 和 [**wm \_ SYSKEYUP**](wm-syskeyup.md)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-177">System keystrokes produce system keystroke messages, [**WM\_SYSKEYDOWN**](wm-syskeydown.md) and [**WM\_SYSKEYUP**](wm-syskeyup.md).</span></span> <span data-ttu-id="cbe1b-178">非系統擊鍵會產生非系統的按鍵訊息、 [**wm 的 \_ KEYDOWN**](wm-keydown.md) 和 [**wm \_ KEYUP**](wm-keyup.md)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-178">Nonsystem keystrokes produce nonsystem keystroke messages, [**WM\_KEYDOWN**](wm-keydown.md) and [**WM\_KEYUP**](wm-keyup.md).</span></span>

<span data-ttu-id="cbe1b-179">如果您的視窗程式必須處理系統擊鍵訊息，請確定在處理訊息之後，程式會將它傳遞至 [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 函式。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-179">If your window procedure must process a system keystroke message, make sure that after processing the message the procedure passes it to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function.</span></span> <span data-ttu-id="cbe1b-180">否則，每當視窗具有鍵盤焦點時，就會停用所有涉及 ALT 鍵的系統作業。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-180">Otherwise, all system operations involving the ALT key will be disabled whenever the window has the keyboard focus.</span></span> <span data-ttu-id="cbe1b-181">也就是說，使用者將無法存取視窗的功能表或系統功能表，也無法使用 ALT + ESC 或 ALT + TAB 鍵組合來啟用不同的視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-181">That is, the user won't be able to access the window's menus or System menu, or use the ALT+ESC or ALT+TAB key combination to activate a different window.</span></span>

<span data-ttu-id="cbe1b-182">系統擊鍵訊息主要是供系統使用，而不是應用程式使用。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-182">System keystroke messages are primarily for use by the system rather than by an application.</span></span> <span data-ttu-id="cbe1b-183">系統會使用它們來提供內建的鍵盤介面給功能表，並允許使用者控制作用中的視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-183">The system uses them to provide its built-in keyboard interface to menus and to allow the user to control which window is active.</span></span> <span data-ttu-id="cbe1b-184">當使用者以 ALT 鍵組合輸入按鍵，或是當使用者輸入和沒有視窗具有鍵盤 (焦點時，例如當使用中應用程式的最小化) 時，就會產生系統擊鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-184">System keystroke messages are generated when the user types a key in combination with the ALT key, or when the user types and no window has the keyboard focus (for example, when the active application is minimized).</span></span> <span data-ttu-id="cbe1b-185">在此情況下，訊息會張貼至附加至使用中視窗的訊息佇列。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-185">In this case, the messages are posted to the message queue attached to the active window.</span></span>

<span data-ttu-id="cbe1b-186">應用程式視窗使用非系統的擊鍵訊息; [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 函數不會執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-186">Nonsystem keystroke messages are for use by application windows; the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function does nothing with them.</span></span> <span data-ttu-id="cbe1b-187">視窗程式可能會捨棄不需要的任何非系統擊鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-187">A window procedure can discard any nonsystem keystroke messages that it does not need.</span></span>

### <a name="virtual-key-codes-described"></a><span data-ttu-id="cbe1b-188">描述的 Virtual-Key 碼</span><span class="sxs-lookup"><span data-stu-id="cbe1b-188">Virtual-Key Codes Described</span></span>

<span data-ttu-id="cbe1b-189">擊鍵訊息的 **wParam** 參數包含已按下或已釋放之金鑰的虛擬機器碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-189">The **wParam** parameter of a keystroke message contains the virtual-key code of the key that was pressed or released.</span></span> <span data-ttu-id="cbe1b-190">視窗程式會根據虛擬機器碼的值來處理或忽略按鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-190">A window procedure processes or ignores a keystroke message, depending on the value of the virtual-key code.</span></span>

<span data-ttu-id="cbe1b-191">一般的視窗程式只會處理它所接收之按鍵訊息的一小部分，並忽略其餘的部分。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-191">A typical window procedure processes only a small subset of the keystroke messages that it receives and ignores the rest.</span></span> <span data-ttu-id="cbe1b-192">例如，視窗程式可能只會處理 [**WM 的 \_ KEYDOWN**](wm-keydown.md) 按鍵訊息，而且只會處理包含資料指標移動索引鍵的虛擬機器碼、shift 鍵 (也稱為控制項索引鍵) 和功能鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-192">For example, a window procedure might process only [**WM\_KEYDOWN**](wm-keydown.md) keystroke messages, and only those that contain virtual-key codes for the cursor movement keys, shift keys (also called control keys), and function keys.</span></span> <span data-ttu-id="cbe1b-193">一般的視窗程式不會處理來自字元鍵的按鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-193">A typical window procedure does not process keystroke messages from character keys.</span></span> <span data-ttu-id="cbe1b-194">相反地，它會使用 [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) 函數將訊息轉換成字元訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-194">Instead, it uses the [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function to convert the message into character messages.</span></span> <span data-ttu-id="cbe1b-195">如需 **TranslateMessage** 和字元訊息的詳細資訊，請參閱 [字元訊息](#character-messages)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-195">For more information about **TranslateMessage** and character messages, see [Character Messages](#character-messages).</span></span>

### <a name="keystroke-message-flags"></a><span data-ttu-id="cbe1b-196">按鍵訊息旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-196">Keystroke Message Flags</span></span>

<span data-ttu-id="cbe1b-197">擊鍵訊息的 **lParam** 參數包含產生訊息之按鍵的其他相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-197">The **lParam** parameter of a keystroke message contains additional information about the keystroke that generated the message.</span></span> <span data-ttu-id="cbe1b-198">這項資訊包括重複計數、掃描碼、擴充按鍵旗標、內容程式碼、先前的索引鍵狀態旗標，以及轉換狀態旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-198">This information includes the repeat count, the scan code, the extended-key flag, the context code, the previous key-state flag, and the transition-state flag.</span></span> <span data-ttu-id="cbe1b-199">下圖顯示這些旗標和值在 **lParam** 參數中的位置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-199">The following illustration shows the locations of these flags and values in the **lParam** parameter.</span></span>

![按鍵訊息的 lparam 參數中，旗標和值的位置](images/csinp-02.png)

<span data-ttu-id="cbe1b-201">應用程式可以使用下列值來操作按鍵旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-201">An application can use the following values to manipulate the keystroke flags.</span></span>



| <span data-ttu-id="cbe1b-202">值</span><span class="sxs-lookup"><span data-stu-id="cbe1b-202">Value</span></span>            | <span data-ttu-id="cbe1b-203">描述</span><span class="sxs-lookup"><span data-stu-id="cbe1b-203">Description</span></span>                                                                       |
|------------------|-----------------------------------------------------------------------------------|
| <span data-ttu-id="cbe1b-204">**KF \_ ALTDOWN**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-204">**KF\_ALTDOWN**</span></span>  | <span data-ttu-id="cbe1b-205">操作 ALT 鍵旗標，指出是否按下 ALT 鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-205">Manipulates the ALT key flag, which indicates whether the ALT key is pressed.</span></span>     |
| <span data-ttu-id="cbe1b-206">**KF \_ DLGMODE**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-206">**KF\_DLGMODE**</span></span>  | <span data-ttu-id="cbe1b-207">操作對話方塊模式旗標，這個旗標會指出對話方塊是否為使用中狀態。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-207">Manipulates the dialog mode flag, which indicates whether a dialog box is active.</span></span> |
| <span data-ttu-id="cbe1b-208">**KF \_ 擴充**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-208">**KF\_EXTENDED**</span></span> | <span data-ttu-id="cbe1b-209">操控擴充按鍵旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-209">Manipulates the extended key flag.</span></span>                                                |
| <span data-ttu-id="cbe1b-210">**KF \_ MENUMODE**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-210">**KF\_MENUMODE**</span></span> | <span data-ttu-id="cbe1b-211">操作功能表模式旗標，指出功能表是否為作用中。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-211">Manipulates the menu mode flag, which indicates whether a menu is active.</span></span>         |
| <span data-ttu-id="cbe1b-212">**KF \_ 重複**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-212">**KF\_REPEAT**</span></span>   | <span data-ttu-id="cbe1b-213">操作先前的金鑰狀態旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-213">Manipulates the previous key state flag.</span></span>                                          |
| <span data-ttu-id="cbe1b-214">**\_向上 KF**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-214">**KF\_UP**</span></span>       | <span data-ttu-id="cbe1b-215">操縱轉換狀態旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-215">Manipulates the transition state flag.</span></span>                                            |



 

### <a name="repeat-count"></a><span data-ttu-id="cbe1b-216">重複計數</span><span class="sxs-lookup"><span data-stu-id="cbe1b-216">Repeat Count</span></span>

<span data-ttu-id="cbe1b-217">您可以檢查 [重複計數] 來判斷擊鍵訊息是否代表一個以上的按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-217">You can check the repeat count to determine whether a keystroke message represents more than one keystroke.</span></span> <span data-ttu-id="cbe1b-218">系統會在鍵盤產生 [**wm 的 \_ KEYDOWN**](wm-keydown.md) 或 [**WM \_ SYSKEYDOWN**](wm-syskeydown.md) 訊息時，以比應用程式可以處理它們更快的速度來遞增計數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-218">The system increments the count when the keyboard generates [**WM\_KEYDOWN**](wm-keydown.md) or [**WM\_SYSKEYDOWN**](wm-syskeydown.md) messages faster than an application can process them.</span></span> <span data-ttu-id="cbe1b-219">這種情況通常發生在使用者所需的時間夠長，以啟動鍵盤的自動重複功能時。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-219">This often occurs when the user holds down a key long enough to start the keyboard's automatic repeat feature.</span></span> <span data-ttu-id="cbe1b-220">系統不會使用產生的索引鍵關閉訊息來填滿系統訊息佇列，而是將訊息合併成單一金鑰的下一則訊息，並遞增重複計數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-220">Instead of filling the system message queue with the resulting key-down messages, the system combines the messages into a single key down message and increments the repeat count.</span></span> <span data-ttu-id="cbe1b-221">釋出金鑰無法啟動自動重複功能，因此， [**wm \_ KEYUP**](wm-keyup.md) 和 [**wm \_ SYSKEYUP**](wm-syskeyup.md) 訊息的重複計數一律設定為1。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-221">Releasing a key cannot start the automatic repeat feature, so the repeat count for [**WM\_KEYUP**](wm-keyup.md) and [**WM\_SYSKEYUP**](wm-syskeyup.md) messages is always set to 1.</span></span>

### <a name="scan-code"></a><span data-ttu-id="cbe1b-222">掃描程式碼</span><span class="sxs-lookup"><span data-stu-id="cbe1b-222">Scan Code</span></span>

<span data-ttu-id="cbe1b-223">掃描碼是當使用者按下按鍵時，鍵盤硬體所產生的值。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-223">The scan code is the value that the keyboard hardware generates when the user presses a key.</span></span> <span data-ttu-id="cbe1b-224">它是裝置相依的值，用來識別已按下的按鍵，而不是索引鍵所代表的字元。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-224">It is a device-dependent value that identifies the key pressed, as opposed to the character represented by the key.</span></span> <span data-ttu-id="cbe1b-225">應用程式通常會忽略掃描程式碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-225">An application typically ignores scan codes.</span></span> <span data-ttu-id="cbe1b-226">相反地，它會使用裝置獨立的虛擬金鑰碼來解讀按鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-226">Instead, it uses the device-independent virtual-key codes to interpret keystroke messages.</span></span>

### <a name="extended-key-flag"></a><span data-ttu-id="cbe1b-227">Extended-Key 旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-227">Extended-Key Flag</span></span>

<span data-ttu-id="cbe1b-228">擴充按鍵旗標會指出擊鍵訊息是否源自增強型鍵盤上的其中一個額外的按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-228">The extended-key flag indicates whether the keystroke message originated from one of the additional keys on the enhanced keyboard.</span></span> <span data-ttu-id="cbe1b-229">擴充的按鍵包含鍵盤右手邊的 ALT 和 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;NUM LOCK 鍵;中斷 (CTRL + PAUSE) 鍵;PRINT SCRN 鍵;並將 (/) ，然後在數位鍵台中輸入按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-229">The extended keys consist of the ALT and CTRL keys on the right-hand side of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; the NUM LOCK key; the BREAK (CTRL+PAUSE) key; the PRINT SCRN key; and the divide (/) and ENTER keys in the numeric keypad.</span></span> <span data-ttu-id="cbe1b-230">如果金鑰是擴充索引鍵，則會設定擴充按鍵旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-230">The extended-key flag is set if the key is an extended key.</span></span>

### <a name="context-code"></a><span data-ttu-id="cbe1b-231">內容程式碼</span><span class="sxs-lookup"><span data-stu-id="cbe1b-231">Context Code</span></span>

<span data-ttu-id="cbe1b-232">內容程式碼指出當產生按鍵訊息時，ALT 鍵是否已關閉。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-232">The context code indicates whether the ALT key was down when the keystroke message was generated.</span></span> <span data-ttu-id="cbe1b-233">如果 ALT 鍵已關閉，則程式碼為1，如果已啟動則為0。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-233">The code is 1 if the ALT key was down and 0 if it was up.</span></span>

### <a name="previous-key-state-flag"></a><span data-ttu-id="cbe1b-234">上一個 Key-State 旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-234">Previous Key-State Flag</span></span>

<span data-ttu-id="cbe1b-235">先前的索引鍵狀態旗標會指出產生按鍵訊息的索引鍵先前是否已啟動或關閉。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-235">The previous key-state flag indicates whether the key that generated the keystroke message was previously up or down.</span></span> <span data-ttu-id="cbe1b-236">如果索引鍵之前已關閉，則為1，如果索引鍵先前已啟動，則為0。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-236">It is 1 if the key was previously down and 0 if the key was previously up.</span></span> <span data-ttu-id="cbe1b-237">您可以使用此旗標來識別鍵盤自動重複功能所產生的按鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-237">You can use this flag to identify keystroke messages generated by the keyboard's automatic repeat feature.</span></span> <span data-ttu-id="cbe1b-238">此旗標會設定為1，代表自動重複功能所產生的 [**wm \_ KEYDOWN**](wm-keydown.md) 和 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md) 擊鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-238">This flag is set to 1 for [**WM\_KEYDOWN**](wm-keydown.md) and [**WM\_SYSKEYDOWN**](wm-syskeydown.md) keystroke messages generated by the automatic repeat feature.</span></span> <span data-ttu-id="cbe1b-239">對於 [**wm 的 \_ KEYUP**](wm-keyup.md) 和 [**wm \_ SYSKEYUP**](wm-syskeyup.md) 訊息，一律會設定為1。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-239">It is always set to 1 for [**WM\_KEYUP**](wm-keyup.md) and [**WM\_SYSKEYUP**](wm-syskeyup.md) messages.</span></span>

### <a name="transition-state-flag"></a><span data-ttu-id="cbe1b-240">Transition-State 旗標</span><span class="sxs-lookup"><span data-stu-id="cbe1b-240">Transition-State Flag</span></span>

<span data-ttu-id="cbe1b-241">轉換狀態旗標會指出按下按鍵或釋放金鑰是否產生按鍵訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-241">The transition-state flag indicates whether pressing a key or releasing a key generated the keystroke message.</span></span> <span data-ttu-id="cbe1b-242">針對 [**wm \_ KEYDOWN**](wm-keydown.md) 和 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md) 訊息，此旗標一律設為 0; 對於 [**wm \_ KEYUP**](wm-keyup.md) 和 [**wm \_ SYSKEYUP**](wm-syskeyup.md) 訊息，此旗標一律設定為1。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-242">This flag is always set to 0 for [**WM\_KEYDOWN**](wm-keydown.md) and [**WM\_SYSKEYDOWN**](wm-syskeydown.md) messages; it is always set to 1 for [**WM\_KEYUP**](wm-keyup.md) and [**WM\_SYSKEYUP**](wm-syskeyup.md) messages.</span></span>

## <a name="character-messages"></a><span data-ttu-id="cbe1b-243">字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-243">Character Messages</span></span>

<span data-ttu-id="cbe1b-244">擊鍵訊息提供許多關於按鍵的資訊，但不提供字元碼來進行字元按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-244">Keystroke messages provide a lot of information about keystrokes, but they do not provide character codes for character keystrokes.</span></span> <span data-ttu-id="cbe1b-245">若要取出字元碼，應用程式必須在其執行緒訊息迴圈中包含 [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) 函數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-245">To retrieve character codes, an application must include the [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function in its thread message loop.</span></span> <span data-ttu-id="cbe1b-246">**TranslateMessage** 會將 [**Wm \_ KEYDOWN**](wm-keydown.md) 或 [**WM \_ SYSKEYDOWN**](wm-syskeydown.md) 訊息傳遞至鍵盤配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-246">**TranslateMessage** passes a [**WM\_KEYDOWN**](wm-keydown.md) or [**WM\_SYSKEYDOWN**](wm-syskeydown.md) message to the keyboard layout.</span></span> <span data-ttu-id="cbe1b-247">配置會檢查訊息的虛擬機器碼，如果它對應至字元索引鍵，則會提供對等的字元碼 (將 SHIFT 和 CAPS LOCK 索引鍵) 的狀態納入考慮。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-247">The layout examines the message's virtual-key code and, if it corresponds to a character key, provides the character code equivalent (taking into account the state of the SHIFT and CAPS LOCK keys).</span></span> <span data-ttu-id="cbe1b-248">然後，它會產生包含字元碼的字元訊息，並將訊息放在訊息佇列的最上方。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-248">It then generates a character message that includes the character code and places the message at the top of the message queue.</span></span> <span data-ttu-id="cbe1b-249">訊息迴圈的下一個反復專案會從佇列中移除字元訊息，然後將訊息分派至適當的視窗程式。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-249">The next iteration of the message loop removes the character message from the queue and dispatches the message to the appropriate window procedure.</span></span>

<span data-ttu-id="cbe1b-250">本節包含下列主題：</span><span class="sxs-lookup"><span data-stu-id="cbe1b-250">This section covers the following topics:</span></span>

-   [<span data-ttu-id="cbe1b-251">非系統字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-251">Nonsystem Character Messages</span></span>](#nonsystem-character-messages)
-   [<span data-ttu-id="cbe1b-252">死字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-252">Dead-Character Messages</span></span>](#dead-character-messages)

### <a name="nonsystem-character-messages"></a><span data-ttu-id="cbe1b-253">非系統字元訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-253">Nonsystem Character Messages</span></span>

<span data-ttu-id="cbe1b-254">視窗程式可以接收下列字元訊息： [**WM \_ CHAR**](wm-char.md)、 [**WM \_ DEADCHAR**](wm-deadchar.md)、 [**wm \_ SYSCHAR**](/windows/desktop/menurc/wm-syschar)、 [**wm \_ SYSDEADCHAR**](wm-sysdeadchar.md)和 [**wm \_ 則 unichar 會**](wm-unichar.md)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-254">A window procedure can receive the following character messages: [**WM\_CHAR**](wm-char.md), [**WM\_DEADCHAR**](wm-deadchar.md), [**WM\_SYSCHAR**](/windows/desktop/menurc/wm-syschar), [**WM\_SYSDEADCHAR**](wm-sysdeadchar.md), and [**WM\_UNICHAR**](wm-unichar.md).</span></span> <span data-ttu-id="cbe1b-255">[**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage)函式會在處理 [**wm \_ KEYDOWN**](wm-keydown.md)訊息時產生 **wm \_ CHAR** 或 **wm \_ DEADCHAR** 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-255">The [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function generates a **WM\_CHAR** or **WM\_DEADCHAR** message when it processes a [**WM\_KEYDOWN**](wm-keydown.md) message.</span></span> <span data-ttu-id="cbe1b-256">同樣地，它會在處理 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md)訊息時產生 **wm \_ SYSCHAR** 或 **WM \_ SYSDEADCHAR** 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-256">Similarly, it generates a **WM\_SYSCHAR** or **WM\_SYSDEADCHAR** message when it processes a [**WM\_SYSKEYDOWN**](wm-syskeydown.md) message.</span></span>

<span data-ttu-id="cbe1b-257">處理鍵盤輸入的應用程式通常會忽略所有的 [**wm \_ CHAR**](wm-char.md) 和 [**WM \_ 則 unichar 會**](wm-unichar.md) 訊息，而將任何其他訊息傳遞至 [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 函式。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-257">An application that processes keyboard input typically ignores all but the [**WM\_CHAR**](wm-char.md) and [**WM\_UNICHAR**](wm-unichar.md) messages, passing any other messages to the [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) function.</span></span> <span data-ttu-id="cbe1b-258">請注意，當 **wm \_ 則 unichar 會** 使用 32 Utf-16 時， **wm \_ CHAR** 會使用16位 Unicode 轉換格式 (utf-16) 。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-258">Note that **WM\_CHAR** uses 16-bit Unicode Transformation Format (UTF) while **WM\_UNICHAR** uses UTF-32.</span></span> <span data-ttu-id="cbe1b-259">系統會使用 [**wm \_ SYSCHAR**](/windows/desktop/menurc/wm-syschar) 和 [**wm \_ SYSDEADCHAR**](wm-sysdeadchar.md) 訊息來執行功能表的助憶鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-259">The system uses the [**WM\_SYSCHAR**](/windows/desktop/menurc/wm-syschar) and [**WM\_SYSDEADCHAR**](wm-sysdeadchar.md) messages to implement menu mnemonics.</span></span>

<span data-ttu-id="cbe1b-260">所有字元訊息的 **wParam** 參數都包含已按下之字元碼的字元碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-260">The **wParam** parameter of all character messages contains the character code of the character key that was pressed.</span></span> <span data-ttu-id="cbe1b-261">字元碼的值取決於接收訊息之視窗的視窗類別。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-261">The value of the character code depends on the window class of the window receiving the message.</span></span> <span data-ttu-id="cbe1b-262">如果使用 Unicode 版本的 [**RegisterClass**](/windows/desktop/api/winuser/nf-winuser-registerclassa) 函式來註冊視窗類別，系統就會提供 unicode 字元給該類別的所有視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-262">If the Unicode version of the [**RegisterClass**](/windows/desktop/api/winuser/nf-winuser-registerclassa) function was used to register the window class, the system provides Unicode characters to all windows of that class.</span></span> <span data-ttu-id="cbe1b-263">否則，系統會提供 ASCII 字元碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-263">Otherwise, the system provides ASCII character codes.</span></span> <span data-ttu-id="cbe1b-264">如需詳細資訊，請參閱 [Unicode 和字元集](/windows/desktop/Intl/unicode-and-character-sets)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-264">For more information, see [Unicode and Character Sets](/windows/desktop/Intl/unicode-and-character-sets).</span></span>

<span data-ttu-id="cbe1b-265">字元訊息的 **lParam** 參數內容，與已轉譯為產生字元訊息的索引鍵的 **lParam** 參數內容相同。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-265">The contents of the **lParam** parameter of a character message are identical to the contents of the **lParam** parameter of the key-down message that was translated to produce the character message.</span></span> <span data-ttu-id="cbe1b-266">如需詳細資訊，請參閱 [按鍵訊息旗標](#keystroke-message-flags)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-266">For information, see [Keystroke Message Flags](#keystroke-message-flags).</span></span>

### <a name="dead-character-messages"></a><span data-ttu-id="cbe1b-267">Dead-Character 訊息</span><span class="sxs-lookup"><span data-stu-id="cbe1b-267">Dead-Character Messages</span></span>

<span data-ttu-id="cbe1b-268">某些非英文鍵盤會包含不需要自行產生字元的字元索引鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-268">Some non-English keyboards contain character keys that are not expected to produce characters by themselves.</span></span> <span data-ttu-id="cbe1b-269">相反地，它們是用來將文字元號新增到後續按鍵產生的字元。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-269">Instead, they are used to add a diacritic to the character produced by the subsequent keystroke.</span></span> <span data-ttu-id="cbe1b-270">這些機碼稱為「 *死索引鍵*」。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-270">These keys are called *dead keys*.</span></span> <span data-ttu-id="cbe1b-271">德文鍵盤上的揚抑符號鍵是死索引鍵的範例。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-271">The circumflex key on a German keyboard is an example of a dead key.</span></span> <span data-ttu-id="cbe1b-272">若要輸入包含 "o" 的字元加上揚揚碼，德文使用者會輸入以抑揚的字元，並在後面加上 "o" 鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-272">To enter the character consisting of an "o" with a circumflex, a German user would type the circumflex key followed by the "o" key.</span></span> <span data-ttu-id="cbe1b-273">具有鍵盤焦點的視窗會收到下列一連串的訊息：</span><span class="sxs-lookup"><span data-stu-id="cbe1b-273">The window with the keyboard focus would receive the following sequence of messages:</span></span>

1.  [<span data-ttu-id="cbe1b-274">**WM \_ KEYDOWN**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-274">**WM\_KEYDOWN**</span></span>](wm-keydown.md)
2.  [<span data-ttu-id="cbe1b-275">**WM \_ DEADCHAR**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-275">**WM\_DEADCHAR**</span></span>](wm-deadchar.md)
3.  [<span data-ttu-id="cbe1b-276">**WM \_ KEYUP**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-276">**WM\_KEYUP**</span></span>](wm-keyup.md)
4.  [<span data-ttu-id="cbe1b-277">**WM \_ KEYDOWN**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-277">**WM\_KEYDOWN**</span></span>](wm-keydown.md)
5.  [<span data-ttu-id="cbe1b-278">**WM \_ 字元**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-278">**WM\_CHAR**</span></span>](wm-char.md)
6.  [<span data-ttu-id="cbe1b-279">**WM \_ KEYUP**</span><span class="sxs-lookup"><span data-stu-id="cbe1b-279">**WM\_KEYUP**</span></span>](wm-keyup.md)

<span data-ttu-id="cbe1b-280">[**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage)會在處理來自無作用金鑰的 [**wm \_ KEYDOWN**](wm-keydown.md)訊息時產生 [**wm \_ DEADCHAR**](wm-deadchar.md)訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-280">[**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) generates the [**WM\_DEADCHAR**](wm-deadchar.md) message when it processes the [**WM\_KEYDOWN**](wm-keydown.md) message from a dead key.</span></span> <span data-ttu-id="cbe1b-281">雖然 **WM \_ DEADCHAR** 訊息的 *wParam* 參數包含死碼之變音符號的字元碼，但應用程式通常會忽略該訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-281">Although the *wParam* parameter of the **WM\_DEADCHAR** message contains the character code of the diacritic for the dead key, an application typically ignores the message.</span></span> <span data-ttu-id="cbe1b-282">相反地，它會處理後續擊鍵所產生的 [**WM \_ 字元**](wm-char.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-282">Instead, it processes the [**WM\_CHAR**](wm-char.md) message generated by the subsequent keystroke.</span></span> <span data-ttu-id="cbe1b-283">**WM \_ 字元** 訊息的 *wParam* 參數包含字母的字元碼加上變音符號。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-283">The *wParam* parameter of the **WM\_CHAR** message contains the character code of the letter with the diacritic.</span></span> <span data-ttu-id="cbe1b-284">如果後續的按鍵產生的字元無法與文字元號結合，系統就會產生兩個 **WM \_ 字元** 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-284">If the subsequent keystroke generates a character that cannot be combined with a diacritic, the system generates two **WM\_CHAR** messages.</span></span> <span data-ttu-id="cbe1b-285">第一個的 *wParam* 參數包含變音符號的字元碼;第二個的 *wParam* 參數包含後續字元索引鍵的字元碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-285">The *wParam* parameter of the first contains the character code of the diacritic; the *wParam* parameter of the second contains the character code of the subsequent character key.</span></span>

<span data-ttu-id="cbe1b-286">[**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage)函式會在處理來自系統失效金鑰的 [**wm \_ SYSKEYDOWN**](wm-syskeydown.md)訊息時產生 [**wm \_ SYSDEADCHAR**](wm-sysdeadchar.md)訊息 (與 ALT 鍵) 組合的無作用索引鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-286">The [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function generates the [**WM\_SYSDEADCHAR**](wm-sysdeadchar.md) message when it processes the [**WM\_SYSKEYDOWN**](wm-syskeydown.md) message from a system dead key (a dead key that is pressed in combination with the ALT key).</span></span> <span data-ttu-id="cbe1b-287">應用程式通常會忽略 **WM \_ SYSDEADCHAR** 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-287">An application typically ignores the **WM\_SYSDEADCHAR** message.</span></span>

## <a name="key-status"></a><span data-ttu-id="cbe1b-288">金鑰狀態</span><span class="sxs-lookup"><span data-stu-id="cbe1b-288">Key Status</span></span>

<span data-ttu-id="cbe1b-289">處理鍵盤訊息時，應用程式可能需要判斷另一個索引鍵的狀態（除了產生目前訊息的金鑰以外）。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-289">While processing a keyboard message, an application may need to determine the status of another key besides the one that generated the current message.</span></span> <span data-ttu-id="cbe1b-290">例如，可讓使用者按下 SHIFT + END 鍵來選取一段文字的文字處理應用程式，必須在每次從結尾按鍵收到按鍵訊息時，檢查 SHIFT 鍵的狀態。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-290">For example, a word-processing application that allows the user to press SHIFT+END to select a block of text must check the status of the SHIFT key whenever it receives a keystroke message from the END key.</span></span> <span data-ttu-id="cbe1b-291">應用程式可以使用 [**GetKeyState**](/windows/win32/api/winuser/nf-winuser-getkeystate) 函式，在產生目前的訊息時，判斷虛擬機器碼的狀態。它可以使用 [**GetAsyncKeyState**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) 函式來取得虛擬機器碼的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-291">The application can use the [**GetKeyState**](/windows/win32/api/winuser/nf-winuser-getkeystate) function to determine the status of a virtual key at the time the current message was generated; it can use the [**GetAsyncKeyState**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) function to retrieve the current status of a virtual key.</span></span>

<span data-ttu-id="cbe1b-292">鍵盤配置會維護名稱清單。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-292">The keyboard layout maintains a list of names.</span></span> <span data-ttu-id="cbe1b-293">產生單一字元的索引鍵名稱與金鑰所產生的字元相同。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-293">The name of a key that produces a single character is the same as the character produced by the key.</span></span> <span data-ttu-id="cbe1b-294">非字元索引鍵（例如 TAB 和 ENTER）的名稱會儲存為字元字串。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-294">The name of a noncharacter key such as TAB and ENTER is stored as a character string.</span></span> <span data-ttu-id="cbe1b-295">應用程式可以藉由呼叫 [**GetKeyNameText**](/windows/win32/api/winuser/nf-winuser-getkeynametexta) 函式，從設備磁碟機取出任何索引鍵的名稱。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-295">An application can retrieve the name of any key from the device driver by calling the [**GetKeyNameText**](/windows/win32/api/winuser/nf-winuser-getkeynametexta) function.</span></span>

## <a name="keystroke-and-character-translations"></a><span data-ttu-id="cbe1b-296">按鍵和字元翻譯</span><span class="sxs-lookup"><span data-stu-id="cbe1b-296">Keystroke and Character Translations</span></span>

<span data-ttu-id="cbe1b-297">系統包含數個特殊用途的函式，這些函式會轉譯各種擊鍵訊息所提供的掃描碼、字元碼和虛擬金鑰代碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-297">The system includes several special purpose functions that translate scan codes, character codes, and virtual-key codes provided by various keystroke messages.</span></span> <span data-ttu-id="cbe1b-298">這些函數包括 [**MapVirtualKey**](/windows/win32/api/winuser/nf-winuser-mapvirtualkeya)、 [**ToAscii**](/windows/win32/api/winuser/nf-winuser-toascii)、 [**ToUnicode**](/windows/win32/api/winuser/nf-winuser-tounicode)和 [**VkKeyScan**](/windows/win32/api/winuser/nf-winuser-vkkeyscana)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-298">These functions include [**MapVirtualKey**](/windows/win32/api/winuser/nf-winuser-mapvirtualkeya), [**ToAscii**](/windows/win32/api/winuser/nf-winuser-toascii), [**ToUnicode**](/windows/win32/api/winuser/nf-winuser-tounicode), and [**VkKeyScan**](/windows/win32/api/winuser/nf-winuser-vkkeyscana).</span></span>

<span data-ttu-id="cbe1b-299">此外，Microsoft Rich Edit 3.0 支援 [HEXTOUNICODE IME](/windows/desktop/Intl/hextounicode-ime)，可讓使用者使用快速鍵在十六進位和 Unicode 字元之間進行轉換。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-299">In addition, Microsoft Rich Edit 3.0 supports the [HexToUnicode IME](/windows/desktop/Intl/hextounicode-ime), which allows a user to convert between hexadecimal and Unicode characters by using hot keys.</span></span> <span data-ttu-id="cbe1b-300">這表示當 Microsoft Rich Edit 3.0 併入應用程式時，應用程式會繼承 HexToUnicode IME 的功能。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-300">This means that when Microsoft Rich Edit 3.0 is incorporated into an application, the application will inherit the features of the HexToUnicode IME.</span></span>

## <a name="hot-key-support"></a><span data-ttu-id="cbe1b-301">Hot-Key 支援</span><span class="sxs-lookup"><span data-stu-id="cbe1b-301">Hot-Key Support</span></span>

<span data-ttu-id="cbe1b-302">快速鍵是產生 [**WM \_ 熱鍵**](wm-hotkey.md)訊息的按鍵組合，*系統會將* 訊息放線上程訊息佇列的頂端，略過佇列中的任何現有訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-302">A *hot key* is a key combination that generates a [**WM\_HOTKEY**](wm-hotkey.md) message, a message the system places at the top of a thread's message queue, bypassing any existing messages in the queue.</span></span> <span data-ttu-id="cbe1b-303">應用程式會使用快速鍵來取得使用者的高優先順序鍵盤輸入。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-303">Applications use hot keys to obtain high-priority keyboard input from the user.</span></span> <span data-ttu-id="cbe1b-304">例如，藉由定義包含 CTRL + C 按鍵組合的熱鍵，應用程式可以讓使用者取消冗長的作業。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-304">For example, by defining a hot key consisting of the CTRL+C key combination, an application can allow the user to cancel a lengthy operation.</span></span>

<span data-ttu-id="cbe1b-305">若要定義快速鍵，應用程式會呼叫 [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) 函式，並指定產生 [**WM \_ 熱鍵**](wm-hotkey.md) 訊息的按鍵組合、接收訊息的視窗控制碼，以及快速鍵的識別碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-305">To define a hot key, an application calls the [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) function, specifying the combination of keys that generates the [**WM\_HOTKEY**](wm-hotkey.md) message, the handle to the window to receive the message, and the identifier of the hot key.</span></span> <span data-ttu-id="cbe1b-306">當使用者按下快速鍵時，會在建立視窗之執行緒的訊息佇列中放置一個 **WM 的 \_ 熱鍵** 訊息。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-306">When the user presses the hot key, a **WM\_HOTKEY** message is placed in the message queue of the thread that created the window.</span></span> <span data-ttu-id="cbe1b-307">訊息的 *wParam* 參數包含快速鍵的識別碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-307">The *wParam* parameter of the message contains the identifier of the hot key.</span></span> <span data-ttu-id="cbe1b-308">應用程式可以定義執行緒的多個快速鍵，但是執行緒中的每個快速鍵都必須有唯一的識別碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-308">The application can define multiple hot keys for a thread, but each hot key in the thread must have a unique identifier.</span></span> <span data-ttu-id="cbe1b-309">應用程式終止之前，應該使用 [**UnregisterHotKey**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) 函式來終結快速鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-309">Before the application terminates, it should use the [**UnregisterHotKey**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) function to destroy the hot key.</span></span>

<span data-ttu-id="cbe1b-310">應用程式可以使用快速鍵控制項，讓使用者可以輕鬆地選擇快速鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-310">Applications can use a hot key control to make it easy for the user to choose a hot key.</span></span> <span data-ttu-id="cbe1b-311">快速鍵控制項通常是用來定義可啟動視窗的快速鍵;它們不會使用 [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) 和 [**UnregisterHotKey**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) 函數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-311">Hot key controls are typically used to define a hot key that activates a window; they do not use the [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) and [**UnregisterHotKey**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) functions.</span></span> <span data-ttu-id="cbe1b-312">相反地，使用快速鍵控制項的應用程式通常會傳送 [**WM \_ SETHOTKEY**](wm-sethotkey.md) 訊息來設定快速鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-312">Instead, an application that uses a hot key control typically sends the [**WM\_SETHOTKEY**](wm-sethotkey.md) message to set the hot key.</span></span> <span data-ttu-id="cbe1b-313">當使用者按下快速鍵時，系統會傳送指定 SC 熱鍵的 [**WM \_ SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) 訊息 \_ 。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-313">Whenever the user presses the hot key, the system sends a [**WM\_SYSCOMMAND**](/windows/desktop/menurc/wm-syscommand) message specifying SC\_HOTKEY.</span></span> <span data-ttu-id="cbe1b-314">如需快速鍵控制項的詳細資訊，請 [參閱快速鍵控制項中的](../controls/hot-key-controls.md)「使用快速鍵控制項」。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-314">For more information about hot key controls, see "Using Hot Key Controls" in [Hot Key Controls](../controls/hot-key-controls.md).</span></span>

## <a name="keyboard-keys-for-browsing-and-other-functions"></a><span data-ttu-id="cbe1b-315">流覽和其他功能的鍵盤按鍵</span><span class="sxs-lookup"><span data-stu-id="cbe1b-315">Keyboard Keys for Browsing and Other Functions</span></span>

<span data-ttu-id="cbe1b-316">Windows 針對瀏覽器函式、媒體功能、應用程式啟動和電源管理提供特殊按鍵的鍵盤支援。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-316">Windows provides support for keyboards with special keys for browser functions, media functions, application launching, and power management.</span></span> <span data-ttu-id="cbe1b-317">[**WM \_ APPCOMMAND**](wm-appcommand.md)支援額外的鍵盤按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-317">The [**WM\_APPCOMMAND**](wm-appcommand.md) supports the extra keyboard keys.</span></span> <span data-ttu-id="cbe1b-318">此外， [**ShellProc**](/previous-versions/windows/desktop/legacy/ms644991(v=vs.85)) 函式會經過修改，以支援額外的鍵盤按鍵。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-318">In addition, the [**ShellProc**](/previous-versions/windows/desktop/legacy/ms644991(v=vs.85)) function is modified to support the extra keyboard keys.</span></span>

<span data-ttu-id="cbe1b-319">元件應用程式中的子視窗不太可能會直接針對這些額外的鍵盤按鍵來執行命令。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-319">It is unlikely that a child window in a component application will be able to directly implement commands for these extra keyboard keys.</span></span> <span data-ttu-id="cbe1b-320">因此，當按下其中一個索引鍵時， [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) 會將 [**WM \_ APPCOMMAND**](wm-appcommand.md) 訊息傳送至視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-320">So when one of these keys is pressed, [**DefWindowProc**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) will send a [**WM\_APPCOMMAND**](wm-appcommand.md) message to a window.</span></span> <span data-ttu-id="cbe1b-321">**DefWindowProc** 也會將 **WM \_ APPCOMMAND** 訊息反升至其父視窗。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-321">**DefWindowProc** will also bubble the **WM\_APPCOMMAND** message to its parent window.</span></span> <span data-ttu-id="cbe1b-322">這與使用滑鼠右鍵叫用快顯功能表的方式類似，也就是 **DefWindowProc** 會在按一下滑鼠右鍵時傳送 [**WM \_ CONTEXTMENU**](/windows/desktop/menurc/wm-contextmenu) 訊息，然後將它反升到其父系。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-322">This is similar to the way context menus are invoked with the right mouse button, which is that **DefWindowProc** sends a [**WM\_CONTEXTMENU**](/windows/desktop/menurc/wm-contextmenu) message on a right button click, and bubbles it to its parent.</span></span> <span data-ttu-id="cbe1b-323">此外，如果 **DefWindowProc** 收到最上層視窗的 **WM \_ APPCOMMAND** 訊息，它就會使用程式碼 **HSHELL \_ APPCOMMAND** 來呼叫 shell 勾點。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-323">Additionally, if **DefWindowProc** receives a **WM\_APPCOMMAND** message for a top-level window, it will call a shell hook with code **HSHELL\_APPCOMMAND**.</span></span>

<span data-ttu-id="cbe1b-324">Windows 也支援 Microsoft 的「智慧按鈕瀏覽器」，這是具有五個按鈕的滑鼠。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-324">Windows also supports the Microsoft IntelliMouse Explorer, which is a mouse with five buttons.</span></span> <span data-ttu-id="cbe1b-325">這兩個額外的按鈕支援向前及向後瀏覽器導覽。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-325">The two extra buttons support forward and backward browser navigation.</span></span> <span data-ttu-id="cbe1b-326">如需詳細資訊，請參閱 [XBUTTONs](about-mouse-input.md)。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-326">For more information, see [XBUTTONs](about-mouse-input.md).</span></span>

## <a name="simulating-input"></a><span data-ttu-id="cbe1b-327">模擬輸入</span><span class="sxs-lookup"><span data-stu-id="cbe1b-327">Simulating Input</span></span>

<span data-ttu-id="cbe1b-328">若要模擬一系列不連續的使用者輸入事件，請使用 [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) 函數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-328">To simulate an uninterrupted series of user input events, use the [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) function.</span></span> <span data-ttu-id="cbe1b-329">函數會接受三個參數。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-329">The function accepts three parameters.</span></span> <span data-ttu-id="cbe1b-330">第一個參數 *cInputs*，表示將模擬的輸入事件數目。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-330">The first parameter, *cInputs*, indicates the number of input events that will be simulated.</span></span> <span data-ttu-id="cbe1b-331">第二個參數 *rgInputs* 是 [**輸入**](/windows/win32/api/winuser/ns-winuser-input) 結構的陣列，每個都描述輸入事件的類型以及該事件的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-331">The second parameter, *rgInputs*, is an array of [**INPUT**](/windows/win32/api/winuser/ns-winuser-input) structures, each describing a type of input event and additional information about that event.</span></span> <span data-ttu-id="cbe1b-332">最後一個參數 *cbSize* 接受 **輸入** 結構的大小（以位元組為單位）。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-332">The last parameter, *cbSize*, accepts the size of the **INPUT** structure, in bytes.</span></span>

<span data-ttu-id="cbe1b-333">[**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput)函式的運作方式是將一連串的模擬輸入事件插入裝置的輸入資料流程。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-333">The [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) function works by injecting a series of simulated input events into a device's input stream.</span></span> <span data-ttu-id="cbe1b-334">這種效果類似于重複呼叫 [**keybd \_ 事件**](/windows/win32/api/winuser/nf-winuser-keybd_event) 或 [**滑鼠 \_ 事件**](/windows/win32/api/winuser/nf-winuser-mouse_event) 函式，不同之處在于系統可確保沒有其他輸入事件與模擬的事件 intermingle。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-334">The effect is similar to calling the [**keybd\_event**](/windows/win32/api/winuser/nf-winuser-keybd_event) or [**mouse\_event**](/windows/win32/api/winuser/nf-winuser-mouse_event) function repeatedly, except that the system ensures that no other input events intermingle with the simulated events.</span></span> <span data-ttu-id="cbe1b-335">當呼叫完成時，傳回值會指出成功播放的輸入事件數目。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-335">When the call completes, the return value indicates the number of input events successfully played.</span></span> <span data-ttu-id="cbe1b-336">如果此值為零，則會封鎖輸入。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-336">If this value is zero, then input was blocked.</span></span>

<span data-ttu-id="cbe1b-337">[**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput)函數不會重設鍵盤的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-337">The [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) function does not reset the keyboard's current state.</span></span> <span data-ttu-id="cbe1b-338">因此，當您呼叫此函式時，如果使用者已按下任何按鍵，則可能會干擾此函式所產生的事件。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-338">Therefore, if the user has any keys pressed when you call this function, they might interfere with the events that this function generates.</span></span> <span data-ttu-id="cbe1b-339">如果您擔心可能的干擾，請使用 [**GetAsyncKeyState**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) 函式檢查鍵盤的狀態，並視需要進行更正。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-339">If you are concerned about possible interference, check the keyboard's state with the [**GetAsyncKeyState**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) function and correct as necessary.</span></span>

## <a name="languages-locales-and-keyboard-layouts"></a><span data-ttu-id="cbe1b-340">語言、地區設定和鍵盤配置</span><span class="sxs-lookup"><span data-stu-id="cbe1b-340">Languages, Locales, and Keyboard Layouts</span></span>

<span data-ttu-id="cbe1b-341">*語言* 是一種自然語言，例如英文、法文和日文。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-341">A *language* is a natural language, such as English, French, and Japanese.</span></span> <span data-ttu-id="cbe1b-342">子 *語言是一* 種自然語言的變異，在特定地理區域中說出，例如英國和美國所說的英文 sublanguages。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-342">A *sublanguage* is a variant of a natural language that is spoken in a specific geographical region, such as the English sublanguages spoken in the United Kingdom and the United States.</span></span> <span data-ttu-id="cbe1b-343">應用程式會使用稱為 [語言識別項](/windows/desktop/Intl/language-identifiers)的值，來唯一識別語言和 sublanguages。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-343">Applications use values, called [language identifiers](/windows/desktop/Intl/language-identifiers), to uniquely identify languages and sublanguages.</span></span>

<span data-ttu-id="cbe1b-344">應用程式通常會使用 *地區* 設定來設定用來處理輸入和輸出的語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-344">Applications typically use *locales* to set the language in which input and output is processed.</span></span> <span data-ttu-id="cbe1b-345">例如，設定鍵盤的地區設定會影響鍵盤產生的字元值。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-345">Setting the locale for the keyboard, for example, affects the character values generated by the keyboard.</span></span> <span data-ttu-id="cbe1b-346">設定顯示器或印表機的地區設定會影響顯示或列印的圖像。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-346">Setting the locale for the display or printer affects the glyphs displayed or printed.</span></span> <span data-ttu-id="cbe1b-347">應用程式會藉由載入和使用鍵盤配置來設定鍵盤的地區設定。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-347">Applications set the locale for a keyboard by loading and using keyboard layouts.</span></span> <span data-ttu-id="cbe1b-348">他們會選取支援指定地區設定的字型，來設定顯示或印表機的地區設定。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-348">They set the locale for a display or printer by selecting a font that supports the specified locale.</span></span>

<span data-ttu-id="cbe1b-349">鍵盤配置不僅會指定鍵盤上按鍵的實體位置，也會決定按下這些按鍵產生的字元值。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-349">A keyboard layout not only specifies the physical position of the keys on the keyboard but also determines the character values generated by pressing those keys.</span></span> <span data-ttu-id="cbe1b-350">每個版面配置都會識別目前的輸入語言，並決定哪些字元值是由哪些索引鍵和按鍵組合所產生。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-350">Each layout identifies the current input language and determines which character values are generated by which keys and key combinations.</span></span>

<span data-ttu-id="cbe1b-351">每個鍵盤配置都有一個對應的控點，可識別版面配置和語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-351">Every keyboard layout has a corresponding handle that identifies the layout and language.</span></span> <span data-ttu-id="cbe1b-352">控制碼的低字組是語言識別項。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-352">The low word of the handle is a language identifier.</span></span> <span data-ttu-id="cbe1b-353">最大的單字是裝置控制碼，指定實體配置，或為零，表示預設實體版面配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-353">The high word is a device handle, specifying the physical layout, or is zero, indicating a default physical layout.</span></span> <span data-ttu-id="cbe1b-354">使用者可以將任何輸入語言與實體版面配置建立關聯。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-354">The user can associate any input language with a physical layout.</span></span> <span data-ttu-id="cbe1b-355">比方說，在法文中非常簡單的英文使用者可以將鍵盤的輸入語言設定為法文，而不需要變更鍵盤的實體配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-355">For example, an English-speaking user who very occasionally works in French can set the input language of the keyboard to French without changing the physical layout of the keyboard.</span></span> <span data-ttu-id="cbe1b-356">這表示使用者可以使用熟悉的英文版面配置來輸入法文格式的文字。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-356">This means the user can enter text in French using the familiar English layout.</span></span>

<span data-ttu-id="cbe1b-357">應用程式通常不需要直接操作輸入語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-357">Applications are generally not expected to manipulate input languages directly.</span></span> <span data-ttu-id="cbe1b-358">相反地，使用者會設定語言和版面配置組合，然後在它們之間切換。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-358">Instead, the user sets up language and layout combinations, then switches among them.</span></span> <span data-ttu-id="cbe1b-359">當使用者按一下標記為不同語言的文字時，應用程式會呼叫 [**ActivateKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout) 函式，以啟動該語言的使用者預設版面配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-359">When the user clicks into text marked with a different language, the application calls the [**ActivateKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout) function to activate the user's default layout for that language.</span></span> <span data-ttu-id="cbe1b-360">如果使用者使用不在作用中清單中的語言來編輯文字，應用程式可以使用語言呼叫 [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) 函式，以取得以該語言為基礎的版面配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-360">If the user edits text in a language which is not in the active list, the application can call the [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) function with the language to get a layout based on that language.</span></span>

<span data-ttu-id="cbe1b-361">[**ActivateKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout)函式會設定目前工作的輸入語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-361">The [**ActivateKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout) function sets the input language for the current task.</span></span> <span data-ttu-id="cbe1b-362">*Hkl* 參數可以是鍵盤配置的控制碼，也可以是零擴充的語言識別項。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-362">The *hkl* parameter can be either the handle to the keyboard layout or a zero-extended language identifier.</span></span> <span data-ttu-id="cbe1b-363">您可以從 [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) 或 [**GetKeyboardLayoutList**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutlist) 函數取得鍵盤配置控制碼。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-363">Keyboard layout handles can be obtained from the [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) or [**GetKeyboardLayoutList**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutlist) function.</span></span> <span data-ttu-id="cbe1b-364">**\_ 接下來的 HKL** 和 **HKL \_ 前** 幾個值也可以用來選取下一個或上一個鍵盤。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-364">The **HKL\_NEXT** and **HKL\_PREV** values can also be used to select the next or previous keyboard.</span></span>

<span data-ttu-id="cbe1b-365">[**GetKeyboardLayoutName**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutnamea)函式會抓取呼叫執行緒的作用中鍵盤配置的名稱。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-365">The [**GetKeyboardLayoutName**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutnamea) function retrieves the name of the active keyboard layout for the calling thread.</span></span> <span data-ttu-id="cbe1b-366">如果應用程式使用 [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) 函式建立作用中配置， **GetKeyboardLayoutName** 會抓取用來建立配置的相同字串。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-366">If an application creates the active layout using the [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) function, **GetKeyboardLayoutName** retrieves the same string used to create the layout.</span></span> <span data-ttu-id="cbe1b-367">否則，字串就是對應至使用中配置之地區設定的主要語言識別項。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-367">Otherwise, the string is the primary language identifier corresponding to the locale of the active layout.</span></span> <span data-ttu-id="cbe1b-368">這表示函式不一定會區分具有相同主要語言的不同版面配置，因此無法傳回輸入語言的特定資訊。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-368">This means the function may not necessarily differentiate among different layouts with the same primary language, so cannot return specific information about the input language.</span></span> <span data-ttu-id="cbe1b-369">不過， [**GetKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayout) 函式可以用來判斷輸入語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-369">The [**GetKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayout) function, however, can be used to determine the input language.</span></span>

<span data-ttu-id="cbe1b-370">[**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta)函式會載入鍵盤配置，並讓使用者可以使用版面配置。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-370">The [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) function loads a keyboard layout and makes the layout available to the user.</span></span> <span data-ttu-id="cbe1b-371">應用程式可以使用 **KLF \_ 啟動** 值，讓目前線程的版面配置立即處於作用中狀態。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-371">Applications can make the layout immediately active for the current thread by using the **KLF\_ACTIVATE** value.</span></span> <span data-ttu-id="cbe1b-372">應用程式可以使用 **KLF \_ 重新排序** 值來重新排序版面配置，而不同時指定 **KLF \_ 啟動** 值。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-372">An application can use the **KLF\_REORDER** value to reorder the layouts without also specifying the **KLF\_ACTIVATE** value.</span></span> <span data-ttu-id="cbe1b-373">在載入鍵盤配置時，應用程式應該一律使用 **KLF \_ 替代 \_ [確定]** 值，以確保選取使用者的喜好設定（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-373">Applications should always use the **KLF\_SUBSTITUTE\_OK** value when loading keyboard layouts to ensure that the user's preference, if any, is selected.</span></span>

<span data-ttu-id="cbe1b-374">若為多語系支援， [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) 函數會提供 **KLF \_ REPLACELANG** 和 **KLF \_ NOTELLSHELL** 旗標。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-374">For multilingual support, the [**LoadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) function provides the **KLF\_REPLACELANG** and **KLF\_NOTELLSHELL** flags.</span></span> <span data-ttu-id="cbe1b-375">**KLF \_ REPLACELANG** 旗標會指示函式取代現有的鍵盤配置，而不需要變更語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-375">The **KLF\_REPLACELANG** flag directs the function to replace an existing keyboard layout without changing the language.</span></span> <span data-ttu-id="cbe1b-376">嘗試使用相同的語言識別項來取代現有的版面配置，但未指定 **KLF \_ REPLACELANG** 是一項錯誤。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-376">Attempting to replace an existing layout using the same language identifier but without specifying **KLF\_REPLACELANG** is an error.</span></span> <span data-ttu-id="cbe1b-377">**KLF \_ NOTELLSHELL** 旗標可防止函式在新增或取代鍵盤配置時通知 shell。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-377">The **KLF\_NOTELLSHELL** flag prevents the function from notifying the shell when a keyboard layout is added or replaced.</span></span> <span data-ttu-id="cbe1b-378">這適用于將多個配置新增至連續一連串呼叫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-378">This is useful for applications that add multiple layouts in a consecutive series of calls.</span></span> <span data-ttu-id="cbe1b-379">此旗標應用於除了最後一個呼叫以外的所有。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-379">This flag should be used in all but the last call.</span></span>

<span data-ttu-id="cbe1b-380">[**UnloadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-unloadkeyboardlayout)函式會受到限制，因為它無法卸載系統預設的輸入語言。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-380">The [**UnloadKeyboardLayout**](/windows/win32/api/winuser/nf-winuser-unloadkeyboardlayout) function is restricted in that it cannot unload the system default input language.</span></span> <span data-ttu-id="cbe1b-381">這可確保使用者一律有一個配置，可使用 shell 和檔案系統所使用的相同字元集來輸入文字。</span><span class="sxs-lookup"><span data-stu-id="cbe1b-381">This ensures that the user always has one layout available for enter text using the same character set as used by the shell and file system.</span></span>

 

 
