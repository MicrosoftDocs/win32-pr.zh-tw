---
title: 關於原始輸入
description: 本主題討論裝置的使用者輸入，例如操作杆、觸控式螢幕和麥克風。
ms.assetid: 013ed309-f667-47ed-ade0-5e7ca5a0997a
keywords:
- 使用者輸入，原始輸入
- 捕獲使用者輸入，原始輸入
- 原始輸入
- 註冊原始輸入
- 讀取原始輸入
- 搖桿原始輸入
- 觸控式螢幕原始輸入
- 麥克風原始輸入
- 人性化介面裝置 (HID)
- " (人體介面裝置) 的 HID"
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b3535e5601ec63a254c76060611999a1a2f08aeb
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/19/2020
ms.locfileid: "104023469"
---
# <a name="about-raw-input"></a><span data-ttu-id="64caa-113">關於原始輸入</span><span class="sxs-lookup"><span data-stu-id="64caa-113">About Raw Input</span></span>

<span data-ttu-id="64caa-114">傳統鍵盤和滑鼠旁邊有許多使用者輸入的裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-114">There are many user-input devices beside the traditional keyboard and mouse.</span></span> <span data-ttu-id="64caa-115">例如，使用者輸入可以來自搖桿、觸控式螢幕、麥克風或其他裝置，以在使用者輸入方面有很大的彈性。</span><span class="sxs-lookup"><span data-stu-id="64caa-115">For example, user input can come from a joystick, a touch screen, a microphone, or other devices that allow great flexibility in user input.</span></span> <span data-ttu-id="64caa-116">這些裝置統稱為人類介面裝置， (HIDs) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-116">These devices are collectively known as Human Interface Devices (HIDs).</span></span> <span data-ttu-id="64caa-117">原始輸入 API 提供穩定且健全的方式，讓應用程式接受來自任何 HID 的原始輸入，包括鍵盤和滑鼠。</span><span class="sxs-lookup"><span data-stu-id="64caa-117">The raw input API provides a stable and robust way for applications to accept raw input from any HID, including the keyboard and mouse.</span></span>

<span data-ttu-id="64caa-118">本節包含下列主題：</span><span class="sxs-lookup"><span data-stu-id="64caa-118">This section covers the following topics:</span></span>

-   [<span data-ttu-id="64caa-119">原始輸入模型</span><span class="sxs-lookup"><span data-stu-id="64caa-119">Raw Input Model</span></span>](#raw-input-model)
-   [<span data-ttu-id="64caa-120">原始輸入的註冊</span><span class="sxs-lookup"><span data-stu-id="64caa-120">Registration for Raw Input</span></span>](#registration-for-raw-input)
-   [<span data-ttu-id="64caa-121">讀取原始輸入</span><span class="sxs-lookup"><span data-stu-id="64caa-121">Reading Raw Input</span></span>](#reading-raw-input)

## <a name="raw-input-model"></a><span data-ttu-id="64caa-122">原始輸入模型</span><span class="sxs-lookup"><span data-stu-id="64caa-122">Raw Input Model</span></span>

<span data-ttu-id="64caa-123">之前，鍵盤和滑鼠通常會產生輸入資料。</span><span class="sxs-lookup"><span data-stu-id="64caa-123">Previously, the keyboard and mouse typically generated input data.</span></span> <span data-ttu-id="64caa-124">系統會將來自這些裝置的資料，以消除未經處理之資訊的裝置特定詳細資料的方式來解讀。</span><span class="sxs-lookup"><span data-stu-id="64caa-124">The system interpreted the data coming from these devices in a way that eliminated the device-specific details of the raw information.</span></span> <span data-ttu-id="64caa-125">例如，鍵盤會產生裝置特定的掃描碼，但系統會提供具有虛擬金鑰碼的應用程式。</span><span class="sxs-lookup"><span data-stu-id="64caa-125">For example, the keyboard generates the device-specific scan code but the system provides an application with the virtual key code.</span></span> <span data-ttu-id="64caa-126">除了隱藏原始輸入的詳細資料之外，「視窗管理員」並不支援所有的新 HIDs。</span><span class="sxs-lookup"><span data-stu-id="64caa-126">Besides hiding the details of the raw input, the window manager did not support all the new HIDs.</span></span> <span data-ttu-id="64caa-127">若要從不支援的 HIDs 取得輸入，應用程式必須執行許多工作：開啟裝置、管理共用模式、定期讀取裝置或設定 i/o 完成埠等等。</span><span class="sxs-lookup"><span data-stu-id="64caa-127">To get input from the unsupported HIDs, an application had to do many things: open the device, manage the shared mode, periodically read the device or set up the I/O completion port, and so forth.</span></span> <span data-ttu-id="64caa-128">原始輸入模型和相關聯的 Api 的開發目的，是為了讓您能夠從所有輸入裝置（包括鍵盤和滑鼠）中輕鬆存取原始輸入。</span><span class="sxs-lookup"><span data-stu-id="64caa-128">The raw input model and the associated APIs were developed to allow simple access to raw input from all input devices, including the keyboard and mouse.</span></span>

<span data-ttu-id="64caa-129">原始輸入模型與鍵盤和滑鼠的原始 Windows 輸入模型不同。</span><span class="sxs-lookup"><span data-stu-id="64caa-129">The raw input model is different from the original Windows input model for the keyboard and mouse.</span></span> <span data-ttu-id="64caa-130">在原始輸入模型中，應用程式會以傳送或張貼至其 windows 的訊息形式（例如 [**wm \_ CHAR**](wm-char.md)、 [**WM \_ MOUSEMOVE**](wm-mousemove.md)和 [**wm \_ APPCOMMAND**](wm-appcommand.md)）接收與裝置無關的輸入。</span><span class="sxs-lookup"><span data-stu-id="64caa-130">In the original input model, an application receives device-independent input in the form of messages that are sent or posted to its windows, such as [**WM\_CHAR**](wm-char.md), [**WM\_MOUSEMOVE**](wm-mousemove.md), and [**WM\_APPCOMMAND**](wm-appcommand.md).</span></span> <span data-ttu-id="64caa-131">相反地，對於原始輸入，應用程式必須註冊要從中取得資料的裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-131">In contrast, for raw input an application must register the devices it wants to get data from.</span></span> <span data-ttu-id="64caa-132">此外，應用程式也會透過 [**WM \_ 輸入**](wm-input.md) 訊息取得原始輸入。</span><span class="sxs-lookup"><span data-stu-id="64caa-132">Also, the application gets the raw input through the [**WM\_INPUT**](wm-input.md) message.</span></span>

<span data-ttu-id="64caa-133">原始輸入模型有幾個優點：</span><span class="sxs-lookup"><span data-stu-id="64caa-133">There are several advantages to the raw input model:</span></span>

-   <span data-ttu-id="64caa-134">應用程式不需要偵測或開啟輸入裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-134">An application does not have to detect or open the input device.</span></span>
-   <span data-ttu-id="64caa-135">應用程式會直接從裝置取得資料，並處理資料以滿足其需求。</span><span class="sxs-lookup"><span data-stu-id="64caa-135">An application gets the data directly from the device, and processes the data for its needs.</span></span>
-   <span data-ttu-id="64caa-136">應用程式即使是來自相同類型的裝置，也可以區別輸入的來源。</span><span class="sxs-lookup"><span data-stu-id="64caa-136">An application can distinguish the source of the input even if it is from the same type of device.</span></span> <span data-ttu-id="64caa-137">例如，兩個滑鼠裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-137">For example, two mouse devices.</span></span>
-   <span data-ttu-id="64caa-138">應用程式會從裝置集合或僅指定特定裝置類型的資料，來管理資料流量。</span><span class="sxs-lookup"><span data-stu-id="64caa-138">An application manages the data traffic by specifying data from a collection of devices or only specific device types.</span></span>
-   <span data-ttu-id="64caa-139">您可以使用 HID 裝置，因為它們在 marketplace 中可供使用，而不需要等候新的訊息類型或更新的 OS 在 [**WM \_ APPCOMMAND**](wm-appcommand.md)中有新的命令。</span><span class="sxs-lookup"><span data-stu-id="64caa-139">HID devices can be used as they become available in the marketplace, without waiting for new message types or an updated OS to have new commands in [**WM\_APPCOMMAND**](wm-appcommand.md).</span></span>

<span data-ttu-id="64caa-140">請注意， [**WM \_ APPCOMMAND**](wm-appcommand.md) 確實提供某些 HID 裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-140">Note that [**WM\_APPCOMMAND**](wm-appcommand.md) does provide for some HID devices.</span></span> <span data-ttu-id="64caa-141">不過， **wm \_ APPCOMMAND** 是較高層級的裝置獨立輸入事件，而 [**wm \_ 輸入**](wm-input.md) 會傳送裝置特定的原始、低層級資料。</span><span class="sxs-lookup"><span data-stu-id="64caa-141">However, **WM\_APPCOMMAND** is a higher level device-independent input event, while [**WM\_INPUT**](wm-input.md) sends raw, low level data that is specific to a device.</span></span>

## <a name="registration-for-raw-input"></a><span data-ttu-id="64caa-142">原始輸入的註冊</span><span class="sxs-lookup"><span data-stu-id="64caa-142">Registration for Raw Input</span></span>

<span data-ttu-id="64caa-143">依預設，沒有任何應用程式會接收原始輸入。</span><span class="sxs-lookup"><span data-stu-id="64caa-143">By default, no application receives raw input.</span></span> <span data-ttu-id="64caa-144">若要接收來自裝置的原始輸入，應用程式必須註冊裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-144">To receive raw input from a device, an application must register the device.</span></span>

<span data-ttu-id="64caa-145">若要註冊裝置，應用程式會先建立 [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice) 結構的陣列，以指定其所要裝置的 [最上層集合](/windows-hardware/drivers/hid/top-level-collections) (TLC) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-145">To register devices, an application first creates an array of [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice) structures that specify the [top level collection](/windows-hardware/drivers/hid/top-level-collections) (TLC) for the devices it wants.</span></span> <span data-ttu-id="64caa-146">TLC 是由 () 裝置類別的 [使用方式頁面](/windows-hardware/drivers/hid/hid-usages#usage-page) 所定義，) 中 (裝置的 [使用識別碼](/windows-hardware/drivers/hid/hid-usages#usage-id) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-146">The TLC is defined by a [Usage Page](/windows-hardware/drivers/hid/hid-usages#usage-page) (the class of the device) and a [Usage ID](/windows-hardware/drivers/hid/hid-usages#usage-id) (the device within the class).</span></span> <span data-ttu-id="64caa-147">例如，若要取得鍵盤 TLC，請設定 UsagePage = 0x01 和 UsageID = 0x06。</span><span class="sxs-lookup"><span data-stu-id="64caa-147">For example, to get the keyboard TLC, set UsagePage = 0x01 and UsageID = 0x06.</span></span> <span data-ttu-id="64caa-148">應用程式會呼叫 [**RegisterRawInputDevices**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) 來註冊裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-148">The application calls [**RegisterRawInputDevices**](/windows/win32/api/winuser/nf-winuser-registerrawinputdevices) to register the devices.</span></span>

<span data-ttu-id="64caa-149">請注意，應用程式可以註冊目前未連接到系統的裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-149">Note that an application can register a device that is not currently attached to the system.</span></span> <span data-ttu-id="64caa-150">連接此裝置時，Windows 管理員會自動將原始輸入傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="64caa-150">When this device is attached, the Windows Manager will automatically send the raw input to the application.</span></span> <span data-ttu-id="64caa-151">為了取得系統上的原始輸入裝置清單，應用程式會呼叫 [**GetRawInputDeviceList**](/windows/win32/api/winuser/nf-winuser-getrawinputdevicelist)。</span><span class="sxs-lookup"><span data-stu-id="64caa-151">To get the list of raw input devices on the system, an application calls [**GetRawInputDeviceList**](/windows/win32/api/winuser/nf-winuser-getrawinputdevicelist).</span></span> <span data-ttu-id="64caa-152">使用此呼叫中的 *hDevice* ，應用程式會呼叫 [**GetRawInputDeviceInfo**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) 來取得裝置資訊。</span><span class="sxs-lookup"><span data-stu-id="64caa-152">Using the *hDevice* from this call, an application calls [**GetRawInputDeviceInfo**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) to get the device information.</span></span>

<span data-ttu-id="64caa-153">透過 [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice)的 **dwFlags** 成員，應用程式可以選取要接聽的裝置，以及想要忽略的裝置。</span><span class="sxs-lookup"><span data-stu-id="64caa-153">Through the **dwFlags** member of [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice), an application can select the devices to listen to and also those it wants to ignore.</span></span> <span data-ttu-id="64caa-154">例如，應用程式可以要求所有電話語音裝置的輸入，但無法接聽電腦。</span><span class="sxs-lookup"><span data-stu-id="64caa-154">For example, an application can ask for input from all telephony devices except for answering machines.</span></span> <span data-ttu-id="64caa-155">如需範例程式碼，請參閱 [註冊原始輸入](using-raw-input.md)。</span><span class="sxs-lookup"><span data-stu-id="64caa-155">For sample code, see [Registering for Raw Input](using-raw-input.md).</span></span>

<span data-ttu-id="64caa-156">請注意，滑鼠和鍵盤也會 HIDs，因此來自這些資料的資料可能會同時通過 HID 訊息 [**WM \_ 輸入**](wm-input.md) 和傳統的訊息。</span><span class="sxs-lookup"><span data-stu-id="64caa-156">Note that the mouse and the keyboard are also HIDs, so data from them can come through both the HID message [**WM\_INPUT**](wm-input.md) and from traditional messages.</span></span> <span data-ttu-id="64caa-157">應用程式可以藉由在 [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice)中適當地選取旗標來選取任一種方法。</span><span class="sxs-lookup"><span data-stu-id="64caa-157">An application can select either method by the proper selection of flags in [**RAWINPUTDEVICE**](/windows/win32/api/winuser/ns-winuser-rawinputdevice).</span></span>

<span data-ttu-id="64caa-158">若要取得應用程式的註冊狀態，請在任何時間呼叫 [**GetRegisteredRawInputDevices**](/windows/win32/api/winuser/nf-winuser-getregisteredrawinputdevices) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-158">To get an application's registration status, call [**GetRegisteredRawInputDevices**](/windows/win32/api/winuser/nf-winuser-getregisteredrawinputdevices) at any time.</span></span>

## <a name="reading-raw-input"></a><span data-ttu-id="64caa-159">讀取原始輸入</span><span class="sxs-lookup"><span data-stu-id="64caa-159">Reading Raw Input</span></span>

<span data-ttu-id="64caa-160">應用程式會從其 [最上層集合](/windows-hardware/drivers/hid/top-level-collections) (TLC) 符合註冊中 TLC 的任何隱藏專案接收原始輸入。</span><span class="sxs-lookup"><span data-stu-id="64caa-160">An application receives raw input from any HID whose [top level collection](/windows-hardware/drivers/hid/top-level-collections) (TLC) matches a TLC from the registration.</span></span> <span data-ttu-id="64caa-161">當應用程式收到未經處理的輸入時，它的訊息佇列會取得 [**WM \_ 輸入**](wm-input.md) 訊息，並將佇列狀態旗標設定為 **QS \_ RAWINPUT** (**QS \_ 輸入** 也包含此旗標) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-161">When an application receives raw input, its message queue gets a [**WM\_INPUT**](wm-input.md) message and the queue status flag **QS\_RAWINPUT** is set (**QS\_INPUT** also includes this flag).</span></span> <span data-ttu-id="64caa-162">當應用程式在前景以及在背景時，可以接收資料。</span><span class="sxs-lookup"><span data-stu-id="64caa-162">An application can receive data when it is in the foreground and when it is in the background.</span></span>

<span data-ttu-id="64caa-163">有兩種方式可以讀取原始資料：未緩衝的 (或標準) 方法和緩衝處理的方法。</span><span class="sxs-lookup"><span data-stu-id="64caa-163">There are two ways to read the raw data: the unbuffered (or standard) method and the buffered method.</span></span> <span data-ttu-id="64caa-164">未緩衝處理的方法會一次取得一 [**RAWINPUT**](/windows/win32/api/winuser/ns-winuser-rawinput) 結構的原始資料，而且適用于許多 HIDs。</span><span class="sxs-lookup"><span data-stu-id="64caa-164">The unbuffered method gets the raw data one [**RAWINPUT**](/windows/win32/api/winuser/ns-winuser-rawinput) structure at a time and is adequate for many HIDs.</span></span> <span data-ttu-id="64caa-165">在此，應用程式會呼叫 [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) 來取得 [**WM \_ 輸入**](wm-input.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="64caa-165">Here, the application calls [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) to get the [**WM\_INPUT**](wm-input.md) message.</span></span> <span data-ttu-id="64caa-166">然後，應用程式會使用包含在 **WM \_ 輸入** 中的 **RAWINPUT** 控制碼來呼叫 [**GetRawInputData**](/windows/win32/api/winuser/nf-winuser-getrawinputdata) 。</span><span class="sxs-lookup"><span data-stu-id="64caa-166">Then the application calls [**GetRawInputData**](/windows/win32/api/winuser/nf-winuser-getrawinputdata) using the **RAWINPUT** handle contained in **WM\_INPUT**.</span></span> <span data-ttu-id="64caa-167">如需範例，請參閱 [執行原始輸入的標準讀取](using-raw-input.md)。</span><span class="sxs-lookup"><span data-stu-id="64caa-167">For an example, see [Doing a Standard Read of Raw Input](using-raw-input.md).</span></span>

<span data-ttu-id="64caa-168">相反地，經過緩衝處理的方法會一次取得 [**RAWINPUT**](/windows/win32/api/winuser/ns-winuser-rawinput) 結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="64caa-168">In contrast, the buffered method gets an array of [**RAWINPUT**](/windows/win32/api/winuser/ns-winuser-rawinput) structures at a time.</span></span> <span data-ttu-id="64caa-169">這是針對可能產生大量原始輸入的裝置而提供。</span><span class="sxs-lookup"><span data-stu-id="64caa-169">This is provided for devices that can produce large amounts of raw input.</span></span> <span data-ttu-id="64caa-170">在這個方法中，應用程式會呼叫 [**GetRawInputBuffer**](/windows/win32/api/winuser/nf-winuser-getrawinputbuffer) 來取得 **RAWINPUT** 結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="64caa-170">In this method, the application calls [**GetRawInputBuffer**](/windows/win32/api/winuser/nf-winuser-getrawinputbuffer) to get an array of **RAWINPUT** structures.</span></span> <span data-ttu-id="64caa-171">請注意， [**NEXTRAWINPUTBLOCK**](/windows/win32/api/winuser/nf-winuser-nextrawinputblock) 宏是用來跨越 **RAWINPUT** 結構的陣列。</span><span class="sxs-lookup"><span data-stu-id="64caa-171">Note that the [**NEXTRAWINPUTBLOCK**](/windows/win32/api/winuser/nf-winuser-nextrawinputblock) macro is used to traverse an array of **RAWINPUT** structures.</span></span> <span data-ttu-id="64caa-172">如需範例，請參閱 [執行原始輸入的緩衝讀取](using-raw-input.md)。</span><span class="sxs-lookup"><span data-stu-id="64caa-172">For an example, see [Doing a Buffered Read of Raw Input](using-raw-input.md).</span></span>

<span data-ttu-id="64caa-173">若要解讀原始輸入，需要 HIDs 的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="64caa-173">To interpret the raw input, detailed information about the HIDs is required.</span></span> <span data-ttu-id="64caa-174">應用程式會藉由呼叫 [**GetRawInputDeviceInfo**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) 和裝置控制碼來取得裝置資訊。</span><span class="sxs-lookup"><span data-stu-id="64caa-174">An application gets the device information by calling [**GetRawInputDeviceInfo**](/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfoa) with the device handle.</span></span> <span data-ttu-id="64caa-175">這個控制碼可以來自 [**WM \_ 輸入**](wm-input.md)或來自 [**RAWINPUTHEADER**](/windows/win32/api/winuser/ns-winuser-rawinputheader)的 **hDevice** 成員。</span><span class="sxs-lookup"><span data-stu-id="64caa-175">This handle can come either from [**WM\_INPUT**](wm-input.md) or from the **hDevice** member of [**RAWINPUTHEADER**](/windows/win32/api/winuser/ns-winuser-rawinputheader).</span></span>