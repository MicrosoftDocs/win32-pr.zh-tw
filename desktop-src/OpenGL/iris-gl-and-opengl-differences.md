---
title: 鳶尾花 GL 和 OpenGL 差異
description: 鳶尾花 GL 和 OpenGL 差異
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- OpenGL、鳶尾花 GL 差異
- 鳶尾花 GL 移植，OpenGL 差異
- 從鳶尾花 GL （OpenGL 差異）移植
- 從鳶尾花 GL 移植至 OpenGL，鳶尾花 GL 差異
- 鳶尾花 GL 的 OpenGL 移植，鳶尾花 GL 差異
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6276eb56cf73df6cbdfc115fe67d55452b13bbc
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "104300643"
---
# <a name="iris-gl-and-opengl-differences"></a><span data-ttu-id="7931d-108">鳶尾花 GL 和 OpenGL 差異</span><span class="sxs-lookup"><span data-stu-id="7931d-108">IRIS GL and OpenGL Differences</span></span>

<span data-ttu-id="7931d-109">本附錄列出 OpenGL 與鳶尾花 GL 之間的差異。</span><span class="sxs-lookup"><span data-stu-id="7931d-109">This appendix lists the differences between OpenGL and IRIS GL.</span></span> <span data-ttu-id="7931d-110">會提供每個差異的詞彙，後面接著描述。</span><span class="sxs-lookup"><span data-stu-id="7931d-110">A term for each difference is given, followed by a description.</span></span>



|                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="7931d-111">累積換行</span><span class="sxs-lookup"><span data-stu-id="7931d-111">accumulation wrapping</span></span>                | <span data-ttu-id="7931d-112">當元件值超過1.0 或低於1.0 時，不會定義 OpenGL 累積緩衝區作業。</span><span class="sxs-lookup"><span data-stu-id="7931d-112">The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below 1.0.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="7931d-113">反鋸齒線條</span><span class="sxs-lookup"><span data-stu-id="7931d-113">antialiased lines</span></span>                    | <span data-ttu-id="7931d-114">OpenGL stipples 反鋸齒程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="7931d-114">OpenGL stipples antialiased lines.</span></span> <span data-ttu-id="7931d-115">鳶尾花 GL 則否。</span><span class="sxs-lookup"><span data-stu-id="7931d-115">IRIS GL does not.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="7931d-116">弧形</span><span class="sxs-lookup"><span data-stu-id="7931d-116">arc</span></span>                                  | <span data-ttu-id="7931d-117">OpenGL 支援其公用程式庫中的弧形。</span><span class="sxs-lookup"><span data-stu-id="7931d-117">OpenGL supports arcs in its utility library.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-118">屬性清單</span><span class="sxs-lookup"><span data-stu-id="7931d-118">attribute lists</span></span>                      | <span data-ttu-id="7931d-119">鳶尾花 GL pushattributes 所推送的屬性與 OpenGL glPushAttrib 所推送的任何屬性集不同。</span><span class="sxs-lookup"><span data-stu-id="7931d-119">The attributes pushed by the IRIS GL pushattributes differ from any of the attribute sets pushed by the OpenGL glPushAttrib .</span></span> <span data-ttu-id="7931d-120">因為所有 OpenGL 狀態都可以讀回，所以您可以使用 OpenGL 來執行任何所需的推播/pop 語法。</span><span class="sxs-lookup"><span data-stu-id="7931d-120">Since all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="7931d-121">自動材質調整</span><span class="sxs-lookup"><span data-stu-id="7931d-121">automatic texture scaling</span></span>            | <span data-ttu-id="7931d-122">OpenGL 材質介面不支援將影像自動調整為雙二維度的影像。</span><span class="sxs-lookup"><span data-stu-id="7931d-122">The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions.</span></span> <span data-ttu-id="7931d-123">不過，X.GLU 隊支援映射調整。</span><span class="sxs-lookup"><span data-stu-id="7931d-123">However, the GLU supports image scaling.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="7931d-124">bbox</span><span class="sxs-lookup"><span data-stu-id="7931d-124">bbox</span></span>                                 | <span data-ttu-id="7931d-125">OpenGL 不支援顯示清單的條件式執行。</span><span class="sxs-lookup"><span data-stu-id="7931d-125">OpenGL doesn't support conditional execution of display lists.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="7931d-126">callfunc</span><span class="sxs-lookup"><span data-stu-id="7931d-126">callfunc</span></span>                             | <span data-ttu-id="7931d-127">OpenGL 不支援來自顯示清單的回呼。</span><span class="sxs-lookup"><span data-stu-id="7931d-127">OpenGL doesn't support callback from display lists.</span></span> <span data-ttu-id="7931d-128">請注意，當用戶端和伺服器位於不同的平臺時，鳶尾花 GL 不支援這項功能。</span><span class="sxs-lookup"><span data-stu-id="7931d-128">Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="7931d-129">圓形</span><span class="sxs-lookup"><span data-stu-id="7931d-129">circle</span></span>                               | <span data-ttu-id="7931d-130">OpenGL 支援使用 X.GLU 隊的圓形。</span><span class="sxs-lookup"><span data-stu-id="7931d-130">OpenGL supports circles with the GLU.</span></span> <span data-ttu-id="7931d-131">在 OpenGL 中，圓圈和弧形 (磁片和部分磁片) 可能有漏洞。</span><span class="sxs-lookup"><span data-stu-id="7931d-131">In OpenGL both circles and arcs (disks and partial disks) can have holes.</span></span> <span data-ttu-id="7931d-132">此外，您可以變更 OpenGL 中的基元，其介面法線適用于光源。</span><span class="sxs-lookup"><span data-stu-id="7931d-132">In addition, you can change subdivision of the primitives in OpenGL, whose surface normals are available for lighting.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-133">清除選項</span><span class="sxs-lookup"><span data-stu-id="7931d-133">clear options</span></span>                        | <span data-ttu-id="7931d-134">OpenGL 實際上會清除緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7931d-134">OpenGL actually clears buffers.</span></span> <span data-ttu-id="7931d-135">它不會套用目前指定的圖元運算，例如混色和 logicop，而不論其模式為何。</span><span class="sxs-lookup"><span data-stu-id="7931d-135">It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes.</span></span> <span data-ttu-id="7931d-136">若要清除使用這類功能，您必須呈現視窗大小的多邊形。</span><span class="sxs-lookup"><span data-stu-id="7931d-136">To clear using such features, you must render a window-size polygon.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="7931d-137">封閉行</span><span class="sxs-lookup"><span data-stu-id="7931d-137">closed lines</span></span>                         | <span data-ttu-id="7931d-138">OpenGL 會轉譯所有單一寬度的鋸齒線條，使連續的線條不會共用任何圖元。</span><span class="sxs-lookup"><span data-stu-id="7931d-138">OpenGL renders all single-width aliased lines such that abutting lines share no pixels.</span></span> <span data-ttu-id="7931d-139">這表示不會繪製獨立行的最後一個圖元。</span><span class="sxs-lookup"><span data-stu-id="7931d-139">This means that the last pixel of an independent line is not drawn.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="7931d-140">色彩/一般旗標</span><span class="sxs-lookup"><span data-stu-id="7931d-140">color/normal flag</span></span>                    | <span data-ttu-id="7931d-141">OpenGL 光源已明確啟用或停用。</span><span class="sxs-lookup"><span data-stu-id="7931d-141">OpenGL lighting is explicitly enabled or disabled.</span></span> <span data-ttu-id="7931d-142">啟用時，不論色彩和法線的指定順序為何，它都有效。</span><span class="sxs-lookup"><span data-stu-id="7931d-142">When enabled, it is effective regardless of the order in which colors and normals are specified.</span></span> <span data-ttu-id="7931d-143">您無法啟用或停用 OpenGL glBegin 和 glEnd 命令之間的光源。</span><span class="sxs-lookup"><span data-stu-id="7931d-143">You cannot enable or disable lighting between OpenGL glBegin and glEnd commands.</span></span> <span data-ttu-id="7931d-144">若要停用 glBegin 與 glEnd 之間的光源，請指定零環境、擴散和反射材質反射率，然後將材質設定為所需的色彩。</span><span class="sxs-lookup"><span data-stu-id="7931d-144">To disable lighting between glBegin and glEnd, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.</span></span>                                                                                                                                                                                                                                                            |
| <span data-ttu-id="7931d-145">凹形多邊形</span><span class="sxs-lookup"><span data-stu-id="7931d-145">concave polygons</span></span>                     | <span data-ttu-id="7931d-146">核心 OpenGL API 不會處理凹形多邊形，但 X.GLU 隊支援將分解凹、非自我交集的輪廓變成三角形。</span><span class="sxs-lookup"><span data-stu-id="7931d-146">The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles.</span></span> <span data-ttu-id="7931d-147">這些三角形可以立即繪製或傳回。</span><span class="sxs-lookup"><span data-stu-id="7931d-147">These triangles can either be drawn immediately or returned.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="7931d-148">目前計算的色彩</span><span class="sxs-lookup"><span data-stu-id="7931d-148">current computed color</span></span>               | <span data-ttu-id="7931d-149">OpenGL 沒有與目前計算色彩相等的專案。</span><span class="sxs-lookup"><span data-stu-id="7931d-149">OpenGL has no equivalent to a current computed color.</span></span> <span data-ttu-id="7931d-150">如果您要使用 OpenGL 作為光源引擎，您可以使用意見反應來取得光源計算所產生的色彩。</span><span class="sxs-lookup"><span data-stu-id="7931d-150">If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-151">目前的圖形位置</span><span class="sxs-lookup"><span data-stu-id="7931d-151">current graphics position</span></span>            | <span data-ttu-id="7931d-152">OpenGL 不會維持目前的圖形位置。</span><span class="sxs-lookup"><span data-stu-id="7931d-152">OpenGL doesn't maintain a current graphics position.</span></span> <span data-ttu-id="7931d-153">相依于目前圖形位置的鳶尾花 GL 命令（例如相關線條和多邊形）不會包含在 OpenGL 中。</span><span class="sxs-lookup"><span data-stu-id="7931d-153">IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="7931d-154">曲線</span><span class="sxs-lookup"><span data-stu-id="7931d-154">curves</span></span>                               | <span data-ttu-id="7931d-155">OpenGL 不支援鳶尾花 GL 曲線。</span><span class="sxs-lookup"><span data-stu-id="7931d-155">OpenGL does not support IRIS GL curves.</span></span> <span data-ttu-id="7931d-156">建議使用 NURBS 曲線。</span><span class="sxs-lookup"><span data-stu-id="7931d-156">Use of NURBS curves is recommended.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="7931d-157">defs/系結</span><span class="sxs-lookup"><span data-stu-id="7931d-157">defs/binds</span></span>                           | <span data-ttu-id="7931d-158">OpenGL 沒有材質、light 或材質物件的概念;僅限材質、淺色和材質屬性。</span><span class="sxs-lookup"><span data-stu-id="7931d-158">OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties.</span></span> <span data-ttu-id="7931d-159">不過，您可以使用顯示清單來建立自己的物件。</span><span class="sxs-lookup"><span data-stu-id="7931d-159">You can use display lists to create their own objects, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="7931d-160">depthcue</span><span class="sxs-lookup"><span data-stu-id="7931d-160">depthcue</span></span>                             | <span data-ttu-id="7931d-161">OpenGL 不提供深度提示的直接支援，但其霧化支援是更一般的功能，可讓您輕鬆地用來模擬鳶尾花 GL depthcue 函數。</span><span class="sxs-lookup"><span data-stu-id="7931d-161">OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL depthcue function.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-162">顯示清單編輯</span><span class="sxs-lookup"><span data-stu-id="7931d-162">display list editing</span></span>                 | <span data-ttu-id="7931d-163">無法 editedonly 建立和終結 OpenGL 顯示清單。</span><span class="sxs-lookup"><span data-stu-id="7931d-163">OpenGL display lists can't be editedonly created and destroyed.</span></span> <span data-ttu-id="7931d-164">不過，您可以指定顯示清單名稱，但是您可以在階層中重新定義個別的顯示清單。</span><span class="sxs-lookup"><span data-stu-id="7931d-164">Because you can specify display list names, however, you can redefine individual display lists in a hierarchy.</span></span> <span data-ttu-id="7931d-165">OpenGL 顯示清單是針對資料快取所設計，而不是用於資料庫管理。</span><span class="sxs-lookup"><span data-stu-id="7931d-165">OpenGL display lists are designed for data caching, not for database management.</span></span> <span data-ttu-id="7931d-166">它們保證會儲存在伺服器上的用戶端/伺服器環境中，因此在執行期間不會受到網路頻寬的限制。</span><span class="sxs-lookup"><span data-stu-id="7931d-166">They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.</span></span> <span data-ttu-id="7931d-167">您可以在 glBegin 和 glEnd 命令之間呼叫 OpenGL 顯示清單，如此一來，顯示清單階層就可以充分發揮其可供編輯的效果。</span><span class="sxs-lookup"><span data-stu-id="7931d-167">OpenGL display lists can be called between glBegin and glEnd commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.</span></span>                                                                                              |
| <span data-ttu-id="7931d-168">錯誤檢查</span><span class="sxs-lookup"><span data-stu-id="7931d-168">error checking</span></span>                       | <span data-ttu-id="7931d-169">OpenGL 會比鳶尾花 GL 更仔細地檢查錯誤。</span><span class="sxs-lookup"><span data-stu-id="7931d-169">OpenGL checks for errors more carefully than IRIS GL.</span></span> <span data-ttu-id="7931d-170">例如，glBegin 和 glEnd 之間未接受的所有 OpenGL 函數都會被偵測為錯誤，而且沒有其他效果。</span><span class="sxs-lookup"><span data-stu-id="7931d-170">For example, all OpenGL functions that are not accepted between glBegin and glEnd are detected as errors, and have no other effect.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-171">錯誤傳回值</span><span class="sxs-lookup"><span data-stu-id="7931d-171">error return values</span></span>                  | <span data-ttu-id="7931d-172">當傳回值的 OpenGL 命令偵測到錯誤時，它一律會傳回零。</span><span class="sxs-lookup"><span data-stu-id="7931d-172">When an OpenGL command that returns a value detects an error, it always returns zero.</span></span> <span data-ttu-id="7931d-173">如果偵測到錯誤，透過傳遞的指標傳回資料的 OpenGL 命令不會變更陣列內容。</span><span class="sxs-lookup"><span data-stu-id="7931d-173">OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-174">錯誤副作用</span><span class="sxs-lookup"><span data-stu-id="7931d-174">error side effects</span></span>                   | <span data-ttu-id="7931d-175">當 OpenGL 命令產生錯誤時，其唯一的副作用是將錯誤旗標更新為適當的值。</span><span class="sxs-lookup"><span data-stu-id="7931d-175">When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value.</span></span> <span data-ttu-id="7931d-176">未進行任何其他狀態變更。</span><span class="sxs-lookup"><span data-stu-id="7931d-176">No other state changes are made.</span></span> <span data-ttu-id="7931d-177"> (例外狀況是記憶體不足 \_ 的 \_ 錯誤，也就是嚴重的錯誤。 ) </span><span class="sxs-lookup"><span data-stu-id="7931d-177">(An exception is the OUT\_OF\_MEMORY error, which is fatal.)</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="7931d-178">意見回應</span><span class="sxs-lookup"><span data-stu-id="7931d-178">feedback</span></span>                             | <span data-ttu-id="7931d-179">在 OpenGL 中已標準化意見反應，因此它不會從電腦變更為電腦。</span><span class="sxs-lookup"><span data-stu-id="7931d-179">Feedback is standardized in OpenGL so it doesn't change from machine to machine.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="7931d-180">字型和字串</span><span class="sxs-lookup"><span data-stu-id="7931d-180">fonts and strings</span></span>                    | <span data-ttu-id="7931d-181">OpenGL 需要將字元字元字元作為個別顯示清單來操作。</span><span class="sxs-lookup"><span data-stu-id="7931d-181">OpenGL requires character glyphs to be manipulated as individual display lists.</span></span> <span data-ttu-id="7931d-182">它會提供顯示清單呼叫函式，此函式會接受顯示清單名稱的清單、每個名稱都以1、2或4個位元組表示。</span><span class="sxs-lookup"><span data-stu-id="7931d-182">It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.</span></span> <span data-ttu-id="7931d-183">GlCallLists 函式會在呼叫之前，將個別指定的位移加入至每個顯示清單名稱，允許將顯示清單名稱清單視為字串。</span><span class="sxs-lookup"><span data-stu-id="7931d-183">The glCallLists function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings.</span></span> <span data-ttu-id="7931d-184">這項機制提供鳶尾花 GL 字型的所有功能，還有更多。</span><span class="sxs-lookup"><span data-stu-id="7931d-184">This mechanism provides all the functionality of IRIS GL fonts, and considerably more.</span></span> <span data-ttu-id="7931d-185">例如，可輕鬆操作由三角形組成的字元。</span><span class="sxs-lookup"><span data-stu-id="7931d-185">For example, characters comprised of triangles can be easily manipulated.</span></span>                                                                                                                  |
| <span data-ttu-id="7931d-186">frontbuffer</span><span class="sxs-lookup"><span data-stu-id="7931d-186">frontbuffer</span></span>                          | <span data-ttu-id="7931d-187">鳶尾花 GL 有複雜的規則，可在單一緩衝區模式中轉譯至前端緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7931d-187">IRIS GL has complex rules for rendering to the front buffer in single buffer mode.</span></span> <span data-ttu-id="7931d-188">OpenGL 會以直接的方式處理對 front 緩衝區的轉譯。</span><span class="sxs-lookup"><span data-stu-id="7931d-188">OpenGL handles rendering to the front buffer in a straightforward way.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-189">空心多邊形</span><span class="sxs-lookup"><span data-stu-id="7931d-189">hollow polygons</span></span>                      | <span data-ttu-id="7931d-190">您可以使用 OpenGL 樣板容量來呈現空心多邊形。</span><span class="sxs-lookup"><span data-stu-id="7931d-190">You can use the OpenGL stencil capacity to render hollow polygons.</span></span> <span data-ttu-id="7931d-191">OpenGL 不支援建立空心多邊形的其他方法。</span><span class="sxs-lookup"><span data-stu-id="7931d-191">OpenGL doesn't support other means for creating hollow polygons.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="7931d-192">索引固定</span><span class="sxs-lookup"><span data-stu-id="7931d-192">index clamping</span></span>                       | <span data-ttu-id="7931d-193">在可能的情況下，OpenGL 會將色彩和樣板索引視為位欄位，而不是數位。</span><span class="sxs-lookup"><span data-stu-id="7931d-193">Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers.</span></span> <span data-ttu-id="7931d-194">因此，會將索引遮罩，而不是壓制至支援的畫面格緩衝區範圍。</span><span class="sxs-lookup"><span data-stu-id="7931d-194">Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="7931d-195">整數色彩</span><span class="sxs-lookup"><span data-stu-id="7931d-195">integer colors</span></span>                       | <span data-ttu-id="7931d-196">帶正負號的整數色彩元件 (紅色、綠色、藍色或 Alpha) 會以線性方式對應至浮點數，如此一來，最大的負整數會對應到1.0，而最大的正整數則會對應到1.0。</span><span class="sxs-lookup"><span data-stu-id="7931d-196">Signed integer color components (red, green, blue, or alpha) are mapped in linear fashion to floating points so that the most negative integer maps to 1.0 and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="7931d-197">當您在 OpenGL 取代目前的色彩之前指定色彩時，就會發生這種對應。</span><span class="sxs-lookup"><span data-stu-id="7931d-197">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span> <span data-ttu-id="7931d-198">不帶正負號的整數色彩元件會以線性方式對應至浮點數，使0對應至0.0，而最大整數對應至1.0。</span><span class="sxs-lookup"><span data-stu-id="7931d-198">Unsigned integer color components are mapped linearly to floating points so that 0 maps to 0.0 and the largest integer maps to 1.0.</span></span> <span data-ttu-id="7931d-199">當您在 OpenGL 取代目前的色彩之前指定色彩時，就會發生這種對應。</span><span class="sxs-lookup"><span data-stu-id="7931d-199">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span>                                                                                                                                               |
| <span data-ttu-id="7931d-200">整數法線</span><span class="sxs-lookup"><span data-stu-id="7931d-200">integer normals</span></span>                      | <span data-ttu-id="7931d-201">整數一般元件的對應方式就像已簽署的色彩元件一樣。</span><span class="sxs-lookup"><span data-stu-id="7931d-201">Integer normal components are mapped just like signed color components.</span></span> <span data-ttu-id="7931d-202">最大的負整數會對應到1.0，最多正整數則對應至1.0。</span><span class="sxs-lookup"><span data-stu-id="7931d-202">The most negative integer maps to 1.0, and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="7931d-203">圖元片段。</span><span class="sxs-lookup"><span data-stu-id="7931d-203">pixel fragments.</span></span> <span data-ttu-id="7931d-204">GlDrawPixels 或 glCopyPixels 所繪製的圖元一律會進行點陣化，並轉換成片段。</span><span class="sxs-lookup"><span data-stu-id="7931d-204">Pixels drawn by glDrawPixels or glCopyPixels are always rasterized and converted to fragments.</span></span> <span data-ttu-id="7931d-205">產生的片段有紋理、fogged、深度緩衝、混合式等等，就像是從幾何點產生的片段一樣。</span><span class="sxs-lookup"><span data-stu-id="7931d-205">The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points.</span></span> <span data-ttu-id="7931d-206">來源圖元未提供的片段資料會從目前的點陣位置增強。</span><span class="sxs-lookup"><span data-stu-id="7931d-206">Fragment data that isn't provided by the source pixels is augmented from the current raster position.</span></span> <span data-ttu-id="7931d-207">例如，RGBA 圖元採用點陣位置 Z 和材質座標。</span><span class="sxs-lookup"><span data-stu-id="7931d-207">For example, RGBA pixels take the raster position Z and texture coordinates.</span></span> <span data-ttu-id="7931d-208">深度圖元採用點陣位置色彩和材質座標。</span><span class="sxs-lookup"><span data-stu-id="7931d-208">Depth pixels take the raster position color and texture coordinates.</span></span> |
| <span data-ttu-id="7931d-209">invariance</span><span class="sxs-lookup"><span data-stu-id="7931d-209">invariance</span></span>                           | <span data-ttu-id="7931d-210">OpenGL 保證鳶尾花 GL 不會有某種一致性。</span><span class="sxs-lookup"><span data-stu-id="7931d-210">OpenGL guarantees a certain consistency that IRIS GL doesn't.</span></span> <span data-ttu-id="7931d-211">例如，OpenGL 保證傳送至相同系統的相同程式碼順序（僅在指定的混合函式中不同）將會產生相同的圖元片段。</span><span class="sxs-lookup"><span data-stu-id="7931d-211">For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments.</span></span> <span data-ttu-id="7931d-212"> (片段會有所不同，但如果已啟用混合，則會加以停用。 ) </span><span class="sxs-lookup"><span data-stu-id="7931d-212">(The fragments differ, however, if blending is enabled and then disabled.)</span></span>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-213">光源方程式</span><span class="sxs-lookup"><span data-stu-id="7931d-213">lighting equation</span></span>                    | <span data-ttu-id="7931d-214">OpenGL 光源方程式與鳶尾花 GL 方程式稍有不同。</span><span class="sxs-lookup"><span data-stu-id="7931d-214">The OpenGL lighting equation differs slightly from the IRIS GL equation.</span></span> <span data-ttu-id="7931d-215">OpenGL 支援每個光源的不同衰減，而不是鳶尾花 GL 等所有燈光來源的單一衰減。</span><span class="sxs-lookup"><span data-stu-id="7931d-215">OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL.</span></span> <span data-ttu-id="7931d-216">OpenGL 會調整方程式，讓環境、擴散和反射光源的投稿全部衰減。</span><span class="sxs-lookup"><span data-stu-id="7931d-216">OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated.</span></span> <span data-ttu-id="7931d-217">此外，OpenGL 還可讓您針對燈光來源的環境、擴散和反射濃度，以及資料的環境、擴散和反射反射率，指定不同的色彩。</span><span class="sxs-lookup"><span data-stu-id="7931d-217">Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials.</span></span> <span data-ttu-id="7931d-218">所有 OpenGL 光源和材質色彩都包含 Alpha。</span><span class="sxs-lookup"><span data-stu-id="7931d-218">All OpenGL light and material colors include alpha.</span></span> <span data-ttu-id="7931d-219">將反射指數設定為零，並不會使 OpenGL 中的反射光源失效。</span><span class="sxs-lookup"><span data-stu-id="7931d-219">Setting the specular exponent to zero does not defeat specular lighting in OpenGL.</span></span>    |
| <span data-ttu-id="7931d-220">mapw</span><span class="sxs-lookup"><span data-stu-id="7931d-220">mapw</span></span>                                 | <span data-ttu-id="7931d-221">OpenGL 公用程式支持對象與視窗座標之間的對應。</span><span class="sxs-lookup"><span data-stu-id="7931d-221">OpenGL utilities support mapping between object and window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="7931d-222">矩陣模式</span><span class="sxs-lookup"><span data-stu-id="7931d-222">matrix mode</span></span>                          | <span data-ttu-id="7931d-223">鳶尾花 GL ortho、ortho2、透視圖和 window 函數會在特定的矩陣上運作，所有 OpenGL 矩陣作業都可在目前的矩陣上運作。</span><span class="sxs-lookup"><span data-stu-id="7931d-223">Where the IRIS GL ortho, ortho2, perspective, and window functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix.</span></span> <span data-ttu-id="7931d-224">除了 glLoadIdentity 和 glLoadMatrix 以外的所有 OpenGL 矩陣作業都會將目前的矩陣相乘，而不會將它取代 (為鳶尾花 GL) 中的 ortho、ortho2、透視圖和 window。</span><span class="sxs-lookup"><span data-stu-id="7931d-224">All OpenGL matrix operations except glLoadIdentity and glLoadMatrix multiply the current matrix rather than replacing it (as do ortho, ortho2, perspective, and window in the IRIS GL).</span></span>                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="7931d-225">mipmap，自動產生</span><span class="sxs-lookup"><span data-stu-id="7931d-225">mipmaps, automatic generation</span></span>        | <span data-ttu-id="7931d-226">OpenGL 材質介面不支援自動產生 mipmap 映射。</span><span class="sxs-lookup"><span data-stu-id="7931d-226">The OpenGL texture interface does not support automatic generation of mipmap images.</span></span> <span data-ttu-id="7931d-227">不過，X.GLU 隊支援針對 1-D 和2D 材質自動產生 mipmap 映射。</span><span class="sxs-lookup"><span data-stu-id="7931d-227">However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="7931d-228">move/draw/pmove/pdraw/pclos</span><span class="sxs-lookup"><span data-stu-id="7931d-228">move/draw/pmove/pdraw/pclos</span></span>          | <span data-ttu-id="7931d-229">OpenGL 僅支援開始/結束樣式圖形，因為它不會維護目前的圖形位置。</span><span class="sxs-lookup"><span data-stu-id="7931d-229">OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position.</span></span> <span data-ttu-id="7931d-230">但是，OpenGL 會針對所有頂點相關的命令，將純量參數規格用於舊的移動/繪製命令。</span><span class="sxs-lookup"><span data-stu-id="7931d-230">The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-231">mprojection 模式</span><span class="sxs-lookup"><span data-stu-id="7931d-231">mprojection mode</span></span>                     | <span data-ttu-id="7931d-232">在投射矩陣模式下，鳶尾花 GL 不會依模型矩陣轉換幾何。</span><span class="sxs-lookup"><span data-stu-id="7931d-232">IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode.</span></span> <span data-ttu-id="7931d-233">無論矩陣模式為何，OpenGL 一律會透過模型和投射矩陣進行轉換。</span><span class="sxs-lookup"><span data-stu-id="7931d-233">OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="7931d-234">多緩衝區繪圖</span><span class="sxs-lookup"><span data-stu-id="7931d-234">multi-buffer drawing</span></span>                 | <span data-ttu-id="7931d-235">OpenGL 會個別轉譯為每個色彩緩衝區，而不是根據一個顏色緩衝區的內容來計算單一、新的色彩值，並將它寫入所有啟用的色彩緩衝區，如同鳶尾花 GL 一樣。</span><span class="sxs-lookup"><span data-stu-id="7931d-235">OpenGL renders to each color buffer individually, rather than computing a single, new, color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="7931d-236">Nurbs</span><span class="sxs-lookup"><span data-stu-id="7931d-236">NURBS</span></span>                                | <span data-ttu-id="7931d-237">OpenGL 支援 NURBS 搭配核心功能 (評估工具) 和 X.GLU 隊支援。</span><span class="sxs-lookup"><span data-stu-id="7931d-237">OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support.</span></span> <span data-ttu-id="7931d-238">支援所有鳶尾花 GL NURBS 功能。</span><span class="sxs-lookup"><span data-stu-id="7931d-238">All IRIS GL NURBS capabilities are supported.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="7931d-239">舊的多邊形模式</span><span class="sxs-lookup"><span data-stu-id="7931d-239">old polygon mode</span></span>                     | <span data-ttu-id="7931d-240">別名的 OpenGL 多邊形一律為點取樣。</span><span class="sxs-lookup"><span data-stu-id="7931d-240">Aliased OpenGL polygons are always point-sampled.</span></span> <span data-ttu-id="7931d-241">不支援鳶尾花 GL 的多邊形相容性模式，也就是在其柵格化中包含多邊形周邊以外的圖元。</span><span class="sxs-lookup"><span data-stu-id="7931d-241">IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported.</span></span> <span data-ttu-id="7931d-242">如果您的程式碼使用這個多邊形模式，可能是矩形。</span><span class="sxs-lookup"><span data-stu-id="7931d-242">If your code uses this polygon mode, it is probably for rectangles.</span></span> <span data-ttu-id="7931d-243">舊的多邊形模式矩形會以較寬或更高的方式顯示一個圖元。</span><span class="sxs-lookup"><span data-stu-id="7931d-243">Old polygon mode rectangles appear one pixel wider and higher.</span></span>                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="7931d-244">壓縮的色彩格式</span><span class="sxs-lookup"><span data-stu-id="7931d-244">packed color formats</span></span>                 | <span data-ttu-id="7931d-245">OpenGL 接受的色彩為8位的元件，但這些元件被視為位元組陣列，而不是壓縮成較大單字的位元組。</span><span class="sxs-lookup"><span data-stu-id="7931d-245">OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words.</span></span> <span data-ttu-id="7931d-246">藉由鼓勵陣列索引編制而不是移位，OpenGL 可以提升 endian 的非變異程式設計。</span><span class="sxs-lookup"><span data-stu-id="7931d-246">By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.</span></span> <span data-ttu-id="7931d-247">如同鳶尾花 GL 可同時接受幾何和圖元轉譯的已封裝色彩，OpenGL 會接受色彩元件的陣列以進行幾何和圖元呈現。</span><span class="sxs-lookup"><span data-stu-id="7931d-247">Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.</span></span>                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-248">patches</span><span class="sxs-lookup"><span data-stu-id="7931d-248">patches</span></span>                              | <span data-ttu-id="7931d-249">OpenGL 不支援鳶尾花 GL 修補程式。</span><span class="sxs-lookup"><span data-stu-id="7931d-249">OpenGL doesn't support IRIS GL patches.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="7931d-250">每位色彩 writemask</span><span class="sxs-lookup"><span data-stu-id="7931d-250">per-bit color writemask</span></span>              | <span data-ttu-id="7931d-251">色彩元件的 OpenGL writemasks 可啟用或停用整個元件的變更 (紅色、綠色、藍色或 Alpha) ，而不是個別元件的元件。</span><span class="sxs-lookup"><span data-stu-id="7931d-251">OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components.</span></span> <span data-ttu-id="7931d-252">請注意，每位 writemasks 都支援兩種色彩索引和樣板索引。</span><span class="sxs-lookup"><span data-stu-id="7931d-252">Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-253">每位深度 writemask</span><span class="sxs-lookup"><span data-stu-id="7931d-253">per-bit depth writemask</span></span>              | <span data-ttu-id="7931d-254">適用于深度元件的 OpenGL writemasks 可啟用或停用整個元件的變更，而不是對深度元件的個別位。</span><span class="sxs-lookup"><span data-stu-id="7931d-254">OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="7931d-255">選擇</span><span class="sxs-lookup"><span data-stu-id="7931d-255">pick</span></span>                                 | <span data-ttu-id="7931d-256">OpenGL 公用程式程式庫包含產生挑選矩陣的支援。</span><span class="sxs-lookup"><span data-stu-id="7931d-256">The OpenGL Utility library includes support for generating a pick matrix.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-257">圖元座標</span><span class="sxs-lookup"><span data-stu-id="7931d-257">pixel coordinates</span></span>                    | <span data-ttu-id="7931d-258">在 OpenGL 和鳶尾花 GL 中，視窗座標系統的原點位於左下角。</span><span class="sxs-lookup"><span data-stu-id="7931d-258">In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner.</span></span> <span data-ttu-id="7931d-259">OpenGL 會將原點放在此圖元的左下角，不過，鳶尾花 GL 會將它放在左下角圖元的中央。</span><span class="sxs-lookup"><span data-stu-id="7931d-259">OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="7931d-260">圖元縮放</span><span class="sxs-lookup"><span data-stu-id="7931d-260">pixel zoom</span></span>                           | <span data-ttu-id="7931d-261">OpenGL 負縮放因數會反映目前的圖形位置。</span><span class="sxs-lookup"><span data-stu-id="7931d-261">OpenGL negative zoom factors reflect about the current graphics position.</span></span> <span data-ttu-id="7931d-262">鳶尾花 GL 不會定義負面比例因數的操作，而是由右 \_ 至 \_ 左和上 \_ 到 \_ 下反映 pixmodes。</span><span class="sxs-lookup"><span data-stu-id="7931d-262">IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT\_TO\_LEFT and TOP\_TO\_BOTTOM reflection pixmodes.</span></span> <span data-ttu-id="7931d-263">這些反映模式會就地反映，而不是與目前的點陣定位相關。</span><span class="sxs-lookup"><span data-stu-id="7931d-263">These reflection modes reflect in place, rather than about the current raster position.</span></span> <span data-ttu-id="7931d-264">OpenGL 不會定義反映模式。</span><span class="sxs-lookup"><span data-stu-id="7931d-264">OpenGL doesn't define reflection modes.</span></span>                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-265">pixmode</span><span class="sxs-lookup"><span data-stu-id="7931d-265">pixmode</span></span>                              | <span data-ttu-id="7931d-266">OpenGL 圖元傳輸會在個別的色彩元件上運作，而不是在鳶尾花 GL 的已封裝 4 8 位元件群組上運作。</span><span class="sxs-lookup"><span data-stu-id="7931d-266">OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL.</span></span> <span data-ttu-id="7931d-267">雖然 OpenGL 提供比鳶尾花 GL 更多的圖元功能，但它不支援封裝的色彩結構，而且也不會讓色彩元件重新指派 (紅色到綠色、紅色到藍色，以及在圖元複製作業期間) 。</span><span class="sxs-lookup"><span data-stu-id="7931d-267">While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</span></span>                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-268">polf/poly</span><span class="sxs-lookup"><span data-stu-id="7931d-268">polf/poly</span></span>                            | <span data-ttu-id="7931d-269">OpenGL 不提供顯示清單以外頂點清單的直接支援。</span><span class="sxs-lookup"><span data-stu-id="7931d-269">OpenGL provides no direct support for vertex lists other than display lists.</span></span> <span data-ttu-id="7931d-270">不過，polf 和 poly 等函式可以使用 OpenGL API 輕鬆地實作為。</span><span class="sxs-lookup"><span data-stu-id="7931d-270">Functions like polf and poly can be implemented easily using the OpenGL API, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="7931d-271">多邊形誘發頂點</span><span class="sxs-lookup"><span data-stu-id="7931d-271">polygon provoking vertex</span></span>             | <span data-ttu-id="7931d-272">平面陰影鳶尾花 GL 多邊形會取得最後一個指定頂點的色彩，而 OpenGL 多邊形則採用指定之第一個頂點的色彩。</span><span class="sxs-lookup"><span data-stu-id="7931d-272">Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="7931d-273">多邊形 stipple</span><span class="sxs-lookup"><span data-stu-id="7931d-273">polygon stipple</span></span>                      | <span data-ttu-id="7931d-274">使用鳶尾花 GL，多邊形 stipple 模式是相對於畫面。</span><span class="sxs-lookup"><span data-stu-id="7931d-274">With IRIS GL the polygon stipple pattern is relative to the screen.</span></span> <span data-ttu-id="7931d-275">使用 OpenGL 時，它會相對於視窗。</span><span class="sxs-lookup"><span data-stu-id="7931d-275">With OpenGL it is relative to a window.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="7931d-276">多邊形頂點計數</span><span class="sxs-lookup"><span data-stu-id="7931d-276">polygon vertex count</span></span>                 | <span data-ttu-id="7931d-277">GlBegin 和 glEnd 與 OpenGL 之間的頂點數目沒有任何限制，即使 glBegin (多邊形 ) 也是如此。</span><span class="sxs-lookup"><span data-stu-id="7931d-277">There is no limit to the number of vertices between glBegin and glEnd with OpenGL, even for glBegin(POLYGON ).</span></span> <span data-ttu-id="7931d-278">使用鳶尾花 GL，多邊形的限制為不超過255個頂點。</span><span class="sxs-lookup"><span data-stu-id="7931d-278">With IRIS GL, polygons are limited to no more than 255 vertices.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="7931d-279">readdisplay</span><span class="sxs-lookup"><span data-stu-id="7931d-279">readdisplay</span></span>                          | <span data-ttu-id="7931d-280">在視窗界限之外讀取圖元，是正確的視窗系統功能，而不是轉譯功能。</span><span class="sxs-lookup"><span data-stu-id="7931d-280">Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability.</span></span> <span data-ttu-id="7931d-281">使用 Windows 函數來取代鳶尾花 GL readdisplay 命令。</span><span class="sxs-lookup"><span data-stu-id="7931d-281">Use Windows functions to replace the IRIS GL readdisplay command.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-282">相對 move/draw/pmove/pdraw/pclos</span><span class="sxs-lookup"><span data-stu-id="7931d-282">relative move/draw/pmove/pdraw/pclos</span></span> | <span data-ttu-id="7931d-283">OpenGL 不會維護目前的圖形位置，因此不支援相對的頂點作業。</span><span class="sxs-lookup"><span data-stu-id="7931d-283">OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="7931d-284">RGBA logicop () </span><span class="sxs-lookup"><span data-stu-id="7931d-284">RGBA logicop()</span></span>                       | <span data-ttu-id="7931d-285">OpenGL 不支援 RGBA 緩衝區上的邏輯作業。</span><span class="sxs-lookup"><span data-stu-id="7931d-285">OpenGL does not support logical operations on RGBA buffers.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="7931d-286">sbox () </span><span class="sxs-lookup"><span data-stu-id="7931d-286">sbox()</span></span>                               | <span data-ttu-id="7931d-287">sbox 是鳶尾花 GL 矩形基本型別，只有在轉換而不旋轉時，才會妥善定義。</span><span class="sxs-lookup"><span data-stu-id="7931d-287">sbox is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation.</span></span> <span data-ttu-id="7931d-288">其設計目的是要比標準矩形更快轉譯。</span><span class="sxs-lookup"><span data-stu-id="7931d-288">It is designed to be rendered faster than standard rectangles.</span></span> <span data-ttu-id="7931d-289">雖然 OpenGL 並不支援這種基本功能，但是當矩陣和其他模式處於簡化計算的狀態時，可以調整以非常快速地轉譯矩形。</span><span class="sxs-lookup"><span data-stu-id="7931d-289">While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations.</span></span>                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="7931d-290">純量引數</span><span class="sxs-lookup"><span data-stu-id="7931d-290">scalar arguments</span></span>                     | <span data-ttu-id="7931d-291">GlBegin 和 glEnd 之間接受的所有 OpenGL 命令都具有接受純量引數的進入點。</span><span class="sxs-lookup"><span data-stu-id="7931d-291">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept scalar arguments.</span></span> <span data-ttu-id="7931d-292">例如，glColor4f (紅色、綠色、藍色、Alpha ) 。</span><span class="sxs-lookup"><span data-stu-id="7931d-292">For example, glColor4f (red, green, blue, alpha ).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="7931d-293">剪刀</span><span class="sxs-lookup"><span data-stu-id="7931d-293">scissor</span></span>                              | <span data-ttu-id="7931d-294">OpenGL glScissor 函式不會追蹤此功能區。</span><span class="sxs-lookup"><span data-stu-id="7931d-294">The OpenGL glScissor function doesn't track the viewport.</span></span> <span data-ttu-id="7931d-295">鳶尾花 GL 視口命令會自動更新 scrmask。</span><span class="sxs-lookup"><span data-stu-id="7931d-295">The IRIS GL viewport command automatically updates the scrmask.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-296">scrbox () </span><span class="sxs-lookup"><span data-stu-id="7931d-296">scrbox()</span></span>                             | <span data-ttu-id="7931d-297">OpenGL 不支援周框方塊計算。</span><span class="sxs-lookup"><span data-stu-id="7931d-297">OpenGL doesn't support bounding box computation.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="7931d-298">scrsubdivide () </span><span class="sxs-lookup"><span data-stu-id="7931d-298">scrsubdivide()</span></span>                       | <span data-ttu-id="7931d-299">OpenGL 不支援螢幕細分。</span><span class="sxs-lookup"><span data-stu-id="7931d-299">OpenGL doesn't support screen subdivision.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="7931d-300">單一矩陣模式</span><span class="sxs-lookup"><span data-stu-id="7931d-300">single matrix mode</span></span>                   | <span data-ttu-id="7931d-301">OpenGL 一律會維護兩個矩陣：模型和投射。</span><span class="sxs-lookup"><span data-stu-id="7931d-301">OpenGL always maintains two matrices: ModelView and Projection.</span></span> <span data-ttu-id="7931d-302">雖然 OpenGL 實作為效能考慮，可以將它們合併成單一矩陣，但它必須一律向程式設計師呈現兩個矩陣模型。</span><span class="sxs-lookup"><span data-stu-id="7931d-302">While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="7931d-303">子圖元模式</span><span class="sxs-lookup"><span data-stu-id="7931d-303">subpixel mode</span></span>                        | <span data-ttu-id="7931d-304">所有 OpenGL 轉譯都是子圖元 positionedsubpixel 模式一律為開啟。</span><span class="sxs-lookup"><span data-stu-id="7931d-304">All OpenGL rendering is subpixel positionedsubpixel mode is always on.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="7931d-305">swaptmesh () </span><span class="sxs-lookup"><span data-stu-id="7931d-305">swaptmesh()</span></span>                          | <span data-ttu-id="7931d-306">OpenGL 不支援 swaptmesh 功能。</span><span class="sxs-lookup"><span data-stu-id="7931d-306">OpenGL doesn't support the swaptmesh capability.</span></span> <span data-ttu-id="7931d-307">它確實提供兩種類型的三角形網格，不過，它會對應至鳶尾花 GL 的預設「帶狀」行為，另一個則是對應至在第三個和所有後續頂點（使用鳶尾花 GL）之前呼叫 swaptmesh。</span><span class="sxs-lookup"><span data-stu-id="7931d-307">It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh prior to the third and all subsequent vertices when using IRIS GL.</span></span>                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="7931d-308">向量引數</span><span class="sxs-lookup"><span data-stu-id="7931d-308">vector arguments</span></span>                     | <span data-ttu-id="7931d-309">GlBegin 和 glEnd 之間接受的所有 OpenGL 命令都具有接受向量引數的進入點。</span><span class="sxs-lookup"><span data-stu-id="7931d-309">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept vector arguments.</span></span> <span data-ttu-id="7931d-310">例如，glColor4fv。</span><span class="sxs-lookup"><span data-stu-id="7931d-310">For example, glColor4fv .</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="7931d-311">視窗管理</span><span class="sxs-lookup"><span data-stu-id="7931d-311">window management</span></span>                    | <span data-ttu-id="7931d-312">OpenGL 不包含任何視窗系統命令。</span><span class="sxs-lookup"><span data-stu-id="7931d-312">OpenGL includes no window system commands.</span></span> <span data-ttu-id="7931d-313">它一律支援做為視窗或作業系統的延伸模組，其包含裝置和視窗控制項的功能。</span><span class="sxs-lookup"><span data-stu-id="7931d-313">It is always supported as an extension to a window or operating system that includes capability for device and window control.</span></span> <span data-ttu-id="7931d-314">每個擴充功能都提供系統特定的機制，可用於建立、終結和操作 OpenGL 轉譯內容。</span><span class="sxs-lookup"><span data-stu-id="7931d-314">Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts.</span></span> <span data-ttu-id="7931d-315">例如，X 視窗系統的 OpenGL 延伸 (GLX) 包含大約10個命令以供此用途。</span><span class="sxs-lookup"><span data-stu-id="7931d-315">For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.</span></span> <span data-ttu-id="7931d-316">鳶尾花 GL 命令（例如 gconfig 和 system.windows.forms.drawmode>）不是由 OpenGL 所執行。</span><span class="sxs-lookup"><span data-stu-id="7931d-316">IRIS GL commands such as gconfig and drawmode are not implemented by OpenGL.</span></span>                                                                                                                                                                            |
| <span data-ttu-id="7931d-317">視窗位移</span><span class="sxs-lookup"><span data-stu-id="7931d-317">window offset</span></span>                        | <span data-ttu-id="7931d-318">鳶尾花 GL 會傳回螢幕中的視口和字元位置，而不是視窗的座標。</span><span class="sxs-lookup"><span data-stu-id="7931d-318">IRIS GL returns viewport and character positions in screen, rather than window, coordinates.</span></span> <span data-ttu-id="7931d-319">OpenGL 一律使用視窗座標。</span><span class="sxs-lookup"><span data-stu-id="7931d-319">OpenGL always uses window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="7931d-320">z 轉譯</span><span class="sxs-lookup"><span data-stu-id="7931d-320">z rendering</span></span>                          | <span data-ttu-id="7931d-321">OpenGL 不支援將色彩轉譯成深度緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7931d-321">OpenGL doesn't support rendering colors to the depth buffer.</span></span> <span data-ttu-id="7931d-322">它允許使用其他視窗設定中用於深度緩衝區的相同記憶體來執行其他的色彩緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7931d-322">It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations.</span></span> <span data-ttu-id="7931d-323">但是這些額外的色彩緩衝區無法與任何單一設定中的深度緩衝區共用記憶體。</span><span class="sxs-lookup"><span data-stu-id="7931d-323">But these additional color buffers cannot share memory with the depth buffer in any single configuration.</span></span>                                                                                                                                                                                                                                                                                                                                          |



 

 

 




