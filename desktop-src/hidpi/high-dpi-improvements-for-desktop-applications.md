---
title: Mixed-Mode DPI 縮放比例和 DPI 感知 Api
description: Mixed-Mode DPI 縮放比例和 DPI 感知 Api
ms.assetid: 44AC0B29-3283-4801-90F5-3E78CCD87B9F
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6f5b16e4c438cfe1f0d04e61524899e213b25ea
ms.sourcegitcommit: b32433cc0394159c7263809ae67615ab5792d40d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/30/2021
ms.locfileid: "113119723"
---
# <a name="mixed-mode-dpi-scaling-and-dpi-aware-apis"></a><span data-ttu-id="10b22-103">Mixed-Mode DPI 縮放比例和 DPI 感知 Api</span><span class="sxs-lookup"><span data-stu-id="10b22-103">Mixed-Mode DPI Scaling and DPI-aware APIs</span></span>

## <a name="sub-process-dpi-awareness-support"></a><span data-ttu-id="10b22-104">Sub-Process DPI 感知支援</span><span class="sxs-lookup"><span data-stu-id="10b22-104">Sub-Process DPI Awareness Support</span></span>

<span data-ttu-id="10b22-105">[**SetThreadDpiAwarenessCoNtext**](/windows/desktop/api/Winuser/nf-winuser-setthreaddpiawarenesscontext) 可讓您在單一進程中使用不同的 DPI 縮放模式。</span><span class="sxs-lookup"><span data-stu-id="10b22-105">[**SetThreadDpiAwarenessContext**](/windows/desktop/api/Winuser/nf-winuser-setthreaddpiawarenesscontext) enables the use of different DPI scaling modes within a single process.</span></span> <span data-ttu-id="10b22-106">在 Windows 10 年度更新版之前，會將視窗的 DPI 感知系結至整個進程的 DPI 感知模式， (DPI 感知、系統 DPI 感知，或 Per-Monitor DPI 感知) 。</span><span class="sxs-lookup"><span data-stu-id="10b22-106">Prior to the Windows 10 Anniversary Update, a window s DPI awareness was bound to the process-wide DPI awareness mode (DPI unaware, System DPI aware, or Per-Monitor DPI aware).</span></span> <span data-ttu-id="10b22-107">但現在，使用 **SetThreadDpiAwarenessCoNtext** 時，最上層的 windows 可以有與整個進程的 DPI 感知模式不同的 DPI 感知模式。</span><span class="sxs-lookup"><span data-stu-id="10b22-107">But now, with **SetThreadDpiAwarenessContext**, top-level windows can have a DPI awareness mode that is different than that of the process-wide DPI awareness mode.</span></span> <span data-ttu-id="10b22-108">這也會影響子視窗，因為它們一律具有與父視窗相同的 DPI 感知模式。</span><span class="sxs-lookup"><span data-stu-id="10b22-108">This also effects child windows, as they will always have the same DPI awareness mode as their parent window.</span></span>

<span data-ttu-id="10b22-109">使用 **SetThreadDpiAwarenessCoNtext** 可讓開發人員在針對桌面應用程式定義 DPI 特定的行為時，決定他們要將其開發工作放在哪裡。</span><span class="sxs-lookup"><span data-stu-id="10b22-109">The use of **SetThreadDpiAwarenessContext** enables developers to decide where they want to focus their development efforts when defining DPI-specific behavior for desktop applications.</span></span> <span data-ttu-id="10b22-110">例如，應用程式的主要最上層視窗可根據個別監視器進行調整，而次要最上層視窗則可透過由作業系統進行點陣圖調整來調整。</span><span class="sxs-lookup"><span data-stu-id="10b22-110">For example, an application's primary top-level window could be scaled on a per-monitor basis while secondary top-level windows could be scaled via bitmap-scaling by the operating system.</span></span>

## <a name="the-dpi-awareness-context"></a><span data-ttu-id="10b22-111">DPI 感知內容</span><span class="sxs-lookup"><span data-stu-id="10b22-111">The DPI Awareness Context</span></span>

<span data-ttu-id="10b22-112">在 **SetThreadDpiAwarenessCoNtext** 可用性之前，進程的 DPI 感知定義在應用程式二進位檔的資訊清單中，或在進程初始化期間透過呼叫 [**SetProcessDpiAwareness**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-setprocessdpiawareness) 。</span><span class="sxs-lookup"><span data-stu-id="10b22-112">Prior to the availability of **SetThreadDpiAwarenessContext** the DPI awareness of a process was defined either in the manifest of the application binary or via a call to [**SetProcessDpiAwareness**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-setprocessdpiawareness) during process initialization.</span></span> <span data-ttu-id="10b22-113">使用 **SetThreadDpiAwarenessCoNtext** 時，每個執行緒可以有個別的 DPI 感知內容，這可能會與整個進程的 DPI 感知模式不同。</span><span class="sxs-lookup"><span data-stu-id="10b22-113">With **SetThreadDpiAwarenessContext**, each thread can have an individual DPI awareness context that may be different than that of the process-wide DPI awareness mode.</span></span> <span data-ttu-id="10b22-114">執行緒的 DPI 感知內容會以 [\* \* \* \* DPI \_ 感知 \_ 內容 \* \*](dpi-awareness-context.md) \* 類型表示，並以下列方式運作：</span><span class="sxs-lookup"><span data-stu-id="10b22-114">The DPI awareness context of a thread is represented with the [\*\*\*\*DPI\_AWARENESS\_CONTEXT\*\*\*\*](dpi-awareness-context.md) type, and behaves in the following ways:</span></span>

-   <span data-ttu-id="10b22-115">執行緒可以隨時變更其 DPI 感知內容。</span><span class="sxs-lookup"><span data-stu-id="10b22-115">A thread can have its DPI awareness context changed at any time.</span></span>
-   <span data-ttu-id="10b22-116">在內容變更之後所做的任何 API 呼叫，將會在對應的 DPI 內容中執行 (且可能會虛擬化) 。</span><span class="sxs-lookup"><span data-stu-id="10b22-116">Any API calls that are made after the context is changed will run in the corresponding DPI context (and may be virtualized).</span></span>
-   <span data-ttu-id="10b22-117">建立視窗時，會在該時間將其 DPI 感知定義為呼叫執行緒的 DPI 感知。</span><span class="sxs-lookup"><span data-stu-id="10b22-117">When a window is created, its DPI awareness is defined as the DPI awareness of the calling thread at that time.</span></span>
-   <span data-ttu-id="10b22-118">當呼叫視窗的視窗程式時，執行緒會自動切換至建立視窗時所使用的 DPI 感知內容。</span><span class="sxs-lookup"><span data-stu-id="10b22-118">When the window procedure for a window is called, the thread is automatically switched to the DPI awareness context that was in use when the window was created.</span></span>

<span data-ttu-id="10b22-119">使用 **SetThreadDpiAwarenessCoNtext** 的常見案例如下：從以一個 (內容執行的執行緒開始，例如， **\_ \_ \_ 每個 \_ 監視器可 \_ 感知 DPI 感知內容**) 暫時切換到不同的內容 (**DPI \_ 感知內容不 \_ \_ 知道**) 、建立視窗，然後立即將執行緒內容切換回先前的狀態。</span><span class="sxs-lookup"><span data-stu-id="10b22-119">A common scenario for the use of **SetThreadDpiAwarenessContext** is as follows: Begin with a thread that is running with one context (such as **DPI\_AWARENESS\_CONTEXT\_PER\_MONITOR\_AWARE**) temporarily switch to a different context (**DPI\_AWARENESS\_CONTEXT\_UNAWARE**), create a window, and then immediately switch the thread context back to its previous state.</span></span> <span data-ttu-id="10b22-120">建立的視窗將會有不 **\_ 感知 DPI 感知 \_ 內容 \_** 的 DPI 內容，而呼叫執行緒的內容將會還原為 **\_ \_ \_ 每個 \_ 監視器 \_ 的 DPI 感知內容** ，並可感知後續的 **SetThreadDpiAwarenessCoNtext** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="10b22-120">The created window will have a DPI context of **DPI\_AWARENESS\_CONTEXT\_UNAWARE**, while the calling thread s context will be restored to **DPI\_AWARENESS\_CONTEXT\_PER\_MONITOR\_AWARE** with a subsequent call to **SetThreadDpiAwarenessContext**.</span></span> <span data-ttu-id="10b22-121">在此案例中，與呼叫執行緒相關聯的視窗會以每個監視器的內容執行 (而不是由作業系統) 的點陣圖延伸，而新建立的視窗則不會 (感知 DPI，因此會自動將顯示集上的點陣圖擴充為 >100% 縮放) 。</span><span class="sxs-lookup"><span data-stu-id="10b22-121">In this scenario, the window associated with the calling thread would run with a per-monitor context (and therefore not be bitmap-stretched by the operating system) while the newly-created window would not be DPI aware (and therefore would be automatically bitmap stretched on a display set to >100% scaling).</span></span>

<span data-ttu-id="10b22-122">圖1說明如何使用 **\_ \_ \_ 每個 \_ 監視器的 DPI 感知內容** 來執行主要進程執行緒，將其內容切換至不 **感知的 DPI \_ 感知 \_ 內容 \_**，然後建立新的視窗。</span><span class="sxs-lookup"><span data-stu-id="10b22-122">Figure 1 illustrates how the main process thread executes with **DPI\_AWARENESS\_CONTEXT\_PER\_MONITOR**, switches its context to **DPI\_AWARENESS\_CONTEXT\_UNAWARE**, and creates a new window.</span></span> <span data-ttu-id="10b22-123">然後，新建立的視窗就會在每次有訊息分派給它或從它發出 API 呼叫時，以 **DPI \_ 感知 \_ 內容 \_** 的 DPI 感知內容執行。</span><span class="sxs-lookup"><span data-stu-id="10b22-123">The newly created window then executes with a DPI awareness context of **DPI\_AWARENESS\_CONTEXT\_UNAWARE** whenever a message is dispatched to it or API calls are made from it.</span></span> <span data-ttu-id="10b22-124">在建立新視窗之後，就會在建立新視窗之後，將主要執行緒還原至其先前的 **DPI \_ 感知內容內容（ \_ \_ 每個 \_ 監視器**）。</span><span class="sxs-lookup"><span data-stu-id="10b22-124">Immediately after creating the new window the main thread is restored to its previous context of **DPI\_AWARENESS\_CONTEXT\_PER\_MONITOR**.</span></span>

![顯示每個監視器 DPI 感知運作方式的圖表](images/dpi-awareness-context.png)

## <a name="new-dpi-related-apis"></a><span data-ttu-id="10b22-126">新的 DPI 相關 Api</span><span class="sxs-lookup"><span data-stu-id="10b22-126">New DPI-related APIs</span></span>

<span data-ttu-id="10b22-127">除了在 **SetThreadDpiAwarenessCoNtext** 提供的單一進程內支援不同的 DPI 感知模式之外，還為桌面應用程式新增了下列 DPI 特定功能：</span><span class="sxs-lookup"><span data-stu-id="10b22-127">In addition to the support for different DPI awareness modes within a single process that **SetThreadDpiAwarenessContext** offers, the following DPI-specific functionality has been added for desktop applications:</span></span><dl> <dd>[<span data-ttu-id="10b22-128">EnableNonClientDpiScaling\*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="10b22-128">\*\*\*\*EnableNonClientDpiScaling\*\*\*\*</span></span>](/windows/desktop/api/Winuser/nf-winuser-enablenonclientdpiscaling)<dl> <dt>



> [!Note]  
> <span data-ttu-id="10b22-129">個別 **監視器 V2** DPI 感知模式會自動啟用這項功能，因此使用它的應用程式不需要呼叫 **EnableNonClientDpiScaling** 。</span><span class="sxs-lookup"><span data-stu-id="10b22-129">The **Per Monitor V2** DPI awareness mode automatically enables this functionality, and calling **EnableNonClientDpiScaling** is therefore unnecessary in applications using it.</span></span>

 

<span data-ttu-id="10b22-130">從視窗 s **WM \_ NCCREATE** 處理常式內呼叫 **EnableNonClientDpiScaling** ，會導致最上層視窗的非工作區自動針對 DPI 進行調整。</span><span class="sxs-lookup"><span data-stu-id="10b22-130">Calling **EnableNonClientDpiScaling** from within a window s **WM\_NCCREATE** handler will result in the non-client area of a top-level window automatically scaling for DPI.</span></span> <span data-ttu-id="10b22-131">如果最上層視窗是個別監視器 DPI 感知的 (，是因為進程本身是個別監視器 DPI 感知，還是在每個監視器 DPI 感知執行緒內建立的視窗) ，則每當視窗的 DPI 變更時，這些視窗的標題列、捲軸、功能表和功能表列都將會進行 DPI 縮放。</span><span class="sxs-lookup"><span data-stu-id="10b22-131">If the top-level window is per-monitor DPI-aware (whether because the process itself is per-monitor DPI-aware or because the window was created within a per-monitor DPI-aware thread), the caption bar, scroll bars, menus, and menu bars of these windows will DPI-scale whenever the window s DPI changes.</span></span>
</dt> <dt>

<span data-ttu-id="10b22-132">請注意，使用此 API 時，子視窗的非用戶端區域（例如子編輯控制項的非用戶端捲軸）將不會自動調整 DPI。</span><span class="sxs-lookup"><span data-stu-id="10b22-132">Note that non-client areas of a child window, such as non-client scroll bars of a child edit control, will not DPI scale automatically when this API is used.</span></span>
</dt> <dt>

> [!Note]  
> <span data-ttu-id="10b22-133">您必須從 **WM \_ NCCREATE** 處理常式呼叫 **EnableNonClientDpiScaling** 。</span><span class="sxs-lookup"><span data-stu-id="10b22-133">**EnableNonClientDpiScaling** must be called from the **WM\_NCCREATE** handler.</span></span>

</dt> </dl> </dd> <dd> <span data-ttu-id="10b22-134"><b> \* ForDpi Api </b></span><span class="sxs-lookup"><span data-stu-id="10b22-134"><b> The \*ForDpi APIs </b></span></span>

-   <span data-ttu-id="10b22-135">數個經常使用的 Api （例如 [**GetSystemMetrics**](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) ）沒有 HWND 的任何內容，因此無法針對其傳回值推算出適當的 DPI 感知。</span><span class="sxs-lookup"><span data-stu-id="10b22-135">Several frequently-used APIs such as [**GetSystemMetrics**](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) do not have any context of an HWND and therefore have no way of deducing the proper DPI awareness for their return values.</span></span> <span data-ttu-id="10b22-136">從不同 DPI 感知模式或內容中執行的執行緒呼叫這些 Api，可能會傳回未針對呼叫執行緒內容進行調整的值。</span><span class="sxs-lookup"><span data-stu-id="10b22-136">Calling these APIs from a thread that is running in a different DPI awareness mode or context may return values that are not scaled for the context of the calling thread.</span></span> <span data-ttu-id="10b22-137">[\* \* \* \* GetSystemMetricForDpi \* \*](/windows/desktop/api/Winuser/nf-winuser-getsystemmetricsfordpi)\* *、 [\* \* \* \* SystemParametersInfoForDpi \* \*](/windows/desktop/api/Winuser/nf-winuser-systemparametersinfofordpi)* 和 \* \* \* \* [AdjustWindowRectExForDpi \*](/windows/desktop/api/Winuser/nf-winuser-adjustwindowrectexfordpi) \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*</span><span class="sxs-lookup"><span data-stu-id="10b22-137">[\*\*\*\*GetSystemMetricForDpi\*\*\*\*](/windows/desktop/api/Winuser/nf-winuser-getsystemmetricsfordpi), [\*\*\*\*SystemParametersInfoForDpi\*\*\*\*](/windows/desktop/api/Winuser/nf-winuser-systemparametersinfofordpi), and [\*\*\*\*AdjustWindowRectExForDpi\*\*\*\*](/windows/desktop/api/Winuser/nf-winuser-adjustwindowrectexfordpi) will perform the same functionality as their DPI unaware counterparts, but take a DPI as an argument and infer the dpi awareness from the current thread's context.</span></span>
-   <span data-ttu-id="10b22-138">**GetSystemMetricForDpi** 和 **SystemParametersInfoForDpi** 將會根據此方程式傳回 DPI 縮放的系統度量值和系統參數值：</span><span class="sxs-lookup"><span data-stu-id="10b22-138">**GetSystemMetricForDpi** and **SystemParametersInfoForDpi** will return DPI-scaled system metric values and system parameter values in accordance to this equation:</span></span>

    
    <span data-ttu-id="10b22-139">GetSystemMetrics ( ... ) @ DPI = = GetSystemMetricsForDpi ( ...，DPI) </span><span class="sxs-lookup"><span data-stu-id="10b22-139">GetSystemMetrics(...) @ dpi == GetSystemMetricsForDpi(..., dpi)</span></span>

    

     

    <span data-ttu-id="10b22-140">因此，在具有特定系統 DPI 值的裝置上執行時，呼叫 **GetSystemMetrics** (或 **SystemParametersInfoForDpi**) 將會傳回與其 Dpi 感知變異 (**GetSystemMetricsForDpi** 和 **SystemParametersInfoForDpi**) 相同的值，並提供與輸入相同的 DPI 值。</span><span class="sxs-lookup"><span data-stu-id="10b22-140">Therefore, calling **GetSystemMetrics** (or **SystemParametersInfoForDpi**), while running on a device with a certain system DPI value will return the same value that their DPI aware variants (**GetSystemMetricsForDpi** and **SystemParametersInfoForDpi**) will, given the same DPI value as input.</span></span>

-   <span data-ttu-id="10b22-141">[**AdjustWindowRectExForDpi**](/windows/desktop/api/Winuser/nf-winuser-adjustwindowrectexfordpi) 會採用 HWND，並以 DPI 敏感性的方式計算視窗矩形所需的大小。</span><span class="sxs-lookup"><span data-stu-id="10b22-141">[**AdjustWindowRectExForDpi**](/windows/desktop/api/Winuser/nf-winuser-adjustwindowrectexfordpi) takes an HWND and will calculate the required size of a window rectangle in a DPI-sensitive way.</span></span>

</dd> <dd>

</dd> <dd><span data-ttu-id="10b22-142"><b><a href="/windows/desktop/api/Winuser/nf-winuser-getdpiforwindow">GetDpiForWindow</a></b></span><span class="sxs-lookup"><span data-stu-id="10b22-142"><b><a href="/windows/desktop/api/Winuser/nf-winuser-getdpiforwindow">GetDpiForWindow</a></b></span></span><dl> <span data-ttu-id="10b22-143"><dt><b>GetDpiForWindow</b>會傳回與提供之 HWND 相關聯的 DPI。</span><span class="sxs-lookup"><span data-stu-id="10b22-143"><dt> <b>GetDpiForWindow</b> will return the DPI associated with the HWND provided.</span></span> <span data-ttu-id="10b22-144">答案將取決於 HWND 的 DPI 感知模式：</span><span class="sxs-lookup"><span data-stu-id="10b22-144">The answer will depend on the DPI awareness mode of the HWND:</span></span>

| <span data-ttu-id="10b22-145">HWND 的 DPI 感知模式</span><span class="sxs-lookup"><span data-stu-id="10b22-145">DPI Awareness mode of HWND</span></span> | <span data-ttu-id="10b22-146">傳回值</span><span class="sxs-lookup"><span data-stu-id="10b22-146">Return value</span></span>                                                                                                                                                                                                  |
|----------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="10b22-147">知道</span><span class="sxs-lookup"><span data-stu-id="10b22-147">Unaware</span></span>                    | <span data-ttu-id="10b22-148">96</span><span class="sxs-lookup"><span data-stu-id="10b22-148">96</span></span>                                                                                                                                                                                                            |
| <span data-ttu-id="10b22-149">系統</span><span class="sxs-lookup"><span data-stu-id="10b22-149">System</span></span>                     | <span data-ttu-id="10b22-150">系統 DPI</span><span class="sxs-lookup"><span data-stu-id="10b22-150">The system DPI</span></span>                                                                                                                                                                                                |
| <span data-ttu-id="10b22-151">Per-Monitor</span><span class="sxs-lookup"><span data-stu-id="10b22-151">Per-Monitor</span></span>                | <span data-ttu-id="10b22-152">相關聯的最上層視窗的顯示 DPI，主要位於</span><span class="sxs-lookup"><span data-stu-id="10b22-152">The DPI of display that the associated top-level window is primarily located on</span></span> <br/> <span data-ttu-id="10b22-153"> (如果提供子視窗，則會傳回對應最上層父視窗的 DPI) </span><span class="sxs-lookup"><span data-stu-id="10b22-153">(If a child window is provided, the DPI of the corresponding top-level parent window will be returned)</span></span><br/> |

</dt> </dl> </dd> <dd><span data-ttu-id="10b22-154"><b><a href="/windows/desktop/api/Winuser/nf-winuser-getdpiforsystem">GetDpiForSystem</a></b></span><span class="sxs-lookup"><span data-stu-id="10b22-154"><b><a href="/windows/desktop/api/Winuser/nf-winuser-getdpiforsystem">GetDpiForSystem</a></b></span></span><dl> <dt>

<span data-ttu-id="10b22-155">呼叫 **GetDpiForSystem** 比呼叫 [**GetDC**](/windows/desktop/api/winuser/nf-winuser-getdc) 和 [**GetDeviceCaps**](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) 來取得系統 DPI 更有效率。</span><span class="sxs-lookup"><span data-stu-id="10b22-155">Calling **GetDpiForSystem** is more efficient than calling [**GetDC**](/windows/desktop/api/winuser/nf-winuser-getdc) and [**GetDeviceCaps**](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) to obtain the system DPI.</span></span>
</dt> <dt>

<span data-ttu-id="10b22-156">任何可能在使用子進程 DPI 感知的應用程式中執行的元件，都不應該假設在進程生命週期期間，系統 DPI 是靜態的。</span><span class="sxs-lookup"><span data-stu-id="10b22-156">Any component that could be running in an application that uses sub-process DPI awareness should not assume that the system DPI is static during the lifecycle of the process.</span></span> <span data-ttu-id="10b22-157">例如，如果在 **DPI \_ 感知 \_ 內容 \_** 感知感知內容下執行的執行緒會查詢系統 DPI，則答案會是96。</span><span class="sxs-lookup"><span data-stu-id="10b22-157">For example, if a thread that is running under **DPI\_AWARENESS\_CONTEXT\_UNAWARE** awareness context queries the system DPI, the answer will be 96.</span></span> <span data-ttu-id="10b22-158">但是，如果該相同執行緒切換至 **DPI \_ 感知 \_ 內容 \_ 系統** 感知內容，並重新查詢系統 DPI，則答案可能會不同。</span><span class="sxs-lookup"><span data-stu-id="10b22-158">However, if that same thread switched to **DPI\_AWARENESS\_CONTEXT\_SYSTEM** awareness context and queried the system DPI again, the answer could be different.</span></span> <span data-ttu-id="10b22-159">若要避免使用快取的 (且可能過時) 系統 DPI 值，請使用 **GetDpiForSystem** 來抓取相對於呼叫執行緒之 DPI 感知模式的系統 DPI。</span><span class="sxs-lookup"><span data-stu-id="10b22-159">To avoid the use of a cached (and possibly stale) system-DPI value, use **GetDpiForSystem** to retrieve the system DPI relative to the DPI awareness mode of the calling thread.</span></span> 
</dt> </dl> </dd> </dl>
