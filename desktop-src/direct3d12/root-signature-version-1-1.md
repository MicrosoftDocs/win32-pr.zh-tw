---
title: 根簽章版本1。1
description: 根簽章版本1.1 的目的是要讓應用程式向驅動程式指出描述項堆積中的描述項不會變更，或資料描述元指向不會變更。
ms.assetid: 8FE42C1C-7F1D-4E70-A7EE-D5EC67237327
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 04a7a32576efa4d93a8d26aa57282f06e0d5a02f
ms.sourcegitcommit: b40a986d5ded926ae7617119cdd35d99b533bad9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/24/2021
ms.locfileid: "110343663"
---
# <a name="root-signature-version-11"></a><span data-ttu-id="b431f-103">根簽章版本1。1</span><span class="sxs-lookup"><span data-stu-id="b431f-103">Root Signature Version 1.1</span></span>

<span data-ttu-id="b431f-104">根簽章版本1.1 的目的是要讓應用程式向驅動程式指出描述項堆積中的描述項不會變更，或資料描述元指向不會變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-104">The purpose of Root Signature version 1.1 is to enable applications to indicate to drivers when descriptors in a descriptor heap won’t change or the data descriptors point to won’t change.</span></span> <span data-ttu-id="b431f-105">如此一來，驅動程式的選項就能進行優化，以瞭解描述項或所指向的記憶體在一段時間內是靜態的。</span><span class="sxs-lookup"><span data-stu-id="b431f-105">This allows the option for drivers to make optimizations that might be possible knowing that a descriptor or the memory it points to is static for some period of time.</span></span>

-   [<span data-ttu-id="b431f-106">概觀</span><span class="sxs-lookup"><span data-stu-id="b431f-106">Overview</span></span>](#overview)
-   [<span data-ttu-id="b431f-107">靜態和 Volatile 旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-107">Static and Volatile Flags</span></span>](#static-and-volatile-flags)
    -   [<span data-ttu-id="b431f-108">描述項 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-108">DESCRIPTORS\_VOLATILE</span></span>](#descriptors_volatile)
    -   [<span data-ttu-id="b431f-109">資料 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-109">DATA\_VOLATILE</span></span>](#data_volatile)
    -   [<span data-ttu-id="b431f-110">\_ \_ \_ \_ 在執行時設定靜態 \_ 資料</span><span class="sxs-lookup"><span data-stu-id="b431f-110">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>](#data_static_while_set_at_execute)
    -   [<span data-ttu-id="b431f-111">資料 \_ 靜態</span><span class="sxs-lookup"><span data-stu-id="b431f-111">DATA\_STATIC</span></span>](#data_static)
    -   [<span data-ttu-id="b431f-112">組合旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-112">Combining Flags</span></span>](#combining-flags)
    -   [<span data-ttu-id="b431f-113">旗標摘要</span><span class="sxs-lookup"><span data-stu-id="b431f-113">Flag Summary</span></span>](#flag-summary)
-   [<span data-ttu-id="b431f-114">版本 1.1 API 摘要</span><span class="sxs-lookup"><span data-stu-id="b431f-114">Version 1.1 API Summary</span></span>](#version-11-api-summary)
    -   [<span data-ttu-id="b431f-115">列舉</span><span class="sxs-lookup"><span data-stu-id="b431f-115">Enums</span></span>](#enums)
    -   [<span data-ttu-id="b431f-116">結構</span><span class="sxs-lookup"><span data-stu-id="b431f-116">Structures</span></span>](#helper-structures)
    -   [<span data-ttu-id="b431f-117">函數</span><span class="sxs-lookup"><span data-stu-id="b431f-117">Functions</span></span>](#functions)
    -   [<span data-ttu-id="b431f-118">方法</span><span class="sxs-lookup"><span data-stu-id="b431f-118">Methods</span></span>](#methods)
    -   [<span data-ttu-id="b431f-119">Helper 結構</span><span class="sxs-lookup"><span data-stu-id="b431f-119">Helper structures</span></span>](#helper-structures)
-   [<span data-ttu-id="b431f-120">違反靜態性質旗標的後果</span><span class="sxs-lookup"><span data-stu-id="b431f-120">Consequences of violating static-ness flags</span></span>](#consequences-of-violating-static-ness-flags)
-   [<span data-ttu-id="b431f-121">版本管理</span><span class="sxs-lookup"><span data-stu-id="b431f-121">Version management</span></span>](#version-management)
-   [<span data-ttu-id="b431f-122">相關主題</span><span class="sxs-lookup"><span data-stu-id="b431f-122">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="b431f-123">概觀</span><span class="sxs-lookup"><span data-stu-id="b431f-123">Overview</span></span>

<span data-ttu-id="b431f-124">根簽章版本1.0 可讓應用程式的內容堆積的內容，以及它們所指向的記憶體，隨時都可供應用程式在 GPU 上進行參考的命令清單/組合時自由變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-124">Root Signature version 1.0 allows the contents of descriptor heaps and the memory they point at to be freely changed by applications any time that command lists / bundles referencing them are potentially in flight on the GPU.</span></span> <span data-ttu-id="b431f-125">不過，通常應用程式在記錄參考它們的命令之後，不需要彈性變更描述元或記憶體。</span><span class="sxs-lookup"><span data-stu-id="b431f-125">Very often, however, applications don’t actually need the flexibility to change descriptors or memory after commands that reference them have been recorded.</span></span>

<span data-ttu-id="b431f-126">應用程式通常完整能夠：</span><span class="sxs-lookup"><span data-stu-id="b431f-126">Applications are often trivially able to:</span></span>

-   <span data-ttu-id="b431f-127">設定描述元 (以及它們在命令清單或組合上系結描述項資料表或根描述元之前所指向) 的記憶體。</span><span class="sxs-lookup"><span data-stu-id="b431f-127">Set up descriptors (and possible the memory they point to) before binding descriptor tables or root descriptors on a command list or bundle.</span></span>
-   <span data-ttu-id="b431f-128">請確定這些描述項在參考它們的命令清單/bundles 完成最後一次執行之後，才會變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-128">Ensure that these descriptors will not change until the command list /bundles referencing them have finished executing for the last time.</span></span>
-   <span data-ttu-id="b431f-129">請確定描述元指向的資料在相同的完整持續時間內不會變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-129">Ensure the data the descriptors point to does not change for the same full duration.</span></span>

<span data-ttu-id="b431f-130">或者，應用程式只能接受該資料不會在較短的時間內變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-130">Alternatively, an application may only be able to honor that data doesn’t change for a shorter duration in time.</span></span> <span data-ttu-id="b431f-131">在命令清單執行期間，在命令清單執行期間，特定資料可能會是靜態的，因為根參數系結 (描述中繼資料表或根描述元) 目前指向資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-131">In particular data might be static for the window in time during command list execution that a root parameter binding (descriptor table or root descriptor) currently points to the data.</span></span> <span data-ttu-id="b431f-132">換句話說，應用程式可能會想要在 GPU 時間軸上執行執行，以在透過根參數設定資料的期間內更新某些資料，並瞭解設定它將是靜態的時候。</span><span class="sxs-lookup"><span data-stu-id="b431f-132">In other words, an application may wish to perform execution on the GPU timeline that updates some data in between time periods where it is set via a root parameter, knowing that when it is set it will be static.</span></span>

<span data-ttu-id="b431f-133">如果描述項或資料描述項指向，將不會變更，則特定的優化驅動程式可能會是硬體廠商專屬的，而且重要的是，它們不會變更可能會改善效能的行為。</span><span class="sxs-lookup"><span data-stu-id="b431f-133">If descriptors, or the data descriptors point to, will not change, then the specific optimizations drivers might do are hardware vendor specific, and importantly they do not change behavior other than possibly improving performance.</span></span> <span data-ttu-id="b431f-134">盡可能保留最多應用程式意圖的知識，並不會對應用程式造成負擔。</span><span class="sxs-lookup"><span data-stu-id="b431f-134">Preserving as much knowledge about application intent as possible does not put a burden on applications.</span></span>

<span data-ttu-id="b431f-135">其中一個優化是許多驅動程式如果知道應用程式可以對描述項和資料的靜態性質產生的保證，就可以產生更有效率的記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="b431f-135">One optimization is that many drivers can produce more efficient memory accesses by shaders if they know the promises an application can make about the static-ness of descriptors and data.</span></span> <span data-ttu-id="b431f-136">例如，如果特定硬體不區分根引數的大小，則驅動程式可以藉由將堆積中的描述項轉換成根描述項，來移除其存取層級的間接取值層級。</span><span class="sxs-lookup"><span data-stu-id="b431f-136">For example, drivers could remove a level of indirection for accessing a descriptor in a heap by converting it into a root descriptor if the particular hardware is not sensitive to root argument size.</span></span>

<span data-ttu-id="b431f-137">使用1.1 版的開發人員所做的額外工作，是盡可能地針對資料的變動性和靜態性質做出承諾，讓驅動程式能夠進行優化。</span><span class="sxs-lookup"><span data-stu-id="b431f-137">The additional task for developer using Version 1.1 is to make promises about the volatility and static-ness of data wherever possible, so that drivers can make the optimizations that make sense.</span></span> <span data-ttu-id="b431f-138">開發人員不需要對靜態性質做出任何承諾。</span><span class="sxs-lookup"><span data-stu-id="b431f-138">Developers do not have to make any promises about static-ness.</span></span>

<span data-ttu-id="b431f-139">因為重新編譯根簽章的應用程式預設為根簽章1.1，所以現在 (有必要的選項可強制執行 1.0) ，所以根簽章版本1.0 會繼續運作。</span><span class="sxs-lookup"><span data-stu-id="b431f-139">Root Signature version 1.0 continues to function unchanged, though applications that recompile root signatures will default to Root Signature 1.1 now (with an option to force version 1.0 if desired).</span></span>

## <a name="static-and-volatile-flags"></a><span data-ttu-id="b431f-140">靜態和 Volatile 旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-140">Static and Volatile Flags</span></span>

<span data-ttu-id="b431f-141">下列旗標是根簽章的一部分，可讓驅動程式選擇在設定個別根引數時，如何最好處理這些引數的策略，並同時將相同的假設內嵌至管線狀態物件 (Pso 在原始編譯時) ，因為根簽章是 PSO 的一部分。</span><span class="sxs-lookup"><span data-stu-id="b431f-141">The following flags are part of the root signature to allow drivers to choose a strategy for how to best handle individual root arguments when they are set, and also embed the same assumptions into Pipeline State Objects (PSOs) when they are originally compiled - since the root signature is part of a PSO.</span></span>

<span data-ttu-id="b431f-142">下列旗標是由應用程式所設定，並套用至描述項或資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-142">The following flags are set by the app and apply to descriptors or data.</span></span>

``` syntax
typedef enum D3D12_DESCRIPTOR_RANGE_FLAGS
{
    D3D12_DESCRIPTOR_RANGE_FLAG_NONE    = 0,
    D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE    = 0x1,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE   = 0x2,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE    = 0x4,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC = 0x8
} D3D12_DESCRIPTOR_RANGE_FLAGS;

typedef enum D3D12_ROOT_DESCRIPTOR_FLAGS
{
    D3D12_ROOT_DESCRIPTOR_FLAG_NONE = 0,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE    = 0x2,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC  = 0x8
} D3D12_ROOT_DESCRIPTOR_FLAGS;
```

### <a name="descriptors_volatile"></a><span data-ttu-id="b431f-143">描述項 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-143">DESCRIPTORS\_VOLATILE</span></span>

<span data-ttu-id="b431f-144">在設定此旗標之後，應用程式可以隨時變更根描述中繼資料表所指向之描述元堆積中的描述元，但不包括系結描述項資料表的命令清單/組合已提交，而且尚未完成執行。</span><span class="sxs-lookup"><span data-stu-id="b431f-144">With this flag set, the descriptors in a descriptor heap pointed to by a root descriptor table can be changed by the application any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="b431f-145">例如，在提交命令清單以便執行 *之前* ，記錄命令清單以及後續變更描述項堆積中的描述項。</span><span class="sxs-lookup"><span data-stu-id="b431f-145">For instance, recording a command list and subsequently changing descriptors in a descriptor heap it refers to *before* submitting the command list for execution is valid.</span></span> <span data-ttu-id="b431f-146">這是根簽章1.0 版唯一支援的行為。</span><span class="sxs-lookup"><span data-stu-id="b431f-146">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="b431f-147">如果 \_ *未* 設定描述項 VOLATILE 旗標，則描述項是靜態的。</span><span class="sxs-lookup"><span data-stu-id="b431f-147">If the DESCRIPTORS\_VOLATILE flag is *not* set then descriptors are static.</span></span> <span data-ttu-id="b431f-148">此模式沒有旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-148">There is no flag for this mode.</span></span> <span data-ttu-id="b431f-149">靜態描述項表示在記錄) 時，根描述中繼資料表所指向之描述元堆積中的描述元已 (初始化，而描述項必須等到命令清單/組合完成最後一次執行之後才能變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-149">Static descriptors mean the descriptors in a descriptor heap pointed to by a root descriptor table have been initialized by the time the descriptor table is set on a command list / bundle (during recording), and the descriptors cannot be changed until the command list / bundle has finished executing for the last time.</span></span> <span data-ttu-id="b431f-150">*針對根簽章版本1.1，靜態描述項是預設假設*，而且應用程式必須 \_ 在必要時指定描述項 VOLATILE 旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-150">*For Root Signature version 1.1, static descriptors are the default assumption*, and the application has to specify the DESCRIPTORS\_VOLATILE flag when needed.</span></span>

<span data-ttu-id="b431f-151">針對使用具有靜態描述項之描述項資料表的組合，在記錄套件組合 (時，必須準備好描述項，而不是在套件組合被) 呼叫時進行變更，而不會在套件組合完成最後一次執行之前變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-151">For bundles using descriptor tables with static descriptors, the descriptors have to be ready starting at the time the bundle is recorded (as opposed to when the bundle is called), and not change until the bundle has finished executing for the last time.</span></span> <span data-ttu-id="b431f-152">指向靜態描述元的描述中繼資料表必須在套件組合記錄期間設定，而不會繼承到組合。</span><span class="sxs-lookup"><span data-stu-id="b431f-152">Descriptor tables pointing to static descriptors have to be set during bundle recording and not inherited into the bundle.</span></span> <span data-ttu-id="b431f-153">命令清單若要使用描述中繼資料表，以及已在組合中設定並傳回命令清單的靜態描述項，這是有效的。</span><span class="sxs-lookup"><span data-stu-id="b431f-153">It is valid for a command list to use a descriptor table with static descriptors that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="b431f-154">當描述項為靜態時，需要設定描述項 VOLATILE 旗標的另一個行為變更 \_ 。</span><span class="sxs-lookup"><span data-stu-id="b431f-154">When descriptors are static there is another change in behavior that requires the DESCRIPTORS\_VOLATILE flag to be set.</span></span> <span data-ttu-id="b431f-155">除了 Texture1D/2D/3D/Cube 視圖之外，外 (任何緩衝區視圖的界限存取) 無效，並產生未定義的結果（包括可能的裝置重設），而不是傳回讀取或卸載寫入的預設值。</span><span class="sxs-lookup"><span data-stu-id="b431f-155">Out of bounds accesses to any Buffer views (as opposed to Texture1D/2D/3D/Cube views) are invalid and produce undefined results, including possible device reset, rather than returning default values for reads or dropping writes.</span></span> <span data-ttu-id="b431f-156">若要移除應用程式相依于硬體超出範圍存取檢查的能力，可讓驅動程式選擇將靜態描述項存取權升階到根描述項存取，如果它們認為較有效率。</span><span class="sxs-lookup"><span data-stu-id="b431f-156">The purpose for removing the ability for applications to depend on hardware out of bounds access checking is to allow drivers to choose to promote static descriptor accesses to root descriptor accesses if they deem that more efficient.</span></span> <span data-ttu-id="b431f-157">根描述項不支援任何超出範圍的檢查。</span><span class="sxs-lookup"><span data-stu-id="b431f-157">Root descriptors don’t support any out of bounds checking.</span></span>

<span data-ttu-id="b431f-158">如果應用程式在存取描述項時相依于不限時的記憶體存取行為，則必須將存取這些描述項的描述項範圍標記為描述項 \_ VOLATILE。</span><span class="sxs-lookup"><span data-stu-id="b431f-158">If applications depend on safe out of bounds memory access behavior when accessing descriptors, they need to mark the descriptor ranges that access those descriptors as DESCRIPTORS\_VOLATILE.</span></span>

### <a name="data_volatile"></a><span data-ttu-id="b431f-159">資料 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-159">DATA\_VOLATILE</span></span>

<span data-ttu-id="b431f-160">設定此旗標之後，CPU 可以隨時變更由描述元所指向的資料，但不包括系結描述項資料表的命令清單/組合已提交，而且尚未完成執行。</span><span class="sxs-lookup"><span data-stu-id="b431f-160">With this flag set, the data pointed to by descriptors can be changed by the CPU any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="b431f-161">這是根簽章1.0 版唯一支援的行為。</span><span class="sxs-lookup"><span data-stu-id="b431f-161">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="b431f-162">旗標適用于兩個描述項範圍旗標和根描述元旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-162">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static_while_set_at_execute"></a><span data-ttu-id="b431f-163">\_ \_ \_ \_ 在執行時設定靜態 \_ 資料</span><span class="sxs-lookup"><span data-stu-id="b431f-163">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>

<span data-ttu-id="b431f-164">設定此旗標之後，如果在 GPU 時間軸上執行時，在命令清單/套件組合上設定基礎根目錄描述元或描述中繼資料表，且在後續的繪製/分派將不再參考資料時，就無法從開始變更描述項所指向的資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-164">With this flag set, the data pointed to by descriptors cannot change starting from when the underlying root descriptor or descriptor table is set on a command list / bundle during execution on the GPU timeline, and ending when subsequent draws/dispatches will no longer reference the data.</span></span>

<span data-ttu-id="b431f-165">在 GPU 上設定根描述元或描述中繼資料表之前，您甚至 *可以* 透過相同的命令清單/套件組合來變更此資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-165">Before a root descriptor or descriptor table has been set on the GPU, this data *can* be changed even by the same command list / bundle.</span></span> <span data-ttu-id="b431f-166">當根描述元或描述中繼資料表指向該資料時，也會在命令清單/套件組合上進行變更，只要繪製/分派參考它已完成。</span><span class="sxs-lookup"><span data-stu-id="b431f-166">The data can also be changed while a root descriptor or descriptor table pointing to it is still set on the command list / bundle, as long as draw/dispatches referencing it have completed.</span></span> <span data-ttu-id="b431f-167">不過，這樣做需要在下一次參考根描述元或描述中繼資料表之前，再次將描述中繼資料表重新綁定至命令清單。</span><span class="sxs-lookup"><span data-stu-id="b431f-167">However, doing so requires the descriptor table be rebound to the command list again before the next time the root descriptor or descriptor table is dereferenced.</span></span> <span data-ttu-id="b431f-168">這可讓驅動程式知道根描述元或描述中繼資料表所指向的資料已經變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-168">This allows the driver to know that data pointed to by a root descriptor or descriptor table has changed.</span></span>

<span data-ttu-id="b431f-169">在「執行」和「資料 volatile」設定時，資料靜態之間的基本差異在於 \_ \_ \_ \_ \_ \_ 資料 \_ volatile 驅動程式無法判斷命令清單中的資料複製是否已變更描述項所指向的資料，而不需要進行額外的狀態追蹤。</span><span class="sxs-lookup"><span data-stu-id="b431f-169">The essential difference between DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE and DATA\_VOLATILE is with DATA\_VOLATILE a driver can’t tell whether data copies in a command list have changed the data pointed to by a descriptor, without doing extra state tracking.</span></span> <span data-ttu-id="b431f-170">比方說，如果驅動程式可以將任何類型的資料預先提取命令插入其命令清單中 (以便讓著色器存取已知資料更有效率，例如) ， \_ \_ \_ 在執行時設定的資料靜態 \_ ， \_ 可讓驅動程式知道它只需要在透過 [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable)、 [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) 或其中一個方法設定常數緩衝區視圖、著色器資源檢視器或未排序的存取權時，執行預先提取資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-170">So if, for instance, a driver can insert any sort of data pre-fetching commands into their command list (to make shader access to known data more efficient, for example), DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE lets the driver know it only needs to perform data pre-fetching at the moment it is set via [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable), [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) or one of the methods to set the constant buffer view, shader resource view, or unordered access view.</span></span>

<span data-ttu-id="b431f-171">針對套件組合，在執行設定時，資料為靜態的保證會在每次執行組合時單獨套用。</span><span class="sxs-lookup"><span data-stu-id="b431f-171">For bundles, the promise that data is static while set at execute applies uniquely to each execution of the bundle.</span></span>

<span data-ttu-id="b431f-172">旗標適用于兩個描述項範圍旗標和根描述元旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-172">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static"></a><span data-ttu-id="b431f-173">資料 \_ 靜態</span><span class="sxs-lookup"><span data-stu-id="b431f-173">DATA\_STATIC</span></span>

<span data-ttu-id="b431f-174">如果設定此旗標，則由描述項所指向的資料已在錄製期間于命令清單/套件組合上設定了參考記憶體的根描述元或描述中繼資料表，且資料必須等到命令清單/組合最後一次執行之後才能變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-174">If this flag is set, the data pointed to by descriptors has been initialized by the time a root descriptor or descriptor table referencing the memory has been set on a command list / bundle during recording, and the data cannot be changed until the command list / bundle has finished executing for the last time.</span></span>

<span data-ttu-id="b431f-175">針對套件組合，靜態持續時間會在記錄套件組合期間從根描述元或描述中繼資料表設定開始，而不是錄製呼叫命令清單。</span><span class="sxs-lookup"><span data-stu-id="b431f-175">For bundles, the static duration starts at root descriptor or descriptor table setting during the recording of the bundle, as opposed to recording of a calling command list.</span></span> <span data-ttu-id="b431f-176">此外，也必須在組合中設定指向靜態資料的描述中繼資料表，而不是繼承。</span><span class="sxs-lookup"><span data-stu-id="b431f-176">In addition, a descriptor table pointing to static data must be set in the bundle and not inherited.</span></span> <span data-ttu-id="b431f-177">命令清單可以使用描述中繼資料表，指向已在組合中設定並傳回至命令清單的靜態資料，這是有效的。</span><span class="sxs-lookup"><span data-stu-id="b431f-177">It is valid for a command list to use a descriptor table pointing to static data that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="b431f-178">旗標適用于兩個描述項範圍旗標和根描述元旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-178">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="combining-flags"></a><span data-ttu-id="b431f-179">組合旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-179">Combining Flags</span></span>

<span data-ttu-id="b431f-180">一次最多隻能指定一個資料旗標，但取樣器描述元範圍（不支援資料旗標）除外，因為取樣器不會指向資料。</span><span class="sxs-lookup"><span data-stu-id="b431f-180">At most one of the DATA flags can be specified at a time, except for Sampler descriptor ranges which do not support DATA flags at all since samplers do not point to data.</span></span>

<span data-ttu-id="b431f-181">如果 SRV 和 CBV 描述項範圍沒有任何資料旗標， \_ \_ \_ \_ \_ 則會假設為在執行行為時設定為靜態資料的預設值。</span><span class="sxs-lookup"><span data-stu-id="b431f-181">The absence of any DATA flags for SRV and CBV descriptor ranges means a default of DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE behavior is assumed.</span></span> <span data-ttu-id="b431f-182">選擇此預設值而非資料靜態的原因 \_ 是， \_ 在執行時設定的靜態資料，在 \_ \_ \_ \_ 大部分的情況下都可能是安全的預設值，但仍會產生比預設為數據 VOLATILE 更好的一些優化商機 \_ 。</span><span class="sxs-lookup"><span data-stu-id="b431f-182">The reason this default is chosen rather than DATA\_STATIC is that DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is much more likely to be a safe default for a majority of cases, while still yielding some optimization opportunity better than defaulting to DATA\_VOLATILE.</span></span>

<span data-ttu-id="b431f-183">缺少 UAV 描述項範圍的資料旗標表示系統會假設使用預設的資料 \_ 變動行為，通常會將 UAVs 寫入。</span><span class="sxs-lookup"><span data-stu-id="b431f-183">The absence of DATA flags for UAV descriptor ranges means a default of DATA\_VOLATILE behavior is assumed, given typically UAVs are written to.</span></span>

<span data-ttu-id="b431f-184">描述項 \_ VOLATILE *無法* 與資料 \_ 靜態合併，但 *可以* 與其他資料旗標合併。</span><span class="sxs-lookup"><span data-stu-id="b431f-184">DESCRIPTORS\_VOLATILE *cannot* be combined with DATA\_STATIC, but *can* be combined with the other DATA flags.</span></span> <span data-ttu-id="b431f-185">當您在執行時設定時，變動性描述元 \_ 可以與資料 \_ 靜態合併，因為 \_ \_ \_ \_ volatile 描述項在執行命令清單/套件組合時，仍需要描述項，而且 \_ 在執行時設定的資料靜態 \_ \_ \_ \_ 只會對命令清單/組合執行的子集內的靜態性質做出承諾。</span><span class="sxs-lookup"><span data-stu-id="b431f-185">The reason DESCRIPTORS\_VOLATILE can be combined with DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is that volatile descriptors still require the descriptors be ready during command list / bundle execution, and DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is only making promises about the static-ness within a subset of command list / bundle execution.</span></span>

### <a name="flag-summary"></a><span data-ttu-id="b431f-186">旗標摘要</span><span class="sxs-lookup"><span data-stu-id="b431f-186">Flag Summary</span></span>

<span data-ttu-id="b431f-187">下表摘要說明可能採用的旗標組合。</span><span class="sxs-lookup"><span data-stu-id="b431f-187">The following tables summarize the flag combinations that might be employed.</span></span>



| <span data-ttu-id="b431f-188">有效的 D3D12 \_ 描述項 \_ 範圍 \_ 旗標設定</span><span class="sxs-lookup"><span data-stu-id="b431f-188">Valid D3D12\_DESCRIPTOR\_RANGE\_FLAGS settings</span></span>                                                               | <span data-ttu-id="b431f-189">Description</span><span class="sxs-lookup"><span data-stu-id="b431f-189">Description</span></span>                                                                                                                                                                                                                                                                                                                                                     |
|----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="b431f-190">未設定旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-190">No flags set</span></span>                                                   | <span data-ttu-id="b431f-191">描述項是靜態 (預設) 。</span><span class="sxs-lookup"><span data-stu-id="b431f-191">Descriptors are static (the default).</span></span> <span data-ttu-id="b431f-192">資料的預設假設：針對 SRV/CBV： \_ \_ 在執行時設定的資料靜態 \_ \_ \_ ，以及 UAV：資料 \_ VOLATILE。</span><span class="sxs-lookup"><span data-stu-id="b431f-192">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="b431f-193">SRV/CBV 的這些預設值會安全地符合大部分根簽章的使用模式。</span><span class="sxs-lookup"><span data-stu-id="b431f-193">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span>                                                                                              |
| <span data-ttu-id="b431f-194">資料 \_ 靜態</span><span class="sxs-lookup"><span data-stu-id="b431f-194">DATA\_STATIC</span></span>                                                   | <span data-ttu-id="b431f-195">描述元和資料都是靜態的。</span><span class="sxs-lookup"><span data-stu-id="b431f-195">Both descriptors and data are static.</span></span> <span data-ttu-id="b431f-196">這可將驅動程式優化的可能性最大化。</span><span class="sxs-lookup"><span data-stu-id="b431f-196">This maximizes the potential for driver optimization.</span></span>                                                                                                                                                                                                                                                          |
| <span data-ttu-id="b431f-197">資料 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-197">DATA\_VOLATILE</span></span>                                                 | <span data-ttu-id="b431f-198">描述項是靜態的，而且資料是暫時性的。</span><span class="sxs-lookup"><span data-stu-id="b431f-198">Descriptors are static and the data is volatile.</span></span>                                                                                                                                                                                                                                                                                                     |
| <span data-ttu-id="b431f-199">\_ \_ \_ \_ 在執行時設定靜態 \_ 資料</span><span class="sxs-lookup"><span data-stu-id="b431f-199">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>                          | <span data-ttu-id="b431f-200">描述項是靜態的，而且資料是在執行時設定的靜態。</span><span class="sxs-lookup"><span data-stu-id="b431f-200">Descriptors are static and data is static while set at execute.</span></span>                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="b431f-201">描述項 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-201">DESCRIPTORS\_VOLATILE</span></span>                                          | <span data-ttu-id="b431f-202">描述項是暫時性的，而且會對資料進行預設假設：針對 SRV/CBV \_ ： \_ 在執行時設定的資料靜態 \_ \_ \_ ，以及 UAV：資料 \_ volatile。</span><span class="sxs-lookup"><span data-stu-id="b431f-202">Descriptors are volatile, and default assumptions are made about data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span>                                                                                                                                                                                              |
| <span data-ttu-id="b431f-203">描述項 \_ VOLATILE VOLATILE \| 資料 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-203">DESCRIPTORS\_VOLATILE \| DATA\_VOLATILE</span></span>                        | <span data-ttu-id="b431f-204">描述元和資料都是 volatile 的，相當於根簽章1.0。</span><span class="sxs-lookup"><span data-stu-id="b431f-204">Both descriptors and data are volatile, equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="b431f-205">描述 \_ \| \_ \_ \_ \_ 在執行時設定的 \_ VOLATILE 靜態資料</span><span class="sxs-lookup"><span data-stu-id="b431f-205">DESCRIPTORS\_VOLATILE \| DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span> | <span data-ttu-id="b431f-206">描述項是暫時性的，但請注意，在命令清單執行期間仍不允許變更。</span><span class="sxs-lookup"><span data-stu-id="b431f-206">Descriptors are volatile, but note that still doesn’t allow them to change during command list execution.</span></span> <span data-ttu-id="b431f-207">因此，當您在執行期間透過根描述中繼資料表來設定資料為靜態時，可將資料變成靜態，而基礎描述項的有效時間比將資料承諾為靜態的時間更長。</span><span class="sxs-lookup"><span data-stu-id="b431f-207">So it is valid to combine the additional declaration that data is static while set via root descriptor table during execution – the underlying descriptors are effectively static for longer than the data is being promised to be static.</span></span> |



 



| <span data-ttu-id="b431f-208">有效的 D3D12 \_ 根目錄 \_ 描述元 \_ 旗標設定</span><span class="sxs-lookup"><span data-stu-id="b431f-208">Valid D3D12\_ROOT\_DESCRIPTOR\_FLAGS settings</span></span>                                                  |  <span data-ttu-id="b431f-209">Description</span><span class="sxs-lookup"><span data-stu-id="b431f-209">Description</span></span>                                                                                                                                                                                                                 |
|---------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="b431f-210">未設定旗標</span><span class="sxs-lookup"><span data-stu-id="b431f-210">No flags set</span></span>                                      | <span data-ttu-id="b431f-211">資料的預設假設：針對 SRV/CBV： \_ \_ 在執行時設定的資料靜態 \_ \_ \_ ，以及 UAV：資料 \_ VOLATILE。</span><span class="sxs-lookup"><span data-stu-id="b431f-211">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="b431f-212">SRV/CBV 的這些預設值會安全地符合大部分根簽章的使用模式。</span><span class="sxs-lookup"><span data-stu-id="b431f-212">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span> |
| <span data-ttu-id="b431f-213">資料 \_ 靜態</span><span class="sxs-lookup"><span data-stu-id="b431f-213">DATA\_STATIC</span></span>                                      | <span data-ttu-id="b431f-214">資料是靜態的，這是驅動程式優化的最佳潛力。</span><span class="sxs-lookup"><span data-stu-id="b431f-214">Data is static, the best potential for driver optimization.</span></span>                                                                                                                                                       |
| <span data-ttu-id="b431f-215">\_ \_ \_ \_ 在執行時設定靜態 \_ 資料</span><span class="sxs-lookup"><span data-stu-id="b431f-215">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>             | <span data-ttu-id="b431f-216">資料在執行時設定為靜態。</span><span class="sxs-lookup"><span data-stu-id="b431f-216">Data is static while set at execute.</span></span>                                                                                                                                                                              |
| <span data-ttu-id="b431f-217">資料 \_ VOLATILE</span><span class="sxs-lookup"><span data-stu-id="b431f-217">DATA\_VOLATILE</span></span>                                    | <span data-ttu-id="b431f-218">相當於根簽章1.0。</span><span class="sxs-lookup"><span data-stu-id="b431f-218">Equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                 |



 

## <a name="version-11-api-summary"></a><span data-ttu-id="b431f-219">版本 1.1 API 摘要</span><span class="sxs-lookup"><span data-stu-id="b431f-219">Version 1.1 API Summary</span></span>

<span data-ttu-id="b431f-220">下列 API 呼叫會啟用1.1 版。</span><span class="sxs-lookup"><span data-stu-id="b431f-220">The following API calls enable version 1.1.</span></span>

### <a name="enums"></a><span data-ttu-id="b431f-221">列舉</span><span class="sxs-lookup"><span data-stu-id="b431f-221">Enums</span></span>

<span data-ttu-id="b431f-222">這些列舉包含用來指定描述元和資料變動性的索引鍵旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-222">These enumerations contain the key flags to specify descriptor and data volatility.</span></span>

-   <span data-ttu-id="b431f-223">[**D3D \_根簽章 \_ \_ 版本**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) ：版本識別碼。</span><span class="sxs-lookup"><span data-stu-id="b431f-223">[**D3D\_ROOT\_SIGNATURE\_VERSION**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) : version ids.</span></span>
-   <span data-ttu-id="b431f-224">[**D3D12 \_描述項 \_ 範圍 \_ 旗標**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) ：判斷描述元或資料是否為 volatile 或靜態的旗標範圍。</span><span class="sxs-lookup"><span data-stu-id="b431f-224">[**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) : a range of flags determining if descriptors or data are volatile or static.</span></span>
-   <span data-ttu-id="b431f-225">[**D3D12 \_根 \_ 描述項 \_ 旗標**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) ： [**D3D12 \_ 描述項 \_ 範圍 \_ 旗標**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags)的類似旗標範圍，但只有資料旗標適用于根描述元。</span><span class="sxs-lookup"><span data-stu-id="b431f-225">[**D3D12\_ROOT\_DESCRIPTOR\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) : a similar range of flags to [**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags), except that only data flags apply to root descriptors.</span></span>

### <a name="structures"></a><span data-ttu-id="b431f-226">結構</span><span class="sxs-lookup"><span data-stu-id="b431f-226">Structures</span></span>

<span data-ttu-id="b431f-227">從1.0 版 (更新的結構，) 包含變動性/靜態旗標的參考。</span><span class="sxs-lookup"><span data-stu-id="b431f-227">Updated structures (from version 1.0) contain references to the volatility/static flags.</span></span>

-   <span data-ttu-id="b431f-228">[**D3D12 \_功能 \_ 資料 \_ 根 \_**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) 簽章：將此結構傳遞給 [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) ，以檢查是否有根簽章版本1.1 支援。</span><span class="sxs-lookup"><span data-stu-id="b431f-228">[**D3D12\_FEATURE\_DATA\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) : pass this structure to [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to check for Root Signature Version 1.1 support.</span></span>
-   <span data-ttu-id="b431f-229">[**D3D12 \_已建立版本的根簽章 \_ \_ \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) ：可以保留任何版本的根簽章描述，而且是設計來搭配下列序列化/還原序列化函數使用。</span><span class="sxs-lookup"><span data-stu-id="b431f-229">[**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) : can hold any version of a root signature description, and is designed to be used with the serialization/deserialization functions listed below.</span></span>
-   <span data-ttu-id="b431f-230">這些結構相當於1.0 版中所使用的結構，並加入描述項範圍和根描述項的新旗標欄位：</span><span class="sxs-lookup"><span data-stu-id="b431f-230">These structures are equivalent to those used in version 1.0, with the addition of new flags fields for descriptor ranges and root descriptors:</span></span>

    -   [<span data-ttu-id="b431f-231">**D3D12 \_ 根簽章 \_ \_ DESC1**</span><span class="sxs-lookup"><span data-stu-id="b431f-231">**D3D12\_ROOT\_SIGNATURE\_DESC1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_signature_desc1)
    -   [<span data-ttu-id="b431f-232">**D3D12 \_ 描述項 \_ RANGE1**</span><span class="sxs-lookup"><span data-stu-id="b431f-232">**D3D12\_DESCRIPTOR\_RANGE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_range1)
    -   [<span data-ttu-id="b431f-233">**D3D12 \_ 根目錄 \_ 描述元 \_ TABLE1**</span><span class="sxs-lookup"><span data-stu-id="b431f-233">**D3D12\_ROOT\_DESCRIPTOR\_TABLE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor_table1)
    -   [<span data-ttu-id="b431f-234">**D3D12 \_ 根 \_ DESCRIPTOR1**</span><span class="sxs-lookup"><span data-stu-id="b431f-234">**D3D12\_ROOT\_DESCRIPTOR1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor1)
    -   [<span data-ttu-id="b431f-235">**D3D12 \_ 根 \_ PARAMETER1**</span><span class="sxs-lookup"><span data-stu-id="b431f-235">**D3D12\_ROOT\_PARAMETER1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_parameter1)

### <a name="functions"></a><span data-ttu-id="b431f-236">函式</span><span class="sxs-lookup"><span data-stu-id="b431f-236">Functions</span></span>

<span data-ttu-id="b431f-237">此處所列的方法會取代原始的 [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) 和 [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) 函式，因為它們是設計用來處理任何版本的根簽章。</span><span class="sxs-lookup"><span data-stu-id="b431f-237">The methods listed here supersede the original [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) and [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) functions, as they are designed to work on any version of root signature.</span></span> <span data-ttu-id="b431f-238">序列化形式是傳遞至 [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) API 的表單。</span><span class="sxs-lookup"><span data-stu-id="b431f-238">The serialized form is what is passed into the [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) API.</span></span> <span data-ttu-id="b431f-239">如果著色器是以根簽章撰寫的，則編譯的著色器會在其中包含已序列化的根簽章。</span><span class="sxs-lookup"><span data-stu-id="b431f-239">If a shader has been authored with a root signature in it, the compiled shader will contain a serialized root signature in it already.</span></span>

-   <span data-ttu-id="b431f-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) ：如果應用程式 Cti 產生 [**D3D12 \_ 版本的 \_ 根 \_**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) 簽章資料結構，它必須使用這個函式來建立序列化的表單。</span><span class="sxs-lookup"><span data-stu-id="b431f-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) : if an application procedurally generates the [**D3D12\_VERSIONED\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) data structure, it must make the serialized form using this function.</span></span>
-   <span data-ttu-id="b431f-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) ：產生可透過 [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc)傳回還原序列化之資料結構的介面。</span><span class="sxs-lookup"><span data-stu-id="b431f-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) : generates an interface that can return the deserialized data structure, via [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc).</span></span>

### <a name="methods"></a><span data-ttu-id="b431f-242">方法</span><span class="sxs-lookup"><span data-stu-id="b431f-242">Methods</span></span>

<span data-ttu-id="b431f-243">會建立 [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) 介面，將根簽章資料結構還原序列化。</span><span class="sxs-lookup"><span data-stu-id="b431f-243">The [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) interface is created to deserialize the root signature data structure.</span></span>

-   <span data-ttu-id="b431f-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) ：將根簽章描述結構轉換為要求的版本。</span><span class="sxs-lookup"><span data-stu-id="b431f-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) : converts root signature description structures to a requested version.</span></span>
-   <span data-ttu-id="b431f-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) ：傳回 [**D3D12 版本根簽章 \_ \_ \_ \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) 結構的指標。</span><span class="sxs-lookup"><span data-stu-id="b431f-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) : returns a pointer to a [**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) structure.</span></span>

### <a name="helper-structures"></a><span data-ttu-id="b431f-246">Helper 結構</span><span class="sxs-lookup"><span data-stu-id="b431f-246">Helper structures</span></span>

<span data-ttu-id="b431f-247">已新增協助程式結構，以協助初始化某些版本1.1 結構。</span><span class="sxs-lookup"><span data-stu-id="b431f-247">Helper structures have been added to aid in the initialization of some of the version 1.1 structures.</span></span>

-   <span data-ttu-id="b431f-248">CD3DX12 \_ 描述項 \_ RANGE1</span><span class="sxs-lookup"><span data-stu-id="b431f-248">CD3DX12\_DESCRIPTOR\_RANGE1</span></span>
-   <span data-ttu-id="b431f-249">CD3DX12 \_ 根 \_ PARAMETER1</span><span class="sxs-lookup"><span data-stu-id="b431f-249">CD3DX12\_ROOT\_PARAMETER1</span></span>
-   <span data-ttu-id="b431f-250">CD3DX12 \_ 靜態 \_ SAMPLER1</span><span class="sxs-lookup"><span data-stu-id="b431f-250">CD3DX12\_STATIC\_SAMPLER1</span></span>
-   <span data-ttu-id="b431f-251">CD3DX12 已建立版本的根簽章 \_ \_ \_ \_ DESC</span><span class="sxs-lookup"><span data-stu-id="b431f-251">CD3DX12\_VERSIONED\_ROOT\_SIGNATURE\_DESC</span></span>

<span data-ttu-id="b431f-252">請參閱 [Helper 結構和函式以進行 D3D12](helper-structures-and-functions-for-d3d12.md)。</span><span class="sxs-lookup"><span data-stu-id="b431f-252">Refer to [Helper Structures and Functions for D3D12](helper-structures-and-functions-for-d3d12.md).</span></span>

## <a name="consequences-of-violating-static-ness-flags"></a><span data-ttu-id="b431f-253">違反靜態性質旗標的後果</span><span class="sxs-lookup"><span data-stu-id="b431f-253">Consequences of violating static-ness flags</span></span>

<span data-ttu-id="b431f-254">上述的描述元和資料旗標 (以及缺少特定旗標所隱含的預設值) 定義應用程式對驅動程式的承諾，以瞭解其行為。</span><span class="sxs-lookup"><span data-stu-id="b431f-254">The descriptor and data flags described above (as well as the defaults implied by the absence of particular flags) define a promise by the application to the driver about how it is going to behave.</span></span> <span data-ttu-id="b431f-255">如果應用程式違反承諾，則這是不正確行為：結果未定義，而且在不同的驅動程式和硬體之間可能不同。</span><span class="sxs-lookup"><span data-stu-id="b431f-255">If an application violates the promise, this is invalid behavior: results are undefined and might be different across different drivers and hardware.</span></span>

<span data-ttu-id="b431f-256">Debug 層有一些選項，可驗證應用程式是否遵守其承諾，包括使用根簽章版本1.1 的預設承諾，而不需要設定任何旗標。</span><span class="sxs-lookup"><span data-stu-id="b431f-256">The debug layer has options for validating that applications honor their promises, including the default promises that come with using Root Signature version 1.1 without setting any flags.</span></span>

## <a name="version-management"></a><span data-ttu-id="b431f-257">版本管理</span><span class="sxs-lookup"><span data-stu-id="b431f-257">Version management</span></span>

<span data-ttu-id="b431f-258">當編譯附加至著色器的根簽章時，較新的 HLSL 編譯器會預設為編譯1.1 版的根簽章，而舊的 HLSL 編譯器只支援1.0。</span><span class="sxs-lookup"><span data-stu-id="b431f-258">When compiling root signatures attached to shaders, newer HLSL compilers will default to compiling the root signature at version 1.1, whereas old HLSL compilers only support 1.0.</span></span> <span data-ttu-id="b431f-259">請注意，1.1 根簽章將無法在不支援根簽章1.1 的作業系統上運作。</span><span class="sxs-lookup"><span data-stu-id="b431f-259">Note that 1.1 root signatures will not work on OS’s that don’t support root signature 1.1.</span></span>

<span data-ttu-id="b431f-260">使用著色器編譯的根簽章版本，可以使用來強制執行特定版本 `/force_rootsig_ver <version>` 。</span><span class="sxs-lookup"><span data-stu-id="b431f-260">The root signature version compiled with a shader can be forced to a particular version using `/force_rootsig_ver <version>`.</span></span> <span data-ttu-id="b431f-261">如果編譯器可以保留在強制版本中編譯之根簽章的行為，例如藉由將不支援的旗標放在僅供優化用途但不會影響行為的根簽章中，則強制執行版本將會成功。</span><span class="sxs-lookup"><span data-stu-id="b431f-261">Forcing the version will succeed if the compiler can preserve the behavior of the root signature being compiled at the forced version, for example by dropping unsupported flags in the root signature that serve only for optimization purposes but do not affect behavior.</span></span>

<span data-ttu-id="b431f-262">比方說，應用程式可以在建立應用程式時將1.1 根簽章編譯為1.0 和1.1，視作業系統支援層級而定，在執行時間選取適當的版本。</span><span class="sxs-lookup"><span data-stu-id="b431f-262">This way an application can, for instance, compile a 1.1 root signature to both 1.0 and 1.1 when building the application and select the appropriate version at runtime depending on the level of OS support.</span></span> <span data-ttu-id="b431f-263">但是，如果應用程式要個別編譯根簽章，這會是最有效率的空間 (特別是在需要多個版本時，請將其與著色器分開) 。</span><span class="sxs-lookup"><span data-stu-id="b431f-263">It would be most space efficient, however, for an application to compile root signatures individually (particularly if multiple versions are needed), separately from shaders.</span></span> <span data-ttu-id="b431f-264">即使著色器最初不是以附加的根簽章進行編譯，也可以使用編譯器選項來保留編譯器驗證與著色器的根簽章相容性的優點 `/verifyrootsignature` 。</span><span class="sxs-lookup"><span data-stu-id="b431f-264">Even if shaders aren’t initially compiled with a root signature attached, the benefit of compiler validation of root signature compatibility with a shader can be preserved by using the `/verifyrootsignature` compiler option.</span></span> <span data-ttu-id="b431f-265">稍後在執行時間，您可以使用不具根簽章的著色器來建立 Pso，並傳遞所需的根簽章 (可能是作業系統所支援的適當版本) 作為個別參數。</span><span class="sxs-lookup"><span data-stu-id="b431f-265">Later at runtime, PSOs can be created using shaders that don’t have root signatures in them while passing the desired root signature (perhaps the appropriate version supported by the OS) as a separate parameter.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b431f-266">相關主題</span><span class="sxs-lookup"><span data-stu-id="b431f-266">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="b431f-267">建立根簽章</span><span class="sxs-lookup"><span data-stu-id="b431f-267">Creating a Root Signature</span></span>](creating-a-root-signature.md)
</dt> <dt>

[<span data-ttu-id="b431f-268">根簽章</span><span class="sxs-lookup"><span data-stu-id="b431f-268">Root Signatures</span></span>](root-signatures.md)
</dt> <dt>

[<span data-ttu-id="b431f-269">在 HLSL 中指定根簽章</span><span class="sxs-lookup"><span data-stu-id="b431f-269">Specifying Root Signatures in HLSL</span></span>](specifying-root-signatures-in-hlsl.md)
</dt> </dl>

 

 




