---
title: 描述元堆積總覽
description: 描述元堆積包含許多不屬於管線狀態物件的物件類型 (PSO) ，例如著色器資源查看 (SRVs) 、未排序的存取視圖 (UAVs) 、常數緩衝區視圖 (CBVs) 和取樣器。
ms.assetid: 14561E77-44E0-4A58-8456-F40D59ECA175
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 29d0017f10a6027fc7ce48618a9d28bd4e92262d83d0f3aa81cc0bc8d02b7edc
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "119124333"
---
# <a name="descriptor-heaps-overview"></a>描述元堆積總覽

描述元堆積包含許多不屬於管線狀態物件的物件類型 (PSO) ，例如著色器資源查看 (SRVs) 、未排序的存取視圖 (UAVs) 、常數緩衝區視圖 (CBVs) 和取樣器。

-   [描述元堆積的用途](#the-purpose-of-descriptor-heaps)
-   [同步處理](#synchronization)
-   [繫結](#binding)
-   [切換堆積](#switching-heaps)
-   [束](#bundles)
-   [管理](#management)
-   [相關主題](#related-topics)

## <a name="the-purpose-of-descriptor-heaps"></a>描述元堆積的用途

描述元堆積的主要目的是要包含在轉譯時，儲存著色器所參考的物件類型之描述項規格規格的大量記憶體配置， (理想的轉譯或更) 的整個框架。 如果應用程式正在切換管線從 API 快速看到的材質，描述項堆積中必須有空格，才能針對每個所需的狀態集合，即時定義描述中繼資料表。 例如，如果在另一個物件中再次使用資源，則應用程式可以選擇重複使用定義，或只在切換不同物件類型時依序指派堆積空間。

描述元堆積也允許個別的軟體元件分別管理描述項儲存。

CPU 可以看到所有堆積。 如果有任何) – write、回寫等等，應用程式也可以要求描述項堆積應該具有 (的 CPU 存取屬性。 應用程式可以視需要使用任何屬性來建立所需的描述項堆積數目。 應用程式一律會有選項，可讓您建立僅供未受限制之暫存用途的描述元堆積，並複製到視需要用於轉譯的描述元堆積。

在相同的描述元堆積中，有一些限制。 CBV、UAV 和 SRV 專案可以位於相同的描述元堆積中。 不過，取樣器專案無法與 CBV、UAV 或 SRV 專案共用堆積。 一般而言，有兩組描述項堆積，一個用於一般資源，第二個用於取樣器。

使用 Direct3D 12 的描述項堆積時，會鏡像大部分的 GPU 硬體，也就是只需要在描述元堆積中存留描述項，或只在使用這些堆積時需要較少的定址位。 Direct3D 12 的確需要使用描述元堆積，而且沒有任何選項可將描述項放在記憶體中的任何位置。

描述元堆積只能由 CPU 立即進行編輯，而且沒有任何選項可依 GPU 編輯描述元堆積。

## <a name="synchronization"></a>同步處理

描述元堆積內容可以在記錄參考它的命令清單之前、期間和之後變更。 不過，當提交要執行的命令清單可能會參考該位置時，無法變更描述項，因為這樣可能會叫用競爭條件。

## <a name="binding"></a>繫結

最多一次只能系結一個 CBV/SRV/UAV 合併堆積和一個取樣器堆積。 這些堆積會在圖形和計算管線之間共用 (在其 Pso) 中所述。

## <a name="switching-heaps"></a>切換堆積

應用程式可接受使用 [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) 和 [**重設**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) api，在相同的命令清單中或在不同的範圍內切換堆積。 在某些硬體上，這可能是昂貴的作業，需要 GPU 延遲才能排清相依于目前系結描述項堆積的所有工作。 如此一來，如果必須變更描述元堆積，則應用程式應該在 GPU 工作負載相對較淺時嘗試這麼做，這可能會限制命令清單的開頭變更。

## <a name="bundles"></a>束

使用套件組合時，只能呼叫 [**SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) 方法，而描述項堆積集合必須完全符合呼叫組合的命令清單。 如果組合未變更描述中繼資料表，則不需要設定描述元堆積。

如需無法搭配配套使用的 API 呼叫清單，請參閱 [建立和錄製命令清單和](recording-command-lists-and-bundles.md)組合。

## <a name="management"></a>管理

若要轉譯場景中的所有物件，將需要許多描述項，而且可以遵循一些不同的管理原則。

最基本的策略是將下一個繪製呼叫的所有需求填入描述項堆積的新區域。 因此，在對命令清單發出 draw 呼叫之前，會將描述項資料表指標設定為剛填入資料表的開頭。 好處是，不需要記錄任何特定描述項在堆積中的位置。

這項策略的缺點是，描述項堆積中可能會有很多重複的描述項，特別是當轉譯非常類似的場景時，以及將會快速使用描述項堆積空間的情況。 針對在 GPU 上轉譯的描述元堆積，以及由 CPU 記錄的描述元堆積，可能需要避免發生衝突。 或者，您也可以使用子配置系統。

此外，您可以藉由從下一次的繪製呼叫中仔細使用重迭的描述中繼資料表，以進一步優化基本系統，如此就只會加入所需的新描述項。

相較于基本的策略，更有效率的策略是預先填入描述項堆積，其中包含物件 (或資料) 的描述項，這些都是場景的一部分。 此處的概念是，只有在繪製時才需要設定描述中繼資料表，因為描述項堆積會預先填入。

預先填入策略的變化是將描述元堆積視為一個大型陣列，包含固定已知位置中的所有必要描述項。 然後，繪製呼叫只需要接收一組常數，也就是需要使用描述項的陣列中的索引。

進一步的優化是確保根常數和根描述元包含最常變更的，而不是將常數放置於描述元堆積中。 在大部分的硬體中，這是處理常數的有效方式。

在實務上，圖形引擎可能會在不同的情況下使用不同的策略，並結合每個策略的元素，以符合特定的繪圖需求。

## <a name="related-topics"></a>相關主題

<dl> <dt>

[描述元堆積](descriptor-heaps.md)
</dt> </dl>

 

 




