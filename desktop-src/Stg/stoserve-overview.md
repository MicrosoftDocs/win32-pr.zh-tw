---
title: StoServe 總覽
description: StoServe 程式碼範例示範如何使用複合檔案執行所提供的結構化儲存體服務。 描述使用標準 IStorage 和 IStream 介面。
ms.assetid: 41ccd333-15c8-46b2-91c6-3e1929f7198c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9c0c8325fbc20d4917785d0b83ca70bffa996824
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104315931"
---
# <a name="stoserve-overview"></a><span data-ttu-id="e74dd-104">StoServe 總覽</span><span class="sxs-lookup"><span data-stu-id="e74dd-104">StoServe Overview</span></span>

## <a name="purpose"></a><span data-ttu-id="e74dd-105">目的</span><span class="sxs-lookup"><span data-stu-id="e74dd-105">Purpose</span></span>

<span data-ttu-id="e74dd-106">這個程式碼範例的主要焦點是使用複合檔案執行所提供的結構化儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="e74dd-106">The primary focus of this code example is the use of Structured Storage services as provided in the compound files implementation.</span></span> <span data-ttu-id="e74dd-107">描述使用標準 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) 和 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) 介面。</span><span class="sxs-lookup"><span data-stu-id="e74dd-107">The use of the standard [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) and [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) interfaces is described.</span></span> <span data-ttu-id="e74dd-108">**StoServe** 可與 [StoClien](structured-storage-client-sample--stoclien-.md) 程式碼範例搭配使用，以說明用戶端和伺服器對複合檔案儲存體的聯合使用。</span><span class="sxs-lookup"><span data-stu-id="e74dd-108">**StoServe** works with the [StoClien](structured-storage-client-sample--stoclien-.md) code example to illustrate the joint use of compound file storage by client and server.</span></span>

## <a name="functionality"></a><span data-ttu-id="e74dd-109">功能</span><span class="sxs-lookup"><span data-stu-id="e74dd-109">Functionality</span></span>

<span data-ttu-id="e74dd-110">**StoServe** 範例引進 COPaper COM 物件，它幾乎代表一張紙紙的空白工作表。</span><span class="sxs-lookup"><span data-stu-id="e74dd-110">The **StoServe** sample introduces the COPaper COM object, which virtually represents a blank sheet of drawing paper.</span></span>

<span data-ttu-id="e74dd-111">COPaper 物件會公開一組功能，以使用指定之色彩和寬度的 "筆墨"，在紙張表面上自由形式的繪圖。</span><span class="sxs-lookup"><span data-stu-id="e74dd-111">COPaper objects expose a set of features for free-form drawing on the paper surface using "ink" of specified color and width.</span></span> <span data-ttu-id="e74dd-112">這項功能的外表方式類似于許多 Microsoft Visual C++ 版本中的「自由曲線」教學課程範例。</span><span class="sxs-lookup"><span data-stu-id="e74dd-112">The functionality is outwardly similar to the "scribble" tutorial samples in many versions of Microsoft Visual C++.</span></span> <span data-ttu-id="e74dd-113">**StoServe** / **StoClien** 範例中的差異在於，主要是以 COM 技術為基礎的架構。</span><span class="sxs-lookup"><span data-stu-id="e74dd-113">The difference in the **StoServe**/**StoClien** samples is an architecture-based primarily on COM technology.</span></span> <span data-ttu-id="e74dd-114">COPaper 物件的電子繪圖檔案功能可透過自訂 [**IPaper**](ipaper-methods.md) 介面提供給用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="e74dd-114">The electronic drawing paper features of COPaper objects are available to clients through a custom [**IPaper**](ipaper-methods.md) interface.</span></span> <span data-ttu-id="e74dd-115">COPaper 會實 **IPaper** 介面。</span><span class="sxs-lookup"><span data-stu-id="e74dd-115">COPaper implements the **IPaper** interface.</span></span> <span data-ttu-id="e74dd-116">用戶端與伺服器之間會保持清楚的架構差異。</span><span class="sxs-lookup"><span data-stu-id="e74dd-116">A clear architectural distinction is kept between client and server.</span></span> <span data-ttu-id="e74dd-117">COPaper 不會提供 (GUI) 的圖形化使用者介面。</span><span class="sxs-lookup"><span data-stu-id="e74dd-117">No graphical user interface (GUI) is provided by COPaper.</span></span> <span data-ttu-id="e74dd-118">COPaper 物件的設計依賴用戶端進行所有 GUI 行為。</span><span class="sxs-lookup"><span data-stu-id="e74dd-118">The design of the COPaper object relies on the client for all GUI behavior.</span></span> <span data-ttu-id="e74dd-119">COPaper 只會封裝繪製筆墨資料的伺服器型捕獲和儲存。</span><span class="sxs-lookup"><span data-stu-id="e74dd-119">COPaper encapsulates only the server-based capture and storage of the drawn ink data.</span></span>

<span data-ttu-id="e74dd-120">在 COPaper 介面上繪製的筆墨資料可以儲存在複合檔案中，也可以從複合檔案載入。</span><span class="sxs-lookup"><span data-stu-id="e74dd-120">The ink data that is drawn on the COPaper surface can be stored in and loaded from compound files.</span></span> <span data-ttu-id="e74dd-121">[**IPaper**](ipaper-methods.md)、 [**Save**](ipaper--save.md)和 [**Load**](ipaper--load.md)方法都會接受 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)介面指標。</span><span class="sxs-lookup"><span data-stu-id="e74dd-121">The [**IPaper**](ipaper-methods.md), [**Save**](ipaper--save.md) and [**Load**](ipaper--load.md) methods accept an [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) interface pointer.</span></span> <span data-ttu-id="e74dd-122">COPaper 會使用此用戶端提供的 **IStorage** 介面來儲存繪圖資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-122">COPaper uses this client-provided **IStorage** interface to store the drawing data.</span></span>

<span data-ttu-id="e74dd-123">COPaper 是存放在同進程伺服器中，而且會公開提供作為自訂 COM 元件。</span><span class="sxs-lookup"><span data-stu-id="e74dd-123">COPaper is housed in an in-process server and is made publicly available as a custom COM component.</span></span> <span data-ttu-id="e74dd-124">與本教學課程系列中的其他伺服器類似，StoServe 是自我註冊的 COM 伺服器。</span><span class="sxs-lookup"><span data-stu-id="e74dd-124">Similar to other servers in this tutorial series, StoServe is a self-registering COM server.</span></span> <span data-ttu-id="e74dd-125">它會使用登錄中的 CLSID DllPaper 註冊，讓用戶端使用 COPaper 物件類型作為 DllPaper 元件 \_ 。</span><span class="sxs-lookup"><span data-stu-id="e74dd-125">It makes the COPaper object type available to clients as the DllPaper component using a CLSID\_DllPaper registration in the Registry.</span></span>

<span data-ttu-id="e74dd-126">如同先前的節省伺服器，COPaper 支援可連線物件功能。</span><span class="sxs-lookup"><span data-stu-id="e74dd-126">As in the previous CONSERVE server, connectable object features are supported in COPaper.</span></span> <span data-ttu-id="e74dd-127">[**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer)介面會公開，並執行適當的連接點。</span><span class="sxs-lookup"><span data-stu-id="e74dd-127">The [**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer) interface is exposed, and an appropriate connection point is implemented.</span></span> <span data-ttu-id="e74dd-128">在此內容中，會宣告外寄自訂 IPaperSink 介面，以便在傳送通知給用戶端時使用。</span><span class="sxs-lookup"><span data-stu-id="e74dd-128">In this context, an outgoing custom IPaperSink interface is declared for use in sending notifications to the client.</span></span>

<span data-ttu-id="e74dd-129">這兩個 [**IPaper**](ipaper-methods.md) 和 [**IPaperSink**](ipapersink-methods.md) 自訂介面是在 IPaper 中宣告的。H 位於一般的共屬 \\ inc. 目錄。</span><span class="sxs-lookup"><span data-stu-id="e74dd-129">The two [**IPaper**](ipaper-methods.md) and [**IPaperSink**](ipapersink-methods.md) custom interfaces are declared in IPAPER.H located in the common sibling \\INC directory.</span></span> <span data-ttu-id="e74dd-130">介面和物件的 Guid 是在 PAPGUIDS 中定義。H 位於相同的一般 include 目錄。</span><span class="sxs-lookup"><span data-stu-id="e74dd-130">The GUIDs for the interfaces and objects are defined in PAPGUIDS.H located in that same common include directory.</span></span>

<span data-ttu-id="e74dd-131">**StoServe** 會使用 APPUTIL 中的 CThreaded 設備來達成執行緒安全性，如同 FRESERVE 範例中所述。</span><span class="sxs-lookup"><span data-stu-id="e74dd-131">The CThreaded facility in APPUTIL is used by **StoServe** to achieve thread safety, as it was in the FRESERVE sample.</span></span> <span data-ttu-id="e74dd-132">COPaper 物件衍生自 CThreaded 類別，並繼承其 OwnThis 和 UnOwnThis 方法。</span><span class="sxs-lookup"><span data-stu-id="e74dd-132">COPaper objects are derived from the CThreaded class and inherit its OwnThis and UnOwnThis methods.</span></span> <span data-ttu-id="e74dd-133">這些方法一次只允許一個執行緒存取 **StoServe** 伺服器，以及 COPaper 由伺服器管理的物件。</span><span class="sxs-lookup"><span data-stu-id="e74dd-133">These methods allow only one thread at a time to have access to the **StoServe** server and to COPaper objects managed by the server.</span></span>

## <a name="copaper-com-object"></a><span data-ttu-id="e74dd-134">COPaper COM 物件</span><span class="sxs-lookup"><span data-stu-id="e74dd-134">COPaper COM Object</span></span>

<span data-ttu-id="e74dd-135">COPaper COM 物件是由此 **StoServe** 同進程伺服器管理的單一物件類型。</span><span class="sxs-lookup"><span data-stu-id="e74dd-135">The COPaper COM object is the single object type managed by this **StoServe** in-process server.</span></span> <span data-ttu-id="e74dd-136">COPaper 是以可連接的 COM 物件來建立，並採用標準 [**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer) 介面和自訂 [**IPaper**](ipaper-methods.md) 介面的實作為。</span><span class="sxs-lookup"><span data-stu-id="e74dd-136">COPaper is constructed as a connectable COM object with an implementation of the standard [**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer) interface and an implementation of the custom [**IPaper**](ipaper-methods.md) interface.</span></span> <span data-ttu-id="e74dd-137">COPaper 會公開 **IPaper** 介面，讓用戶端可以在 COPaper 的實例上執行一組小型的電子檔作業。</span><span class="sxs-lookup"><span data-stu-id="e74dd-137">COPaper exposes the **IPaper** interface so clients can perform a small set of electronic paper operations on an instance of COPaper.</span></span> <span data-ttu-id="e74dd-138">基本作業是啟動筆墨繪圖序列、在 COPaper 虛擬紙張表面上繪製筆墨資料，以及結束筆墨繪圖順序。</span><span class="sxs-lookup"><span data-stu-id="e74dd-138">The essential operations are starting an ink drawing sequence, drawing the ink data on COPaper virtual paper surface, and ending the ink drawing sequence.</span></span> <span data-ttu-id="e74dd-139">在此配置中，會假設用戶端是由滑鼠或平板電腦裝置驅動的 GUI 應用程式。</span><span class="sxs-lookup"><span data-stu-id="e74dd-139">In this scheme, the client is assumed to be a GUI application driven by a mouse or tablet device.</span></span> <span data-ttu-id="e74dd-140">用戶端負責將滑鼠移動轉譯為 COPaper 的要求，以將這些要求儲存為筆墨資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-140">The client is responsible for translating mouse movements into requests to COPaper, which saves these requests as ink data.</span></span>

<span data-ttu-id="e74dd-141">COPaper 中有兩種層級的筆墨資料儲存。</span><span class="sxs-lookup"><span data-stu-id="e74dd-141">There are two levels of ink data saving in COPaper.</span></span> <span data-ttu-id="e74dd-142">COPaper 會將筆墨資料儲存在代表目前繪圖的 RAM 型陣列中，而 COPaper 會持續將整個繪圖儲存成複合檔案。</span><span class="sxs-lookup"><span data-stu-id="e74dd-142">COPaper saves the ink data in a RAM-based array that represents the current drawing, and COPaper persistently saves an entire drawing into a compound file.</span></span> <span data-ttu-id="e74dd-143">[**IPaper**](ipaper-methods.md)介面中的方法會執行兩者。</span><span class="sxs-lookup"><span data-stu-id="e74dd-143">Methods in the [**IPaper**](ipaper-methods.md) interface perform both.</span></span>

<span data-ttu-id="e74dd-144">因為用戶端不會管理繪製的紙張資料，而是負責將它轉譯為螢幕上的影像，所以 COPaper 中的 [**IPaper**](ipaper-methods.md) 執行必須公開方法，讓用戶端可以取得繪圖資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-144">Because the client does not manage the drawn paper data, but is responsible for rendering it as an image on the screen, the [**IPaper**](ipaper-methods.md) implementation in COPaper must expose a method that enables the client to obtain the drawing data.</span></span> <span data-ttu-id="e74dd-145">COPaper 中的可連線物件技術可用於此用途。</span><span class="sxs-lookup"><span data-stu-id="e74dd-145">The connectable object technology in COPaper is used for this purpose.</span></span> <span data-ttu-id="e74dd-146">CONNPOINT \_ PAPERSINK 連接點是由 COPaper 所執行，因此用戶端可以連接到 COPaper 來接收筆墨資料以進行繪製。</span><span class="sxs-lookup"><span data-stu-id="e74dd-146">A CONNPOINT\_PAPERSINK connection point is implemented by COPaper so a client can connect to COPaper to receive the ink data for drawing.</span></span> <span data-ttu-id="e74dd-147">用戶端會先在 COPaper 物件上呼叫 [IPaper：：重繪](ipaper--redraw.md) 方法，以要求目前繪圖的所有筆墨資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-147">The client first calls the [IPaper::Redraw](ipaper--redraw.md) method on the COPaper object to request all the ink data of the current drawing.</span></span> <span data-ttu-id="e74dd-148">重繪的 COPaper 執行會使用 [**IPaperSink**](ipapersink-methods.md) 的用戶端執行，將資料傳遞給用戶端。</span><span class="sxs-lookup"><span data-stu-id="e74dd-148">The COPaper implementation of Redraw then uses the client implementation of [**IPaperSink**](ipapersink-methods.md) to pass the data to the client.</span></span>

<span data-ttu-id="e74dd-149">當使用者以互動方式在用戶端中繪製時，它會立即將資料繪製到螢幕，同時也會將資料傳送到 COPaper 進行儲存。</span><span class="sxs-lookup"><span data-stu-id="e74dd-149">As the user interactively draws in the client, it paints the data immediately to the screen while also sending it to COPaper for saving.</span></span> <span data-ttu-id="e74dd-150">當用戶端需要重新繪製畫面時，它會呼叫 COPaper 重新 [繪製](ipaper--redraw.md) 方法。</span><span class="sxs-lookup"><span data-stu-id="e74dd-150">When the client requires the screen to be repainted, it calls the COPaper [Redraw](ipaper--redraw.md) method.</span></span> <span data-ttu-id="e74dd-151">這類重新繪製在應用程式中是很常見的。</span><span class="sxs-lookup"><span data-stu-id="e74dd-151">Such repainting is common in applications.</span></span> <span data-ttu-id="e74dd-152">例如，當用戶端視窗與另一個應用程式視窗重迭時，就會發生重新繪製。</span><span class="sxs-lookup"><span data-stu-id="e74dd-152">For example, repainting occurs when the client window is overlaid by another application window.</span></span> <span data-ttu-id="e74dd-153">用戶端有繪製影像的點陣圖轉譯，但點陣圖很容易遺失，且通常必須重新繪製。</span><span class="sxs-lookup"><span data-stu-id="e74dd-153">The client has a bitmap rendering of the drawn image, but the bitmap is easily lost and must often be repainted.</span></span> <span data-ttu-id="e74dd-154">用戶端會依賴伺服器中的 COPaper，以取得重畫所需的筆墨資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-154">The client relies on COPaper in the server for the ink data required for repainting.</span></span>

<span data-ttu-id="e74dd-155">這是一項常見的用戶端/伺服器的人力。</span><span class="sxs-lookup"><span data-stu-id="e74dd-155">This is a common client/server division of labor.</span></span> <span data-ttu-id="e74dd-156">當有多個用戶端需要共用資料時，特別適合。</span><span class="sxs-lookup"><span data-stu-id="e74dd-156">It is especially appropriate when there is a requirement for multiple clients to share the data.</span></span> <span data-ttu-id="e74dd-157">COPaper 會進行編碼以啟用此功能。</span><span class="sxs-lookup"><span data-stu-id="e74dd-157">COPaper is coded to enable this.</span></span> <span data-ttu-id="e74dd-158">它會使用 APPUTIL CThreaded 設備來達成執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="e74dd-158">It uses the APPUTIL CThreaded facility to achieve thread safety.</span></span> <span data-ttu-id="e74dd-159">可能會利用這項設計的應用程式是共用的白板應用程式，可讓多個用戶端參與經常觀看的繪圖。</span><span class="sxs-lookup"><span data-stu-id="e74dd-159">An application that might exploit this design is a shared whiteboard application, where multiple clients can contribute to a commonly viewed drawing.</span></span> <span data-ttu-id="e74dd-160">COM 支援分散式 COM (DCOM) 支援這種類型的工作組應用程式在網路上的使用方式。</span><span class="sxs-lookup"><span data-stu-id="e74dd-160">COM support for Distributed COM (DCOM) supports this type of workgroup application usage across the network.</span></span> <span data-ttu-id="e74dd-161">如需詳細資訊，請參閱先前的 REMCLIEN 範例。</span><span class="sxs-lookup"><span data-stu-id="e74dd-161">For more information, see the earlier REMCLIEN sample.</span></span>

<span data-ttu-id="e74dd-162">COPaper 用戶端/伺服器配置更適度的使用方式，就是針對在同一部電腦上不同應用程式中所執行的物件，整合其行為。</span><span class="sxs-lookup"><span data-stu-id="e74dd-162">A more modest use of the COPaper client/server scheme is to integrate behavior for objects implemented in different applications on the same computer.</span></span> <span data-ttu-id="e74dd-163">在此情況下，用戶端可能是個別應用程式中，共用相同物件所管理之資料的 ActiveX 容器。</span><span class="sxs-lookup"><span data-stu-id="e74dd-163">In this case, the clients might be an ActiveX container in separate applications that share data managed by the same object.</span></span> <span data-ttu-id="e74dd-164">此資料可能不是 DllPaper 元件支援的筆墨繪圖資料。</span><span class="sxs-lookup"><span data-stu-id="e74dd-164">This data may not be the ink drawing data that the DllPaper component supports.</span></span> <span data-ttu-id="e74dd-165">**StoServe** 可做為管理其他共用資料類型之程式設計元件的起始架構。</span><span class="sxs-lookup"><span data-stu-id="e74dd-165">**StoServe** can be used as a starting framework for programming components that manage other types of shared data.</span></span>

## <a name="support-information"></a><span data-ttu-id="e74dd-166">支援資訊</span><span class="sxs-lookup"><span data-stu-id="e74dd-166">Support Information</span></span>

<span data-ttu-id="e74dd-167">**StoServe** makefile 會在登錄中註冊 **StoServe** DllPaper COM 元件。</span><span class="sxs-lookup"><span data-stu-id="e74dd-167">The **StoServe** makefile registers the **StoServe** DllPaper COM component in the registry.</span></span> <span data-ttu-id="e74dd-168">此元件必須在 **StoServe** 可供外部 COM 用戶端作為該元件的伺服器之前註冊。</span><span class="sxs-lookup"><span data-stu-id="e74dd-168">This component must be registered before **StoServe** is available to outside COM clients as a server for that component.</span></span> <span data-ttu-id="e74dd-169">這項自我註冊是使用內建于註冊範例的 Register.exe 公用程式來完成。</span><span class="sxs-lookup"><span data-stu-id="e74dd-169">This self-registration is done using the Register.exe utility built into the REGISTER sample.</span></span> <span data-ttu-id="e74dd-170">若要建立或執行 **StoServe**，請先建立註冊程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="e74dd-170">To build or run **StoServe**, first build the REGISTER code example.</span></span>

<span data-ttu-id="e74dd-171">如需有關設定系統以建立和測試此 COM 教學課程系列中程式碼範例的詳細資訊，請參閱 [如何建立範例](how-to-build-samples.md)。</span><span class="sxs-lookup"><span data-stu-id="e74dd-171">For more information about setting up your system to build and test the code examples in this COM Tutorial series, see [How to Build Samples](how-to-build-samples.md).</span></span> <span data-ttu-id="e74dd-172">提供的 makefile (MAKEFILE) 與 Microsoft NMAKE 相容。</span><span class="sxs-lookup"><span data-stu-id="e74dd-172">The supplied makefile (MAKEFILE) is Microsoft NMAKE-compatible.</span></span> <span data-ttu-id="e74dd-173">若要建立 debug 組建，請在 [命令提示字元] 視窗中發出 NMAKE 命令。</span><span class="sxs-lookup"><span data-stu-id="e74dd-173">To create a debug build, issue the NMAKE command in the command prompt window.</span></span>

<span data-ttu-id="e74dd-174">為了方便使用 Microsoft Visual Studio，會針對每個範例提供專案檔。</span><span class="sxs-lookup"><span data-stu-id="e74dd-174">For convenient use in Microsoft Visual Studio, a project file is provided for each sample.</span></span> <span data-ttu-id="e74dd-175">若要載入 **StoServe** 範例的專案，您可以在範例目錄的命令提示字元中執行 Visual Studio，如下所示：</span><span class="sxs-lookup"><span data-stu-id="e74dd-175">To load the project for the **StoServe** example, you can run Visual Studio at the command prompt in the samples directory as follows:</span></span>

<span data-ttu-id="e74dd-176">MSDEV STOSERVE.Dsp</span><span class="sxs-lookup"><span data-stu-id="e74dd-176">MSDEV STOSERVE.DSP</span></span>

<span data-ttu-id="e74dd-177">您也可以按兩下 Windows 檔案總管中的 Stoserve，將範例專案載入 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="e74dd-177">You can also double-click the Stoserve.dsp file in Windows Explorer to load a sample project into Visual Studio.</span></span> <span data-ttu-id="e74dd-178">在 Visual Studio 您可以流覽範例來源的 c + + 類別，並通常執行其他編輯編譯-編譯-debug 作業。</span><span class="sxs-lookup"><span data-stu-id="e74dd-178">In Visual Studio you can browse the C++ classes of the sample source and generally perform the other edit-compile-debug operations.</span></span>

> [!Note]  
> <span data-ttu-id="e74dd-179">作為平臺軟體發展工具組的一部分 (SDK) ，在 Visual Studio 中編譯這些範例需要 Visual Studio 中正確設定目錄路徑。</span><span class="sxs-lookup"><span data-stu-id="e74dd-179">As part of the Platform Software Development Kit (SDK), the compilation of these samples from within Visual Studio requires the proper setting of directory paths in Visual Studio.</span></span> <span data-ttu-id="e74dd-180">如需詳細資訊，請參閱 [如何建立範例](how-to-build-samples.md)。</span><span class="sxs-lookup"><span data-stu-id="e74dd-180">For more information, see [How to Build Samples](how-to-build-samples.md).</span></span>

 

 

 