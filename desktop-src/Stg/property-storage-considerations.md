---
title: 屬性儲存體考慮
description: IPropertyStorage ReadMultiple 會讀取 rgpspec 陣列中所指定的多個屬性，如同在屬性集中找到的屬性。
ms.assetid: 7540966f-a3b2-46c9-9e04-b15133a517eb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2aad6aabf8b22a7c01f91a090136e6cc8156c791
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106967899"
---
# <a name="property-storage-considerations"></a><span data-ttu-id="6b30a-103">屬性儲存體考慮</span><span class="sxs-lookup"><span data-stu-id="6b30a-103">Property Storage Considerations</span></span>

<span data-ttu-id="6b30a-104">[**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) 會讀取 *rgpspec* 陣列中所指定的多個屬性，如同在屬性集中找到的屬性。</span><span class="sxs-lookup"><span data-stu-id="6b30a-104">[**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) reads as many of the properties specified in the *rgpspec* array as are found in the property set.</span></span> <span data-ttu-id="6b30a-105">只要讀取要求的任何屬性，取得不存在之屬性的要求就不會是錯誤。</span><span class="sxs-lookup"><span data-stu-id="6b30a-105">As long as any of the properties requested is read, a request to retrieve a property that does not exist is not an error.</span></span> <span data-ttu-id="6b30a-106">相反地，這必須在傳回時，將 \_ 該屬性的 VT 空白寫入 *rgvar* \[ \] 陣列。</span><span class="sxs-lookup"><span data-stu-id="6b30a-106">Instead, this must cause VT\_EMPTY to be written for that property to the *rgvar*\[\] array on return.</span></span> <span data-ttu-id="6b30a-107">當沒有任何要求的屬性存在時，此方法應該會傳回 \_ FALSE，並 \_ 在每個 [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)中設定 VT 空白。</span><span class="sxs-lookup"><span data-stu-id="6b30a-107">When none of the requested properties exist, the method should return S\_FALSE, and set VT\_EMPTY in each [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant).</span></span> <span data-ttu-id="6b30a-108">如果傳回任何其他錯誤，則不會抓取任何屬性值，而且呼叫端不需要擔心釋放它們。</span><span class="sxs-lookup"><span data-stu-id="6b30a-108">If any other error is returned, no property values are retrieved, and the caller need not worry about releasing them.</span></span>

<span data-ttu-id="6b30a-109">*Rgpspec* 參數是 [**PROPSPEC**](/windows/win32/api/propidlbase/ns-propidlbase-propspec)結構的陣列，可指定每個屬性的屬性識別碼，或指派給一個字串識別碼的屬性。</span><span class="sxs-lookup"><span data-stu-id="6b30a-109">The *rgpspec* parameter is an array of [**PROPSPEC**](/windows/win32/api/propidlbase/ns-propidlbase-propspec) structures, which specify for each property either its property identifier or, if one is assigned, a string identifier.</span></span> <span data-ttu-id="6b30a-110">您可以藉由呼叫 [**IPropertyStorage：： WritePropertyNames**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writepropertynames)，將字串對應至屬性識別碼。</span><span class="sxs-lookup"><span data-stu-id="6b30a-110">You can map a string to a property identifier by calling [**IPropertyStorage::WritePropertyNames**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writepropertynames).</span></span> <span data-ttu-id="6b30a-111">不過，使用屬性識別碼可能會比使用字串更有效率。</span><span class="sxs-lookup"><span data-stu-id="6b30a-111">The use of property identifiers is, however, likely to be significantly more efficient than the use of strings.</span></span>

<span data-ttu-id="6b30a-112">字串名稱 (PRSPEC LPWSTR) 所要求的屬性 \_ 會對應至屬性識別碼 (識別碼) ，因為它們是在目前的屬性集 (中指定，而且根據目前的系統地區設定) 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-112">Properties that are requested by string name (PRSPEC\_LPWSTR) are mapped case-insensitively to property identifiers (IDs) as they are specified in the current property set (and according to the current system locale).</span></span>

<span data-ttu-id="6b30a-113">當屬性型別為 VT \_ LPSTR，而且從 ANSI 屬性集讀取屬性時（亦即，屬性集的字碼頁設定為 Unicode 以外的值），屬性的值會使用與屬性集相同的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="6b30a-113">When the property type is VT\_LPSTR and the property is read from an ANSI property set, that is, the code page for the property set is set to something other than Unicode, the value of the property uses the same code page as the property set.</span></span> <span data-ttu-id="6b30a-114">\_從 Unicode 屬性集讀取 VT LPSTR 屬性時，屬性值會使用系統目前的預設 ANSI 字碼頁，也就是從 **GetACP** 函數傳回的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="6b30a-114">When a VT\_LPSTR property is read from a Unicode property set, the value of the property uses the system's current default ANSI code page, that is, the code page returned from the **GetACP** function.</span></span>

<span data-ttu-id="6b30a-115">除了做為資料流程和儲存體指標的 [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)以外，它也稱為簡單 **PROPVARIANT**。</span><span class="sxs-lookup"><span data-stu-id="6b30a-115">A [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant), except for those that are pointers to streams and storages, is called a simple **PROPVARIANT**.</span></span> <span data-ttu-id="6b30a-116">這些簡單的 **PROPVARIANT** 會以傳值方式接收資料，因此呼叫 [**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) 會提供呼叫端所擁有的資料複本。</span><span class="sxs-lookup"><span data-stu-id="6b30a-116">These simple **PROPVARIANT** s receive data by value, so a call to [**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) supplies a copy of the data that the caller then owns.</span></span> <span data-ttu-id="6b30a-117">若要建立或更新這些屬性，請呼叫 [**IPropertyStorage：： WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple)。</span><span class="sxs-lookup"><span data-stu-id="6b30a-117">To create or update these properties, call [**IPropertyStorage::WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple).</span></span>

<span data-ttu-id="6b30a-118">相反地，variant 型別會將 VT \_ 資料流程、vt 資料流程 \_ \_ 物件、VT \_ 儲存和 vt \_ 儲存 \_ 的物件視為非簡單的屬性，因為這種方法不會提供值，而是會抓取指向介面的指標，然後從該介面讀取資料。</span><span class="sxs-lookup"><span data-stu-id="6b30a-118">In contrast, the variant types VT\_STREAM, VT\_STREAMED\_OBJECT, VT\_STORAGE, and VT\_STORED\_OBJECT are non-simple properties, because rather than supplying a value, the method retrieves a pointer to the indicated interface, from which the data can then be read.</span></span> <span data-ttu-id="6b30a-119">這些類型允許透過單一屬性儲存大量資訊。</span><span class="sxs-lookup"><span data-stu-id="6b30a-119">These types permit the storage of large amounts of information through a single property.</span></span> <span data-ttu-id="6b30a-120">使用簡單屬性時，會發生數個問題。</span><span class="sxs-lookup"><span data-stu-id="6b30a-120">There are several issues that arise in using nonsimple properties.</span></span>

<span data-ttu-id="6b30a-121">若要建立這些屬性，請呼叫 [**IPropertyStorage：： WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple)，做為其他屬性。</span><span class="sxs-lookup"><span data-stu-id="6b30a-121">To create these properties, as for the other properties, call [**IPropertyStorage::WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple).</span></span> <span data-ttu-id="6b30a-122">不過，您可以更有效率地先呼叫 [**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) 來取得資料流程或儲存體的介面指標，然後使用 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) 或 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) 方法來寫入資料，而不是呼叫相同的方法進行更新。</span><span class="sxs-lookup"><span data-stu-id="6b30a-122">Rather than calling the same method to update, however, it is more efficient to first call [**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) to get the interface pointer to the stream or storage, then write data using the [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) or [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) methods.</span></span> <span data-ttu-id="6b30a-123">透過屬性開啟的資料流程或儲存體一律會以直接模式開啟，因此不會引進額外的嵌套交易層級。</span><span class="sxs-lookup"><span data-stu-id="6b30a-123">A stream or storage opened through a property is always opened in direct mode, so an additional level of nested transaction is not introduced.</span></span> <span data-ttu-id="6b30a-124">但是，根據 [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage)的開啟或建立方式而定，可能仍會在屬性上設定為整體的交易。</span><span class="sxs-lookup"><span data-stu-id="6b30a-124">There may, however, still be a transaction on the property set as a whole, depending on how it was opened or created through [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage).</span></span> <span data-ttu-id="6b30a-125">此外，當屬性集開啟或建立時，指定的存取和共用模式標記會傳遞給以屬性為基礎的資料流程或儲存體。</span><span class="sxs-lookup"><span data-stu-id="6b30a-125">Further, the access and share mode tags specified when the property set is opened or created, are passed to property-based streams or storages.</span></span>

<span data-ttu-id="6b30a-126">以屬性為基礎的資料流程或儲存體指標的存留期，雖然理論上與其相關聯的 [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) 和 [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) 指標無關，但實際上卻依賴它們。</span><span class="sxs-lookup"><span data-stu-id="6b30a-126">The lifetimes of property-based stream or storage pointers, although theoretically independent of their associated [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) and [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) pointers, in fact, effectively depend on them.</span></span> <span data-ttu-id="6b30a-127">透過資料流程或儲存體可見的資料，與從中抓取的屬性儲存體物件上的交易有關，就如同儲存物件 (使用包含的資料流程和儲存子物件支援 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)) 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-127">The data visible through the stream or storage is related to the transaction on the property storage object from which it is retrieved, just as for a storage object (supporting [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)) with contained stream and storage sub-objects.</span></span> <span data-ttu-id="6b30a-128">如果父物件的交易中止，則無法再存取該物件的現有 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) 和 **IStorage** 指標。</span><span class="sxs-lookup"><span data-stu-id="6b30a-128">If the transaction on the parent object is aborted, existing [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) and **IStorage** pointers subordinate to that object are no longer accessible.</span></span> <span data-ttu-id="6b30a-129">因為 **IPropertyStorage** 是屬性儲存物件上的唯一介面，所以包含的 **IStream** 和 **IStorage** 指標的有用存留期是由 **IPropertyStorage** 介面的存留期所限制。</span><span class="sxs-lookup"><span data-stu-id="6b30a-129">Because **IPropertyStorage** is the only interface on the property storage object, the useful lifetime of the contained **IStream** and **IStorage** pointers is bounded by the lifetime of the **IPropertyStorage** interface.</span></span>

<span data-ttu-id="6b30a-130">執行也必須處理相同的資料流程或儲存體值屬性透過相同的 [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) 介面實例多次要求的情況。</span><span class="sxs-lookup"><span data-stu-id="6b30a-130">The implementation must also deal with the situation where the same stream- or storage-valued property is requested multiple times through the same [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) interface instance.</span></span> <span data-ttu-id="6b30a-131">例如，在 COM 複合檔案執行中，開啟會成功或失敗，取決於屬性是否已開啟。</span><span class="sxs-lookup"><span data-stu-id="6b30a-131">For example, in the COM compound file implementation, the open will succeed or fail depending on whether or not the property is already open.</span></span>

<span data-ttu-id="6b30a-132">另一個問題是交易模式中有多重開啟。</span><span class="sxs-lookup"><span data-stu-id="6b30a-132">Another issue is multiple opens in transacted mode.</span></span> <span data-ttu-id="6b30a-133">結果取決於透過呼叫 [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) 方法所指定的隔離等級， ([**開啟**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) 或 [**建立**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create) 方法，方法是透過 STGM 旗標在開啟屬性儲存時) 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-133">The result depends on the isolation level that was specified through a call to [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) methods, (either the [**Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) or [**Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create) method, through the STGM flags) at the time that the property storage was opened.</span></span>

<span data-ttu-id="6b30a-134">如果開啟屬性集的呼叫指定讀寫存取， [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) 和 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)值屬性一律會以讀寫存取來開啟。</span><span class="sxs-lookup"><span data-stu-id="6b30a-134">If the call to open the property set specifies read-write access, [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) and [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)-valued properties are always opened with read-write access.</span></span> <span data-ttu-id="6b30a-135">然後可以透過這些介面寫入資料，變更屬性的值，這是更新這些屬性最有效率的方式。</span><span class="sxs-lookup"><span data-stu-id="6b30a-135">Data can then be written through these interfaces, changing the value of the property, which is the most efficient way to update these properties.</span></span> <span data-ttu-id="6b30a-136">屬性值本身沒有額外的交易嵌套層級，因此，如果屬性儲存物件上有任何) ，則變更會限定在交易 (。</span><span class="sxs-lookup"><span data-stu-id="6b30a-136">The property value itself does not have an additional level of transaction nesting, so changes are scoped under the transaction (if any) on the property storage object.</span></span>

## <a name="storage-and-stream-properties"></a><span data-ttu-id="6b30a-137">儲存體和資料流程屬性</span><span class="sxs-lookup"><span data-stu-id="6b30a-137">Storage and Stream Properties</span></span>

<span data-ttu-id="6b30a-138">若要將資料流程或儲存物件寫入屬性集，屬性集必須建立為簡單。</span><span class="sxs-lookup"><span data-stu-id="6b30a-138">To write a stream or storage object to a property set, the property set must have been created as nonsimple.</span></span> <span data-ttu-id="6b30a-139">如需簡單和簡單屬性集的詳細資訊，請參閱標題為「 [儲存」和「資料流程物件」的屬性集](storage-vs--stream-for-a-property-set.md)區段。</span><span class="sxs-lookup"><span data-stu-id="6b30a-139">For more information on simple and nonsimple property sets, see the section titled [Storage and Stream Objects for a Property Set](storage-vs--stream-for-a-property-set.md).</span></span> <span data-ttu-id="6b30a-140">下列屬性類型（如 *rgvar* 陣列元素的 *vt* 欄位中所指定）為數據流或儲存類型： vt \_ 資料流程、vt \_ 儲存、vt \_ 資料流程 \_ 物件、vt 儲存的 \_ \_ 物件。</span><span class="sxs-lookup"><span data-stu-id="6b30a-140">The following property types, as specified in the *vt* field of the *rgvar* array elements, are stream or storage types: VT\_STREAM, VT\_STORAGE, VT\_STREAMED\_OBJECT, VT\_STORED\_OBJECT.</span></span>

<span data-ttu-id="6b30a-141">若要以非簡單屬性集中的屬性來寫入資料流程或儲存物件，請呼叫 [**IPropertyStorage：： WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple)。</span><span class="sxs-lookup"><span data-stu-id="6b30a-141">To write a stream or storage object as a property in a non-simple property set, call [**IPropertyStorage::WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple).</span></span> <span data-ttu-id="6b30a-142">雖然您也會呼叫這個方法來更新簡單的屬性，但它並不是在屬性集中更新資料流程和儲存物件的有效方式。</span><span class="sxs-lookup"><span data-stu-id="6b30a-142">While you would also call this method to update simple properties, it is not an efficient way to update stream and storage objects in a property set.</span></span> <span data-ttu-id="6b30a-143">這是因為透過呼叫 **WriteMultiple** 來更新其中一個屬性會在屬性儲存物件中建立傳入資料的複本，而 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) 或 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) 指標不會在此呼叫的持續時間內保留。</span><span class="sxs-lookup"><span data-stu-id="6b30a-143">This is because updating one of these properties through a call to **WriteMultiple** creates in the property storage object a copy of the passed-in data, and the [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) or [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) pointers are not retained beyond the duration of this call.</span></span> <span data-ttu-id="6b30a-144">通常會先呼叫 [**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) 來取得資料流程或儲存體的介面指標，然後透過 **IStream** 或 **IStorage** 方法寫入資料，以更有效率的方式直接更新資料流程或儲存物件。</span><span class="sxs-lookup"><span data-stu-id="6b30a-144">It is usually more efficient to update stream or storage objects directly by first calling [**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) to get the interface pointer to the stream or storage, then writing data through the **IStream** or **IStorage** methods.</span></span>

<span data-ttu-id="6b30a-145">例如，您可以呼叫 [**IPropertyStorage：： WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) 來寫入 **Null** 資料流程或儲存物件。</span><span class="sxs-lookup"><span data-stu-id="6b30a-145">For example, you can call [**IPropertyStorage::WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) to write a **NULL** stream or storage object.</span></span> <span data-ttu-id="6b30a-146">然後，此實作為會在屬性集中建立空的物件。</span><span class="sxs-lookup"><span data-stu-id="6b30a-146">The implementation will then create an empty object in the property set.</span></span> <span data-ttu-id="6b30a-147">然後，您可以藉由呼叫 [**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple)來取得此物件的存取權。</span><span class="sxs-lookup"><span data-stu-id="6b30a-147">You can then get access to this object by calling [**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple).</span></span> <span data-ttu-id="6b30a-148">當您完成更新這個物件時，您不需要將它寫入屬性集，因為您的更新會直接進入屬性集。</span><span class="sxs-lookup"><span data-stu-id="6b30a-148">When you finish updating this object you need not write it to the property set, as your updates were going directly into the property set.</span></span>

<span data-ttu-id="6b30a-149">透過屬性開啟的資料流程或儲存體一律會以直接模式開啟，因此不會引進額外的嵌套交易層級。</span><span class="sxs-lookup"><span data-stu-id="6b30a-149">A stream or storage opened through a property is always opened in direct mode, so an additional level of nested transaction is not introduced.</span></span> <span data-ttu-id="6b30a-150">屬性（property）上的屬性（property）仍可能會設定為整體的交易。</span><span class="sxs-lookup"><span data-stu-id="6b30a-150">There still may be a transaction on the property set as a whole.</span></span> <span data-ttu-id="6b30a-151">(For example, if the [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) was obtained by calling [**IPropertySetStorage::Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) with the STGM\_TRANSACTED flag set in the *grfmode* parameter.) Further, a property-based stream or storage is opened in read-write mode, if possible, given the mode on the property set; otherwise, read mode is used.</span><span class="sxs-lookup"><span data-stu-id="6b30a-151">(For example, if the [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) was obtained by calling [**IPropertySetStorage::Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) with the STGM\_TRANSACTED flag set in the *grfmode* parameter.) Further, a property-based stream or storage is opened in read-write mode, if possible, given the mode on the property set; otherwise, read mode is used.</span></span>

<span data-ttu-id="6b30a-152">如先前所述，當資料流程或儲存物件寫入具有 [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) 方法的屬性集時，會建立物件的複本。</span><span class="sxs-lookup"><span data-stu-id="6b30a-152">As mentioned earlier, when a stream or storage object is written to a property set with the [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) method, a copy of the object is made.</span></span> <span data-ttu-id="6b30a-153">當資料流程物件上進行這類複製時，複製作業會從來源的目前搜尋位置開始。</span><span class="sxs-lookup"><span data-stu-id="6b30a-153">When such a copy is made on a stream object, the copy operation starts at the current seek position of the source.</span></span> <span data-ttu-id="6b30a-154">失敗時，搜尋位置未定義，但在成功時，是在資料流程的結尾;搜尋指標不會還原至其原始位置。</span><span class="sxs-lookup"><span data-stu-id="6b30a-154">The seek position is undefined on failure, but on success it is at the end of the stream; the seek pointer is not restored to its original position.</span></span>

<span data-ttu-id="6b30a-155">如果已從具有 [**ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple)的屬性集讀取資料流程或儲存屬性，仍會保持開啟狀態，而且會針對相同的屬性進行後續的 [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) 呼叫， **WriteMultiple** 作業將會成功。</span><span class="sxs-lookup"><span data-stu-id="6b30a-155">If a stream or storage property has been read from a property set with [**ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple), is still held open, and a subsequent call to [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) for the same property is made, the **WriteMultiple** operation will succeed.</span></span> <span data-ttu-id="6b30a-156">先前開啟的資料流程或儲存體屬性會處於還原狀態， (對它的所有呼叫都會傳回 STG. \_ E 已 \_ 還原的錯誤) 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-156">The previously opened stream or storage property is placed in the reverted state (all calls to it will return STG\_E\_REVERTED error).</span></span>

<span data-ttu-id="6b30a-157">如果 [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) 方法在寫入屬性的陣列時傳回錯誤，或甚至是個別的非簡單屬性，則實際寫入的資料量是未定義的。</span><span class="sxs-lookup"><span data-stu-id="6b30a-157">If the [**WriteMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) method returns an error when writing an array of properties, or even individual non-simple properties, the amount of data actually written is undefined.</span></span>

## <a name="reference-properties"></a><span data-ttu-id="6b30a-158">參考屬性</span><span class="sxs-lookup"><span data-stu-id="6b30a-158">Reference Properties</span></span>

<span data-ttu-id="6b30a-159">如果指定的 [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) 結構 \_ 在其 **VT** 成員中包含 vt BYREF 旗標，則相關聯的屬性會是參考屬性。</span><span class="sxs-lookup"><span data-stu-id="6b30a-159">If a specified [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) structure includes the VT\_BYREF flag in its **vt** member, the associated property is a reference property.</span></span> <span data-ttu-id="6b30a-160">在將值寫入屬性集之前，會自動取值參考屬性。</span><span class="sxs-lookup"><span data-stu-id="6b30a-160">A reference property is automatically dereferenced before writing the value to the property set.</span></span> <span data-ttu-id="6b30a-161">例如，如果 **PROPVARIANT** 結構的 **vt** 成員指定了型別 vt \_ BYREF vt I4 的值 \| \_ ，則實際寫入的值是 vt \_ I4 型別。</span><span class="sxs-lookup"><span data-stu-id="6b30a-161">For example, if the **vt** member of the **PROPVARIANT** structure specifies a value of type VT\_BYREF \| VT\_I4, the actual value written is a VT\_I4 type.</span></span> <span data-ttu-id="6b30a-162">[**IPropertyStorage：： ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple)方法的後續呼叫會以 VT I4 的形式傳回值 \_ 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-162">A subsequent call to the [**IPropertyStorage::ReadMultiple**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) method returns a value as VT\_I4.</span></span> <span data-ttu-id="6b30a-163">使用參考屬性類似于呼叫 [VariantCopyInd](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) 函數。</span><span class="sxs-lookup"><span data-stu-id="6b30a-163">Using reference properties is similar to calling the [VariantCopyInd](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) function.</span></span> <span data-ttu-id="6b30a-164">如果將來源指定為 VT BYREF， [VariantCopyInd](/windows/win32/api/oleauto/nf-oleauto-variantcopyind)就會釋出目的地變異，並複製來源 VARIANTARG，執行必要的間接取值 \_ 。</span><span class="sxs-lookup"><span data-stu-id="6b30a-164">[VariantCopyInd](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) frees the destination variant and makes a copy of the source VARIANTARG, performing the necessary indirection if the source is specified to be VT\_BYREF.</span></span> <span data-ttu-id="6b30a-165">當需要變異的複本，並確保它不是 VT \_ BYREF 時（例如，在處理 [**IDispatch：： Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)的函式中處理引數）時，這個函式會很有用。</span><span class="sxs-lookup"><span data-stu-id="6b30a-165">This function is useful when a copy of a variant is needed, and to guarantee that it is not VT\_BYREF, for example when handling arguments in an implementation of [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).</span></span>

## <a name="notes-to-callers"></a><span data-ttu-id="6b30a-166">給呼叫者的注意事項</span><span class="sxs-lookup"><span data-stu-id="6b30a-166">Notes to Callers</span></span>

<span data-ttu-id="6b30a-167">建議您 \_ 在 [**IPropertySetStorage：： Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create)的 *GRFFLAGS* 參數中設定 PROPSETFLAG ANSI 旗標，以將屬性集建立為 Unicode。</span><span class="sxs-lookup"><span data-stu-id="6b30a-167">It is recommended that property sets be created as Unicode, by not setting the PROPSETFLAG\_ANSI flag in the *grfFlags* parameter of [**IPropertySetStorage::Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create).</span></span> <span data-ttu-id="6b30a-168">此外，也建議您避免使用 VT \_ LPSTR 值，並改為使用 vt \_ LPWSTR 值。</span><span class="sxs-lookup"><span data-stu-id="6b30a-168">It is also recommended that you avoid using VT\_LPSTR values, and use VT\_LPWSTR values instead.</span></span> <span data-ttu-id="6b30a-169">當屬性集字碼頁是 Unicode 時，VT \_ LPSTR 字串值會在儲存時轉換成 unicode，並在抓取時轉換回多位元組字元串值。</span><span class="sxs-lookup"><span data-stu-id="6b30a-169">When the property set code page is Unicode, VT\_LPSTR string values are converted to Unicode when stored, and back to multibyte string values when retrieved.</span></span> <span data-ttu-id="6b30a-170">當屬性集的字碼頁不是 Unicode 時，屬性名稱、VT \_ BSTR 字串和非簡單的屬性值會在儲存時轉換成多位元組字元串，並且在抓取時轉換回 Unicode，全都使用目前的系統 ANSI 字碼頁。</span><span class="sxs-lookup"><span data-stu-id="6b30a-170">When the code page of the property set is not Unicode, property names, VT\_BSTR strings, and non-simple property values are converted to multibyte strings when stored, and converted back to Unicode when retrieved, all using the current system ANSI code page.</span></span>

## <a name="notes-to-implementers"></a><span data-ttu-id="6b30a-171">給實施者的注意事項</span><span class="sxs-lookup"><span data-stu-id="6b30a-171">Notes to Implementers</span></span>

<span data-ttu-id="6b30a-172">配置屬性識別碼時，實作為屬性識別碼的屬性（property）識別碼（property）的屬性（property）（property）不會在屬性（property）識別碼中使用任何目前使用中的值，只要它不是0或1或大於0x80000000 （這些都是保留值）。</span><span class="sxs-lookup"><span data-stu-id="6b30a-172">When allocating a property identifier, the implementation can choose any value not currently in use in the property set for a property identifier, as long as it is not 0 or 1 or greater than 0x80000000, all of which are reserved values.</span></span> <span data-ttu-id="6b30a-173">*PropidNameFirst* 參數會在集合內建立屬性識別碼的最小值，而且必須大於1且小於0x80000000。</span><span class="sxs-lookup"><span data-stu-id="6b30a-173">The *propidNameFirst* parameter establishes a minimum value for property identifiers within the set, and must be greater than 1 and less than 0x80000000.</span></span> <span data-ttu-id="6b30a-174">請參閱上述的備註一節。</span><span class="sxs-lookup"><span data-stu-id="6b30a-174">See Remarks section above.</span></span>

## <a name="related-topics"></a><span data-ttu-id="6b30a-175">相關主題</span><span class="sxs-lookup"><span data-stu-id="6b30a-175">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="6b30a-176">IPropertyStorage-複合檔案執行</span><span class="sxs-lookup"><span data-stu-id="6b30a-176">IPropertyStorage-Compound File Implementation</span></span>](ipropertystorage-compound-file-implementation.md)
</dt> <dt>

[<span data-ttu-id="6b30a-177">IPropertyStorage-NTFS 檔案系統執行</span><span class="sxs-lookup"><span data-stu-id="6b30a-177">IPropertyStorage-NTFS File System Implementation</span></span>](ipropertystorage-ntfs-file-system-implementation.md)
</dt> <dt>

[<span data-ttu-id="6b30a-178">IPropertyStorage-獨立執行</span><span class="sxs-lookup"><span data-stu-id="6b30a-178">IPropertyStorage-Stand-alone Implementation</span></span>](ipropertystorage-stand-alone-implementation.md)
</dt> </dl>

 

 