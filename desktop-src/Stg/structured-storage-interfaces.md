---
title: 結構化儲存介面
description: 結構化儲存體服務分成三種類型的介面。
ms.assetid: a4281f07-eae4-4bcb-8d16-b6c0bd3c5b21
keywords:
- 結構化儲存介面
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0010a0d4dec4908111c8a5bb939f795f0a2b2eb3
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "106996562"
---
# <a name="structured-storage-interfaces"></a><span data-ttu-id="e4fbc-104">結構化儲存介面</span><span class="sxs-lookup"><span data-stu-id="e4fbc-104">Structured Storage Interfaces</span></span>

<span data-ttu-id="e4fbc-105">結構化儲存體服務分成三種類型的 [介面](interfaces.md)。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-105">Structured Storage services are organized into three categories of [interfaces](interfaces.md).</span></span> <span data-ttu-id="e4fbc-106">每個集合都代表複合檔案、它所包含的物件和儲存這些個別元件之實體媒體之間的連續間接取值層級或抽象層。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-106">Each set represents a successive level of indirection or abstraction between a compound file, the objects it contains, and the physical media in which these individual components are stored.</span></span>

<span data-ttu-id="e4fbc-107">介面的第一個類別是由 [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)、 [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)和 [**IRootStorage**](/windows/desktop/api/Objidl/nn-objidl-irootstorage)所組成。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-107">The first category of interfaces consists of [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage), [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream), and [**IRootStorage**](/windows/desktop/api/Objidl/nn-objidl-irootstorage).</span></span> <span data-ttu-id="e4fbc-108">前兩個介面會定義如何將物件儲存在複合檔案中。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-108">The first two interfaces define how objects are stored within a compound file.</span></span> <span data-ttu-id="e4fbc-109">這些介面提供開啟儲存元素、認可和還原變更、複製和移動元素，以及讀取和寫入資料流程的方法。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-109">These interfaces provide methods for opening storage elements, committing and reverting changes, copying and moving elements, and reading and writing streams.</span></span> <span data-ttu-id="e4fbc-110">這些介面無法辨識個別物件的原生資料格式，因此沒有方法可將這些物件儲存至持續性儲存區。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-110">These interfaces do not recognize the native data formats of the individual objects and therefore have no methods for saving those objects to persistent storage.</span></span> <span data-ttu-id="e4fbc-111">**IRootStorage** 介面具有單一方法，可讓複合檔案與基礎檔案系統名稱產生關聯。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-111">The **IRootStorage** interface has a single method for associating a compound document with an underlying file system name.</span></span> <span data-ttu-id="e4fbc-112">用戶端必須為其複合檔案執行這些介面。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-112">Clients must implement these interfaces for their compound files.</span></span>

<span data-ttu-id="e4fbc-113">第二個類別的介面是由 [**IPersist**](/windows/win32/api/objidl/nn-objidl-ipersist) 介面所組成，這些介面的物件會執行這些介面來管理其持續性資料。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-113">The second category of interfaces consists of the [**IPersist**](/windows/win32/api/objidl/nn-objidl-ipersist) interfaces, which objects implement to manage their persistent data.</span></span> <span data-ttu-id="e4fbc-114">這些介面會提供方法來讀取個別物件的資料格式，進而知道如何儲存它們。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-114">These interfaces provide methods to read the data formats of individual objects and therefore know how to store them.</span></span> <span data-ttu-id="e4fbc-115">物件會負責執行這些介面，因為用戶端不知道其嵌套物件的原生資料格式。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-115">Objects are responsible for implementing these interfaces because clients do not know the native data formats of their nested objects.</span></span> <span data-ttu-id="e4fbc-116">不過，這些介面並不知道特定的實體儲存體媒體。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-116">These interfaces, however, have no knowledge of specific physical storage media.</span></span>

<span data-ttu-id="e4fbc-117">第三個類別是由單一介面 [**ILockBytes**](/windows/desktop/api/Objidl/nn-objidl-ilockbytes)所組成，它提供將檔案寫入特定實體媒體（例如硬碟或磁帶機）的方法。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-117">A third category consists of a single interface, [**ILockBytes**](/windows/desktop/api/Objidl/nn-objidl-ilockbytes), which provides methods for writing files to specific physical media, such as a hard disk or tape drive.</span></span> <span data-ttu-id="e4fbc-118">不過，大部分的應用程式都不會實 **ILockBytes** 介面，因為 COM 已經提供兩種最常見的情況，也就是以檔案為基礎的執行和以記憶體為基礎的實作為。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-118">However, most applications will not implement the **ILockBytes** interface because COM already provides implementations for the two most common situations, which are File-based implementation and Memory-based implementation.</span></span> <span data-ttu-id="e4fbc-119">複合檔案儲存物件會呼叫 **ILockBytes** 方法，您不會直接在執行中呼叫它們。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-119">The compound file storage object calls the **ILockBytes** methods you do not call them directly in the implementation.</span></span>

## <a name="compound-file-implementation-limits"></a><span data-ttu-id="e4fbc-120">複合檔案執行限制</span><span class="sxs-lookup"><span data-stu-id="e4fbc-120">Compound File Implementation Limits</span></span>

<span data-ttu-id="e4fbc-121">結構化儲存體架構的 COM 實作為所謂的 *複合檔案*。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-121">The COM implementation of Structured Storage architecture is called *compound files*.</span></span> <span data-ttu-id="e4fbc-122">在複合檔案中執行的儲存物件包含 [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) 和 [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) 介面的執行。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-122">Storage objects, as implemented in compound files, include an implementation of the [**IPropertyStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) and [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) interfaces.</span></span>

<span data-ttu-id="e4fbc-123">藉由呼叫 [**StgCreateStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatestorageex) 函式來建立新的複合檔案物件，或使用 [**StgOpenStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorageex) 來開啟先前建立的複合檔案，即可取得這些介面的複合檔案實指標。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-123">Pointers to the compound file implementation of these interfaces are acquired by calling the [**StgCreateStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatestorageex) function to create a new compound file object, or [**StgOpenStorageEx**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorageex) to open a previously created compound file.</span></span>

<span data-ttu-id="e4fbc-124">取得這些介面之複合檔案執行指標的替代方法是呼叫較舊且更有限的 [**StgCreateDocfile**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatedocfile) 或 [**StgOpenStorage**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorage) 函式。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-124">An alternative method for acquiring a pointer to the compound file implementation of these interfaces is by calling the older and more limited [**StgCreateDocfile**](/windows/desktop/api/coml2api/nf-coml2api-stgcreatedocfile) or [**StgOpenStorage**](/windows/desktop/api/coml2api/nf-coml2api-stgopenstorage) function.</span></span> <span data-ttu-id="e4fbc-125">這四個函式會被視為複合檔案執行。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-125">All four functions are treated as compound file implementations.</span></span>

<span data-ttu-id="e4fbc-126">複合檔案執行可以設定為使用512或4096位元組的磁區，如 [**STGOPTIONS**](/windows/win32/api/coml2api/ns-coml2api-stgoptions) 結構中所定義。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-126">The compound file implementation can be configured to use 512 or 4096 byte sectors, as defined in the [**STGOPTIONS**](/windows/win32/api/coml2api/ns-coml2api-stgoptions) structure.</span></span>

<span data-ttu-id="e4fbc-127">複合檔案的複合檔案執行受限於下列實條件約束。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-127">The compound file implementation of compound files is subject to the following implementation constraints.</span></span>



| <span data-ttu-id="e4fbc-128">限制</span><span class="sxs-lookup"><span data-stu-id="e4fbc-128">Limit</span></span>                                           | <span data-ttu-id="e4fbc-129">複合檔案</span><span class="sxs-lookup"><span data-stu-id="e4fbc-129">Compound file</span></span>                                                                                                                                                                      |
|-------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="e4fbc-130">檔案大小限制：</span><span class="sxs-lookup"><span data-stu-id="e4fbc-130">File size limits:</span></span>                               | <span data-ttu-id="e4fbc-131">512： 2 gb (GB) 4096：最高達檔案系統限制</span><span class="sxs-lookup"><span data-stu-id="e4fbc-131">512: 2 gigabytes (GB) 4096: Up to file system limits</span></span><br/>                                                                                                                    |
| <span data-ttu-id="e4fbc-132">開啟元素所需的堆積大小上限：</span><span class="sxs-lookup"><span data-stu-id="e4fbc-132">Maximum heap size required for open elements:</span></span>   | <span data-ttu-id="e4fbc-133">512： 4 mb (MB) 4096：最多虛擬記憶體限制</span><span class="sxs-lookup"><span data-stu-id="e4fbc-133">512: 4 megabytes (MB) 4096: Up to virtual memory limits</span></span><br/>                                                                                                                 |
| <span data-ttu-id="e4fbc-134">並行根目錄會開啟 (開啟相同檔案) ：</span><span class="sxs-lookup"><span data-stu-id="e4fbc-134">Concurrent root opens (opens of the same file):</span></span> | <span data-ttu-id="e4fbc-135">如果 \_ 指定 STGM READ 和 STGM \_ SHARE \_ DENY \_ WRITE，則限制是由檔案系統限制所決定。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-135">If STGM\_READ and STGM\_SHARE\_DENY\_WRITE are specified, limits are dictated by the file-system limits.</span></span> <span data-ttu-id="e4fbc-136">否則，相同檔案的限制為20個並行的根目錄開啟。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-136">Otherwise, there is a limit of 20 concurrent root opens of the same file.</span></span> |
| <span data-ttu-id="e4fbc-137">檔案中的元素數目：</span><span class="sxs-lookup"><span data-stu-id="e4fbc-137">Number of elements in a file:</span></span>                   | <span data-ttu-id="e4fbc-138">512：無限制，但如果上千4096：無限制的元素數，效能可能會降低</span><span class="sxs-lookup"><span data-stu-id="e4fbc-138">512: Unlimited, but performance may degrade if elements number in the thousands 4096: Unlimited</span></span><br/>                                                                         |



 

<span data-ttu-id="e4fbc-139">由於 4 MB 堆積大小的限制，交易模式中開啟的元素數目通常僅限於數千個元素。</span><span class="sxs-lookup"><span data-stu-id="e4fbc-139">Due to the 4-MB heap-size limit, the number of open elements in transacted mode is typically limited to several thousand elements.</span></span>

 

