---
title: 獨立和複合檔案執行之間的差異
description: 屬性集介面和複合檔案執行的獨立實作為某些方式不同。
ms.assetid: 650d4759-a58a-47a4-922d-5757e356cf56
keywords:
- IPropertyStorage Strctd Stg.，實施
- IPropertyStorage Strctd Stg.，實施，差異
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 988f8a9cfdaca0a131bedf98cd8ff10ae8b89525
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "103839831"
---
# <a name="differences-between-stand-alone-and-compound-file-implementations"></a><span data-ttu-id="5779f-105">獨立和複合檔案執行之間的差異</span><span class="sxs-lookup"><span data-stu-id="5779f-105">Differences between Stand-alone and Compound File Implementations</span></span>

<span data-ttu-id="5779f-106">屬性集介面和複合檔案執行的獨立實作為某些方式不同。</span><span class="sxs-lookup"><span data-stu-id="5779f-106">The stand-alone implementation of the property set interfaces and the compound file implementation differ in some ways.</span></span> <span data-ttu-id="5779f-107">在資料流程、儲存體、屬性集儲存區和屬性儲存物件的複合檔案中，不同的介面會彼此協調，因為它們共用一般的實值。</span><span class="sxs-lookup"><span data-stu-id="5779f-107">In the compound-file implementation of stream, storage, property set storage, and property storage objects, the various interfaces coordinate with each another because they share a common implementation.</span></span> <span data-ttu-id="5779f-108">在獨立的執行中，介面實現是相異的。</span><span class="sxs-lookup"><span data-stu-id="5779f-108">In the stand-alone implementation, the interface implementations are distinct.</span></span>

<span data-ttu-id="5779f-109">因此，複合檔案執行會處理並行問題，並將屬性集物件與儲存體或資料流程物件同步處理。</span><span class="sxs-lookup"><span data-stu-id="5779f-109">As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object.</span></span> <span data-ttu-id="5779f-110">使用獨立執行時，用戶端會負責處理儲存體或資料流程物件與屬性集之間的平行存取和同步處理問題。</span><span class="sxs-lookup"><span data-stu-id="5779f-110">With the stand-alone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set.</span></span> <span data-ttu-id="5779f-111">用戶端可以遵循兩個簡單的規則來滿足這些需求。</span><span class="sxs-lookup"><span data-stu-id="5779f-111">A client can meet these requirements by following two simple rules.</span></span> <span data-ttu-id="5779f-112">首先，絕對不要在屬性儲存物件開啟時，使用其資料流程或儲存介面來操作屬性集。</span><span class="sxs-lookup"><span data-stu-id="5779f-112">First, never manipulate a property set using its stream or storage interfaces while a property storage object is open on it.</span></span> <span data-ttu-id="5779f-113">其次，在上階儲存物件上呼叫 **CopyTo**、 **MoveElementTo** 或 **commit** 之前，一律在屬性儲存物件上呼叫 **commit** 。</span><span class="sxs-lookup"><span data-stu-id="5779f-113">Second, always call **Commit** on a property storage object before calling **CopyTo**, **MoveElementTo**, or **Commit** on an ancestor storage object.</span></span> <span data-ttu-id="5779f-114">具體而言，下列專案需要用戶端注意：</span><span class="sxs-lookup"><span data-stu-id="5779f-114">Specifically, the following items require client attention:</span></span>

-   <span data-ttu-id="5779f-115">在複合檔案的執行中，單一機制會針對儲存物件和其相關聯的屬性集物件提供並行保護。</span><span class="sxs-lookup"><span data-stu-id="5779f-115">In the compound-file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects.</span></span> <span data-ttu-id="5779f-116">不過，在獨立的執行中，儲存體物件的執行與屬性集的執行是分開的，而且每個都提供自己的並行機制。</span><span class="sxs-lookup"><span data-stu-id="5779f-116">However, in the stand-alone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms.</span></span> <span data-ttu-id="5779f-117">因此，在獨立的執行中，用戶端會負責透過相互排除的機制來維護兩個執行之間的並行保護。</span><span class="sxs-lookup"><span data-stu-id="5779f-117">Thus, in the stand-alone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mechanism of mutual exclusion.</span></span>
-   <span data-ttu-id="5779f-118">在複合檔案執行中，屬性集的變更會在屬性集快取中進行緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="5779f-118">In the compound file implementation, changes to property sets are buffered in a property-set cache.</span></span> <span data-ttu-id="5779f-119">然後，在儲存物件上呼叫 [**IStorage：： Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) 方法時，複合檔案執行會在認可儲存物件之前，自動從屬性集緩衝區清除屬性集變更。</span><span class="sxs-lookup"><span data-stu-id="5779f-119">Then, when the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method is called on the storage object, the compound files implementation automatically flushes the property-set changes from the property-set buffer before the storage object is committed.</span></span> <span data-ttu-id="5779f-120">因此，屬性集的變更會在認可的交易中變成可見。</span><span class="sxs-lookup"><span data-stu-id="5779f-120">Thus, the property-set changes are made visible as part of the transaction being committed.</span></span>

    <span data-ttu-id="5779f-121">在獨立的執行中，用戶端必須在呼叫 IPropertyStorage：： commit 方法之前，先呼叫 [**：： commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) 來明確地排清屬性集緩衝區，然後再呼叫儲存體上的 [**IStorage：： commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) 方法。</span><span class="sxs-lookup"><span data-stu-id="5779f-121">In the stand-alone implementation, the client must explicitly flush the property-set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method on the storage.</span></span> <span data-ttu-id="5779f-122">或者，用戶端可以在獨立的執行中使用新的 PROPSETFLAG \_ 無緩衝值，直接寫入屬性集，而不是快取屬性集內部緩衝區的變更。</span><span class="sxs-lookup"><span data-stu-id="5779f-122">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value in the stand-alone implementation to write directly to the property set instead of caching changes to the property set's internal buffer.</span></span> <span data-ttu-id="5779f-123">如果使用 PROPSETFLAG 無 \_ 緩衝，則會自動符合用戶端的責任。</span><span class="sxs-lookup"><span data-stu-id="5779f-123">If PROPSETFLAG\_UNBUFFERED is used, the client's responsibilities are automatically met.</span></span> <span data-ttu-id="5779f-124">複合檔案執行不支援 PROPSETFLAG 未緩衝的 \_ 值。</span><span class="sxs-lookup"><span data-stu-id="5779f-124">The compound file implementation does not support the PROPSETFLAG\_UNBUFFERED value.</span></span> <span data-ttu-id="5779f-125">如需詳細資訊，請參閱 [**PROPSETFLAG 常數**](propsetflag-constants.md)。</span><span class="sxs-lookup"><span data-stu-id="5779f-125">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

-   <span data-ttu-id="5779f-126">如同交易式儲存體，複合檔案執行會在執行 [**IStorage：： CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) 或 [**IStorage：： MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto)的呼叫之前，先清除其內部緩衝區來更新屬性集。</span><span class="sxs-lookup"><span data-stu-id="5779f-126">As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer before executing a call to [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="5779f-127">因此，屬性集的變更會反映在複製或移動的儲存元素中。</span><span class="sxs-lookup"><span data-stu-id="5779f-127">Thus, changes to the property set are reflected in the copied or moved storage element.</span></span>

    <span data-ttu-id="5779f-128">在獨立的執行中，用戶端必須在呼叫 [**IStorage：： CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto)或 [**IStorage：： MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto)之前呼叫 [**IPropertyStorage：： Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) ，以明確地清除屬性集緩衝區。</span><span class="sxs-lookup"><span data-stu-id="5779f-128">In the stand-alone implementation, the client must explicitly flush the property set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="5779f-129">或者，用戶端可以使用新的 PROPSETFLAG \_ 無緩衝值直接寫入屬性集，而不是快取屬性集緩衝區的變更。</span><span class="sxs-lookup"><span data-stu-id="5779f-129">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value to write directly to the property set instead of caching changes to the property set buffer.</span></span> <span data-ttu-id="5779f-130">如需詳細資訊，請參閱 [**PROPSETFLAG 常數**](propsetflag-constants.md)。</span><span class="sxs-lookup"><span data-stu-id="5779f-130">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

 

 




