---
title: 檔案系統的演進
description: 在開發電腦以在磁片作業系統上運作之前，每一部電腦都是為了執行單一專屬的應用程式，而該應用程式擁有整個電腦的完整且專屬的控制權。
ms.assetid: 46d497b5-c325-4395-8512-1ed4b88441de
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7dc34dc699488b5952d52dfd13f49ea63aaa85aa
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "106967818"
---
# <a name="the-evolution-of-file-systems"></a><span data-ttu-id="e61c5-103">檔案系統的演進</span><span class="sxs-lookup"><span data-stu-id="e61c5-103">The Evolution of File Systems</span></span>

<span data-ttu-id="e61c5-104">在開發電腦以在磁片作業系統上運作之前，每一部電腦都是為了執行單一專屬的應用程式，而該應用程式擁有整個電腦的完整且專屬的控制權。</span><span class="sxs-lookup"><span data-stu-id="e61c5-104">Before computers were developed to function on disk operating systems, each computer was built to run a single, proprietary application, which had complete and exclusive control of the entire machine.</span></span> <span data-ttu-id="e61c5-105">應用程式會直接將命令傳送至磁碟控制卡，以將其持續性資料直接寫入磁片或鼓。</span><span class="sxs-lookup"><span data-stu-id="e61c5-105">The application would write its persistent data directly to a disk, or drum, by sending commands directly to the disk controller.</span></span> <span data-ttu-id="e61c5-106">應用程式負責管理磁片上資料的絕對位置，以確保它不會覆寫現有的資料。</span><span class="sxs-lookup"><span data-stu-id="e61c5-106">The application was responsible for managing the absolute locations of data on the disk, making sure that it was not overwriting already-existing data.</span></span> <span data-ttu-id="e61c5-107">因為每次只有一個應用程式在電腦上執行，所以這項工作不太困難。</span><span class="sxs-lookup"><span data-stu-id="e61c5-107">Since only one application was running on the computer at any time, this task was not too difficult.</span></span>

<span data-ttu-id="e61c5-108">可能執行一個以上應用程式的電腦系統出現，需要一種機制，以確保應用程式不會寫入彼此的資料。</span><span class="sxs-lookup"><span data-stu-id="e61c5-108">The advent of computer systems that could run more than one application required a mechanism to ensure that applications did not write over each other's data.</span></span> <span data-ttu-id="e61c5-109">應用程式開發人員解決此問題的方法是，採用單一標準來區分使用的磁片區，而不是藉由適當地標示它們。</span><span class="sxs-lookup"><span data-stu-id="e61c5-109">Application developers addressed this problem by adopting a single standard for distinguishing disk sectors in use from those that were free by marking them accordingly.</span></span> <span data-ttu-id="e61c5-110">在這段時間內，這些標準會合並成為磁片作業系統，以提供應用程式的各種服務，包括用來管理持續性儲存的檔案系統。</span><span class="sxs-lookup"><span data-stu-id="e61c5-110">In time, these standards coalesced to become a disk operating system, which provided various services to the applications, including a file system for managing persistent storage.</span></span> <span data-ttu-id="e61c5-111">隨著檔案系統的出現，應用程式就不再需要直接處理實體儲存媒體。</span><span class="sxs-lookup"><span data-stu-id="e61c5-111">With the advent of a file system, applications no longer had to deal directly with the physical storage medium.</span></span> <span data-ttu-id="e61c5-112">相反地，它們只是告訴檔案系統將資料區塊寫入磁片，並讓檔案系統擔心如何進行。</span><span class="sxs-lookup"><span data-stu-id="e61c5-112">Instead, they simply told the file system to write blocks of data to the disk and let the file system worry about how to do it.</span></span> <span data-ttu-id="e61c5-113">此外，檔案系統還允許應用程式透過稱為目錄的抽象概念來建立資料階層。</span><span class="sxs-lookup"><span data-stu-id="e61c5-113">In addition, the file system allowed applications to create data hierarchies through an abstraction known as a directory.</span></span> <span data-ttu-id="e61c5-114">目錄可能不只包含檔案，也可以包含其他目錄，而這些目錄也可以包含自己的檔案和目錄等等。</span><span class="sxs-lookup"><span data-stu-id="e61c5-114">A directory could contain not only files but other directories, which in turn could contain their own files and directories, and so on.</span></span>

<span data-ttu-id="e61c5-115">檔案系統在應用程式與磁片之間提供了單一的間接取值層級，因此每個應用程式都會將檔案視為磁片上的單一連續位元組資料流程，即使檔案系統實際上將檔案儲存在不連續的磁區中也是一樣。</span><span class="sxs-lookup"><span data-stu-id="e61c5-115">The file system provided a single level of indirection between applications and the disk, and the result was that every application saw a file as a single contiguous stream of bytes on the disk even though the file system was actually storing the file in discontiguous sectors.</span></span> <span data-ttu-id="e61c5-116">間接取值會釋出應用程式，使其不需要追蹤儲存裝置上資料的絕對位置。</span><span class="sxs-lookup"><span data-stu-id="e61c5-116">The indirection freed the applications from having to track the absolute position of data on a storage device.</span></span>

<span data-ttu-id="e61c5-117">目前，所有的檔案輸入和輸出系統 Api 都提供將資訊寫入一般檔案的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e61c5-117">Today, virtually all system APIs for file input and output provide applications for writing information into a flat file.</span></span> <span data-ttu-id="e61c5-118">應用程式會以單一位元組資料流程的形式來查看這個檔案，直到磁片已滿時，才會視需要成長。</span><span class="sxs-lookup"><span data-stu-id="e61c5-118">Applications see this file as a single stream of bytes that can grow as large as necessary until the disk is full.</span></span> <span data-ttu-id="e61c5-119">經過一段時間後，這些 Api 就足以讓應用程式儲存其持續性資訊。</span><span class="sxs-lookup"><span data-stu-id="e61c5-119">For a long time these APIs have been sufficient for applications to store their persistent information.</span></span> <span data-ttu-id="e61c5-120">應用程式對處理單一資料流程的方式進行了大幅的創新，以提供增量「快速」儲存等功能。</span><span class="sxs-lookup"><span data-stu-id="e61c5-120">Applications have made significant innovations in how they deal with a single stream of information to provide features like incremental "fast" saves.</span></span>

<span data-ttu-id="e61c5-121">不過，在元件物件的世界中，將資料儲存在單一一般檔案中已不再有效。</span><span class="sxs-lookup"><span data-stu-id="e61c5-121">However, in a world of component objects, storing data in a single flat file is no longer efficient.</span></span> <span data-ttu-id="e61c5-122">就像檔案系統不需要讓多個應用程式共用相同的儲存媒體一樣，現在元件物件需要一個系統，讓它們能夠在單一檔案的概念架構內共用儲存區。</span><span class="sxs-lookup"><span data-stu-id="e61c5-122">Just as file systems arose out of the need for multiple applications to share the same storage medium, so, now, do component objects require a system that allows them to share storage within the conceptual framework of a single file.</span></span> <span data-ttu-id="e61c5-123">雖然您可以使用傳統的一般檔案儲存體來儲存個別的物件，但如果其中一個物件的大小增加，或您只是要加入另一個物件，則必須將整個檔案載入記憶體中，然後插入新的物件，再儲存整個檔案。</span><span class="sxs-lookup"><span data-stu-id="e61c5-123">Even though it is possible to store the separate objects using conventional flat-file storage, if one of the objects increases in size, or if you simply add another object, it becomes necessary to load the entire file into memory, insert the new object, and then save the whole file.</span></span> <span data-ttu-id="e61c5-124">此程式可能相當耗時。</span><span class="sxs-lookup"><span data-stu-id="e61c5-124">This process can be extremely time-consuming.</span></span>

<span data-ttu-id="e61c5-125">COM 提供的解決方案是執行第二層間接取值：檔案內的檔案系統。</span><span class="sxs-lookup"><span data-stu-id="e61c5-125">The solution provided by COM is to implement a second level of indirection: a file system within a file.</span></span> <span data-ttu-id="e61c5-126">一般檔案儲存體要求磁片上的大型連續位元組序列必須透過單一搜尋指標的單一檔案控制代碼來操作。</span><span class="sxs-lookup"><span data-stu-id="e61c5-126">Flat-file storage requires that a large contiguous sequence of bytes on the disk be manipulated through a single file handle with a single seek pointer.</span></span> <span data-ttu-id="e61c5-127">相較之下，COM 結構化儲存體定義了如何將單一檔案系統實體視為兩種物件類型的結構化集合（儲存體和資料流程），其作用就像是目錄和檔案。</span><span class="sxs-lookup"><span data-stu-id="e61c5-127">By contrast, COM structured storage defines how to treat a single file system entity as a structured collection of two types of objects — storages and streams — that act like directories and files.</span></span>

 

 




