---
title: IPaperSink 方法
description: COPaper 會公開 IConnectionPointContainer 介面，讓用戶端可以連線到 COPaper，以便接收 COPaper 中所發生之指定事件的通知。
ms.assetid: 2466c721-b275-4dbc-a604-2d5e6a29d6a1
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: ac8dee615b278c5214ad1efa3c10d22759620103
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104186056"
---
# <a name="ipapersink-methods"></a><span data-ttu-id="86e18-103">IPaperSink 方法</span><span class="sxs-lookup"><span data-stu-id="86e18-103">IPaperSink Methods</span></span>

<span data-ttu-id="86e18-104">COPaper 會公開 [**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer) 介面，讓用戶端可以連線到 COPaper，以便接收 COPaper 中所發生之指定事件的通知。</span><span class="sxs-lookup"><span data-stu-id="86e18-104">COPaper exposes the [**IConnectionPointContainer**](/windows/win32/api/ocidl/nn-ocidl-iconnectionpointcontainer) interface so clients can connect to COPaper in order to receive notifications of specified events that occur in COPaper.</span></span> <span data-ttu-id="86e18-105">藉由公開這個介面，COPaper 會變成可連接的物件。</span><span class="sxs-lookup"><span data-stu-id="86e18-105">By exposing this interface, COPaper becomes a connectable object.</span></span> <span data-ttu-id="86e18-106">用戶端可以呼叫這個介面的 [**QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) ，並用它來取得物件的連接點。</span><span class="sxs-lookup"><span data-stu-id="86e18-106">A client can call [**QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) for this interface and use it to obtain the object's connection points.</span></span> <span data-ttu-id="86e18-107">相關聯的 **StoClien** 範例涵蓋了此配置的用戶端參與。</span><span class="sxs-lookup"><span data-stu-id="86e18-107">The client participation in this scheme is covered in the associated **StoClien** sample.</span></span>

<span data-ttu-id="86e18-108">基本上，用戶端會使用接收介面，以接收物件的形式來實作為接收器。</span><span class="sxs-lookup"><span data-stu-id="86e18-108">Basically, the client implements what is called a sink in the form of a sink object with a sink interface.</span></span> <span data-ttu-id="86e18-109">當用戶端將接收端正確連接到 COPaper 實例之後，接收介面會接收來自 COPaper 的傳出事件通知呼叫。</span><span class="sxs-lookup"><span data-stu-id="86e18-109">The sink interface receives outgoing event notification calls from COPaper after the sink is properly connected by the client to a COPaper instance.</span></span> <span data-ttu-id="86e18-110">用戶端會使用由 COPaper 管理的連接點物件來進行連接。</span><span class="sxs-lookup"><span data-stu-id="86e18-110">The client makes the connection by using a connection point object that is managed by COPaper.</span></span> <span data-ttu-id="86e18-111">單一可連接的 COM 物件上可以有多個連接點。</span><span class="sxs-lookup"><span data-stu-id="86e18-111">There can be numerous connection points on a single connectable COM object.</span></span> <span data-ttu-id="86e18-112">在 **StoServe** 範例中，COPaper 只有一個連接點，它會處理繪圖的紙事件。</span><span class="sxs-lookup"><span data-stu-id="86e18-112">In the **StoServe** sample, COPaper has only one connection point, which handles drawing paper events.</span></span>

<span data-ttu-id="86e18-113">任何數目的用戶端都可以連接到單一連接點。</span><span class="sxs-lookup"><span data-stu-id="86e18-113">Any number of clients can connect to a single connection point.</span></span> <span data-ttu-id="86e18-114">\_COPaper 中的 CONNPOINT PAPERSINK 連接點會維護一組可在執行時間動態成長的連接。</span><span class="sxs-lookup"><span data-stu-id="86e18-114">The CONNPOINT\_PAPERSINK connection point in COPaper maintains a group of connections that can grow dynamically at run time.</span></span> <span data-ttu-id="86e18-115">COPaper 可連線物件支援的完整詳細資料，是以檔案連接來撰寫。H 和 CONNECT。並不會在此討論。</span><span class="sxs-lookup"><span data-stu-id="86e18-115">The full details on COPaper's connectable object support is coded in files CONNECT.H and CONNECT.CPP and will not be covered here.</span></span> <span data-ttu-id="86e18-116">此結構非常類似于保存程式碼範例中的研究。</span><span class="sxs-lookup"><span data-stu-id="86e18-116">The construction is very similar to what was studied in the CONSERVE code sample.</span></span>

<span data-ttu-id="86e18-117">**StoClien** 用戶端會針對預期在 COPaper 中找到的連接點，執行適當的接收物件。</span><span class="sxs-lookup"><span data-stu-id="86e18-117">The **StoClien** client implements appropriate sink objects for the connection points it expects to find in COPaper.</span></span> <span data-ttu-id="86e18-118">從 COPaper 的內容中， **StoClien** 所實行的重要接收物件會公開 **IPaperSink** 介面。</span><span class="sxs-lookup"><span data-stu-id="86e18-118">From the context of COPaper, the important sink object that **StoClien** implements exposes the **IPaperSink** interface.</span></span> <span data-ttu-id="86e18-119">這是 COPaper 用來通知 **StoClien** COPaper 中各種事件的連出介面。</span><span class="sxs-lookup"><span data-stu-id="86e18-119">This is the outgoing interface used by COPaper to notify **StoClien** of various events in COPaper.</span></span>

<span data-ttu-id="86e18-120">以下是從 IPAPER **IPaperSink** 的方法摘要。H \\ ： inc. 的同級目錄。</span><span class="sxs-lookup"><span data-stu-id="86e18-120">Here is a summary of the methods in **IPaperSink** from IPAPER.H in the \\INC sibling directory.</span></span>



| <span data-ttu-id="86e18-121">方法</span><span class="sxs-lookup"><span data-stu-id="86e18-121">Method</span></span>   | <span data-ttu-id="86e18-122">描述</span><span class="sxs-lookup"><span data-stu-id="86e18-122">Description</span></span>                                                   |
|----------|---------------------------------------------------------------|
| <span data-ttu-id="86e18-123">已鎖定</span><span class="sxs-lookup"><span data-stu-id="86e18-123">Locked</span></span>   | <span data-ttu-id="86e18-124">用戶端已取得和鎖定紙張的控制權。</span><span class="sxs-lookup"><span data-stu-id="86e18-124">A client has taken control of and locked the paper.</span></span>           |
| <span data-ttu-id="86e18-125">已解除鎖定</span><span class="sxs-lookup"><span data-stu-id="86e18-125">Unlocked</span></span> | <span data-ttu-id="86e18-126">用戶端具有紙張的 relinquished 控制。</span><span class="sxs-lookup"><span data-stu-id="86e18-126">A client has relinquished control of the paper.</span></span>               |
| <span data-ttu-id="86e18-127">已載入</span><span class="sxs-lookup"><span data-stu-id="86e18-127">Loaded</span></span>   | <span data-ttu-id="86e18-128">用戶端已從自己的複合檔案載入紙張內容。</span><span class="sxs-lookup"><span data-stu-id="86e18-128">A client has loaded paper content from its own compound file.</span></span> |
| <span data-ttu-id="86e18-129">已儲存</span><span class="sxs-lookup"><span data-stu-id="86e18-129">Saved</span></span>    | <span data-ttu-id="86e18-130">用戶端已將書面內容儲存至它自己的複合檔案。</span><span class="sxs-lookup"><span data-stu-id="86e18-130">A client has saved paper content to its own compound file.</span></span>    |
| <span data-ttu-id="86e18-131">InkStart</span><span class="sxs-lookup"><span data-stu-id="86e18-131">InkStart</span></span> | <span data-ttu-id="86e18-132">用戶端已啟動紙張的色彩筆墨繪圖順序。</span><span class="sxs-lookup"><span data-stu-id="86e18-132">A client started a color ink drawing sequence to the paper.</span></span>   |
| <span data-ttu-id="86e18-133">InkDraw</span><span class="sxs-lookup"><span data-stu-id="86e18-133">InkDraw</span></span>  | <span data-ttu-id="86e18-134">用戶端會將筆墨資料點放在紙張表面上。</span><span class="sxs-lookup"><span data-stu-id="86e18-134">A client is putting ink data points on the paper surface.</span></span>     |
| <span data-ttu-id="86e18-135">InkStop</span><span class="sxs-lookup"><span data-stu-id="86e18-135">InkStop</span></span>  | <span data-ttu-id="86e18-136">用戶端已停止紙張的筆墨繪圖順序。</span><span class="sxs-lookup"><span data-stu-id="86e18-136">A client has stopped its ink drawing sequence to the paper.</span></span>   |
| <span data-ttu-id="86e18-137">刪除</span><span class="sxs-lookup"><span data-stu-id="86e18-137">Erased</span></span>   | <span data-ttu-id="86e18-138">用戶端已從紙張中清除所有筆墨資料。</span><span class="sxs-lookup"><span data-stu-id="86e18-138">A client has erased all ink data from the paper.</span></span>              |
| <span data-ttu-id="86e18-139">調整</span><span class="sxs-lookup"><span data-stu-id="86e18-139">Resized</span></span>  | <span data-ttu-id="86e18-140">用戶端已調整紙張大小。</span><span class="sxs-lookup"><span data-stu-id="86e18-140">A client has resized the paper.</span></span>                               |



 

<span data-ttu-id="86e18-141">這些方法大多容易理解。</span><span class="sxs-lookup"><span data-stu-id="86e18-141">These methods are largely self-explanatory.</span></span> <span data-ttu-id="86e18-142">雖然接收必須以某種方式執行所有這些方法，但是許多會實作為存根，而且不會用於 **StoServe** / **StoClien** 範例中。</span><span class="sxs-lookup"><span data-stu-id="86e18-142">Although the sink must implement all these methods in some fashion, many are implemented as stubs and are not used in the **StoServe**/**StoClien** samples.</span></span>

<span data-ttu-id="86e18-143">這些範例中使用的重要方法是已載入的方法。</span><span class="sxs-lookup"><span data-stu-id="86e18-143">An important method used in these samples is the Loaded method.</span></span> <span data-ttu-id="86e18-144">當用戶端告知 COPaper 從檔案載入新的繪圖時，它需要一種方法，在載入新資料時通知用戶端。</span><span class="sxs-lookup"><span data-stu-id="86e18-144">When COPaper is told by the client to load a new drawing from file, it needs a way to notify the client when the new data is loaded.</span></span> <span data-ttu-id="86e18-145">若要這樣做，COPaper 會呼叫 **IPaperSink：：** 在用戶端接收上載入。</span><span class="sxs-lookup"><span data-stu-id="86e18-145">To do this, COPaper Calls **IPaperSink::Loaded** on the client sink.</span></span> <span data-ttu-id="86e18-146">然後，用戶端可以呼叫 [**IPaper：：重繪**](ipaper--redraw.md) ，要求 COPaper 播放新資料給用戶端。</span><span class="sxs-lookup"><span data-stu-id="86e18-146">The client can then call [**IPaper::Redraw**](ipaper--redraw.md) to request that COPaper play back the new data to the client.</span></span> <span data-ttu-id="86e18-147">重新繪製會導致在用戶端的顯示器中重新繪製載入的繪圖。</span><span class="sxs-lookup"><span data-stu-id="86e18-147">Redraw causes the loaded drawing in the client's display to be repainted.</span></span> <span data-ttu-id="86e18-148">當載入完成時，新載入的繪圖會自動顯示在用戶端提供的視窗中。</span><span class="sxs-lookup"><span data-stu-id="86e18-148">When the load is completed, the newly loaded drawing is displayed automatically in the window provided by the client.</span></span>

<span data-ttu-id="86e18-149">如需此 IPaper 方法與 **IPaperSink** 連線的完整資訊，請參閱 [**IPaper：：重繪**](ipaper--redraw.md)。</span><span class="sxs-lookup"><span data-stu-id="86e18-149">See [**IPaper::Redraw**](ipaper--redraw.md) for complete information of this IPaper method's connectivity to **IPaperSink**.</span></span>

<span data-ttu-id="86e18-150">**InkStart**、 **InkDraw** 和 **InkStop** 的 **IPaperSink** 方法可用來將個別的筆墨資料封包傳送回用戶端。</span><span class="sxs-lookup"><span data-stu-id="86e18-150">The **IPaperSink** methods **InkStart**, **InkDraw**, and **InkStop** are used to send individual ink data packets back to the client.</span></span> <span data-ttu-id="86e18-151">在接收時，用戶端會在其顯示中繪製它們，就像最初將它們傳送至 COPaper 的方式一樣。</span><span class="sxs-lookup"><span data-stu-id="86e18-151">On reception, the client paints them in its display in the same manner as when it originally sent them to COPaper.</span></span> <span data-ttu-id="86e18-152">上述邏輯的一般功能足以讓多個用戶端全都接聽相同的 CONNPOINT \_ PAPERSINK 連接點。</span><span class="sxs-lookup"><span data-stu-id="86e18-152">The above logic is general enough to allow for multiple clients that are all listening on the same CONNPOINT\_PAPERSINK connection point.</span></span> <span data-ttu-id="86e18-153">如果這些用戶端共用了一般 COPaper 實例，則這些用戶端可能會藉由連接到此連接點來顯示相同的繪圖。</span><span class="sxs-lookup"><span data-stu-id="86e18-153">If a common COPaper instance was shared by these clients, they could all display the same drawing by connecting to this connection point.</span></span>

 

 