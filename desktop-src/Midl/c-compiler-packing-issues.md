---
title: C-編譯器封裝問題
description: 封裝層級會以相同方式影響 MIDL 和 Microsoft C/c + + 編譯器之類型的記憶體配置。
ms.assetid: 029e2f68-e68f-4627-bdf0-889939d7d3c6
keywords:
- MIDL 編譯器 MIDL，C-編譯器封裝問題
- 封裝 MIDL
- 記憶體配置 MIDL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5d355214c7f3222d67fd7673de4f9d32d19b4c885e8f97143c80df7b98bc0e38
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "117807891"
---
# <a name="c-compiler-packing-issues"></a>C-編譯器封裝問題

封裝層級會以相同方式影響 MIDL 和 Microsoft C/c + + 編譯器之類型的記憶體配置。 在 Microsoft 組建環境中（例如 VC++ 所定義的組建環境或平臺軟體發展工具組 (SDK) ），MIDL 和 c/c + + 編譯器的預設封裝層級是相同的;32位和64位 Windows 組建環境的預設封裝層級為8。

## <a name="natural-alignment"></a>自然對齊

對於記憶體中的型別，預設對齊方式與其自然對齊方式相同。

-   基底型別（例如 short、float 和 \_ \_ int64）和指標在其標記法開始于其大小的模數位址時自然對齊。 所有目前支援的基底類型都有1、2、4或8的大小。 在32位環境中，指標的大小為4，64位的環境中則為8。
-   如果它的每個元件都是以自然方式相對於型別開頭，且沒有任何不必要的間距 (填補在元件之間) ，則會自然對齊複合類型。 複合元件（例如欄位或元素）會遞迴至指標或基底類型元件。

有一個簡單的規則，可協助您記住這項行為，也就是類型的自然對齊方式等於其元件的最大對齊。

在 C 或 c + + 和 IDL 等語言中，類型的對齊和記憶體大小之間有連接，如運算子 **sizeof ()** 所表示。 大小是對齊的倍數 (最小倍數橫跨類型) 。 這會在記憶體中的陣列標記法之後進行。

自然對齊很重要，因為存取未對齊的資料可能會在某些系統上造成例外狀況。 當資料不一致時，可以將資料標示為安全的操作，但這通常牽涉到某些平臺上可能會有巨大的速度。

> [!Note]  
> 在記憶體中，當放置在 *n* 的倍數的位址時，具有自然對齊 *n* 的類型物件一定會適當地對齊。

 

## <a name="packing-versus-alignment"></a>封裝與對齊

指定大於自然對齊類型的封裝層級並不會變更類型對齊。 指定小於自然對齊的封裝層級，會將類型對齊減少為封裝層級。 如此一來，封裝的型別可能會放在記憶體中的位址，這些位址是封裝層級的倍數 (減少對齊) 而不會造成不一致的情況。 這會影響簡單類型和元件類型。 針對複合類型，類型的內部配置可能會受到影響，因為較小的元件對齊可能會變更適當對齊元件所需的填補大小，進而減少類型的大小。

有一個簡單的規則，可協助您記住這項行為，也就是封裝類型的新對齊方式是封裝層級和其自然對齊的較小者。 此類型的大小為新對齊的倍數。 **Sizeof ()** 運算子會傳回壓縮類型的縮減大小。

例如，在封裝層級2中，長時間會變成2，因此可能會放在任何偶數的位址，而不只是在具有自然對齊的情況下的4個位址。 具有簡短和長（封裝于2）的結構，不需要自然對齊所需的短時間與下列長度之間的內部間距;因此，不只是現在的結構在2，它的大小也會從8降到6。

例如，假設有一個包含1位元組字元的複合類型、一個整數的4個位元組，以及一個1位元組字元：

``` syntax
struct mystructtype 
{    
    char c1;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
    long l2;  /* requires 4 bytes */
    char c3;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
 } mystruct;
```

此結構自然對齊4，且自然大小為12。

針對封裝層級4或更高版本，結構 **mystruct>)** 會對齊4，且 `sizeof(struct mystructtype)` 等於12。 如果位於記憶體中的位址不是4的倍數，則結構將會對齊。

針對封裝層級2，結構會對齊2，而其大小為8。 如果在記憶體中的位址不是2的倍數，則以層級2封裝的結構將會對齊。

針對封裝層級1，結構會對齊1，且其大小為6。 以層級1壓縮的結構可以放置在任何位置，而不會造成錯誤。

## <a name="related-topics"></a>相關主題

<dl> <dt>


</dt> <dt>

[/Zp](./-zp.md)
</dt> <dt>

[/pack](./-pack.md)
</dt> </dl>

 

 