---
description: 有許多應用程式會建立執行緒，以在睡眠狀態下花費大量時間等待事件發生。
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: 執行緒共用
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103849256"
---
# <a name="thread-pooling"></a><span data-ttu-id="e40f5-103">執行緒共用</span><span class="sxs-lookup"><span data-stu-id="e40f5-103">Thread Pooling</span></span>

<span data-ttu-id="e40f5-104">有許多應用程式會建立執行緒，以在睡眠狀態下花費大量時間等待事件發生。</span><span class="sxs-lookup"><span data-stu-id="e40f5-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="e40f5-105">其他執行緒可能只會進入睡眠狀態，才能定期進行喚醒以輪詢變更或更新狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="e40f5-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="e40f5-106">*執行緒* 共用可讓您的應用程式使用由系統管理的背景工作執行緒集區，讓您更有效率地使用執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="e40f5-107">至少有一個執行緒會監視佇列到執行緒集區的所有等候作業的狀態。</span><span class="sxs-lookup"><span data-stu-id="e40f5-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="e40f5-108">等候作業完成時，執行緒集區中的背景工作執行緒會執行對應的回呼函數。</span><span class="sxs-lookup"><span data-stu-id="e40f5-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="e40f5-109">本主題說明原始執行緒集區 API。</span><span class="sxs-lookup"><span data-stu-id="e40f5-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="e40f5-110">Windows Vista 中引進的執行緒集區 API 更簡單、更可靠、效能更佳，並為開發人員提供更大的彈性。</span><span class="sxs-lookup"><span data-stu-id="e40f5-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="e40f5-111">如需目前線程集區 API 的詳細資訊，請參閱 [執行緒](thread-pools.md)集區。</span><span class="sxs-lookup"><span data-stu-id="e40f5-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="e40f5-112">您也可以將與等待作業無關的工作專案加入執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="e40f5-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="e40f5-113">若要要求執行緒集區中的執行緒工作專案，請呼叫 [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) 函數。</span><span class="sxs-lookup"><span data-stu-id="e40f5-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="e40f5-114">此函式會將參數提供給從執行緒集區選取的執行緒所呼叫的函式。</span><span class="sxs-lookup"><span data-stu-id="e40f5-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="e40f5-115">在工作專案排入佇列之後，沒有任何方法可以取消。</span><span class="sxs-lookup"><span data-stu-id="e40f5-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="e40f5-116">[計時器-佇列計時器](../sync/timer-queues.md) 和 [已註冊的等候作業](../sync/wait-functions.md) 也會使用執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="e40f5-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="e40f5-117">其回呼函式會排入執行緒集區佇列中。</span><span class="sxs-lookup"><span data-stu-id="e40f5-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="e40f5-118">您也可以使用 [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) 函式來張貼非同步 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="e40f5-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="e40f5-119">當 i/o 完成時，回呼會由執行緒集區執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="e40f5-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="e40f5-120">當您第一次呼叫 [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) 或 [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback)，或當計時器佇列計時器或已註冊的等候作業將回呼函數排入佇列時，就會建立執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="e40f5-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="e40f5-121">根據預設，可以線上程集區中建立的執行緒數目大約是500。</span><span class="sxs-lookup"><span data-stu-id="e40f5-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="e40f5-122">每個執行緒都會使用預設堆疊大小，並以預設優先權執行。</span><span class="sxs-lookup"><span data-stu-id="e40f5-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="e40f5-123">執行緒集區中有兩種類型的背景工作執行緒： i/o 和非 i/o。</span><span class="sxs-lookup"><span data-stu-id="e40f5-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="e40f5-124">*I/o 工作者執行緒* 是以可提供警示等候狀態等候的執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="e40f5-125">工作專案會以非同步程序呼叫的形式排入 i/o 背景工作執行緒， (APC) 。</span><span class="sxs-lookup"><span data-stu-id="e40f5-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="e40f5-126">如果工作專案應該在等待可提供警示狀態的執行緒中執行，您應該將工作專案排入佇列，以將它排入 i/o 工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="e40f5-127">*非 i/o 背景工作執行緒* 等候 i/o 完成埠。</span><span class="sxs-lookup"><span data-stu-id="e40f5-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="e40f5-128">使用非 i/o 背景工作執行緒比使用 i/o 背景工作執行緒更有效率。</span><span class="sxs-lookup"><span data-stu-id="e40f5-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="e40f5-129">因此，您應該盡可能使用非 i/o 背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="e40f5-130">如果有暫止的非同步 i/o 要求，i/o 和非 i/o 背景工作執行緒都會結束。</span><span class="sxs-lookup"><span data-stu-id="e40f5-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="e40f5-131">起始非同步 i/o 完成要求的工作專案可使用這兩種類型的執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="e40f5-132">但是，如果可能需要很長的時間才能完成，請避免將非同步 i/o 完成要求張貼在非 i/o 工作者執行緒中。</span><span class="sxs-lookup"><span data-stu-id="e40f5-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="e40f5-133">若要使用執行緒共用，工作專案及其呼叫的所有函式都必須是執行緒集區安全的。</span><span class="sxs-lookup"><span data-stu-id="e40f5-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="e40f5-134">Safe 函式不會假設執行它的執行緒是專用或持續性的執行緒。</span><span class="sxs-lookup"><span data-stu-id="e40f5-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="e40f5-135">一般而言，您應該避免使用 [執行緒區域儲存區](thread-local-storage.md) ，或是進行需要持續性執行緒的非同步呼叫，例如 [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) 函式。</span><span class="sxs-lookup"><span data-stu-id="e40f5-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="e40f5-136">不過，您可以在專用的執行緒上呼叫這類函式， (由應用程式建立) 或使用 [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) 搭配 wt. EXECUTEINPERSISTENTTHREAD 選項) 來排入持續性背景工作執行緒 (\_ 。</span><span class="sxs-lookup"><span data-stu-id="e40f5-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="e40f5-137">相關主題</span><span class="sxs-lookup"><span data-stu-id="e40f5-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e40f5-138">可提供警示 i/o</span><span class="sxs-lookup"><span data-stu-id="e40f5-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="e40f5-139">非同步程序呼叫</span><span class="sxs-lookup"><span data-stu-id="e40f5-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="e40f5-140">I/o 完成埠</span><span class="sxs-lookup"><span data-stu-id="e40f5-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="e40f5-141">執行緒集區</span><span class="sxs-lookup"><span data-stu-id="e40f5-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
