---
description: 為了避免競爭情況和鎖死，必須將多個執行緒的存取權同步至共用資源。 也需要同步處理，以確保相依的程式碼會以正確的循序執行。
ms.assetid: 74af0502-dae1-438c-8e4b-7663093b3fe3
title: 同步處理多個執行緒的執行
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c6a1b3dd51d666d507771476792e679f7980fab8
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106986931"
---
# <a name="synchronizing-execution-of-multiple-threads"></a><span data-ttu-id="62874-104">同步處理多個執行緒的執行</span><span class="sxs-lookup"><span data-stu-id="62874-104">Synchronizing Execution of Multiple Threads</span></span>

<span data-ttu-id="62874-105">為了避免競爭情況和鎖死，必須將多個執行緒的存取權同步至共用資源。</span><span class="sxs-lookup"><span data-stu-id="62874-105">To avoid race conditions and deadlocks, it is necessary to synchronize access by multiple threads to shared resources.</span></span> <span data-ttu-id="62874-106">也需要同步處理，以確保相依的程式碼會以正確的循序執行。</span><span class="sxs-lookup"><span data-stu-id="62874-106">Synchronization is also necessary to ensure that interdependent code is executed in the proper sequence.</span></span>

<span data-ttu-id="62874-107">有一些物件可以用來同步處理多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="62874-107">There are a number of objects whose handles can be used to synchronize multiple threads.</span></span> <span data-ttu-id="62874-108">這些物件包括：</span><span class="sxs-lookup"><span data-stu-id="62874-108">These objects include:</span></span>

-   <span data-ttu-id="62874-109">主控台輸入緩衝區</span><span class="sxs-lookup"><span data-stu-id="62874-109">Console input buffers</span></span>
-   <span data-ttu-id="62874-110">事件</span><span class="sxs-lookup"><span data-stu-id="62874-110">Events</span></span>
-   <span data-ttu-id="62874-111">Mutex</span><span class="sxs-lookup"><span data-stu-id="62874-111">Mutexes</span></span>
-   <span data-ttu-id="62874-112">處理序</span><span class="sxs-lookup"><span data-stu-id="62874-112">Processes</span></span>
-   <span data-ttu-id="62874-113">信號燈</span><span class="sxs-lookup"><span data-stu-id="62874-113">Semaphores</span></span>
-   <span data-ttu-id="62874-114">執行緒</span><span class="sxs-lookup"><span data-stu-id="62874-114">Threads</span></span>
-   <span data-ttu-id="62874-115">計時器</span><span class="sxs-lookup"><span data-stu-id="62874-115">Timers</span></span>

<span data-ttu-id="62874-116">每個物件的狀態為已發出信號或未收到信號。</span><span class="sxs-lookup"><span data-stu-id="62874-116">The state of each of these objects is either signaled or not signaled.</span></span> <span data-ttu-id="62874-117">當您在其中一個 [等候](../sync/wait-functions.md)函式的呼叫中指定任何這些物件的控制碼時，會封鎖呼叫執行緒的執行，直到指定物件的狀態變成發出信號為止。</span><span class="sxs-lookup"><span data-stu-id="62874-117">When you specify a handle to any of these objects in a call to one of the [wait functions](../sync/wait-functions.md), the execution of the calling thread is blocked until the state of the specified object becomes signaled.</span></span>

<span data-ttu-id="62874-118">在某些事件發生之前，這些物件中的某些物件很適合用來封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="62874-118">Some of these objects are useful in blocking a thread until some event occurs.</span></span> <span data-ttu-id="62874-119">例如，當有未讀取的輸入時（例如擊鍵或按滑鼠按鍵），主控台輸入緩衝區控制碼就會收到信號。</span><span class="sxs-lookup"><span data-stu-id="62874-119">For example, a console input buffer handle is signaled when there is unread input, such as a keystroke or mouse button click.</span></span> <span data-ttu-id="62874-120">進程和執行緒控制碼會在進程或執行緒終止時收到信號。</span><span class="sxs-lookup"><span data-stu-id="62874-120">Process and thread handles are signaled when the process or thread terminates.</span></span> <span data-ttu-id="62874-121">例如，這可以讓進程建立子進程，然後封鎖它自己的執行，直到新的進程終止為止。</span><span class="sxs-lookup"><span data-stu-id="62874-121">This allows a process, for example, to create a child process and then block its own execution until the new process has terminated.</span></span>

<span data-ttu-id="62874-122">其他物件適用于保護共用資源免于同時存取。</span><span class="sxs-lookup"><span data-stu-id="62874-122">Other objects are useful in protecting shared resources from simultaneous access.</span></span> <span data-ttu-id="62874-123">例如，多個執行緒可以有 mutex 物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="62874-123">For example, multiple threads can each have a handle to a mutex object.</span></span> <span data-ttu-id="62874-124">在存取共用資源之前，執行緒必須呼叫其中一個 [等候](../sync/wait-functions.md) 函式，等候 mutex 的狀態被告知。</span><span class="sxs-lookup"><span data-stu-id="62874-124">Before accessing a shared resource, the threads must call one of the [wait functions](../sync/wait-functions.md) to wait for the state of the mutex to be signaled.</span></span> <span data-ttu-id="62874-125">當 mutex 變成信號時，只會釋放一個等候中的執行緒以存取資源。</span><span class="sxs-lookup"><span data-stu-id="62874-125">When the mutex becomes signaled, only one waiting thread is released to access the resource.</span></span> <span data-ttu-id="62874-126">Mutex 的狀態會立即重設為未收到信號，因此任何其他等候中的執行緒都會保持封鎖狀態。</span><span class="sxs-lookup"><span data-stu-id="62874-126">The state of the mutex is immediately reset to not signaled so any other waiting threads remain blocked.</span></span> <span data-ttu-id="62874-127">當執行緒完成資源時，它必須將 mutex 的狀態設定為已收到信號，以允許其他執行緒存取資源。</span><span class="sxs-lookup"><span data-stu-id="62874-127">When the thread is finished with the resource, it must set the state of the mutex to signaled to allow other threads to access the resource.</span></span>

<span data-ttu-id="62874-128">針對單一進程的執行緒，重要區段物件提供比 mutex 更有效率的同步處理方法。</span><span class="sxs-lookup"><span data-stu-id="62874-128">For the threads of a single process, critical-section objects provide a more efficient means of synchronization than mutexes.</span></span> <span data-ttu-id="62874-129">重要區段會像 mutex 一樣用來一次啟用一個執行緒，以使用受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="62874-129">A critical section is used like a mutex to enable one thread at a time to use the protected resource.</span></span> <span data-ttu-id="62874-130">執行緒可以使用 [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) 函數來要求重要區段的擁有權。</span><span class="sxs-lookup"><span data-stu-id="62874-130">A thread can use the [**EnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-entercriticalsection) function to request ownership of a critical section.</span></span> <span data-ttu-id="62874-131">如果它已經由另一個執行緒所擁有，則會封鎖要求的執行緒。</span><span class="sxs-lookup"><span data-stu-id="62874-131">If it is already owned by another thread, the requesting thread is blocked.</span></span> <span data-ttu-id="62874-132">執行緒可以使用 [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) 函數來要求重要區段的擁有權，而不會在無法取得重要區段時封鎖。</span><span class="sxs-lookup"><span data-stu-id="62874-132">A thread can use the [**TryEnterCriticalSection**](/windows/win32/api/synchapi/nf-synchapi-tryentercriticalsection) function to request ownership of a critical section, without blocking upon failure to obtain the critical section.</span></span> <span data-ttu-id="62874-133">在接收到擁有權之後，執行緒就可以自由使用受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="62874-133">After it receives ownership, the thread is free to use the protected resource.</span></span> <span data-ttu-id="62874-134">除非進程的其他執行緒嘗試進入相同的重要區段，否則這些執行緒的執行不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="62874-134">The execution of the other threads of the process is not affected unless they attempt to enter the same critical section.</span></span>

<span data-ttu-id="62874-135">[**WaitForInputIdle**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle)函式會讓執行緒等候，直到指定的進程初始化，並等候使用者輸入，但沒有任何暫止的輸入。</span><span class="sxs-lookup"><span data-stu-id="62874-135">The [**WaitForInputIdle**](/windows/desktop/api/Winuser/nf-winuser-waitforinputidle) function makes a thread wait until a specified process is initialized and waiting for user input with no input pending.</span></span> <span data-ttu-id="62874-136">呼叫 **WaitForInputIdle** 有助於同步處理父系和子進程，因為 [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) 會傳回，而不會等待子進程完成其初始化。</span><span class="sxs-lookup"><span data-stu-id="62874-136">Calling **WaitForInputIdle** can be useful for synchronizing parent and child processes, because [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) returns without waiting for the child process to complete its initialization.</span></span>

<span data-ttu-id="62874-137">如需詳細資訊，請參閱 [同步](../sync/synchronization.md)處理。</span><span class="sxs-lookup"><span data-stu-id="62874-137">For more information, see [Synchronization](../sync/synchronization.md).</span></span>

 

 
