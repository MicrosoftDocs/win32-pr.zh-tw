---
description: 執行緒集區是工作者執行緒的集合，可代表應用程式有效率地執行非同步回呼。
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: 執行緒集區
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d7918a0f6f0b881233ebea8e664d6e743a7bff105e265270063b08af313417e7
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/11/2021
ms.locfileid: "120081258"
---
# <a name="thread-pools"></a>執行緒集區

*執行緒* 集區是工作者執行緒的集合，可代表應用程式有效率地執行非同步回呼。 執行緒集區主要是用來減少應用程式執行緒的數目，並提供工作者執行緒的管理。 應用程式可以將工作專案排入佇列、建立工作與可等候控制碼的關聯、根據計時器自動排入佇列，以及使用 i/o 系結。

## <a name="thread-pool-architecture"></a>執行緒集區架構

下列應用程式可受益于使用執行緒集區：

-   高度平行處理的應用程式，可以非同步分派大量的小型工作專案 (例如分散式索引搜尋或網路 i/o) 。
-   一種應用程式，可建立和終結大量的執行緒，每個執行緒都執行一小段時間。 使用執行緒集區可以降低執行緒管理的複雜度，以及執行緒建立和終結的額外負荷。
-   在背景和平行 (中處理獨立工作專案的應用程式，例如) 中載入多個索引標籤。
-   應用程式必須對核心物件執行獨佔等候，或封鎖物件上的傳入事件。 使用執行緒集區可降低執行緒管理的複雜度，並藉由減少內容切換的數目來提高效能。
-   此應用程式會建立自訂等候者執行緒以等候事件。

原始的執行緒集區已在 Windows Vista 中完全重新架構。 新的執行緒集區已獲得改善，因為它提供單一背景工作執行緒類型 (同時支援 i/o 和非 i/o) 、不使用計時器執行緒、提供單一計時器佇列，並提供專用的持續性執行緒。 它也提供清理群組、更高的效能、個別排程的每個進程的多個集區，以及新的執行緒集區 API。

執行緒集區架構包含下列各項：

-   執行回呼函數的背景工作執行緒
-   等候多個等候控制碼的等候執行緒
-   工作佇列
-   每個進程的預設執行緒集區
-   管理工作者執行緒的背景工作 factory

## <a name="best-practices"></a>最佳做法

新的 [執行緒集區 api](thread-pool-api.md) 提供比 [原始執行緒集區 api](thread-pooling.md)更多的彈性和控制。 不過，有幾個微妙但重要的差異。 在原始 API 中，等候重設為自動;在新的 API 中，每次都必須明確地重設等候。 原始 API 會自動處理模擬，將呼叫進程的安全性內容傳送到執行緒。 使用新的 API，應用程式必須明確設定安全性內容。

以下是使用執行緒集區時的最佳作法：

-   進程的執行緒共用執行緒集區。 單一工作者執行緒可以執行多個回呼函數，一次一個。 這些工作者執行緒是由執行緒集區所管理。 因此，請勿線上程上呼叫 [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) ，或從回呼函式呼叫 [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) ，藉以終止執行緒集區中的執行緒。
-   I/o 要求可以線上程集區中的任何執行緒上執行。 線上程集區執行緒上取消 i/o 需要同步處理，因為 cancel 函式可能會在與處理 i/o 要求的執行緒不同的執行緒上執行，這可能會導致取消未知的作業。 若要避免這種情況，請一律提供在呼叫 [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex)進行非同步 i/o 時起始 i/o 要求的重 [**迭結構，**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped)或使用您自己的同步處理，以確保在呼叫 [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio)或 **CancelIoEx** 函式之前，不會在目標執行緒上啟動其他 i/o。
-   從函式傳回之前，清除回呼函式中所建立的所有資源。 這些包括 TLS、安全性內容、執行緒優先順序和 COM 註冊。 回呼函式也必須在傳回之前還原執行緒狀態。
-   讓等候控制碼與其相關聯的物件保持運作，直到執行緒集區已發出控制碼的信號完成為止。
-   標記等候冗長作業的所有線程 (例如 i/o 排清或資源清除) ，讓執行緒集區可以配置新的執行緒，而不是等候這個執行緒。
-   在卸載使用執行緒集區的 DLL 之前，請先取消所有的工作專案、i/o、等候作業和計時器，並等候執行中的回呼完成。
-   藉由確保回呼未等候本身完成，以及藉由保留執行緒優先順序，來避免發生鎖死，方法是刪除工作專案與回呼之間的相依性。
-   使用預設執行緒集區時，請勿在具有其他元件的進程中太快地將太多專案排入佇列。 每個進程都有一個預設的執行緒集區，包括 Svchost.exe。 根據預設，每個執行緒集區的最大值為500個背景工作執行緒。 當備妥/執行中狀態的背景工作執行緒數目必須小於處理器數目時，執行緒集區會嘗試建立更多工作者執行緒。
-   請避免 COM 單一執行緒的單元模型，因為它與執行緒集區不相容。 STA 會建立執行緒狀態，這可能會影響執行緒的下一個工作專案。 STA 通常很長，且具有線程親和性，也就是執行緒集區的相反。
-   建立新的執行緒集區，以控制執行緒優先順序和隔離、建立自訂特性，而且可能會改善回應能力。 不過，其他執行緒集區需要更多的系統資源 (執行緒、核心記憶體) 。 太多集區會增加 CPU 競爭的可能性。
-   可能的話，請使用可等候物件，而不是以 APC 為基礎的機制來發出執行緒集區執行緒的信號。 由於系統會控制執行緒集區執行緒的存留期，所以 Apc 無法也與執行緒集區執行緒一樣運作，因為系統會控制執行緒集區執行緒的存留期，因此在傳遞通知之前，執行緒可能會終止。
-   使用執行緒集區偵錯工具擴充功能！ tp。 此命令的使用方式如下：

    -   集區 *位址**旗標*
    -   obj *位址**旗標*
    -   t *位址**旗標*
    -   等候者 *位址*
    -   背景工作 *位址*

    針對集區、等候者和背景工作角色，如果位址為零，則命令會傾印所有物件。 若為等候和工作者，則省略位址會傾印目前的執行緒。 已定義下列旗標： 0x1 (單行輸出) 、0x2 (傾印成員) 和 0x4 (傾印集區工作佇列) 。

## <a name="related-topics"></a>相關主題

<dl> <dt>

[執行緒集區 API](thread-pool-api.md)
</dt> <dt>

[使用執行緒集區函數](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
