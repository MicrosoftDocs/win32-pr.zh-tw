---
description: 執行緒集區是工作者執行緒的集合，可代表應用程式有效率地執行非同步回呼。
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: 執行緒集區
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 690aa3eb6fd3ce7a99d71e0f57118529ef79113f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106985180"
---
# <a name="thread-pools"></a><span data-ttu-id="929f6-103">執行緒集區</span><span class="sxs-lookup"><span data-stu-id="929f6-103">Thread Pools</span></span>

<span data-ttu-id="929f6-104">*執行緒* 集區是工作者執行緒的集合，可代表應用程式有效率地執行非同步回呼。</span><span class="sxs-lookup"><span data-stu-id="929f6-104">A *thread pool* is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application.</span></span> <span data-ttu-id="929f6-105">執行緒集區主要是用來減少應用程式執行緒的數目，並提供工作者執行緒的管理。</span><span class="sxs-lookup"><span data-stu-id="929f6-105">The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.</span></span> <span data-ttu-id="929f6-106">應用程式可以將工作專案排入佇列、建立工作與可等候控制碼的關聯、根據計時器自動排入佇列，以及使用 i/o 系結。</span><span class="sxs-lookup"><span data-stu-id="929f6-106">Applications can queue work items, associate work with waitable handles, automatically queue based on a timer, and bind with I/O.</span></span>

## <a name="thread-pool-architecture"></a><span data-ttu-id="929f6-107">執行緒集區架構</span><span class="sxs-lookup"><span data-stu-id="929f6-107">Thread Pool Architecture</span></span>

<span data-ttu-id="929f6-108">下列應用程式可受益于使用執行緒集區：</span><span class="sxs-lookup"><span data-stu-id="929f6-108">The following applications can benefit from using a thread pool:</span></span>

-   <span data-ttu-id="929f6-109">高度平行處理的應用程式，可以非同步分派大量的小型工作專案 (例如分散式索引搜尋或網路 i/o) 。</span><span class="sxs-lookup"><span data-stu-id="929f6-109">An application that is highly parallel and can dispatch a large number of small work items asynchronously (such as distributed index search or network I/O).</span></span>
-   <span data-ttu-id="929f6-110">一種應用程式，可建立和終結大量的執行緒，每個執行緒都執行一小段時間。</span><span class="sxs-lookup"><span data-stu-id="929f6-110">An application that creates and destroys a large number of threads that each run for a short time.</span></span> <span data-ttu-id="929f6-111">使用執行緒集區可以降低執行緒管理的複雜度，以及執行緒建立和終結的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="929f6-111">Using the thread pool can reduce the complexity of thread management and the overhead involved in thread creation and destruction.</span></span>
-   <span data-ttu-id="929f6-112">在背景和平行 (中處理獨立工作專案的應用程式，例如) 中載入多個索引標籤。</span><span class="sxs-lookup"><span data-stu-id="929f6-112">An application that processes independent work items in the background and in parallel (such as loading multiple tabs).</span></span>
-   <span data-ttu-id="929f6-113">應用程式必須對核心物件執行獨佔等候，或封鎖物件上的傳入事件。</span><span class="sxs-lookup"><span data-stu-id="929f6-113">An application that must perform an exclusive wait on kernel objects or block on incoming events on an object.</span></span> <span data-ttu-id="929f6-114">使用執行緒集區可降低執行緒管理的複雜度，並藉由減少內容切換的數目來提高效能。</span><span class="sxs-lookup"><span data-stu-id="929f6-114">Using the thread pool can reduce the complexity of thread management and increase performance by reducing the number of context switches.</span></span>
-   <span data-ttu-id="929f6-115">此應用程式會建立自訂等候者執行緒以等候事件。</span><span class="sxs-lookup"><span data-stu-id="929f6-115">An application that creates custom waiter threads to wait on events.</span></span>

<span data-ttu-id="929f6-116">原始的執行緒集區已在 Windows Vista 中完全重新架構。</span><span class="sxs-lookup"><span data-stu-id="929f6-116">The original thread pool has been completely rearchitected in Windows Vista.</span></span> <span data-ttu-id="929f6-117">新的執行緒集區已獲得改善，因為它提供單一背景工作執行緒類型 (同時支援 i/o 和非 i/o) 、不使用計時器執行緒、提供單一計時器佇列，並提供專用的持續性執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-117">The new thread pool is improved because it provides a single worker thread type (supports both I/O and non-I/O), does not use a timer thread, provides a single timer queue, and provides a dedicated persistent thread.</span></span> <span data-ttu-id="929f6-118">它也提供清理群組、更高的效能、個別排程的每個進程的多個集區，以及新的執行緒集區 API。</span><span class="sxs-lookup"><span data-stu-id="929f6-118">It also provides clean-up groups, higher performance, multiple pools per process that are scheduled independently, and a new thread pool API.</span></span>

<span data-ttu-id="929f6-119">執行緒集區架構包含下列各項：</span><span class="sxs-lookup"><span data-stu-id="929f6-119">The thread pool architecture consists of the following:</span></span>

-   <span data-ttu-id="929f6-120">執行回呼函數的背景工作執行緒</span><span class="sxs-lookup"><span data-stu-id="929f6-120">Worker threads that execute the callback functions</span></span>
-   <span data-ttu-id="929f6-121">等候多個等候控制碼的等候執行緒</span><span class="sxs-lookup"><span data-stu-id="929f6-121">Waiter threads that wait on multiple wait handles</span></span>
-   <span data-ttu-id="929f6-122">工作佇列</span><span class="sxs-lookup"><span data-stu-id="929f6-122">A work queue</span></span>
-   <span data-ttu-id="929f6-123">每個進程的預設執行緒集區</span><span class="sxs-lookup"><span data-stu-id="929f6-123">A default thread pool for each process</span></span>
-   <span data-ttu-id="929f6-124">管理工作者執行緒的背景工作 factory</span><span class="sxs-lookup"><span data-stu-id="929f6-124">A worker factory that manages the worker threads</span></span>

## <a name="best-practices"></a><span data-ttu-id="929f6-125">最佳做法</span><span class="sxs-lookup"><span data-stu-id="929f6-125">Best Practices</span></span>

<span data-ttu-id="929f6-126">新的 [執行緒集區 api](thread-pool-api.md) 提供比 [原始執行緒集區 api](thread-pooling.md)更多的彈性和控制。</span><span class="sxs-lookup"><span data-stu-id="929f6-126">The new [thread pool API](thread-pool-api.md) provides more flexibility and control than the [original thread pool API](thread-pooling.md).</span></span> <span data-ttu-id="929f6-127">不過，有幾個微妙但重要的差異。</span><span class="sxs-lookup"><span data-stu-id="929f6-127">However, there are a few subtle but important differences.</span></span> <span data-ttu-id="929f6-128">在原始 API 中，等候重設為自動;在新的 API 中，每次都必須明確地重設等候。</span><span class="sxs-lookup"><span data-stu-id="929f6-128">In the original API, the wait reset was automatic; in the new API, the wait must be explicitly reset each time.</span></span> <span data-ttu-id="929f6-129">原始 API 會自動處理模擬，將呼叫進程的安全性內容傳送到執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-129">The original API handled impersonation automatically, transferring the security context of the calling process to the thread.</span></span> <span data-ttu-id="929f6-130">使用新的 API，應用程式必須明確設定安全性內容。</span><span class="sxs-lookup"><span data-stu-id="929f6-130">With the new API, the application must explicitly set the security context.</span></span>

<span data-ttu-id="929f6-131">以下是使用執行緒集區時的最佳作法：</span><span class="sxs-lookup"><span data-stu-id="929f6-131">The following are best practices when using a thread pool:</span></span>

-   <span data-ttu-id="929f6-132">進程的執行緒共用執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="929f6-132">The threads of a process share the thread pool.</span></span> <span data-ttu-id="929f6-133">單一工作者執行緒可以執行多個回呼函數，一次一個。</span><span class="sxs-lookup"><span data-stu-id="929f6-133">A single worker thread can execute multiple callback functions, one at a time.</span></span> <span data-ttu-id="929f6-134">這些工作者執行緒是由執行緒集區所管理。</span><span class="sxs-lookup"><span data-stu-id="929f6-134">These worker threads are managed by the thread pool.</span></span> <span data-ttu-id="929f6-135">因此，請勿線上程上呼叫 [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) ，或從回呼函式呼叫 [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) ，藉以終止執行緒集區中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-135">Therefore, do not terminate a thread from the thread pool by calling [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) on the thread or by calling [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) from a callback function.</span></span>
-   <span data-ttu-id="929f6-136">I/o 要求可以線上程集區中的任何執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="929f6-136">An I/O request can run on any thread in the thread pool.</span></span> <span data-ttu-id="929f6-137">線上程集區執行緒上取消 i/o 需要同步處理，因為 cancel 函式可能會在與處理 i/o 要求的執行緒不同的執行緒上執行，這可能會導致取消未知的作業。</span><span class="sxs-lookup"><span data-stu-id="929f6-137">Canceling I/O on a thread pool thread requires synchronization because the cancel function might run on a different thread than the one that is handling the I/O request, which can result in cancellation of an unknown operation.</span></span> <span data-ttu-id="929f6-138">若要避免這種情況，請一律提供在呼叫 [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex)進行非同步 i/o 時起始 i/o 要求的重 [**迭結構，**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped)或使用您自己的同步處理，以確保在呼叫 [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio)或 **CancelIoEx** 函式之前，不會在目標執行緒上啟動其他 i/o。</span><span class="sxs-lookup"><span data-stu-id="929f6-138">To avoid this, always provide the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure with which an I/O request was initiated when calling [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) for asynchronous I/O, or use your own synchronization to ensure that no other I/O can be started on the target thread before calling either the [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) or **CancelIoEx** function.</span></span>
-   <span data-ttu-id="929f6-139">從函式傳回之前，清除回呼函式中所建立的所有資源。</span><span class="sxs-lookup"><span data-stu-id="929f6-139">Clean up all resources created in the callback function before returning from the function.</span></span> <span data-ttu-id="929f6-140">這些包括 TLS、安全性內容、執行緒優先順序和 COM 註冊。</span><span class="sxs-lookup"><span data-stu-id="929f6-140">These include TLS, security contexts, thread priority, and COM registration.</span></span> <span data-ttu-id="929f6-141">回呼函式也必須在傳回之前還原執行緒狀態。</span><span class="sxs-lookup"><span data-stu-id="929f6-141">Callback functions must also restore the thread state before returning.</span></span>
-   <span data-ttu-id="929f6-142">讓等候控制碼與其相關聯的物件保持運作，直到執行緒集區已發出控制碼的信號完成為止。</span><span class="sxs-lookup"><span data-stu-id="929f6-142">Keep wait handles and their associated objects alive until the thread pool has signaled that it is finished with the handle.</span></span>
-   <span data-ttu-id="929f6-143">標記等候冗長作業的所有線程 (例如 i/o 排清或資源清除) ，讓執行緒集區可以配置新的執行緒，而不是等候這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-143">Mark all threads that are waiting on lengthy operations (such as I/O flushes or resource cleanup) so that the thread pool can allocate new threads instead of waiting for this one.</span></span>
-   <span data-ttu-id="929f6-144">在卸載使用執行緒集區的 DLL 之前，請先取消所有的工作專案、i/o、等候作業和計時器，並等候執行中的回呼完成。</span><span class="sxs-lookup"><span data-stu-id="929f6-144">Before unloading a DLL that uses the thread pool, cancel all work items, I/O, wait operations, and timers, and wait for executing callbacks to complete.</span></span>
-   <span data-ttu-id="929f6-145">藉由確保回呼未等候本身完成，以及藉由保留執行緒優先順序，來避免發生鎖死，方法是刪除工作專案與回呼之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="929f6-145">Avoid deadlocks by eliminating dependencies between work items and between callbacks, by ensuring a callback is not waiting for itself to complete, and by preserving the thread priority.</span></span>
-   <span data-ttu-id="929f6-146">使用預設執行緒集區時，請勿在具有其他元件的進程中太快地將太多專案排入佇列。</span><span class="sxs-lookup"><span data-stu-id="929f6-146">Do not queue too many items too quickly in a process with other components using the default thread pool.</span></span> <span data-ttu-id="929f6-147">每個進程都有一個預設的執行緒集區，包括 Svchost.exe。</span><span class="sxs-lookup"><span data-stu-id="929f6-147">There is one default thread pool per process, including Svchost.exe.</span></span> <span data-ttu-id="929f6-148">根據預設，每個執行緒集區的最大值為500個背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-148">By default, each thread pool has a maximum of 500 worker threads.</span></span> <span data-ttu-id="929f6-149">當備妥/執行中狀態的背景工作執行緒數目必須小於處理器數目時，執行緒集區會嘗試建立更多工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-149">The thread pool attempts to create more worker threads when the number of worker threads in the ready/running state must be less than the number of processors.</span></span>
-   <span data-ttu-id="929f6-150">請避免 COM 單一執行緒的單元模型，因為它與執行緒集區不相容。</span><span class="sxs-lookup"><span data-stu-id="929f6-150">Avoid the COM single-threaded apartment model, as it is incompatible with the thread pool.</span></span> <span data-ttu-id="929f6-151">STA 會建立執行緒狀態，這可能會影響執行緒的下一個工作專案。</span><span class="sxs-lookup"><span data-stu-id="929f6-151">STA creates thread state which can affect the next work item for the thread.</span></span> <span data-ttu-id="929f6-152">STA 通常很長，且具有線程親和性，也就是執行緒集區的相反。</span><span class="sxs-lookup"><span data-stu-id="929f6-152">STA is generally long-lived and has thread affinity, which is the opposite of the thread pool.</span></span>
-   <span data-ttu-id="929f6-153">建立新的執行緒集區，以控制執行緒優先順序和隔離、建立自訂特性，而且可能會改善回應能力。</span><span class="sxs-lookup"><span data-stu-id="929f6-153">Create a new thread pool to control thread priority and isolation, create custom characteristics, and possibly improve responsiveness.</span></span> <span data-ttu-id="929f6-154">不過，其他執行緒集區需要更多的系統資源 (執行緒、核心記憶體) 。</span><span class="sxs-lookup"><span data-stu-id="929f6-154">However, additional thread pools require more system resources (threads, kernel memory).</span></span> <span data-ttu-id="929f6-155">太多集區會增加 CPU 競爭的可能性。</span><span class="sxs-lookup"><span data-stu-id="929f6-155">Too many pools increases the potential for CPU contention.</span></span>
-   <span data-ttu-id="929f6-156">可能的話，請使用可等候物件，而不是以 APC 為基礎的機制來發出執行緒集區執行緒的信號。</span><span class="sxs-lookup"><span data-stu-id="929f6-156">If possible, use a waitable object instead of an APC-based mechanism to signal a thread pool thread.</span></span> <span data-ttu-id="929f6-157">由於系統會控制執行緒集區執行緒的存留期，所以 Apc 無法也與執行緒集區執行緒一樣運作，因為系統會控制執行緒集區執行緒的存留期，因此在傳遞通知之前，執行緒可能會終止。</span><span class="sxs-lookup"><span data-stu-id="929f6-157">APCs do not work as well with thread pool threads as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span>
-   <span data-ttu-id="929f6-158">使用執行緒集區偵錯工具擴充功能！ tp。</span><span class="sxs-lookup"><span data-stu-id="929f6-158">Use the thread pool debugger extension, !tp.</span></span> <span data-ttu-id="929f6-159">此命令的使用方式如下：</span><span class="sxs-lookup"><span data-stu-id="929f6-159">This command has the following usage:</span></span>

    -   <span data-ttu-id="929f6-160">集區 *位址\*\*旗標*</span><span class="sxs-lookup"><span data-stu-id="929f6-160">pool *address* *flags*</span></span>
    -   <span data-ttu-id="929f6-161">obj *位址\*\*旗標*</span><span class="sxs-lookup"><span data-stu-id="929f6-161">obj *address* *flags*</span></span>
    -   <span data-ttu-id="929f6-162">t *位址\*\*旗標*</span><span class="sxs-lookup"><span data-stu-id="929f6-162">tqueue *address* *flags*</span></span>
    -   <span data-ttu-id="929f6-163">等候者 *位址*</span><span class="sxs-lookup"><span data-stu-id="929f6-163">waiter *address*</span></span>
    -   <span data-ttu-id="929f6-164">背景工作 *位址*</span><span class="sxs-lookup"><span data-stu-id="929f6-164">worker *address*</span></span>

    <span data-ttu-id="929f6-165">針對集區、等候者和背景工作角色，如果位址為零，則命令會傾印所有物件。</span><span class="sxs-lookup"><span data-stu-id="929f6-165">For pool, waiter, and worker, if the address is zero, the command dumps all objects.</span></span> <span data-ttu-id="929f6-166">若為等候和工作者，則省略位址會傾印目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="929f6-166">For waiter and worker, omitting the address dumps the current thread.</span></span> <span data-ttu-id="929f6-167">已定義下列旗標： 0x1 (單行輸出) 、0x2 (傾印成員) 和 0x4 (傾印集區工作佇列) 。</span><span class="sxs-lookup"><span data-stu-id="929f6-167">The following flags are defined: 0x1 (single-line output), 0x2 (dump members), and 0x4 (dump pool work queue).</span></span>

## <a name="related-topics"></a><span data-ttu-id="929f6-168">相關主題</span><span class="sxs-lookup"><span data-stu-id="929f6-168">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="929f6-169">執行緒集區 API</span><span class="sxs-lookup"><span data-stu-id="929f6-169">Thread Pool API</span></span>](thread-pool-api.md)
</dt> <dt>

[<span data-ttu-id="929f6-170">使用執行緒集區函數</span><span class="sxs-lookup"><span data-stu-id="929f6-170">Using the Thread Pool Functions</span></span>](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
