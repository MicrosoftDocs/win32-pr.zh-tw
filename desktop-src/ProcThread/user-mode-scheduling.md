---
description: 使用者模式排程 (UMS) 是一種輕量的機制，可讓應用程式用來排程自己的執行緒。
ms.assetid: f9dd92fe-6d7a-452c-893e-e6df1757e377
title: User-Mode 排程
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f3ceea3c4d4e40d73f48414d074bcb5b4f6e911d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106992471"
---
# <a name="user-mode-scheduling"></a><span data-ttu-id="935b8-103">User-Mode 排程</span><span class="sxs-lookup"><span data-stu-id="935b8-103">User-Mode Scheduling</span></span>

<span data-ttu-id="935b8-104">使用者模式排程 (UMS) 是一種輕量的機制，可讓應用程式用來排程自己的執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-104">User-mode scheduling (UMS) is a lightweight mechanism that applications can use to schedule their own threads.</span></span> <span data-ttu-id="935b8-105">應用程式可以在使用者模式中的 UMS 執行緒之間切換，而不需要涉及 [系統](scheduling.md) 排程器，而且如果核心中的 ums 執行緒區塊，則會重新取得處理器的控制權。</span><span class="sxs-lookup"><span data-stu-id="935b8-105">An application can switch between UMS threads in user mode without involving the [system scheduler](scheduling.md) and regain control of the processor if a UMS thread blocks in the kernel.</span></span> <span data-ttu-id="935b8-106">UMS 執行緒與 [纖維](fibers.md) 不同之處在于，每個 ums 執行緒都有自己的執行緒內容，而不是共用單一執行緒的執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="935b8-106">UMS threads differ from [fibers](fibers.md) in that each UMS thread has its own thread context instead of sharing the thread context of a single thread.</span></span> <span data-ttu-id="935b8-107">在使用者模式中切換執行緒的能力，讓 UMS 比 [執行緒](thread-pools.md) 集區更有效率，以管理需要少數系統呼叫的大量短時間工作專案。</span><span class="sxs-lookup"><span data-stu-id="935b8-107">The ability to switch between threads in user mode makes UMS more efficient than [thread pools](thread-pools.md) for managing large numbers of short-duration work items that require few system calls.</span></span>

<span data-ttu-id="935b8-108">如果應用程式需要高效能需求，且需要在多處理器或多核心系統上同時執行許多執行緒，則建議使用 UMS。</span><span class="sxs-lookup"><span data-stu-id="935b8-108">UMS is recommended for applications with high performance requirements that need to efficiently run many threads concurrently on multiprocessor or multicore systems.</span></span> <span data-ttu-id="935b8-109">若要利用 UMS，應用程式必須執行排程器元件來管理應用程式的 UMS 執行緒，並判斷它們應該執行的時機。</span><span class="sxs-lookup"><span data-stu-id="935b8-109">To take advantage of UMS, an application must implement a scheduler component that manages the application's UMS threads and determines when they should run.</span></span> <span data-ttu-id="935b8-110">開發人員應考慮其應用程式效能需求是否符合開發這類元件的相關工作。</span><span class="sxs-lookup"><span data-stu-id="935b8-110">Developers should consider whether their application performance requirements justify the work involved in developing such a component.</span></span> <span data-ttu-id="935b8-111">具有中等效能需求的應用程式，可能會因為允許系統排程器排程其執行緒而提供更佳的服務。</span><span class="sxs-lookup"><span data-stu-id="935b8-111">Applications with moderate performance requirements might be better served by allowing the system scheduler to schedule their threads.</span></span>

<span data-ttu-id="935b8-112">UMS 適用于在64位版本的 Windows 7 和 Windows Server 2008 R2 或64更新版本的 windows 版本上執行的64位應用程式。</span><span class="sxs-lookup"><span data-stu-id="935b8-112">UMS is available for 64-bit applications running on 64-bit versions of Windows 7 and Windows Server 2008 R2 or later 64-bit versions of Windows.</span></span> <span data-ttu-id="935b8-113">這項功能不適用於32位版本的 Windows。</span><span class="sxs-lookup"><span data-stu-id="935b8-113">This feature is not available on 32-bit versions of Windows.</span></span>

<span data-ttu-id="935b8-114">如需詳細資訊，請參閱下列各節：</span><span class="sxs-lookup"><span data-stu-id="935b8-114">For details, see the following sections:</span></span>

-   [<span data-ttu-id="935b8-115">UMS 排程器</span><span class="sxs-lookup"><span data-stu-id="935b8-115">UMS Scheduler</span></span>](#ums-scheduler)
-   [<span data-ttu-id="935b8-116">UMS 排程器執行緒</span><span class="sxs-lookup"><span data-stu-id="935b8-116">UMS Scheduler Thread</span></span>](#ums-scheduler-thread)
-   [<span data-ttu-id="935b8-117">UMS 背景工作執行緒、執行緒內容和完成清單</span><span class="sxs-lookup"><span data-stu-id="935b8-117">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>](#ums-worker-threads-thread-contexts-and-completion-lists)
-   [<span data-ttu-id="935b8-118">UMS 排程器進入點函數</span><span class="sxs-lookup"><span data-stu-id="935b8-118">UMS Scheduler Entry Point Function</span></span>](#ums-scheduler-entry-point-function)
-   [<span data-ttu-id="935b8-119">UMS 執行緒執行</span><span class="sxs-lookup"><span data-stu-id="935b8-119">UMS Thread Execution</span></span>](#ums-thread-execution)
-   [<span data-ttu-id="935b8-120">UMS 最佳作法</span><span class="sxs-lookup"><span data-stu-id="935b8-120">UMS Best Practices</span></span>](#ums-best-practices)

## <a name="ums-scheduler"></a><span data-ttu-id="935b8-121">UMS 排程器</span><span class="sxs-lookup"><span data-stu-id="935b8-121">UMS Scheduler</span></span>

<span data-ttu-id="935b8-122">應用程式的 UMS 排程器負責建立、管理及刪除 UMS 執行緒，以及判斷要執行的 UMS 執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-122">An application's UMS scheduler is responsible for creating, managing, and deleting UMS threads and determining which UMS thread to run.</span></span> <span data-ttu-id="935b8-123">應用程式的排程器會執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="935b8-123">An application's scheduler performs the following tasks:</span></span>

-   <span data-ttu-id="935b8-124">為每個處理器建立一個 UMS 排程器執行緒，應用程式將在其中執行 UMS 工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-124">Creates one UMS scheduler thread for each processor on which the application will run UMS worker threads.</span></span>
-   <span data-ttu-id="935b8-125">建立 UMS 背景工作執行緒來執行應用程式的工作。</span><span class="sxs-lookup"><span data-stu-id="935b8-125">Creates UMS worker threads to perform the work of the application.</span></span>
-   <span data-ttu-id="935b8-126">會針對已準備好執行的背景工作執行緒，維護自己的就緒執行緒佇列，並根據應用程式的排程原則選取要執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-126">Maintains its own ready-thread queue of worker threads that are ready to run, and selects threads to run based on the application's scheduling policies.</span></span>
-   <span data-ttu-id="935b8-127">建立並監視一或多個完成清單，其中系統會線上程完成核心處理之後將其排入佇列。</span><span class="sxs-lookup"><span data-stu-id="935b8-127">Creates and monitors one or more completion lists where the system queues threads after they finish processing in the kernel.</span></span> <span data-ttu-id="935b8-128">這包括新建立的背景工作執行緒，以及先前在被解除封鎖的系統呼叫上封鎖的執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-128">These include newly created worker threads and threads previously blocked on a system call that become unblocked.</span></span>
-   <span data-ttu-id="935b8-129">提供排程器進入點函式，以處理來自系統的通知。</span><span class="sxs-lookup"><span data-stu-id="935b8-129">Provides a scheduler entry point function to handles notifications from the system.</span></span> <span data-ttu-id="935b8-130">系統會在建立排程器執行緒、當背景工作執行緒在系統呼叫上封鎖，或當背景工作執行緒明確產生控制權時，呼叫進入點函數。</span><span class="sxs-lookup"><span data-stu-id="935b8-130">The system calls the entry point function when a scheduler thread is created, when a worker thread blocks on a system call, or when a worker thread explicitly yields control.</span></span>
-   <span data-ttu-id="935b8-131">針對已完成執行的背景工作執行緒執行清除工作。</span><span class="sxs-lookup"><span data-stu-id="935b8-131">Performs cleanup tasks for worker threads that have finished running.</span></span>
-   <span data-ttu-id="935b8-132">在應用程式要求時，執行排程器的有條理關機。</span><span class="sxs-lookup"><span data-stu-id="935b8-132">Performs an orderly shutdown of the scheduler when requested by the application.</span></span>

## <a name="ums-scheduler-thread"></a><span data-ttu-id="935b8-133">UMS 排程器執行緒</span><span class="sxs-lookup"><span data-stu-id="935b8-133">UMS Scheduler Thread</span></span>

<span data-ttu-id="935b8-134">UMS 排程器執行緒是透過呼叫 [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) 函數，將本身轉換成 UMS 的一般執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-134">A UMS scheduler thread is an ordinary thread that has converted itself to UMS by calling the [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) function.</span></span> <span data-ttu-id="935b8-135">系統排程器會判斷 UMS 排程器執行緒執行的時間，是根據其相對於其他就緒執行緒的優先權。</span><span class="sxs-lookup"><span data-stu-id="935b8-135">The system scheduler determines when the UMS scheduler thread runs based on its priority relative to other ready threads.</span></span> <span data-ttu-id="935b8-136">執行排程器執行緒的處理器會受到執行緒親和性的影響，與非 UMS 執行緒相同。</span><span class="sxs-lookup"><span data-stu-id="935b8-136">The processor on which the scheduler thread runs is influenced by the thread's affinity, same as for non-UMS threads.</span></span>

<span data-ttu-id="935b8-137">[**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode)的呼叫端會指定完成清單以及與 UMS 排程器執行緒相關聯的 [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point)進入點函數。</span><span class="sxs-lookup"><span data-stu-id="935b8-137">The caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) specifies a completion list and a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) entry point function to associate with the UMS scheduler thread.</span></span> <span data-ttu-id="935b8-138">當系統完成將呼叫執行緒轉換成 UMS 時，系統會呼叫指定的進入點函數。</span><span class="sxs-lookup"><span data-stu-id="935b8-138">The system calls the specified entry point function when it is finished converting the calling thread to UMS.</span></span> <span data-ttu-id="935b8-139">排程器進入點函數負責判斷指定執行緒的適當下一個動作。</span><span class="sxs-lookup"><span data-stu-id="935b8-139">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="935b8-140">如需詳細資訊，請參閱本主題稍後的 UMS 排程器 [進入點函數](#ums-scheduler-entry-point-function) 。</span><span class="sxs-lookup"><span data-stu-id="935b8-140">For more information, see [UMS Scheduler Entry Point Function](#ums-scheduler-entry-point-function) later in this topic.</span></span>

<span data-ttu-id="935b8-141">應用程式可能會為將用來執行 UMS 執行緒的每個處理器建立一個 UMS 排程器執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-141">An application might create one UMS scheduler thread for each processor that will be used to run UMS threads.</span></span> <span data-ttu-id="935b8-142">應用程式也可能會針對特定邏輯處理器，設定每個 UMS 排程器執行緒的親和性，這通常會排除不相關的執行緒，使其無法在該處理器上執行，並有效地為該排程器執行緒保留該執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-142">The application might also set the affinity of each UMS scheduler thread for a specific logical processor, which tends to exclude unrelated threads from running on that processor, effectively reserving it for that scheduler thread.</span></span> <span data-ttu-id="935b8-143">請注意，以這種方式設定執行緒親和性，會 starvation 可能在系統上執行的其他進程，進而影響整體系統效能。</span><span class="sxs-lookup"><span data-stu-id="935b8-143">Be aware that setting thread affinity in this way can affect overall system performance by starving other processes that may be running on the system.</span></span> <span data-ttu-id="935b8-144">如需執行緒親和性的詳細資訊，請參閱 [多個處理器](multiple-processors.md)。</span><span class="sxs-lookup"><span data-stu-id="935b8-144">For more information about thread affinity, see [Multiple Processors](multiple-processors.md).</span></span>

## <a name="ums-worker-threads-thread-contexts-and-completion-lists"></a><span data-ttu-id="935b8-145">UMS 背景工作執行緒、執行緒內容和完成清單</span><span class="sxs-lookup"><span data-stu-id="935b8-145">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>

<span data-ttu-id="935b8-146">藉由呼叫 [**CreateRemoteThreadEx**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) \_ 和 PROC 執行緒 \_ 屬性 \_ UMS \_ 執行緒屬性，並指定 ums 執行緒內容和完成清單來建立 ums 背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-146">A UMS worker thread is created by calling [**CreateRemoteThreadEx**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) with the PROC\_THREAD\_ATTRIBUTE\_UMS\_THREAD attribute and specifying a UMS thread context and a completion list.</span></span>

<span data-ttu-id="935b8-147">UMS 執行緒內容代表背景工作執行緒的 UMS 執行緒狀態，用來識別 UMS 函式呼叫中的背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-147">A UMS thread context represents the UMS thread state of a worker thread and is used to identify the worker thread in UMS function calls.</span></span> <span data-ttu-id="935b8-148">它是透過呼叫 [**CreateUmsThreadCoNtext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext)來建立。</span><span class="sxs-lookup"><span data-stu-id="935b8-148">It is created by calling [**CreateUmsThreadContext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext).</span></span>

<span data-ttu-id="935b8-149">完成清單會藉由呼叫 [**CreateUmsCompletionList**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) 函數來建立。</span><span class="sxs-lookup"><span data-stu-id="935b8-149">A completion list is created by calling the [**CreateUmsCompletionList**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) function.</span></span> <span data-ttu-id="935b8-150">完成清單會接收在核心中已完成執行的 UMS 工作者執行緒，並準備好在使用者模式中執行。</span><span class="sxs-lookup"><span data-stu-id="935b8-150">A completion list receives UMS worker threads that have completed execution in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="935b8-151">只有系統可以將背景工作執行緒佇列至完成清單。</span><span class="sxs-lookup"><span data-stu-id="935b8-151">Only the system can queue worker threads to a completion list.</span></span> <span data-ttu-id="935b8-152">新的 UMS 背景工作執行緒會自動排入執行緒建立時指定的完成清單。</span><span class="sxs-lookup"><span data-stu-id="935b8-152">New UMS worker threads are automatically queued to the completion list specified when the threads were created.</span></span> <span data-ttu-id="935b8-153">先前已封鎖的背景工作執行緒在不再被封鎖時，也會在完成清單中排入佇列。</span><span class="sxs-lookup"><span data-stu-id="935b8-153">Previously blocked worker threads are also queued to the completion list when they are no longer blocked.</span></span>

<span data-ttu-id="935b8-154">每個 UMS 排程器執行緒都會與單一完成清單相關聯。</span><span class="sxs-lookup"><span data-stu-id="935b8-154">Each UMS scheduler thread is associated with a single completion list.</span></span> <span data-ttu-id="935b8-155">不過，相同的完成清單可以與任何數目的 UMS 排程器執行緒相關聯，而排程器執行緒可以從任何具有指標的完成清單中取得 UMS 內容。</span><span class="sxs-lookup"><span data-stu-id="935b8-155">However, the same completion list can be associated with any number of UMS scheduler threads, and a scheduler thread can retrieve UMS contexts from any completion list for which it has a pointer.</span></span>

<span data-ttu-id="935b8-156">每個完成清單都有相關聯的事件，當系統將一或多個背景工作執行緒排入空的清單時，系統就會發出信號。</span><span class="sxs-lookup"><span data-stu-id="935b8-156">Each completion list has an associated event that is signaled by the system when it queues one or more worker threads to an empty list.</span></span> <span data-ttu-id="935b8-157">[**GetUmsCompletionListEvent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent)函式會針對指定的完成清單抓取事件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="935b8-157">The [**GetUmsCompletionListEvent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent) function retrieves a handle to the event for a specified completion list.</span></span> <span data-ttu-id="935b8-158">應用程式可以等候一個以上的完成清單事件，以及對應用程式有意義的其他事件。</span><span class="sxs-lookup"><span data-stu-id="935b8-158">An application can wait on more than one completion list event along with other events that make sense for the application.</span></span>

## <a name="ums-scheduler-entry-point-function"></a><span data-ttu-id="935b8-159">UMS 排程器進入點函數</span><span class="sxs-lookup"><span data-stu-id="935b8-159">UMS Scheduler Entry Point Function</span></span>

<span data-ttu-id="935b8-160">應用程式的排程器進入點函數會實作為 [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) 函數。</span><span class="sxs-lookup"><span data-stu-id="935b8-160">An application's scheduler entry point function is implemented as a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function.</span></span> <span data-ttu-id="935b8-161">系統會在下列時間呼叫應用程式的排程器進入點函數：</span><span class="sxs-lookup"><span data-stu-id="935b8-161">The system calls the application's scheduler entry point function at the following times:</span></span>

-   <span data-ttu-id="935b8-162">當非 UMS 執行緒藉由呼叫 [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode)轉換成 ums 排程器執行緒時。</span><span class="sxs-lookup"><span data-stu-id="935b8-162">When a non-UMS thread is converted to a UMS scheduler thread by calling [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span>
-   <span data-ttu-id="935b8-163">當 UMS 工作者執行緒呼叫 [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield)時。</span><span class="sxs-lookup"><span data-stu-id="935b8-163">When a UMS worker thread calls [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span>
-   <span data-ttu-id="935b8-164">當 UMS 背景工作執行緒在系統服務上封鎖，例如系統呼叫或分頁錯誤時。</span><span class="sxs-lookup"><span data-stu-id="935b8-164">When a UMS worker thread blocks on a system service such as a system call or a page fault.</span></span>

<span data-ttu-id="935b8-165">[*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point)函式的 *reason* 參數會指定呼叫進入點函數的原因。</span><span class="sxs-lookup"><span data-stu-id="935b8-165">The *Reason* parameter of the [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function specifies the reason that the entry point function was called.</span></span> <span data-ttu-id="935b8-166">如果因為建立了新的 UMS 排程器執行緒而呼叫進入點函式，則 *SchedulerParam* 參數會包含 [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode)呼叫端所指定的資料。</span><span class="sxs-lookup"><span data-stu-id="935b8-166">If the entry point function was called because a new UMS scheduler thread was created, the *SchedulerParam* parameter contains data specified by the caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span> <span data-ttu-id="935b8-167">如果因為產生 UMS 工作者執行緒而呼叫進入點函式，則 *SchedulerParam* 參數會包含 [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield)呼叫端所指定的資料。</span><span class="sxs-lookup"><span data-stu-id="935b8-167">If the entry point function was called because a UMS worker thread yielded, the *SchedulerParam* parameter contains data specified by the caller of [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span> <span data-ttu-id="935b8-168">如果因為核心中的 UMS 背景工作執行緒遭到封鎖而呼叫進入點函式，則 *SchedulerParam* 參數為 Null。</span><span class="sxs-lookup"><span data-stu-id="935b8-168">If the entry point function was called because a UMS worker thread blocked in the kernel, the *SchedulerParam* parameter is NULL.</span></span>

<span data-ttu-id="935b8-169">排程器進入點函數負責判斷指定執行緒的適當下一個動作。</span><span class="sxs-lookup"><span data-stu-id="935b8-169">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="935b8-170">例如，如果背景工作執行緒遭到封鎖，排程器進入點函數可能會執行下一個可用的 UMS 背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-170">For example, if a worker thread is blocked, the scheduler entry point function might run the next available ready UMS worker thread.</span></span>

<span data-ttu-id="935b8-171">呼叫排程器進入點函式時，應用程式的排程器應嘗試呼叫 [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) 函數，以取得其相關聯完成清單中的所有專案。</span><span class="sxs-lookup"><span data-stu-id="935b8-171">When the scheduler entry point function is called, the application's scheduler should attempt to retrieve all of the items in its associated completion list by calling the [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) function.</span></span> <span data-ttu-id="935b8-172">此函式會取得在核心中已完成處理且已準備好在使用者模式下執行的 UMS 執行緒內容清單。</span><span class="sxs-lookup"><span data-stu-id="935b8-172">This function retrieves a list of UMS thread contexts that have finished processing in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="935b8-173">應用程式的排程器不應直接從此清單執行 UMS 執行緒，因為這可能會導致應用程式中發生無法預期的行為。</span><span class="sxs-lookup"><span data-stu-id="935b8-173">The application's scheduler should not run UMS threads directly from this list because this can cause unpredictable behavior in the application.</span></span> <span data-ttu-id="935b8-174">相反地，排程器應該針對每個內容呼叫 [**GetNextUmsListItem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) 函數一次，以抓取所有的 ums 執行緒內容，將 ums 執行緒內容插入排程器的就緒執行緒佇列中，然後只從就緒執行緒佇列執行 ums 執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-174">Instead, the scheduler should retrieve all UMS thread contexts by calling the [**GetNextUmsListItem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) function once for each context, insert the UMS thread contexts in the scheduler’s ready thread queue, and only then run UMS threads from the ready thread queue.</span></span>

<span data-ttu-id="935b8-175">如果排程器不需要等待多個事件，則應該使用非零的 timeout 參數來呼叫 [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) ，以便函式在傳回之前等候完成清單事件。</span><span class="sxs-lookup"><span data-stu-id="935b8-175">If the scheduler does not need to wait on multiple events, it should call [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) with a nonzero timeout parameter so the function waits on the completion list event before returning.</span></span> <span data-ttu-id="935b8-176">如果排程器需要等候多個完成清單事件，它應該呼叫 **DequeueUmsCompletionListItems** ，並將 timeout 參數設為零，讓函數立即傳回，即使完成清單是空的。</span><span class="sxs-lookup"><span data-stu-id="935b8-176">If the scheduler does need to wait on multiple completion list events, it should call **DequeueUmsCompletionListItems** with a timeout parameter of zero so the function returns immediately, even if the completion list is empty.</span></span> <span data-ttu-id="935b8-177">在此情況下，排程器可以明確地在完成清單事件上等候，例如，使用 [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects)。</span><span class="sxs-lookup"><span data-stu-id="935b8-177">In this case, the scheduler can wait explicitly on completion list events, for example, by using [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

## <a name="ums-thread-execution"></a><span data-ttu-id="935b8-178">UMS 執行緒執行</span><span class="sxs-lookup"><span data-stu-id="935b8-178">UMS Thread Execution</span></span>

<span data-ttu-id="935b8-179">新建立的 UMS 背景工作執行緒會排入指定的完成清單佇列中，且在應用程式的 UMS 排程器選取執行之前，不會開始執行。</span><span class="sxs-lookup"><span data-stu-id="935b8-179">A newly created UMS worker thread is queued to the specified completion list and does not begin running until the application's UMS scheduler selects it to run.</span></span> <span data-ttu-id="935b8-180">這與非 UMS 執行緒不同，除非呼叫端明確建立擱置的執行緒，否則系統排程器會自動排程執行。</span><span class="sxs-lookup"><span data-stu-id="935b8-180">This differs from non-UMS threads, which the system scheduler automatically schedules to run unless the caller explicitly creates the thread suspended.</span></span>

<span data-ttu-id="935b8-181">排程器會藉由呼叫 [**ExecuteUmsThread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) 與背景工作執行緒的 UMS 內容來執行背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-181">The scheduler runs a worker thread by calling [**ExecuteUmsThread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) with the worker thread's UMS context.</span></span> <span data-ttu-id="935b8-182">UMS 背景工作執行緒會執行，直到它透過呼叫 [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) 函式、區塊或終止來產生為止。</span><span class="sxs-lookup"><span data-stu-id="935b8-182">A UMS worker thread runs until it yields by calling the [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) function, blocks, or terminates.</span></span>

## <a name="ums-best-practices"></a><span data-ttu-id="935b8-183">UMS 最佳作法</span><span class="sxs-lookup"><span data-stu-id="935b8-183">UMS Best Practices</span></span>

<span data-ttu-id="935b8-184">執行 UMS 的應用程式應該遵循下列最佳作法：</span><span class="sxs-lookup"><span data-stu-id="935b8-184">Applications that implement UMS should follow these best practices:</span></span>

-   <span data-ttu-id="935b8-185">UMS 執行緒內容的基礎結構是由系統管理，不應該直接修改。</span><span class="sxs-lookup"><span data-stu-id="935b8-185">The underlying structures for UMS thread contexts are managed by the system and should not be modified directly.</span></span> <span data-ttu-id="935b8-186">相反地，請使用 [**QueryUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) 和 [**SetUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) 來取得和設定 UMS 工作者執行緒的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="935b8-186">Instead, use [**QueryUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) and [**SetUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) to retrieve and set information about a UMS worker thread.</span></span>
-   <span data-ttu-id="935b8-187">為了協助防止鎖死，UMS 排程器執行緒不應與 UMS 工作者執行緒共用鎖定。</span><span class="sxs-lookup"><span data-stu-id="935b8-187">To help prevent deadlocks, the UMS scheduler thread should not share locks with UMS worker threads.</span></span> <span data-ttu-id="935b8-188">這包括應用程式建立的鎖定和系統鎖定，這些都是由作業間接取得，例如從堆積配置或載入 Dll。</span><span class="sxs-lookup"><span data-stu-id="935b8-188">This includes both application-created locks and system locks that are acquired indirectly by operations such as allocating from the heap or loading DLLs.</span></span> <span data-ttu-id="935b8-189">例如，假設排程器執行會載入 DLL 的 UMS 工作者執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-189">For example, suppose the scheduler runs a UMS worker thread that loads a DLL.</span></span> <span data-ttu-id="935b8-190">背景工作執行緒會取得載入器鎖定和區塊。</span><span class="sxs-lookup"><span data-stu-id="935b8-190">The worker thread acquires the loader lock and blocks.</span></span> <span data-ttu-id="935b8-191">系統會呼叫排程器進入點函數，然後載入 DLL。</span><span class="sxs-lookup"><span data-stu-id="935b8-191">The system calls the scheduler entry point function, which then loads a DLL.</span></span> <span data-ttu-id="935b8-192">這會造成鎖死，因為已持有載入器鎖定，而且在第一個執行緒解除封鎖之前無法釋出。</span><span class="sxs-lookup"><span data-stu-id="935b8-192">This causes a deadlock, because the loader lock is already held and cannot be released until the first thread unblocks.</span></span> <span data-ttu-id="935b8-193">若要避免這個問題，請將可能與 UMS 工作者執行緒共用鎖定的工作委派給專用的 UMS 背景工作執行緒或非 UMS 執行緒。</span><span class="sxs-lookup"><span data-stu-id="935b8-193">To help avoid this problem, delegate work that might share locks with UMS worker threads to a dedicated UMS worker thread or a non-UMS thread.</span></span>
-   <span data-ttu-id="935b8-194">當大部分處理都是在使用者模式下完成時，UMS 是最有效率的。</span><span class="sxs-lookup"><span data-stu-id="935b8-194">UMS is most efficient when most processing is done in user mode.</span></span> <span data-ttu-id="935b8-195">請盡可能避免在 UMS 工作者執行緒中進行系統呼叫。</span><span class="sxs-lookup"><span data-stu-id="935b8-195">Whenever possible, avoid making system calls in UMS worker threads.</span></span>
-   <span data-ttu-id="935b8-196">UMS 工作者執行緒不應假設系統排程器正在使用中。</span><span class="sxs-lookup"><span data-stu-id="935b8-196">UMS worker threads should not assume the system scheduler is being used.</span></span> <span data-ttu-id="935b8-197">這種假設有很微妙的效果;例如，如果未知程式碼中的執行緒設定執行緒優先順序或親和性，則 UMS 排程器可能仍會覆寫它。</span><span class="sxs-lookup"><span data-stu-id="935b8-197">This assumption can have subtle effects; for example, if a thread in the unknown code sets a thread priority or affinity, the UMS scheduler might still override it.</span></span> <span data-ttu-id="935b8-198">假設使用系統排程器的程式碼可能不會如預期般運作，而且在 UMS 執行緒呼叫時可能會中斷。</span><span class="sxs-lookup"><span data-stu-id="935b8-198">Code that assumes the system scheduler is being used may not behave as expected and may break when called by a UMS thread.</span></span>
-   <span data-ttu-id="935b8-199">系統可能需要鎖定 UMS 工作者執行緒的執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="935b8-199">The system may need to lock the thread context of a UMS worker thread.</span></span> <span data-ttu-id="935b8-200">例如， (APC) 的核心模式非同步程序呼叫可能會變更 UMS 執行緒的內容，因此必須鎖定執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="935b8-200">For example, a kernel-mode asynchronous procedure call (APC) might change the context of the UMS thread, so the thread context must be locked.</span></span> <span data-ttu-id="935b8-201">如果排程器在鎖定時嘗試執行 UMS 執行緒內容，則呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="935b8-201">If the scheduler tries to execute the UMS thread context while it is locked, the call will fail.</span></span> <span data-ttu-id="935b8-202">這是設計的行為，而且排程器的設計目的是要重試 UMS 執行緒內容的存取。</span><span class="sxs-lookup"><span data-stu-id="935b8-202">This behavior is by design, and the scheduler should be designed to retry access to the UMS thread context.</span></span>

 

 
