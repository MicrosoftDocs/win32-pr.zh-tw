---
description: 光纖是必須由應用程式手動排程的執行單位。
ms.assetid: 6283f56b-23ae-4840-abd0-2478a50c670c
title: 纖維
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4ea0383e6d207a77c621f00f358c72bb8873ecb5
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103693015"
---
# <a name="fibers"></a><span data-ttu-id="85c2a-103">纖維</span><span class="sxs-lookup"><span data-stu-id="85c2a-103">Fibers</span></span>

<span data-ttu-id="85c2a-104">*光纖* 是必須由應用程式手動排程的執行單位。</span><span class="sxs-lookup"><span data-stu-id="85c2a-104">A *fiber* is a unit of execution that must be manually scheduled by the application.</span></span> <span data-ttu-id="85c2a-105">在排程執行緒的執行緒內容中執行纖程。</span><span class="sxs-lookup"><span data-stu-id="85c2a-105">Fibers run in the context of the threads that schedule them.</span></span> <span data-ttu-id="85c2a-106">每個執行緒都可以排程多個纖維。</span><span class="sxs-lookup"><span data-stu-id="85c2a-106">Each thread can schedule multiple fibers.</span></span> <span data-ttu-id="85c2a-107">一般而言，在設計完善的多執行緒應用程式上，纖維並不提供任何優點。</span><span class="sxs-lookup"><span data-stu-id="85c2a-107">In general, fibers do not provide advantages over a well-designed multithreaded application.</span></span> <span data-ttu-id="85c2a-108">不過，使用纖維可讓您更輕鬆地移植設計來排程其自有線程的應用程式。</span><span class="sxs-lookup"><span data-stu-id="85c2a-108">However, using fibers can make it easier to port applications that were designed to schedule their own threads.</span></span>

<span data-ttu-id="85c2a-109">從系統的觀點來看，光纖會假設執行它的執行緒的身分識別。</span><span class="sxs-lookup"><span data-stu-id="85c2a-109">From a system standpoint, a fiber assumes the identity of the thread that runs it.</span></span> <span data-ttu-id="85c2a-110">例如，如果光纖 (TLS) 存取 [執行緒區域儲存區](thread-local-storage.md) ，它就會存取執行它之執行緒的執行緒區域儲存區。</span><span class="sxs-lookup"><span data-stu-id="85c2a-110">For example, if a fiber accesses [thread local storage](thread-local-storage.md) (TLS), it is accessing the thread local storage of the thread that is running it.</span></span> <span data-ttu-id="85c2a-111">此外，如果光纖呼叫 [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) 函式，則會結束執行它的執行緒。</span><span class="sxs-lookup"><span data-stu-id="85c2a-111">In addition, if a fiber calls the [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) function, the thread that is running it exits.</span></span> <span data-ttu-id="85c2a-112">不過，光纖並沒有與執行緒相關聯的所有相同狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="85c2a-112">However, a fiber does not have all the same state information associated with it as that associated with a thread.</span></span> <span data-ttu-id="85c2a-113">針對光纖維護的唯一狀態資訊是它的堆疊、其暫存器的子集，以及光纖建立期間提供的光纖資料。</span><span class="sxs-lookup"><span data-stu-id="85c2a-113">The only state information maintained for a fiber is its stack, a subset of its registers, and the fiber data provided during fiber creation.</span></span> <span data-ttu-id="85c2a-114">儲存的暫存器是一組通常會在函式呼叫中保留的暫存器。</span><span class="sxs-lookup"><span data-stu-id="85c2a-114">The saved registers are the set of registers typically preserved across a function call.</span></span>

<span data-ttu-id="85c2a-115">未事先排程的纖維。</span><span class="sxs-lookup"><span data-stu-id="85c2a-115">Fibers are not preemptively scheduled.</span></span> <span data-ttu-id="85c2a-116">您可以從另一個光纖切換至光纖，以排程光纖。</span><span class="sxs-lookup"><span data-stu-id="85c2a-116">You schedule a fiber by switching to it from another fiber.</span></span> <span data-ttu-id="85c2a-117">系統仍會排定要執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="85c2a-117">The system still schedules threads to run.</span></span> <span data-ttu-id="85c2a-118">當執行纖程的執行緒被優先佔用時，其目前正在執行的光纖會被佔用，但仍保持選取狀態。</span><span class="sxs-lookup"><span data-stu-id="85c2a-118">When a thread running fibers is preempted, its currently running fiber is preempted but remains selected.</span></span> <span data-ttu-id="85c2a-119">選取的光纖會在其執行緒執行時執行。</span><span class="sxs-lookup"><span data-stu-id="85c2a-119">The selected fiber runs when its thread runs.</span></span>

<span data-ttu-id="85c2a-120">在排程第一個光纖之前，請先呼叫 [**ConvertThreadToFiber**](/windows/desktop/api/WinBase/nf-winbase-convertthreadtofiber) 函式來建立儲存光纖狀態資訊的區域。</span><span class="sxs-lookup"><span data-stu-id="85c2a-120">Before scheduling the first fiber, call the [**ConvertThreadToFiber**](/windows/desktop/api/WinBase/nf-winbase-convertthreadtofiber) function to create an area in which to save fiber state information.</span></span> <span data-ttu-id="85c2a-121">呼叫執行緒現在是目前正在執行的光纖。</span><span class="sxs-lookup"><span data-stu-id="85c2a-121">The calling thread is now the currently executing fiber.</span></span> <span data-ttu-id="85c2a-122">這個光纖的儲存狀態資訊包括以引數形式傳遞至 **ConvertThreadToFiber** 的光纖資料。</span><span class="sxs-lookup"><span data-stu-id="85c2a-122">The stored state information for this fiber includes the fiber data passed as an argument to **ConvertThreadToFiber**.</span></span>

<span data-ttu-id="85c2a-123">[**CreateFiber**](/windows/desktop/api/WinBase/nf-winbase-createfiber)函式是用來從現有的光纖建立新的光纖。呼叫需要堆疊大小、起始位址和光纖資料。</span><span class="sxs-lookup"><span data-stu-id="85c2a-123">The [**CreateFiber**](/windows/desktop/api/WinBase/nf-winbase-createfiber) function is used to create a new fiber from an existing fiber; the call requires the stack size, the starting address, and the fiber data.</span></span> <span data-ttu-id="85c2a-124">起始位址通常是使用者提供的函式，稱為「光纖函數」（ (光纖資料) 使用一個參數，且不會傳回值。</span><span class="sxs-lookup"><span data-stu-id="85c2a-124">The starting address is typically a user-supplied function, called the fiber function, that takes one parameter (the fiber data) and does not return a value.</span></span> <span data-ttu-id="85c2a-125">如果您的光纖函式傳回，則會結束執行光纖的執行緒。</span><span class="sxs-lookup"><span data-stu-id="85c2a-125">If your fiber function returns, the thread running the fiber exits.</span></span> <span data-ttu-id="85c2a-126">若要執行以 **CreateFiber** 建立的任何光纖，請呼叫 [**SwitchToFiber**](/windows/desktop/api/WinBase/nf-winbase-switchtofiber) 函數。</span><span class="sxs-lookup"><span data-stu-id="85c2a-126">To execute any fiber created with **CreateFiber**, call the [**SwitchToFiber**](/windows/desktop/api/WinBase/nf-winbase-switchtofiber) function.</span></span> <span data-ttu-id="85c2a-127">您可以使用不同執行緒所建立的光纖位址來呼叫 **SwitchToFiber** 。</span><span class="sxs-lookup"><span data-stu-id="85c2a-127">You can call **SwitchToFiber** with the address of a fiber created by a different thread.</span></span> <span data-ttu-id="85c2a-128">若要這樣做，您必須在呼叫 **CreateFiber** 時，將位址傳回至另一個執行緒，而且您必須使用適當的同步處理。</span><span class="sxs-lookup"><span data-stu-id="85c2a-128">To do this, you must have the address returned to the other thread when it called **CreateFiber** and you must use proper synchronization.</span></span>

<span data-ttu-id="85c2a-129">光纖可以藉由呼叫 [**GetFiberData**](/windows/win32/api/winnt/nf-winnt-getfiberdata) 宏來取出光纖資料。</span><span class="sxs-lookup"><span data-stu-id="85c2a-129">A fiber can retrieve the fiber data by calling the [**GetFiberData**](/windows/win32/api/winnt/nf-winnt-getfiberdata) macro.</span></span> <span data-ttu-id="85c2a-130">光纖可以在任何時間呼叫 [**GetCurrentFiber**](/windows/win32/api/winnt/nf-winnt-getcurrentfiber) 宏來取出光纖位址。</span><span class="sxs-lookup"><span data-stu-id="85c2a-130">A fiber can retrieve the fiber address at any time by calling the [**GetCurrentFiber**](/windows/win32/api/winnt/nf-winnt-getcurrentfiber) macro.</span></span>

## <a name="fiber-local-storage"></a><span data-ttu-id="85c2a-131">光纖本機儲存體</span><span class="sxs-lookup"><span data-stu-id="85c2a-131">Fiber Local Storage</span></span>

<span data-ttu-id="85c2a-132">光纖可以使用 *光纖本機儲存體* (FLS) 為每個光纖建立唯一的變數複本。</span><span class="sxs-lookup"><span data-stu-id="85c2a-132">A fiber can use *fiber local storage* (FLS) to create a unique copy of a variable for each fiber.</span></span> <span data-ttu-id="85c2a-133">如果未發生任何光纖切換，FLS 與 [執行緒區域儲存區](thread-local-storage.md)的行為完全相同。</span><span class="sxs-lookup"><span data-stu-id="85c2a-133">If no fiber switching occurs, FLS acts exactly the same as [thread local storage](thread-local-storage.md).</span></span> <span data-ttu-id="85c2a-134">FLS 函式 ([**FlsAlloc**](/windows/win32/api/fibersapi/nf-fibersapi-flsalloc)、 [**FlsFree**](/windows/win32/api/fibersapi/nf-fibersapi-flsfree)、 [**FlsGetValue**](/windows/win32/api/fibersapi/nf-fibersapi-flsgetvalue)和 [**FlsSetValue**](/windows/win32/api/fibersapi/nf-fibersapi-flssetvalue)) 操作與目前線程相關聯的 FLS。</span><span class="sxs-lookup"><span data-stu-id="85c2a-134">The FLS functions ([**FlsAlloc**](/windows/win32/api/fibersapi/nf-fibersapi-flsalloc), [**FlsFree**](/windows/win32/api/fibersapi/nf-fibersapi-flsfree), [**FlsGetValue**](/windows/win32/api/fibersapi/nf-fibersapi-flsgetvalue), and [**FlsSetValue**](/windows/win32/api/fibersapi/nf-fibersapi-flssetvalue)) manipulate the FLS associated with the current thread.</span></span> <span data-ttu-id="85c2a-135">如果執行緒正在執行光纖並切換光纖，FLS 也會一併切換。</span><span class="sxs-lookup"><span data-stu-id="85c2a-135">If the thread is executing a fiber and the fiber is switched, the FLS is also switched.</span></span>

<span data-ttu-id="85c2a-136">若要清除與光纖相關聯的資料，請呼叫 [**DeleteFiber**](/windows/desktop/api/WinBase/nf-winbase-deletefiber) 函數。</span><span class="sxs-lookup"><span data-stu-id="85c2a-136">To clean up the data associated with a fiber, call the [**DeleteFiber**](/windows/desktop/api/WinBase/nf-winbase-deletefiber) function.</span></span> <span data-ttu-id="85c2a-137">這項資料包括堆疊、暫存器的子集，以及光纖資料。</span><span class="sxs-lookup"><span data-stu-id="85c2a-137">This data includes the stack, a subset of the registers, and the fiber data.</span></span> <span data-ttu-id="85c2a-138">如果目前執行的光纖呼叫 **DeleteFiber**，它的執行緒會呼叫 [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) 並終止。</span><span class="sxs-lookup"><span data-stu-id="85c2a-138">If the currently running fiber calls **DeleteFiber**, its thread calls [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) and terminates.</span></span> <span data-ttu-id="85c2a-139">但是，如果選取的執行緒光纖是由另一個執行緒中執行的光纖所刪除，則具有已刪除之光纖的執行緒可能會異常終止，因為已釋放光纖堆疊。</span><span class="sxs-lookup"><span data-stu-id="85c2a-139">However, if the selected fiber of a thread is deleted by a fiber running in another thread, the thread with the deleted fiber is likely to terminate abnormally because the fiber stack has been freed.</span></span>

## <a name="related-topics"></a><span data-ttu-id="85c2a-140">相關主題</span><span class="sxs-lookup"><span data-stu-id="85c2a-140">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="85c2a-141">使用纖維</span><span class="sxs-lookup"><span data-stu-id="85c2a-141">Using Fibers</span></span>](using-fibers.md)
</dt> </dl>

 

 
