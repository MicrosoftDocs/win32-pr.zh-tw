---
description: 每個進程都有系統提供的預設堆積。 從堆積進行頻繁配置的應用程式，可以使用私用堆積來改善效能。
ms.assetid: cfb683fa-4f46-48b5-9a28-f4625a9cb8cd
title: 堆積函數
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d0e591c1e349ed6806cbebe00a178a99e63bb412
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "103849162"
---
# <a name="heap-functions"></a><span data-ttu-id="80466-104">堆積函數</span><span class="sxs-lookup"><span data-stu-id="80466-104">Heap Functions</span></span>

<span data-ttu-id="80466-105">每個進程都有系統提供的預設堆積。</span><span class="sxs-lookup"><span data-stu-id="80466-105">Each process has a default heap provided by the system.</span></span> <span data-ttu-id="80466-106">從堆積進行頻繁配置的應用程式，可以使用私用堆積來改善效能。</span><span class="sxs-lookup"><span data-stu-id="80466-106">Applications that make frequent allocations from the heap can improve performance by using private heaps.</span></span>

<span data-ttu-id="80466-107">私用堆積是呼叫進程的位址空間中一或多個頁面的區塊。</span><span class="sxs-lookup"><span data-stu-id="80466-107">A private heap is a block of one or more pages in the address space of the calling process.</span></span> <span data-ttu-id="80466-108">建立私用堆積之後，進程會使用 [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) 和 [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree) 等函數來管理該堆積中的記憶體。</span><span class="sxs-lookup"><span data-stu-id="80466-108">After creating the private heap, the process uses functions such as [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) and [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree) to manage the memory in that heap.</span></span>

<span data-ttu-id="80466-109">堆積函數也可以用來使用 [**GetProcessHeap**](/windows/desktop/api/HeapApi/nf-heapapi-getprocessheap) 函式所傳回的控制碼，在進程的預設堆積中管理記憶體。</span><span class="sxs-lookup"><span data-stu-id="80466-109">The heap functions can also be used to manage memory in the process's default heap, using the handle returned by the [**GetProcessHeap**](/windows/desktop/api/HeapApi/nf-heapapi-getprocessheap) function.</span></span> <span data-ttu-id="80466-110">新的應用程式應該使用堆積函式，而不是使用 [全域和區域](global-and-local-functions.md) 函式來進行這項工作。</span><span class="sxs-lookup"><span data-stu-id="80466-110">New applications should use the heap functions instead of the [global and local functions](global-and-local-functions.md) for this purpose.</span></span>

<span data-ttu-id="80466-111">從私用堆積配置的記憶體與使用其他記憶體配置函數配置的記憶體之間沒有任何差異。</span><span class="sxs-lookup"><span data-stu-id="80466-111">There is no difference between memory allocated from a private heap and that allocated by using the other memory allocation functions.</span></span> <span data-ttu-id="80466-112">如需函式的完整清單，請參閱 [記憶體管理函數](memory-management-functions.md)中的資料表。</span><span class="sxs-lookup"><span data-stu-id="80466-112">For a complete list of functions, see the table in [Memory Management Functions](memory-management-functions.md).</span></span>

> [!Note]  
> <span data-ttu-id="80466-113">執行緒應該只針對進程的預設堆積以及執行緒所建立和管理的私用堆積呼叫堆積函數，並使用 [**GetProcessHeap**](/windows/desktop/api/HeapApi/nf-heapapi-getprocessheap) 或 [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) 函數所傳回的控制碼。</span><span class="sxs-lookup"><span data-stu-id="80466-113">A thread should call heap functions only for the process's default heap and private heaps that the thread creates and manages, using handles returned by the [**GetProcessHeap**](/windows/desktop/api/HeapApi/nf-heapapi-getprocessheap) or [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) function.</span></span>

 

<span data-ttu-id="80466-114">[**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate)函式會建立私用堆積物件，呼叫進程可以使用 [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc)函數來配置記憶體區塊。</span><span class="sxs-lookup"><span data-stu-id="80466-114">The [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) function creates a private heap object from which the calling process can allocate memory blocks by using the [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) function.</span></span> <span data-ttu-id="80466-115">**HeapCreate** 指定堆積的初始大小和大小上限。</span><span class="sxs-lookup"><span data-stu-id="80466-115">**HeapCreate** specifies both an initial size and a maximum size for the heap.</span></span> <span data-ttu-id="80466-116">初始大小會決定一開始為堆積配置的認可、讀取/寫入頁面數目。</span><span class="sxs-lookup"><span data-stu-id="80466-116">The initial size determines the number of committed, read/write pages initially allocated for the heap.</span></span> <span data-ttu-id="80466-117">大小上限決定了保留的頁面總數。</span><span class="sxs-lookup"><span data-stu-id="80466-117">The maximum size determines the total number of reserved pages.</span></span> <span data-ttu-id="80466-118">這些頁面會在堆積可以成長的進程的虛擬位址空間中建立連續區塊。</span><span class="sxs-lookup"><span data-stu-id="80466-118">These pages create a contiguous block in the virtual address space of a process into which the heap can grow.</span></span> <span data-ttu-id="80466-119">如果 **HeapAlloc** 要求超過目前認可的頁面大小，則會自動從這個保留的空間認可其他頁面，但前提是它的實體儲存體可供使用。</span><span class="sxs-lookup"><span data-stu-id="80466-119">Additional pages are automatically committed from this reserved space if requests by **HeapAlloc** exceed the current size of committed pages, assuming that the physical storage for it is available.</span></span> <span data-ttu-id="80466-120">一旦頁面認可之後，就不會已取消認可這些頁面，直到進程終止，或呼叫 [**HeapDestroy**](/windows/desktop/api/HeapApi/nf-heapapi-heapdestroy) 函數來終結堆積為止。</span><span class="sxs-lookup"><span data-stu-id="80466-120">Once the pages are committed, they are not decommitted until the process is terminated or until the heap is destroyed by calling the [**HeapDestroy**](/windows/desktop/api/HeapApi/nf-heapapi-heapdestroy) function.</span></span>

<span data-ttu-id="80466-121">私用堆積物件的記憶體只能由建立它的進程存取。</span><span class="sxs-lookup"><span data-stu-id="80466-121">The memory of a private heap object is accessible only to the process that created it.</span></span> <span data-ttu-id="80466-122">如果動態連結程式庫 (DLL) 建立私用堆積，則會在呼叫 DLL 之進程的位址空間中執行此動作。</span><span class="sxs-lookup"><span data-stu-id="80466-122">If a dynamic-link library (DLL) creates a private heap, it does so in the address space of the process that called the DLL.</span></span> <span data-ttu-id="80466-123">只有該進程可以存取它。</span><span class="sxs-lookup"><span data-stu-id="80466-123">It is accessible only to that process.</span></span>

<span data-ttu-id="80466-124">[**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc)函式會從私用堆積配置指定的位元組數，並將指標傳回給配置的區塊。</span><span class="sxs-lookup"><span data-stu-id="80466-124">The [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) function allocates a specified number of bytes from a private heap and returns a pointer to the allocated block.</span></span> <span data-ttu-id="80466-125">此指標可以用於 [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree)、 [**HeapReAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heaprealloc)、 [**HeapSize**](/windows/desktop/api/HeapApi/nf-heapapi-heapsize)和 [**HeapValidate**](/windows/desktop/api/HeapApi/nf-heapapi-heapvalidate) 函數。</span><span class="sxs-lookup"><span data-stu-id="80466-125">This pointer can be used in the [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree), [**HeapReAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heaprealloc), [**HeapSize**](/windows/desktop/api/HeapApi/nf-heapapi-heapsize), and [**HeapValidate**](/windows/desktop/api/HeapApi/nf-heapapi-heapvalidate) functions.</span></span>

<span data-ttu-id="80466-126">[**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc)配置的記憶體不是可移動的。</span><span class="sxs-lookup"><span data-stu-id="80466-126">Memory allocated by [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) is not movable.</span></span> <span data-ttu-id="80466-127">在釋放或重新配置記憶體區塊之前， **HeapAlloc** 傳回的位址是有效的;記憶體區塊不需要鎖定。</span><span class="sxs-lookup"><span data-stu-id="80466-127">The address returned by **HeapAlloc** is valid until the memory block is freed or reallocated; the memory block does not need to be locked.</span></span>

<span data-ttu-id="80466-128">因為系統無法壓縮私用堆積，所以它可能會分散。</span><span class="sxs-lookup"><span data-stu-id="80466-128">Because the system cannot compact a private heap, it can become fragmented.</span></span> <span data-ttu-id="80466-129">以各種配置大小配置大量記憶體的應用程式，可以使用 [低片段堆積](low-fragmentation-heap.md) 來減少堆積片段。</span><span class="sxs-lookup"><span data-stu-id="80466-129">Applications that allocate large amounts of memory in various allocation sizes can use the [low-fragmentation heap](low-fragmentation-heap.md) to reduce heap fragmentation.</span></span>

<span data-ttu-id="80466-130">堆積函式的可能用途是在進程啟動時建立私用堆積，指定足夠的初始大小來滿足進程的記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="80466-130">A possible use for the heap functions is to create a private heap when a process starts up, specifying an initial size sufficient to satisfy the memory requirements of the process.</span></span> <span data-ttu-id="80466-131">如果對 [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) 函式的呼叫失敗，進程可以終止或通知使用者記憶體不足;但是，如果成功，進程就能確保記憶體需要。</span><span class="sxs-lookup"><span data-stu-id="80466-131">If the call to the [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) function fails, the process can terminate or notify the user of the memory shortage; if it succeeds, however, the process is assured of having the memory it needs.</span></span>

<span data-ttu-id="80466-132">[**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate)要求的記憶體不一定是連續的。</span><span class="sxs-lookup"><span data-stu-id="80466-132">Memory requested by [**HeapCreate**](/windows/desktop/api/HeapApi/nf-heapapi-heapcreate) may or may not be contiguous.</span></span> <span data-ttu-id="80466-133">[**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc)在堆積內配置的記憶體是連續的。</span><span class="sxs-lookup"><span data-stu-id="80466-133">Memory allocated within a heap by [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc) is contiguous.</span></span> <span data-ttu-id="80466-134">您不應該寫入或讀取堆積中的記憶體（除了由 **HeapAlloc** 所配置），也不應該假設 **HeapAlloc** 所配置的兩個記憶體區域之間有任何關聯性。</span><span class="sxs-lookup"><span data-stu-id="80466-134">You should not write to or read from memory in a heap except that allocated by **HeapAlloc**, nor should you assume any relationship between two areas of memory allocated by **HeapAlloc**.</span></span>

<span data-ttu-id="80466-135">您不應該以任何方式參考 [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree)已釋放的記憶體。</span><span class="sxs-lookup"><span data-stu-id="80466-135">You should not refer in any way to memory that has been freed by [**HeapFree**](/windows/desktop/api/HeapApi/nf-heapapi-heapfree).</span></span> <span data-ttu-id="80466-136">釋放記憶體之後，其中可能存在的任何資訊都會永久消失。</span><span class="sxs-lookup"><span data-stu-id="80466-136">After the memory is freed, any information that may have been in it is gone forever.</span></span> <span data-ttu-id="80466-137">如果您需要資訊，請勿釋放包含資訊的記憶體。</span><span class="sxs-lookup"><span data-stu-id="80466-137">If you require information, do not free memory containing the information.</span></span> <span data-ttu-id="80466-138">傳回記憶體 (資訊的函式呼叫，例如 [**HeapSize**](/windows/desktop/api/HeapApi/nf-heapapi-heapsize)) 可能無法搭配釋出的記憶體使用，因為它們可能會傳回假的資料。</span><span class="sxs-lookup"><span data-stu-id="80466-138">Function calls that return information about memory (such as [**HeapSize**](/windows/desktop/api/HeapApi/nf-heapapi-heapsize)) may not be used with freed memory, as they may return bogus data.</span></span>

<span data-ttu-id="80466-139">[**HeapDestroy**](/windows/desktop/api/HeapApi/nf-heapapi-heapdestroy)函式會終結私用堆積物件。</span><span class="sxs-lookup"><span data-stu-id="80466-139">The [**HeapDestroy**](/windows/desktop/api/HeapApi/nf-heapapi-heapdestroy) function destroys a private heap object.</span></span> <span data-ttu-id="80466-140">它會解除和釋放堆積物件的所有頁面，並使堆積的控制碼失效。</span><span class="sxs-lookup"><span data-stu-id="80466-140">It decommits and releases all the pages of the heap object, and it invalidates the handle to the heap.</span></span>

## <a name="related-topics"></a><span data-ttu-id="80466-141">相關主題</span><span class="sxs-lookup"><span data-stu-id="80466-141">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="80466-142">比較記憶體配置方法</span><span class="sxs-lookup"><span data-stu-id="80466-142">Comparing Memory Allocation Methods</span></span>](comparing-memory-allocation-methods.md)
</dt> </dl>

 

 



