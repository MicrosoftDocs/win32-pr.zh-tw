---
description: 進程所配置的所有記憶體都會使用記憶體配置函數 ( HeapAlloc、VirtualAlloc、GlobalAlloc 或 LocalAlloc) 僅供進程存取。
ms.assetid: b47200dc-6824-4fd8-8d9f-2aaa439a74ff
title: 配置的記憶體範圍
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b8d2db67a04c019683e737d0f9c581ce8d16b800
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104191504"
---
# <a name="scope-of-allocated-memory"></a><span data-ttu-id="2a79f-103">配置的記憶體範圍</span><span class="sxs-lookup"><span data-stu-id="2a79f-103">Scope of Allocated Memory</span></span>

<span data-ttu-id="2a79f-104">進程所配置的所有記憶體都會使用記憶體配置函數 ( [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc)、 [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)、 [**GlobalAlloc**](/windows/desktop/api/WinBase/nf-winbase-globalalloc)或 [**LocalAlloc**](/windows/desktop/api/WinBase/nf-winbase-localalloc)) 僅供進程存取。</span><span class="sxs-lookup"><span data-stu-id="2a79f-104">All memory a process allocates by using the memory allocation functions ( [**HeapAlloc**](/windows/desktop/api/HeapApi/nf-heapapi-heapalloc), [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [**GlobalAlloc**](/windows/desktop/api/WinBase/nf-winbase-globalalloc), or [**LocalAlloc**](/windows/desktop/api/WinBase/nf-winbase-localalloc)) is accessible only to the process.</span></span> <span data-ttu-id="2a79f-105">不過，DLL 配置的記憶體會配置在呼叫 DLL 之進程的位址空間中，且使用相同 DLL 無法存取其他進程。</span><span class="sxs-lookup"><span data-stu-id="2a79f-105">However, memory allocated by a DLL is allocated in the address space of the process that called the DLL and is not accessible to other processes using the same DLL.</span></span> <span data-ttu-id="2a79f-106">若要建立共用記憶體，您必須使用檔案對應。</span><span class="sxs-lookup"><span data-stu-id="2a79f-106">To create shared memory, you must use file mapping.</span></span>

<span data-ttu-id="2a79f-107">命名檔案對應提供簡單的方法來建立共用記憶體區塊。</span><span class="sxs-lookup"><span data-stu-id="2a79f-107">Named file mapping provides an easy way to create a block of shared memory.</span></span> <span data-ttu-id="2a79f-108">當進程使用 [**CreateFileMapping**](/windows/desktop/api/WinBase/nf-winbase-createfilemappinga) 函式來建立檔案對應物件時，可以指定名稱。</span><span class="sxs-lookup"><span data-stu-id="2a79f-108">A process can specify a name when it uses the [**CreateFileMapping**](/windows/desktop/api/WinBase/nf-winbase-createfilemappinga) function to create a file-mapping object.</span></span> <span data-ttu-id="2a79f-109">其他進程可以為 **CreateFileMapping** 或 [**OpenFileMapping**](/windows/desktop/api/WinBase/nf-winbase-openfilemappinga) 函式指定相同的名稱，以取得對應物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="2a79f-109">Other processes can specify the same name to either the **CreateFileMapping** or [**OpenFileMapping**](/windows/desktop/api/WinBase/nf-winbase-openfilemappinga) function to obtain a handle to the mapping object.</span></span>

<span data-ttu-id="2a79f-110">每個進程會在 [**MapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile) 函式中指定其檔案對應物件的控制碼，以將檔案的視圖對應到它自己的位址空間。</span><span class="sxs-lookup"><span data-stu-id="2a79f-110">Each process specifies its handle to the file-mapping object in the [**MapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile) function to map a view of the file into its own address space.</span></span> <span data-ttu-id="2a79f-111">單一檔案對應物件的所有進程的視圖都會對應到相同的可共用的實體儲存體頁面。</span><span class="sxs-lookup"><span data-stu-id="2a79f-111">The views of all processes for a single file-mapping object are mapped into the same sharable pages of physical storage.</span></span> <span data-ttu-id="2a79f-112">不過，除非使用 [**MapViewOfFileEx**](/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffileex) 函式將視圖對應到指定的位址，否則對應視圖的虛擬位址可能會從一個進程變更為另一個進程。</span><span class="sxs-lookup"><span data-stu-id="2a79f-112">However, the virtual addresses of the mapped views can vary from one process to another, unless the [**MapViewOfFileEx**](/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffileex) function is used to map the view at a specified address.</span></span> <span data-ttu-id="2a79f-113">雖然可共用，但用於對應檔案視圖的實體儲存體頁面並不是全域的，尚未對應檔案視圖的進程無法存取它們。</span><span class="sxs-lookup"><span data-stu-id="2a79f-113">Although sharable, the pages of physical storage used for a mapped file view are not global; they are not accessible to processes that have not mapped a view of the file.</span></span>

<span data-ttu-id="2a79f-114">藉由對應檔案的視圖所認可的任何頁面，會在最後一個處理常式的對應物件結束時釋出，或是藉由呼叫 [**UnmapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile) 函數來 unmaps 其觀點。</span><span class="sxs-lookup"><span data-stu-id="2a79f-114">Any pages committed by mapping a view of a file are released when the last process with a view of the mapping object either terminates or unmaps its view by calling the [**UnmapViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile) function.</span></span> <span data-ttu-id="2a79f-115">目前，指定的檔案 (是否已更新與對應物件相關聯的任何) 。</span><span class="sxs-lookup"><span data-stu-id="2a79f-115">At this time, the specified file (if any) associated with the mapping object is updated.</span></span> <span data-ttu-id="2a79f-116">您也可以藉由呼叫 [**FlushViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-flushviewoffile) 函數，強制更新指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="2a79f-116">A specified file can also be forced to update by calling the [**FlushViewOfFile**](/windows/win32/api/memoryapi/nf-memoryapi-flushviewoffile) function.</span></span>

<span data-ttu-id="2a79f-117">如需詳細資訊，請參閱檔案 [對應](file-mapping.md)。</span><span class="sxs-lookup"><span data-stu-id="2a79f-117">For more information, see [File Mapping](file-mapping.md).</span></span> <span data-ttu-id="2a79f-118">如需 DLL 中共用記憶體的範例，請參閱 [使用 Dynamic-Link 程式庫中的共用記憶體](../dlls/using-shared-memory-in-a-dynamic-link-library.md)。</span><span class="sxs-lookup"><span data-stu-id="2a79f-118">For an example of shared memory in a DLL, see [Using Shared Memory in a Dynamic-Link Library](../dlls/using-shared-memory-in-a-dynamic-link-library.md).</span></span>

<span data-ttu-id="2a79f-119">如果多個進程具有共用記憶體的寫入存取權，您就必須同步處理記憶體的存取。</span><span class="sxs-lookup"><span data-stu-id="2a79f-119">If multiple processes have write access to shared memory, you must synchronize access to the memory.</span></span> <span data-ttu-id="2a79f-120">如需詳細資訊，請參閱 [同步](../sync/synchronization.md)處理。</span><span class="sxs-lookup"><span data-stu-id="2a79f-120">For more information, see [Synchronization](../sync/synchronization.md).</span></span>

 

 
