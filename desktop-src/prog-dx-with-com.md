---
description: 使用 COM 進行 DirectX 程式設計。
title: 使用 COM 進行 DirectX 程式設計
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/26/2021
ms.locfileid: "103945533"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="fc10a-103">使用 COM 進行 DirectX 程式設計</span><span class="sxs-lookup"><span data-stu-id="fc10a-103">Programming DirectX with COM</span></span>

<span data-ttu-id="fc10a-104">Microsoft 元件物件模型 (COM) 是數種技術所使用的物件導向程式設計模型，包括大量的 DirectX API 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="fc10a-105">基於這個理由，您 (為 DirectX 開發人員) 在程式設計 DirectX 時，不一定要使用 COM。</span><span class="sxs-lookup"><span data-stu-id="fc10a-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="fc10a-106">使用 [COM 元件與 c + +/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) 的主題) 會示範如何使用 [c + +/WinRT](/windows/uwp/cpp-and-winrt-apis/) (和任何 COM API 來使用 DirectX api。</span><span class="sxs-lookup"><span data-stu-id="fc10a-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="fc10a-107">這是目前最方便使用和建議使用的技術。</span><span class="sxs-lookup"><span data-stu-id="fc10a-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="fc10a-108">或者，您也可以使用原始的 COM，這就是本主題的內容。</span><span class="sxs-lookup"><span data-stu-id="fc10a-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="fc10a-109">您將需要對使用 COM Api 的原則和程式設計技術有基本的瞭解。</span><span class="sxs-lookup"><span data-stu-id="fc10a-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="fc10a-110">雖然 COM 的聲譽很困難且複雜，但大部分 DirectX 應用程式所需的 COM 程式設計很簡單。</span><span class="sxs-lookup"><span data-stu-id="fc10a-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="fc10a-111">在部分情況下，這是因為您將使用 DirectX 提供的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="fc10a-112">您不需要撰寫自己的 COM 物件，這通常會發生複雜度。</span><span class="sxs-lookup"><span data-stu-id="fc10a-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="fc10a-113">COM 元件總覽</span><span class="sxs-lookup"><span data-stu-id="fc10a-113">COM component overview</span></span>

<span data-ttu-id="fc10a-114">COM 物件基本上是功能的封裝元件，可供應用程式用來執行一或多個工作。</span><span class="sxs-lookup"><span data-stu-id="fc10a-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="fc10a-115">針對部署，會將一或多個 COM 元件封裝成稱為 COM 伺服器的二進位檔;通常比 DLL 更多。</span><span class="sxs-lookup"><span data-stu-id="fc10a-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="fc10a-116">傳統的 DLL 會匯出免費的函式。</span><span class="sxs-lookup"><span data-stu-id="fc10a-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="fc10a-117">COM 伺服器可以這樣做。</span><span class="sxs-lookup"><span data-stu-id="fc10a-117">A COM server can do the same.</span></span> <span data-ttu-id="fc10a-118">但是 COM 伺服器內的 COM 元件會公開 COM 介面和屬於這些介面的成員方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="fc10a-119">您的應用程式會建立 COM 元件的實例、從中抓取介面，以及在這些介面上呼叫方法，以受益于 COM 元件中所執行的功能。</span><span class="sxs-lookup"><span data-stu-id="fc10a-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="fc10a-120">在實務上，這似乎類似于在一般 c + + 物件上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="fc10a-121">但有一些差異。</span><span class="sxs-lookup"><span data-stu-id="fc10a-121">But there are some differences.</span></span>

- <span data-ttu-id="fc10a-122">COM 物件會強制執行比 c + + 物件更嚴格的封裝。</span><span class="sxs-lookup"><span data-stu-id="fc10a-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="fc10a-123">您無法只建立物件，然後呼叫任何公用方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="fc10a-124">相反地，COM 元件的公用方法會分組為一或多個 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="fc10a-125">若要呼叫方法，您可以建立物件，並從物件取出實作為方法的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="fc10a-126">介面通常會執行一組相關的方法，以提供物件特定功能的存取權。</span><span class="sxs-lookup"><span data-stu-id="fc10a-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="fc10a-127">例如， [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) 介面代表一個虛擬圖形介面卡，其中包含可讓您建立資源的方法，例如，以及許多其他與介面卡相關的工作。</span><span class="sxs-lookup"><span data-stu-id="fc10a-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="fc10a-128">COM 物件的建立方式與 c + + 物件的方式相同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="fc10a-129">有幾種方式可以建立 COM 物件，但全都牽涉到 COM 專屬的技巧。</span><span class="sxs-lookup"><span data-stu-id="fc10a-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="fc10a-130">DirectX API 包含各種協助程式函式和方法，可簡化大部分的 DirectX COM 物件的建立工作。</span><span class="sxs-lookup"><span data-stu-id="fc10a-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="fc10a-131">您必須使用 COM 特定的技術來控制 COM 物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="fc10a-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="fc10a-132">COM 伺服器 (通常不需要明確載入 DLL) 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="fc10a-133">您也可以連結到靜態程式庫，以便使用 COM 元件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="fc10a-134">每個 COM 元件都有唯一的註冊識別碼 (全域唯一識別碼或 GUID) ，您的應用程式會使用此識別碼來識別 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="fc10a-135">您的應用程式會識別元件，而 COM 執行時間會自動載入正確的 COM 伺服器 DLL。</span><span class="sxs-lookup"><span data-stu-id="fc10a-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="fc10a-136">COM 是二進位規格。</span><span class="sxs-lookup"><span data-stu-id="fc10a-136">COM is a binary specification.</span></span> <span data-ttu-id="fc10a-137">您可以使用各種語言來撰寫和存取 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="fc10a-138">您不需要知道物件原始程式碼的任何相關資訊。</span><span class="sxs-lookup"><span data-stu-id="fc10a-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="fc10a-139">例如，Visual Basic 的應用程式會定期使用以 c + + 撰寫的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="fc10a-140">元件、物件和介面</span><span class="sxs-lookup"><span data-stu-id="fc10a-140">Component, object, and interface</span></span>

<span data-ttu-id="fc10a-141">請務必瞭解元件、物件和介面之間的差異。</span><span class="sxs-lookup"><span data-stu-id="fc10a-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="fc10a-142">在偶爾使用的情況下，您可能會聽到其主體介面名稱所參考的元件或物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="fc10a-143">但是這些詞彙不是可互換的。</span><span class="sxs-lookup"><span data-stu-id="fc10a-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="fc10a-144">元件可以執行任意數目的介面;而物件是元件的實例。</span><span class="sxs-lookup"><span data-stu-id="fc10a-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="fc10a-145">例如，雖然所有元件都必須執行 [**IUnknown 介面**](/windows/desktop/api/unknwn/nn-unknwn-iunknown)，但它們通常會執行至少一個額外的介面，而且它們可能會實作為多個介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="fc10a-146">若要使用特定的介面方法，您不能只具現化物件，您也必須從它取得正確的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="fc10a-147">此外，有一個以上的元件可能會執行相同的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="fc10a-148">介面是一組方法，可執行邏輯相關的作業集合。</span><span class="sxs-lookup"><span data-stu-id="fc10a-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="fc10a-149">介面定義只會指定方法的語法及其一般功能。</span><span class="sxs-lookup"><span data-stu-id="fc10a-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="fc10a-150">任何需要支援一組特定作業的 COM 元件都可以藉由執行適當的介面來執行此作業。</span><span class="sxs-lookup"><span data-stu-id="fc10a-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="fc10a-151">某些介面具有高度特製化，而且只能由單一元件執行;其他在各種情況下都很有用，而且是由許多元件所執行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="fc10a-152">如果元件會執行介面，則必須支援介面定義中的每個方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="fc10a-153">換句話說，您必須能夠呼叫任何方法，並確信它存在。</span><span class="sxs-lookup"><span data-stu-id="fc10a-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="fc10a-154">不過，特定方法的執行方式詳細資料可能會與另一個元件不同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="fc10a-155">例如，不同的元件可能會使用不同的演算法來到達最終結果。</span><span class="sxs-lookup"><span data-stu-id="fc10a-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="fc10a-156">也不保證會以重要的方式支援方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="fc10a-157">有時候，元件會實作為常用的介面，但它只需要支援方法的子集。</span><span class="sxs-lookup"><span data-stu-id="fc10a-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="fc10a-158">您仍然可以成功呼叫其餘的方法，但是會傳回 [**HRESULT**](#hresult-values) (，這是代表結果碼的標準 COM 型別，) 包含 **E_NOTIMPL** 值的結果碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="fc10a-159">您應該參考其檔，以查看介面如何由任何特定元件來執行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="fc10a-160">COM 標準需要介面定義在發行之後不能變更。</span><span class="sxs-lookup"><span data-stu-id="fc10a-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="fc10a-161">例如，作者無法將新的方法加入至現有的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="fc10a-162">作者必須改為建立新的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-162">The author must instead create a new interface.</span></span> <span data-ttu-id="fc10a-163">雖然該介面中的方法沒有任何限制，但常見的作法是讓下一代介面包含舊介面方法的所有方法，再加上任何新的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="fc10a-164">介面不尋常有數個層代。</span><span class="sxs-lookup"><span data-stu-id="fc10a-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="fc10a-165">一般而言，所有世代的執行基本上都是相同的整體工作，但它們在細節方面不同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="fc10a-166">COM 元件通常會在每個目前和先前產生的指定介面歷程中進行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="fc10a-167">這麼做可讓較舊的應用程式繼續使用物件的舊版介面，而較新的應用程式可以利用較新介面的功能。</span><span class="sxs-lookup"><span data-stu-id="fc10a-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="fc10a-168">一般而言，介面的下降群組全都具有相同的名稱，加上指出世代的整數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="fc10a-169">例如，如果原始介面命名為 **IMyInterface** (意指第1代) ，則接下來的兩個層代會稱為 **IMyInterface2** 和 **IMyInterface3**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="fc10a-170">在 DirectX 介面的情況下，後續的世代通常會命名為 DirectX 的版本號碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="fc10a-171">GUID</span><span class="sxs-lookup"><span data-stu-id="fc10a-171">GUIDs</span></span>

<span data-ttu-id="fc10a-172">Guid 是 COM 程式設計模型的重要部分。</span><span class="sxs-lookup"><span data-stu-id="fc10a-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="fc10a-173">在最基本的情況下，GUID 是128位的結構。</span><span class="sxs-lookup"><span data-stu-id="fc10a-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="fc10a-174">不過，Guid 的建立方式，是為了保證兩個 Guid 都不相同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="fc10a-175">COM 會將 Guid 廣泛使用於兩個主要用途。</span><span class="sxs-lookup"><span data-stu-id="fc10a-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="fc10a-176">唯一識別特定的 COM 元件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="fc10a-177">指派用來識別 COM 元件的 GUID 稱為)  (CLSID 的識別碼，當您想要建立相關聯之 COM 元件的實例時，可以使用 CLSID。</span><span class="sxs-lookup"><span data-stu-id="fc10a-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="fc10a-178">唯一識別特定的 COM 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="fc10a-179">指派用來識別 COM 介面的 GUID 稱為 (IID) 的介面識別碼，當您從元件的實例要求特定介面時，您會使用 IID)  (物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="fc10a-180">無論哪個元件會執行介面，介面的 IID 都會相同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="fc10a-181">為了方便起見，DirectX 檔通常會以描述性名稱參考元件和介面 (例如， **ID3D12Device**) ，而不是其 guid。</span><span class="sxs-lookup"><span data-stu-id="fc10a-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="fc10a-182">在 DirectX 檔的內容中，不會有任何混淆。</span><span class="sxs-lookup"><span data-stu-id="fc10a-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="fc10a-183">技術上來說，協力廠商有可能會以描述性名稱 **ID3D12Device** 來撰寫介面 (必須有不同的 IID 才能成為有效的) 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="fc10a-184">不過，為了清楚起見，我們不建議這麼做。</span><span class="sxs-lookup"><span data-stu-id="fc10a-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="fc10a-185">因此，唯一參考特定物件或介面的唯一方法是透過其 GUID。</span><span class="sxs-lookup"><span data-stu-id="fc10a-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="fc10a-186">雖然 GUID 是一個結構，但是 GUID 通常是以對等字串形式來表示。</span><span class="sxs-lookup"><span data-stu-id="fc10a-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="fc10a-187">GUID 字串形式的一般格式為32十六進位數位，格式為8-4-4-4-12。</span><span class="sxs-lookup"><span data-stu-id="fc10a-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="fc10a-188">也就是 {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}，其中每個 x 都對應到一個十六進位數位。</span><span class="sxs-lookup"><span data-stu-id="fc10a-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="fc10a-189">例如， **ID3D12Device** 介面的 IID 字串形式為 {189819F1-1DB6-4B57-BE54-1821339B85F7}。</span><span class="sxs-lookup"><span data-stu-id="fc10a-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="fc10a-190">因為實際的 GUID 有點笨拙，而且很容易出錯，所以通常也會提供對等的名稱。</span><span class="sxs-lookup"><span data-stu-id="fc10a-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="fc10a-191">在您的程式碼中，當您呼叫函式時（例如，當您將參數的引數傳遞給 D3D12CreateDevice），就可以使用這個名稱來取代實際的結構 `riid` 。 [](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice)</span><span class="sxs-lookup"><span data-stu-id="fc10a-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="fc10a-192">慣例命名慣例是分別在介面或物件的描述性名稱前面加上 IID_ 或 CLSID_。</span><span class="sxs-lookup"><span data-stu-id="fc10a-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="fc10a-193">例如， **ID3D12Device** 介面的 IID 名稱是 IID_ID3D12Device。</span><span class="sxs-lookup"><span data-stu-id="fc10a-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="fc10a-194">DirectX 應用程式應與 ``dxguid.lib`` 和連結， ``uuid.lib`` 以提供各種介面和類別 guid 的定義。</span><span class="sxs-lookup"><span data-stu-id="fc10a-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="fc10a-195">Visual C++ 和其他編譯器支援 **__uuidof** 運算子語言延伸模組，但與這些程式庫的明確 C 樣式連結也受到支援且可完整移植。</span><span class="sxs-lookup"><span data-stu-id="fc10a-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="fc10a-196">HRESULT 值</span><span class="sxs-lookup"><span data-stu-id="fc10a-196">HRESULT values</span></span>

<span data-ttu-id="fc10a-197">大部分的 COM 方法會傳回稱為 **HRESULT** 的32位整數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="fc10a-198">使用大部分的方法時，HRESULT 基本上是包含兩個主要資訊片段的結構。</span><span class="sxs-lookup"><span data-stu-id="fc10a-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="fc10a-199">方法是否成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="fc10a-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="fc10a-200">方法所執行之作業結果的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="fc10a-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="fc10a-201">某些方法會從所定義的標準集傳回 **HRESULT** 值 `Winerror.h` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="fc10a-202">但是，方法可以用來傳回自訂的 **HRESULT** 值，並提供更多特製化的資訊。</span><span class="sxs-lookup"><span data-stu-id="fc10a-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="fc10a-203">這些值通常會記載在方法的參考頁面上。</span><span class="sxs-lookup"><span data-stu-id="fc10a-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="fc10a-204">您在方法參考頁面上找到的 **HRESULT** 值清單通常只是可能傳回的可能值子集。</span><span class="sxs-lookup"><span data-stu-id="fc10a-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="fc10a-205">此清單通常只會涵蓋方法特有的值，以及具有某些特定方法意義的標準值。</span><span class="sxs-lookup"><span data-stu-id="fc10a-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="fc10a-206">您應該假設某個方法可能會傳回各種標準 **HRESULT** 值，即使這些值未明確記載也是一樣。</span><span class="sxs-lookup"><span data-stu-id="fc10a-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="fc10a-207">雖然 **HRESULT** 值通常用來傳回錯誤資訊，但您不應該將它們視為錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="fc10a-208">表示成功或失敗的位會與包含詳細資訊的位分開儲存，讓 **HRESULT** 值具有任何數目的成功和失敗代碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="fc10a-209">依照慣例，成功碼的名稱前面會加上 S_ 和失敗代碼，E_。</span><span class="sxs-lookup"><span data-stu-id="fc10a-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="fc10a-210">例如，兩個最常使用的程式碼是 S_OK 並 E_FAIL，分別表示簡單的成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="fc10a-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="fc10a-211">COM 方法可能會傳回各種成功或失敗的程式碼，這表示您必須小心測試 **HRESULT** 值。</span><span class="sxs-lookup"><span data-stu-id="fc10a-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="fc10a-212">例如，假設有一個假設性的方法，其中包含已記載的 S_OK 的傳回值，如果成功，則 E_FAIL。</span><span class="sxs-lookup"><span data-stu-id="fc10a-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="fc10a-213">不過，請記住，此方法可能也會傳回其他失敗或成功碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="fc10a-214">下列程式碼片段說明使用簡單測試的風險，其中 `hr` 包含方法所傳回的 **HRESULT** 值。</span><span class="sxs-lookup"><span data-stu-id="fc10a-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="fc10a-215">只要在失敗的情況下，此方法只會傳回 E_FAIL (，而不是) 其他失敗代碼，則這項測試會正常運作。</span><span class="sxs-lookup"><span data-stu-id="fc10a-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="fc10a-216">但是，為了傳回一組特定的失敗代碼（可能是 E_NOTIMPL 或 E_INVALIDARG），會更實際地執行指定的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="fc10a-217">使用上述程式碼，這些值將會不正確地解讀為成功。</span><span class="sxs-lookup"><span data-stu-id="fc10a-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="fc10a-218">如果您需要有關方法呼叫結果的詳細資訊，您需要測試每個相關的 **HRESULT** 值。</span><span class="sxs-lookup"><span data-stu-id="fc10a-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="fc10a-219">不過，您可能只對方法是否成功或失敗感興趣。</span><span class="sxs-lookup"><span data-stu-id="fc10a-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="fc10a-220">測試 **HRESULT** 值是否會指出成功或失敗的健全方式，是將值傳遞至下列其中一個在 winerror.h 中定義的宏。</span><span class="sxs-lookup"><span data-stu-id="fc10a-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="fc10a-221">`SUCCEEDED`宏會針對成功碼傳回 TRUE，並針對失敗碼傳回 FALSE。</span><span class="sxs-lookup"><span data-stu-id="fc10a-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="fc10a-222">`FAILED`針對失敗代碼，宏會傳回 TRUE，若為成功碼，則會傳回 FALSE。</span><span class="sxs-lookup"><span data-stu-id="fc10a-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="fc10a-223">因此，您可以使用宏來修正上述程式碼片段 `FAILED` ，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="fc10a-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="fc10a-224">此更正的程式碼片段會適當地將 E_NOTIMPL 和 E_INVALIDARG 視為失敗。</span><span class="sxs-lookup"><span data-stu-id="fc10a-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="fc10a-225">雖然大部分的 COM 方法會傳回結構化的 **hresult** 值，但較小的數位會使用 **HRESULT** 傳回簡單的整數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="fc10a-226">這些方法一律會成功。</span><span class="sxs-lookup"><span data-stu-id="fc10a-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="fc10a-227">如果您將此排序的 **HRESULT** 傳遞至成功的宏，則宏一律會傳回 TRUE。</span><span class="sxs-lookup"><span data-stu-id="fc10a-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="fc10a-228">不會傳回 **HRESULT** 的一般呼叫方法範例是 **IUnknown：： Release** 方法，它會傳回 ULONG。</span><span class="sxs-lookup"><span data-stu-id="fc10a-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="fc10a-229">這個方法會將物件的參考計數遞減1，並傳回目前的參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="fc10a-230">如需參考計數的討論，請參閱 [管理 COM 物件的存留期](#managing-a-com-objects-lifetime) 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="fc10a-231">指標的位址</span><span class="sxs-lookup"><span data-stu-id="fc10a-231">The address of a pointer</span></span>

<span data-ttu-id="fc10a-232">如果您看到幾個 COM 方法參考頁面，您可能會在類似下面的內容上執行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="fc10a-233">雖然 C/c + + 開發人員很熟悉一般指標，但 COM 通常會使用額外的間接取值層級。</span><span class="sxs-lookup"><span data-stu-id="fc10a-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="fc10a-234">第二個層級的間接取值是由兩個星號（在類型宣告之後）來表示， `**` 而變數名稱通常會有前置詞 `pp` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="fc10a-235">針對上面的函式， `ppDevice` 參數通常稱為 void 的指標位址。</span><span class="sxs-lookup"><span data-stu-id="fc10a-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="fc10a-236">實際上，在此範例中， `ppDevice` 是 **ID3D12Device** 介面指標的位址。</span><span class="sxs-lookup"><span data-stu-id="fc10a-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="fc10a-237">與 c + + 物件不同的是，您不會直接存取 COM 物件的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="fc10a-238">您必須改為取得介面的指標，該介面會公開方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="fc10a-239">若要叫用方法，基本上使用的語法與叫用 c + + 方法指標的語法相同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="fc10a-240">例如，若要叫用 **IMyInterface：:D osomething** 方法，您可以使用下列語法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="fc10a-241">第二層間接取值的需求來自于您未直接建立介面指標的事實。</span><span class="sxs-lookup"><span data-stu-id="fc10a-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="fc10a-242">您必須呼叫其中一種方法，例如上面所示的 **D3D12CreateDevice** 方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="fc10a-243">若要使用這類方法來取得介面指標，您可以將變數宣告為所需介面的指標，然後將該變數的位址傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="fc10a-244">換句話說，您會將指標的位址傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="fc10a-245">當方法傳回時，變數會指向要求的介面，您可以使用該指標來呼叫任何介面的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="fc10a-246">建立 COM 物件</span><span class="sxs-lookup"><span data-stu-id="fc10a-246">Creating a COM object</span></span>

<span data-ttu-id="fc10a-247">建立 COM 物件的方式有好幾種。</span><span class="sxs-lookup"><span data-stu-id="fc10a-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="fc10a-248">這些是 DirectX 程式設計中最常使用的兩個。</span><span class="sxs-lookup"><span data-stu-id="fc10a-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="fc10a-249">間接地呼叫為您建立物件的 DirectX 方法或函式。</span><span class="sxs-lookup"><span data-stu-id="fc10a-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="fc10a-250">方法會建立物件，並傳回物件上的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="fc10a-251">當您以這種方式建立物件時，有時您可以指定應該傳回的介面，其他時候則會隱含介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="fc10a-252">上述程式碼範例顯示如何間接建立 Direct3D 12 裝置 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="fc10a-253">直接將物件的 CLSID 傳遞至 [**CoCreateInstance 函數**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance)。</span><span class="sxs-lookup"><span data-stu-id="fc10a-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="fc10a-254">此函式會建立物件的實例，並將指標傳回您指定的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="fc10a-255">一次，在您建立任何 COM 物件之前，必須先呼叫 [**CoInitializeEx 函數**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)來初始化 com。</span><span class="sxs-lookup"><span data-stu-id="fc10a-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="fc10a-256">如果您要間接建立物件，則物件建立方法會處理這項工作。</span><span class="sxs-lookup"><span data-stu-id="fc10a-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="fc10a-257">但是，如果您需要建立具有 **CoCreateInstance** 的物件，則必須明確呼叫 **CoInitializeEx** 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="fc10a-258">當您完成時，COM 必須藉由呼叫 [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize)來解除初始化。</span><span class="sxs-lookup"><span data-stu-id="fc10a-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="fc10a-259">如果您對 **CoInitializeEx** 進行呼叫，則必須與 **CoUninitialize** 的呼叫相符。</span><span class="sxs-lookup"><span data-stu-id="fc10a-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="fc10a-260">一般而言，需要明確初始化 COM 的應用程式會在其啟動常式中進行，並在其清除常式中將 COM 解除初始化。</span><span class="sxs-lookup"><span data-stu-id="fc10a-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="fc10a-261">若要使用 **CoCreateInstance** 來建立 COM 物件的新實例，您必須擁有物件的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="fc10a-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="fc10a-262">如果此 CLSID 可公開取得，您將會在參考檔或適當的標頭檔中找到它。</span><span class="sxs-lookup"><span data-stu-id="fc10a-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="fc10a-263">如果 CLSID 無法公開使用，則您無法直接建立物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="fc10a-264">**CoCreateInstance** 函數有五個參數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="fc10a-265">針對您將搭配 DirectX 使用的 COM 物件，您通常可以依照下列方式設定參數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="fc10a-266">*rclsid* 將此設定為您想要建立之物件的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="fc10a-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="fc10a-267">*pUnkOuter* 設定為 `nullptr` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="fc10a-268">只有當您要匯總物件時，才會使用這個參數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="fc10a-269">COM 匯總的討論已超出本主題的範圍。</span><span class="sxs-lookup"><span data-stu-id="fc10a-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="fc10a-270">*dwClsCoNtext* 設定為 CLSCTX_INPROC_SERVER。</span><span class="sxs-lookup"><span data-stu-id="fc10a-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="fc10a-271">這項設定表示物件會實作為 DLL，並在您的應用程式進程中執行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="fc10a-272">*riid* 設定為您想要傳回之介面的 IID。</span><span class="sxs-lookup"><span data-stu-id="fc10a-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="fc10a-273">函式會建立物件，並在 ppv 參數中傳回要求的介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="fc10a-274">*ppv* 將此設定為指標的位址，這個指標會設定為函式傳回時所指定的介面 `riid` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="fc10a-275">此變數應宣告為所要求介面的指標，而參數清單中指標的參考應轉換為 (LPVOID \* ) 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="fc10a-276">間接建立物件通常很簡單，如上述程式碼範例中所見。</span><span class="sxs-lookup"><span data-stu-id="fc10a-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="fc10a-277">您可以將物件建立方法傳遞給介面指標的位址，然後方法會建立物件並傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="fc10a-278">當您間接建立物件時，即使您無法選擇該方法所傳回的介面，通常仍然可以指定如何建立物件的各種相關事項。</span><span class="sxs-lookup"><span data-stu-id="fc10a-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="fc10a-279">例如，您可以傳遞給 **D3D12CreateDevice** 值，指定所傳回裝置應該支援的最小 D3D 功能等級，如上述程式碼範例所示。</span><span class="sxs-lookup"><span data-stu-id="fc10a-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="fc10a-280">使用 COM 介面</span><span class="sxs-lookup"><span data-stu-id="fc10a-280">Using COM interfaces</span></span>

<span data-ttu-id="fc10a-281">當您建立 COM 物件時，建立方法會傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="fc10a-282">然後，您可以使用該指標來存取任何介面的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="fc10a-283">語法與 c + + 方法的指標所使用的語法相同。</span><span class="sxs-lookup"><span data-stu-id="fc10a-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="fc10a-284">要求其他介面</span><span class="sxs-lookup"><span data-stu-id="fc10a-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="fc10a-285">在許多情況下，您從建立方法收到的介面指標可能是您唯一需要的介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="fc10a-286">事實上，物件只匯出 **IUnknown** 以外的一個介面相當常見。</span><span class="sxs-lookup"><span data-stu-id="fc10a-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="fc10a-287">不過，許多物件會匯出多個介面，而您可能需要其中一些介面的指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="fc10a-288">如果您需要的介面多於建立方法所傳回的介面，則不需要建立新的物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="fc10a-289">相反地，請使用物件的 [**IUnknown：： QueryInterface 方法**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))來要求另一個介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="fc10a-290">如果您使用 **CoCreateInstance** 建立物件，則可以要求 **iunknown** 介面指標，然後呼叫 **iunknown：： QueryInterface** 要求您需要的每個介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="fc10a-291">但是，如果您只需要單一介面，這種方法就很不方便，如果您使用的物件建立方法不允許您指定應該傳回的介面指標，則這種方法並不適用。</span><span class="sxs-lookup"><span data-stu-id="fc10a-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="fc10a-292">在實務上，您通常不需要取得明確的 **iunknown** 指標，因為所有的 COM 介面都會擴充 **iunknown** 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="fc10a-293">擴充介面在概念上類似于繼承自 c + + 類別。</span><span class="sxs-lookup"><span data-stu-id="fc10a-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="fc10a-294">子介面會公開所有父介面的方法，加上一或多個它自己的方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="fc10a-295">事實上，您通常會看到「繼承自」，而不是「擴充」。</span><span class="sxs-lookup"><span data-stu-id="fc10a-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="fc10a-296">您需要記住的是，繼承是物件內部的。</span><span class="sxs-lookup"><span data-stu-id="fc10a-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="fc10a-297">您的應用程式無法繼承或擴充物件的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="fc10a-298">不過，您可以使用子系介面呼叫子系或父系的任何方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="fc10a-299">因為所有介面都是 **IUnknown** 的子系，所以您可以在任何已有物件的介面指標上呼叫 **QueryInterface** 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="fc10a-300">當您這樣做時，必須提供所要求介面的 IID，以及當方法傳回時將包含介面指標的指標位址。</span><span class="sxs-lookup"><span data-stu-id="fc10a-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="fc10a-301">例如，下列程式碼片段會呼叫 **IDXGIFactory2：： CreateSwapChainForHwnd** 來建立主要交換鏈物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="fc10a-302">此物件會公開數個介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-302">This object exposes several interfaces.</span></span> <span data-ttu-id="fc10a-303">**CreateSwapChainForHwnd** 方法會傳回 **IDXGISwapChain1** 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="fc10a-304">後續的程式碼接著會使用 **IDXGISwapChain1** 介面來呼叫 **QueryInterface** ，以要求 **IDXGISwapChain3** 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="fc10a-305">在 c + + 中，您可以使用 ``IID_PPV_ARGS`` 宏，而不是明確的 IID 和 cast 指標： ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="fc10a-306">這通常用於建立方法和 **QueryInterface**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="fc10a-307">如需詳細資訊，請參閱[combaseapi。](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args)</span><span class="sxs-lookup"><span data-stu-id="fc10a-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="fc10a-308">管理 COM 物件的存留期</span><span class="sxs-lookup"><span data-stu-id="fc10a-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="fc10a-309">當建立物件時，系統會配置必要的記憶體資源。</span><span class="sxs-lookup"><span data-stu-id="fc10a-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="fc10a-310">當不再需要物件時，應該將它終結。</span><span class="sxs-lookup"><span data-stu-id="fc10a-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="fc10a-311">系統可以將該記憶體用於其他用途。</span><span class="sxs-lookup"><span data-stu-id="fc10a-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="fc10a-312">使用 c + + 物件時，您可以直接使用和運算子來控制物件的存留期 `new` `delete` ，因為您是在該層級運作，或是使用堆疊和範圍存留期。</span><span class="sxs-lookup"><span data-stu-id="fc10a-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="fc10a-313">COM 無法讓您直接建立或終結物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="fc10a-314">這項設計的原因是，相同的物件可能會由應用程式的多個部分使用，或在某些情況下由一個以上的應用程式使用。</span><span class="sxs-lookup"><span data-stu-id="fc10a-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="fc10a-315">如果其中一個參考是終結物件，則其他參考會變成無效。</span><span class="sxs-lookup"><span data-stu-id="fc10a-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="fc10a-316">相反地，COM 會使用參考計數系統來控制物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="fc10a-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="fc10a-317">物件的參考計數是它的其中一個介面已被要求的次數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="fc10a-318">每次要求介面時，參考計數就會遞增。</span><span class="sxs-lookup"><span data-stu-id="fc10a-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="fc10a-319">應用程式會在不再需要該介面時釋放介面，遞減參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="fc10a-320">只要參考計數大於零，物件就會保留在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="fc10a-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="fc10a-321">當參考計數到達零時，物件就會終結本身。</span><span class="sxs-lookup"><span data-stu-id="fc10a-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="fc10a-322">您不需要知道物件參考計數的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="fc10a-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="fc10a-323">只要您正確地取得和釋放物件的介面，物件將會有適當的存留期。</span><span class="sxs-lookup"><span data-stu-id="fc10a-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="fc10a-324">正確處理參考計數是 COM 程式設計的重要部分。</span><span class="sxs-lookup"><span data-stu-id="fc10a-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="fc10a-325">若未這麼做，可能會很容易造成記憶體流失或損毀。</span><span class="sxs-lookup"><span data-stu-id="fc10a-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="fc10a-326">COM 程式設計人員所做的最常見錯誤之一，就是無法釋放介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="fc10a-327">發生這種情況時，參考計數永遠不會到達零，而物件會無限期保留在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="fc10a-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="fc10a-328">Direct3D 10 或更新版本有稍微修改物件的存留期規則。</span><span class="sxs-lookup"><span data-stu-id="fc10a-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="fc10a-329">尤其是，衍生自 **ID3DxxDeviceChild** 的物件絕不會存留時間其父裝置 (也就是，如果擁有 **ID3DxxDevice** 叫用 0 refcount，則所有子物件也會立即無效，) 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="fc10a-330">此外，當您使用 **Set** 方法將物件系結至轉譯管線時，這些參考不會增加參考計數 (也就是) 的弱式參考。</span><span class="sxs-lookup"><span data-stu-id="fc10a-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="fc10a-331">在實務上，最好是在釋出裝置之前，確保您完全釋出所有裝置子物件。</span><span class="sxs-lookup"><span data-stu-id="fc10a-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="fc10a-332">遞增和遞減參考計數</span><span class="sxs-lookup"><span data-stu-id="fc10a-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="fc10a-333">每當您取得新的介面指標時，參考計數都必須透過呼叫 [**IUnknown：： AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref)來遞增。</span><span class="sxs-lookup"><span data-stu-id="fc10a-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="fc10a-334">不過，您的應用程式通常不需要呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="fc10a-335">如果您藉由呼叫物件建立方法或呼叫 **IUnknown：： QueryInterface** 來取得介面指標，則物件會自動遞增參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="fc10a-336">但是，如果您以其他方式建立介面指標，例如複製現有的指標，則您必須明確地呼叫 **IUnknown：： AddRef**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="fc10a-337">否則，當您釋出原始介面指標時，即使您仍然需要使用指標的複本，該物件仍可能會被破壞。</span><span class="sxs-lookup"><span data-stu-id="fc10a-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="fc10a-338">無論您或物件是否遞增參考計數，您都必須釋放所有介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="fc10a-339">當您不再需要介面指標時，請呼叫 [**IUnknown：： Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) 來遞減參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="fc10a-340">常見的作法是將所有介面指標初始化為 `nullptr` ，然後在釋放時將其設定回 `nullptr` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="fc10a-341">該慣例可讓您測試清除程式碼中的所有介面指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="fc10a-342">那些未處於作用 `nullptr` 中狀態，而且您必須在終止應用程式之前釋放它們。</span><span class="sxs-lookup"><span data-stu-id="fc10a-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="fc10a-343">下列程式碼片段會擴充稍早所示的範例，以說明如何處理參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="fc10a-344">COM 智慧型指標</span><span class="sxs-lookup"><span data-stu-id="fc10a-344">COM Smart Pointers</span></span>

<span data-ttu-id="fc10a-345">目前為止的程式碼已明確呼叫 ``Release`` 並 ``AddRef`` 使用 **IUnknown** 方法維護參考計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="fc10a-346">這種模式需要用心程式設計人員記住，才能在所有可能的 codepaths 中正確維護計數。</span><span class="sxs-lookup"><span data-stu-id="fc10a-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="fc10a-347">這可能會導致複雜的錯誤處理，而已啟用 c + + 例外狀況處理可能會特別難以實行。</span><span class="sxs-lookup"><span data-stu-id="fc10a-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="fc10a-348">使用 c + + 的較佳解決方案是利用 [智慧型指標](/cpp/cpp/smart-pointers-modern-cpp)。</span><span class="sxs-lookup"><span data-stu-id="fc10a-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="fc10a-349">**winrt：： com_ptr** 是 [c + +/WinRT 語言投影](/uwp/cpp-ref-for-winrt/com-ptr)提供的智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="fc10a-350">這是建議用於 UWP 應用程式的 COM 智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="fc10a-351">請注意，c + +/WinRT 需要 c + + 17。</span><span class="sxs-lookup"><span data-stu-id="fc10a-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="fc10a-352">**Microsoft：： WRL：： ComPtr** 是 [Windows 執行階段 C++ 範本庫 (WRL)](/cpp/cppcx/wrl/comptr-class)所提供的智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="fc10a-353">此程式庫是「純」 c + +，因此可用於透過 c + +/CX 或 c + +/WinRT) 以及傳統 Win32 桌面應用程式 (的 Windows 執行階段應用程式。</span><span class="sxs-lookup"><span data-stu-id="fc10a-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="fc10a-354">這個智慧型指標也適用于不支援 Windows 執行階段 Api 的較舊版本 Windows。</span><span class="sxs-lookup"><span data-stu-id="fc10a-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="fc10a-355">針對 Win32 桌面應用程式，您可以使用 ``#include <wrl/client.h>`` 僅包含此類別，並選擇性地定義預處理器符號 ``__WRL_CLASSIC_COM_STRICT__`` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="fc10a-356">如需詳細資訊，請參閱進行中的 [COM 智慧型指標](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited)。</span><span class="sxs-lookup"><span data-stu-id="fc10a-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="fc10a-357">**CComPtr** 是 [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class)所提供的智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="fc10a-358">**Microsoft：： WRL：： ComPtr** 是此實作為的較新版本，可解決一些微妙的使用問題，因此不建議在新的專案中使用這個智慧型指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="fc10a-359">如需詳細資訊，請參閱 [如何建立和使用 CComPtr 和 CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances)。</span><span class="sxs-lookup"><span data-stu-id="fc10a-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="fc10a-360">使用 ATL 搭配 DirectX 9</span><span class="sxs-lookup"><span data-stu-id="fc10a-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="fc10a-361">若要使用 Active Template Library (ATL) 搭配 DirectX 9，您必須重新定義 ATL 相容性的介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="fc10a-362">這可讓您正確地使用 **CComQIPtr** 類別，以取得介面的指標。</span><span class="sxs-lookup"><span data-stu-id="fc10a-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="fc10a-363">您會知道是否未重新定義 ATL 的介面，因為您會看到下列錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="fc10a-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="fc10a-364">下列程式碼範例說明如何定義 IDirectXFileData 介面。</span><span class="sxs-lookup"><span data-stu-id="fc10a-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="fc10a-365">重新定義介面之後，您必須使用 **attach** 方法將介面附加至所傳回的介面指標 **：:D irect3dcreate9**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="fc10a-366">如果沒有，則 **IDirect3D9** 介面將不會由智慧型指標類別正確釋放。</span><span class="sxs-lookup"><span data-stu-id="fc10a-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="fc10a-367">**CComPtr** 類別會在建立物件時，以及將介面指派給 **CComPtr** 類別時，在內部對介面指標呼叫 **IUnknown：： AddRef** 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="fc10a-368">若要避免洩漏介面指標，請不要對從 **：:D irect3dcreate9** 傳回的介面呼叫 \* \* IUnknown：： AddRef。</span><span class="sxs-lookup"><span data-stu-id="fc10a-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="fc10a-369">下列程式碼會適當地釋放介面，而不需要呼叫 **IUnknown：： AddRef**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="fc10a-370">使用先前的程式碼。</span><span class="sxs-lookup"><span data-stu-id="fc10a-370">Use the previous code.</span></span> <span data-ttu-id="fc10a-371">請勿使用下列程式碼，此程式碼會呼叫 **iunknown：： AddRef** 後面接著 **Iunknown：： Release**，而不會釋放由下列方法新增的參考 **：:D irect3dcreate9**。</span><span class="sxs-lookup"><span data-stu-id="fc10a-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="fc10a-372">請注意，這是在 Direct3D 9 中的唯一位置，您必須以這種方式使用 **附加** 方法。</span><span class="sxs-lookup"><span data-stu-id="fc10a-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="fc10a-373">如需 **CComPTR** 和 **CComQIPtr** 類別的詳細資訊，請參閱標頭檔中的定義 `Atlbase.h` 。</span><span class="sxs-lookup"><span data-stu-id="fc10a-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
