---
description: 有兩種類型的輸入/輸出 (i/o) 同步處理：同步 i/o 和非同步 i/o。 非同步 i/o 也稱為重迭 i/o。
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: 同步和非同步 i/o
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2021
ms.locfileid: "106985730"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="d2903-104">同步和非同步 i/o</span><span class="sxs-lookup"><span data-stu-id="d2903-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="d2903-105">另請參閱 [i/o 相關的範例應用程式](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io)。</span><span class="sxs-lookup"><span data-stu-id="d2903-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="d2903-106">有兩種類型的輸入/輸出 (i/o) 同步處理：同步 i/o 和非同步 i/o。</span><span class="sxs-lookup"><span data-stu-id="d2903-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="d2903-107">非同步 i/o 也稱為重迭 i/o。</span><span class="sxs-lookup"><span data-stu-id="d2903-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="d2903-108">在 *同步檔案 i/o* 中，執行緒會啟動 i/o 作業，並立即進入等候狀態，直到 i/o 要求完成為止。</span><span class="sxs-lookup"><span data-stu-id="d2903-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="d2903-109">執行非同步檔案 *i/o* 的執行緒會呼叫適當的函式，將 i/o 要求傳送到核心。</span><span class="sxs-lookup"><span data-stu-id="d2903-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="d2903-110">如果核心接受要求，呼叫執行緒會繼續處理另一個工作，直到核心向執行緒發出 i/o 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="d2903-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="d2903-111">然後，它會中斷其目前的工作，並視需要處理 i/o 作業的資料。</span><span class="sxs-lookup"><span data-stu-id="d2903-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="d2903-112">下圖說明這兩種同步處理類型。</span><span class="sxs-lookup"><span data-stu-id="d2903-112">The two synchronization types are illustrated in the following figure.</span></span>

![同步和非同步 i/o](images/fig2bedit.png)

<span data-ttu-id="d2903-114">在預期 i/o 要求需要花費大量時間的情況下，例如重新整理或備份大型資料庫或慢速的通訊連結時，非同步 i/o 通常是將處理效率優化的好方法。</span><span class="sxs-lookup"><span data-stu-id="d2903-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="d2903-115">不過，對於相對快速的 i/o 作業，處理核心 i/o 要求和核心信號的額外負荷，可能會使非同步 i/o 變得更小，特別是當需要進行許多快速的 i/o 作業時。</span><span class="sxs-lookup"><span data-stu-id="d2903-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="d2903-116">在此情況下，同步 i/o 會更好。</span><span class="sxs-lookup"><span data-stu-id="d2903-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="d2903-117">如何完成這些工作的機制和實行詳細資料，會根據所使用的裝置控制碼類型以及應用程式的特定需求而異。</span><span class="sxs-lookup"><span data-stu-id="d2903-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="d2903-118">換句話說，通常有多種方法可解決此問題。</span><span class="sxs-lookup"><span data-stu-id="d2903-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="d2903-119">同步和非同步 i/o 考慮</span><span class="sxs-lookup"><span data-stu-id="d2903-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="d2903-120">如果為同步 i/o 開啟檔案或裝置 (也就是未指定檔案 **\_ \_ 旗** 標重迭) ，後續對函式的呼叫（例如 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) ）可以封鎖呼叫執行緒的執行，直到發生下列其中一個事件為止：</span><span class="sxs-lookup"><span data-stu-id="d2903-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="d2903-121">在此範例中，i/o 作業 (完成，資料寫入) 。</span><span class="sxs-lookup"><span data-stu-id="d2903-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="d2903-122">發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="d2903-122">An I/O error occurs.</span></span> <span data-ttu-id="d2903-123"> (例如，管線已從另一端關閉。 ) </span><span class="sxs-lookup"><span data-stu-id="d2903-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="d2903-124">呼叫本身發生錯誤 (例如，一或多個參數) 無效。</span><span class="sxs-lookup"><span data-stu-id="d2903-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="d2903-125">進程中的另一個執行緒會使用封鎖執行緒的執行緒控制碼來呼叫 [**CancelSynchronousIo**](cancelsynchronousio-func.md) 函式，而此控制碼會終止該執行緒的 i/o 作業，而導致 i/o 作業失敗。</span><span class="sxs-lookup"><span data-stu-id="d2903-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="d2903-126">封鎖的執行緒由系統終止;例如，進程本身已終止，或另一個執行緒使用封鎖執行緒的控制碼呼叫 [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) 函式。</span><span class="sxs-lookup"><span data-stu-id="d2903-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="d2903-127"> (這通常視為最後手段，而不是良好的應用程式設計。 ) </span><span class="sxs-lookup"><span data-stu-id="d2903-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="d2903-128">在某些情況下，應用程式的設計和用途可能無法接受此延遲，因此應用程式設計人員應該考慮使用非同步 i/o 搭配適當的執行緒同步處理物件（例如 [i/o 完成埠](i-o-completion-ports.md)）。</span><span class="sxs-lookup"><span data-stu-id="d2903-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="d2903-129">如需有關執行緒同步處理的詳細資訊，請參閱 [關於同步](/windows/desktop/Sync/about-synchronization)處理。</span><span class="sxs-lookup"><span data-stu-id="d2903-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="d2903-130">進程會在 *dwFlagsAndAttributes* 參數中指定檔案 **旗標重 \_ \_** 迭旗標，以在呼叫 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea)時開啟非同步 i/o 的檔案。</span><span class="sxs-lookup"><span data-stu-id="d2903-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="d2903-131">如果未指定檔案旗標重迭，則會開啟檔案以進行同步 i/o。 **\_ \_**</span><span class="sxs-lookup"><span data-stu-id="d2903-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="d2903-132">開啟非同步 i/o 的檔案時，會將重 [**迭結構的**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) 指標傳遞至 [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) 和 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)的呼叫。</span><span class="sxs-lookup"><span data-stu-id="d2903-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="d2903-133">執行同步 i/o 時，呼叫 **ReadFile** 和 **WriteFile** 不需要此結構。</span><span class="sxs-lookup"><span data-stu-id="d2903-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="d2903-134">如果檔案或裝置開啟為非同步 i/o，則使用該控制碼的函式（例如 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) ）的後續呼叫通常會立即傳回，但可能也會以同步方式與封鎖的執行相關。</span><span class="sxs-lookup"><span data-stu-id="d2903-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="d2903-135">如需詳細資訊，請參閱 [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932)。</span><span class="sxs-lookup"><span data-stu-id="d2903-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="d2903-136">雖然 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) 是最常用來開啟檔案、磁片區、匿名管道和其他類似裝置的函式，但 i/o 作業也可以使用從其他系統物件 *轉換* 的控制碼來執行， [**例如通訊端**](/windows/desktop/api/winsock2/nf-winsock2-socket) 所建立的通訊端或 [**接受**](/windows/desktop/api/winsock2/nf-winsock2-accept) 函數。</span><span class="sxs-lookup"><span data-stu-id="d2903-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="d2903-137">藉由呼叫 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) 函數與檔案 **旗標 \_ \_ 備份 \_ 語義** 屬性，即可取得目錄物件的控制碼。</span><span class="sxs-lookup"><span data-stu-id="d2903-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="d2903-138">目錄控制碼幾乎不會用到，備份應用程式是通常會使用這些應用程式的幾個應用程式之一。</span><span class="sxs-lookup"><span data-stu-id="d2903-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="d2903-139">開啟非同步 i/o 的檔案物件之後，必須正確地建立及初始化重迭 [**的結構，**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 並將其傳遞至每個函式的呼叫，例如 [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) 和 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)。</span><span class="sxs-lookup"><span data-stu-id="d2903-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="d2903-140">在非同步讀取和寫入作業中使用重迭 [**的結構時，請**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) 記住下列事項：</span><span class="sxs-lookup"><span data-stu-id="d2903-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="d2903-141">在檔案物件的所有非同步 i/o 作業都完成之前，請勿解除配置或修改重 [**迭結構或**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 資料緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d2903-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="d2903-142">如果 [**您將重迭結構的**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 指標宣告為區域變數，請勿在檔案物件的所有非同步 i/o 作業都完成之前結束區域函數。</span><span class="sxs-lookup"><span data-stu-id="d2903-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="d2903-143">如果區域函式提前結束，則重迭 **的結構將** 會超出範圍，且在該函式之外遇到的任何 [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) 或 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) 函數將無法存取它。</span><span class="sxs-lookup"><span data-stu-id="d2903-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="d2903-144">您也可以建立事件，並將控制碼放在重迭 [**的結構中**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; [等候](/windows/desktop/Sync/wait-functions) 函式可用來等候 i/o 作業完成，方法是等候事件控制碼。</span><span class="sxs-lookup"><span data-stu-id="d2903-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="d2903-145">如先前所述，當使用非同步控制碼時，應用程式應該在決定何時釋放與該控制碼上指定之 i/o 作業相關聯的資源時，請小心。</span><span class="sxs-lookup"><span data-stu-id="d2903-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="d2903-146">如果將控制碼提前解除配置， [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) 或 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) 可能會不正確地報告 i/o 作業是否已完成。</span><span class="sxs-lookup"><span data-stu-id="d2903-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="d2903-147">此外， **WriteFile** 函式有時會傳回 **TRUE** ，並將 [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) 值設為 [ **錯誤 \_ 成功**]，即使它使用非同步控制碼 (也可以傳回 **FALSE** ，並將 **錯誤 \_ IO \_ 擱置**) 。</span><span class="sxs-lookup"><span data-stu-id="d2903-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="d2903-148">習慣同步 i/o 設計的程式設計師通常會釋出資料緩衝區資源，原因是 **TRUE** 和 **錯誤 \_ 成功** 表示作業已完成。</span><span class="sxs-lookup"><span data-stu-id="d2903-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="d2903-149">但是，如果 [i/o 完成埠](i-o-completion-ports.md) 與這個非同步控制碼搭配使用，即使 i/o 作業立即完成，也會傳送完成封包。</span><span class="sxs-lookup"><span data-stu-id="d2903-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="d2903-150">換言之，如果應用程式在 **WriteFile** 傳回 **TRUE** 之後，除了 i/o 完成埠常式中的 **錯誤 \_ 成功** ，也會有雙精度的錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="d2903-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="d2903-151">在此範例中，建議是讓完成埠常式完全負責這類資源的所有釋放作業。</span><span class="sxs-lookup"><span data-stu-id="d2903-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="d2903-152">系統不會在支援檔案指標的檔案和裝置的非同步控制碼上維護檔案指標 (也就是說，搜尋裝置) ，因此檔案位置必須傳遞至重 [**迭結構的**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 相關位移資料成員中的讀取和寫入功能。</span><span class="sxs-lookup"><span data-stu-id="d2903-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="d2903-153">如需詳細資訊，請參閱 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) 和 [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile)。</span><span class="sxs-lookup"><span data-stu-id="d2903-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="d2903-154">當讀取或寫入資料時，系統會維護同步控制碼的檔案指標位置，也可以使用 [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) 或 [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) 函數來更新。</span><span class="sxs-lookup"><span data-stu-id="d2903-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="d2903-155">應用程式也可以等候檔案控制代碼來同步處理完成 i/o 作業，但這麼做需要非常小心。</span><span class="sxs-lookup"><span data-stu-id="d2903-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="d2903-156">每次啟動 i/o 作業時，作業系統會將檔案控制代碼設定為未收到信號狀態。</span><span class="sxs-lookup"><span data-stu-id="d2903-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="d2903-157">每次完成 i/o 作業時，作業系統會將檔案控制代碼設定為已發出信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="d2903-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="d2903-158">因此，如果應用程式啟動兩個 i/o 作業，並等候檔案控制代碼，就無法在控制碼設為已發出信號的狀態時，判斷哪一項作業已完成。</span><span class="sxs-lookup"><span data-stu-id="d2903-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="d2903-159">如果應用程式必須在單一檔案上執行多個非同步 i/o 作業，則應該等候每個 i/o 作業 [**之特定重**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 迭結構中的事件控制碼，而不是在一般檔案控制代碼上。</span><span class="sxs-lookup"><span data-stu-id="d2903-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="d2903-160">若要取消所有暫止的非同步 i/o 作業，請使用下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="d2903-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="d2903-161">[**CancelIo**](cancelio.md)：此函式只會取消呼叫執行緒針對指定檔案控制代碼發出的作業。</span><span class="sxs-lookup"><span data-stu-id="d2903-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="d2903-162">[**CancelIoEx**](cancelioex-func.md)：此函式會取消執行緒針對指定的檔案控制代碼所發出的所有作業。</span><span class="sxs-lookup"><span data-stu-id="d2903-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="d2903-163">使用 [**CancelSynchronousIo**](cancelsynchronousio-func.md) 來取消暫止的同步 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="d2903-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="d2903-164">[**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex)和 [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex)函式可讓應用程式指定要執行的常式 (請在完成非同步 I/o 要求時參閱 [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) 。</span><span class="sxs-lookup"><span data-stu-id="d2903-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
