---
description: 層級1隨機鎖定的網路流量查看圖表、批次隨機鎖定，以及篩選隨機鎖定。
ms.assetid: 78830113-b18e-40c7-8ec4-8896dbc58030
title: 隨機鎖定範例
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ae8b8a0c5b04897ddc2fc8f2e3bdec20f2fdb02d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104513504"
---
# <a name="opportunistic-lock-examples"></a>隨機鎖定範例

下列範例會顯示資料和 SMB 訊息移動，因為會進行隨機鎖定並中斷。 請注意，用戶端可以快取檔案屬性資料和檔案資料。

也請注意，這些範例是以用戶端應用程式從遠端伺服器要求隨機鎖定的情況為基礎。 網路重新導向程式和遠端伺服器會自動起始這些程式，用戶端應用程式或應用程式不會直接介入。 這些範例所描述的程式可以一般化至本機用戶端應用程式直接從本機檔案系統要求隨機鎖定的情況，但不會涉及網路上的資料交換。

## <a name="level-1-opportunistic-lock"></a>層級1隨機鎖定

下圖顯示對檔案層級1隨機鎖定的網路流量查看。 箭號表示資料移動的方向（如果有的話）。



| 事件 | 用戶端 X                                          | 伺服器                                   | 用戶端 Y                                          |
|-------|---------------------------------------------------|------------------------------------------|---------------------------------------------------|
| 1     | 開啟檔案，要求層級1鎖定 = =>          |                                          |                                                   |
| 2     |                                                   | <= = 授予層級1的隨機鎖定 |                                                   |
| 3     | 執行讀取、寫入及其他作業 = => |                                          |                                                   |
| 4     |                                                   |                                          | <= = 開啟檔案的要求                      |
| 5     |                                                   | <= = 中斷隨機鎖定         |                                                   |
| 6     | 捨棄預先讀取的資料                          |                                          |                                                   |
| 7     | 寫入資料 = =>                                |                                          |                                                   |
| 8     | 傳送「關閉」或「完成」訊息 = =>            |                                          |                                                   |
| 9     |                                                   | Okays open operation = =>              |                                                   |
| 10    | 執行讀取、寫入及其他作業 = => |                                          | <= = 執行讀取、寫入和其他作業 |



 

在事件1中，用戶端 X 會開啟檔案，而開啟作業的一部分會要求檔案的層級1隨機鎖定。 在事件2中，伺服器會授與層級1鎖定，因為沒有其他用戶端開啟該檔案。 用戶端會繼續以事件3中的一般方式存取檔案。

在事件4中，用戶端 Y 會嘗試開啟檔案並要求隨機鎖定。 伺服器看到用戶端 X 開啟了檔案。 伺服器會忽略 Y 的要求，而用戶端 X 會排清任何寫入資料，並放棄其檔案的讀取快取。

伺服器會將傳送至 X 一則 SMB 訊息，以中斷隨機鎖定（事件5），藉此強制清除 X。 用戶端 X 「無訊息」會捨棄任何預先讀取的資料;換句話說，此進程不會產生任何網路流量。 在事件7中，用戶端 X 會將任何快取的寫入資料寫入伺服器。 當用戶端 X 完成將快取的資料寫入至伺服器時，用戶端 X 會將「關閉」或「已完成」訊息傳送至伺服器，也就是事件8。

當伺服器通知用戶端 X 完成將其寫入快取排清至伺服器或已關閉檔案之後，伺服器可以在事件9中開啟用戶端 Y 的檔案。 因為伺服器現在有兩個已開啟相同檔案的用戶端，所以它會將隨機鎖定授與兩者皆不允許。 這兩個用戶端都會繼續從檔案讀取，一個或不會寫入檔案。

## <a name="batch-opportunistic-lock"></a>Batch 隨機鎖定

下圖顯示批次隨機鎖定的網路流量查看。 箭號表示資料移動的方向（如果有的話）。



| 事件 | 用戶端 X                               | 伺服器                                 | 用戶端 Y                                          |
|-------|----------------------------------------|----------------------------------------|---------------------------------------------------|
| 1     | 開啟檔案，要求批次鎖定 = => |                                        |                                                   |
| 2     |                                        | <= = 授與批次隨機鎖定 |                                                   |
| 3     | 讀取檔 = =>                      |                                        |                                                   |
| 4     |                                        | <= = 傳送資料                      |                                                   |
| 5     | 關閉檔案                            |                                        |                                                   |
| 6     | 開啟檔案                             |                                        |                                                   |
| 7     | 搜尋資料                      |                                        |                                                   |
| 8     | 讀取資料 = =>                      |                                        |                                                   |
| 9     |                                        | <= = 傳送資料                      |                                                   |
| 10    | 關閉檔案                            |                                        |                                                   |
| 11    |                                        |                                        | <= = 開啟檔案                                 |
| 12    |                                        | <= = 中斷隨機鎖定       |                                                   |
| 13    | 關閉 file = =>                     |                                        |                                                   |
| 14    |                                        | Okays open operation = =>            |                                                   |
| 15    |                                        |                                        | <= = 執行讀取、寫入和其他作業 |



 

在批次隨機鎖定中，用戶端 X 會開啟檔案、事件1，而伺服器會在事件2中授與用戶端 X 批次鎖定。 用戶端 X 嘗試讀取資料（事件3），伺服器會以資料回應，事件4。

事件5顯示 batch 隨機鎖定工作。 用戶端 X 上的應用程式會關閉檔案。 不過，網路重新導向程式會篩選出關閉作業，而不會傳輸關閉的訊息，因此會執行「無訊息」關閉。 網路重新導向程式可以這樣做，因為用戶端 X 擁有檔案的唯一擁有權。 稍後在事件6中，應用程式會重新開啟檔案。 同樣地，不會在網路上流動資料。 至於伺服器的考慮，此用戶端會在事件2之後開啟該檔案。

事件7、8和9顯示一般的網路流量。 在事件10中，會出現另一個無訊息關閉。

在事件11中，用戶端 Y 嘗試開啟檔案。 伺服器的檔案視圖是，即使用戶端 X 上的應用程式已關閉它，用戶端 X 仍會開啟該檔案。 因此，伺服器會傳送一則訊息，將隨機鎖定傳送給用戶端 X。用戶端 X 現在會將關閉訊息傳送到整個網路（事件13）。 當伺服器開啟用戶端 Y 的檔案時，就會發生事件14。用戶端 X 上的應用程式已關閉檔案，因此不會再對該檔案的伺服器進行傳輸。 用戶端 Y 在事件15中會像往常一樣開始進行資料傳輸。

在將事件2中的檔案鎖定授與用戶端 X 的時間，以及事件13的最後一個關閉時，用戶端已快取的任何檔案資料都是有效的，但這是因為中間的應用程式開啟和關閉作業。 不過，在隨機鎖定中斷之後，快取的資料就不會被視為有效。

## <a name="filter-opportunistic-lock"></a>篩選隨機鎖定

下圖顯示篩選隨機鎖定的網路流量查看。 箭號表示資料移動的方向（如果有的話）。



| 事件 | 用戶端 X                                | 伺服器                   | 用戶端 Y                    |
|-------|-----------------------------------------|--------------------------|-----------------------------|
| 1     | 開啟沒有存取權限的檔案 = => |                          |                             |
| 2     |                                         | <= = 開啟檔案    |                             |
| 3     | 要求篩選鎖定 = =>              |                          |                             |
| 4     |                                         | <= = 授與鎖定       |                             |
| 5     | 開啟檔案以供讀取 = =>           |                          |                             |
| 6     |                                         | <= = 重新開啟檔案  |                             |
| 7     | 使用 read handle = => 讀取資料 |                          |                             |
| 8     |                                         | <= = 傳送資料        |                             |
| 9     |                                         | <= = 傳送資料        |                             |
| 10    |                                         | <= = 傳送資料        |                             |
| 11    |                                         |                          | <= = 開啟檔案       |
| 12    |                                         | 開啟 file = =>    |                             |
| 13    |                                         |                          | <= = 要求篩選鎖定 |
| 14    |                                         | 拒絕 filter lock = => |                             |
| 15    |                                         |                          | <= = 讀取資料           |
| 16    |                                         | 傳送資料 = =>        |                             |
| 17    | 讀取 (快取的) 資料                     |                          |                             |
| 18    | 關閉 file = =>                      |                          |                             |
| 19    |                                         |                          | <= = 關閉檔案          |



 

在篩選隨機鎖定中，用戶端 X 會開啟檔案、事件1，而伺服器會在事件2中回應。 然後，用戶端會在事件3中要求篩選隨機鎖定，接著在事件4中授與隨機鎖定伺服器。 然後，用戶端 X 會再次開啟檔案，以便在事件5中進行讀取（伺服器在事件6中的回應）。 然後，用戶端會嘗試讀取資料，而伺服器會以資料（事件8）回應。

事件9顯示篩選隨機鎖定工作。 伺服器會先行讀取用戶端，並透過網路傳送資料，即使用戶端尚未要求它也一樣。 用戶端會快取資料。 在事件10中，伺服器也會預期未來的資料要求，並傳送檔案的另一個部分供用戶端快取。

在事件11和12中，另一個用戶端 Y 會開啟檔案。 用戶端 Y 也會要求篩選隨機鎖定。 在事件14中，伺服器會拒絕它。 在事件15中，用戶端 Y 會要求資料，而伺服器會在事件16中傳送這些資料。 這兩者都不會影響用戶端 X。在任何時間，其他用戶端都可以開啟此檔案進行讀取存取。 其他用戶端則不會影響用戶端 X 的篩選鎖定。

事件17顯示用戶端 X 讀取資料。 不過，因為伺服器已經傳送資料，而且用戶端已快取該資料，所以沒有任何流量會跨越網路。

在此範例中，用戶端 X 永遠不會嘗試讀取檔案中的所有資料，因此事件9和10所指出的預先讀取為「浪費」;也就是說，資料絕對不會使用。 這是可接受的損失，因為預先讀取已加速應用程式。

在事件18中，用戶端 X 會關閉檔案。 用戶端的網路重新導向程式會放棄快取的資料。 伺服器會關閉檔案。

 

 



