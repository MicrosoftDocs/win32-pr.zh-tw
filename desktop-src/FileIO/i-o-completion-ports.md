---
description: I/o 完成埠可提供有效率的執行緒模型，以處理多處理器系統上的多個非同步 i/o 要求。
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: I/o 完成埠
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106979358"
---
# <a name="io-completion-ports"></a><span data-ttu-id="00b80-103">I/o 完成埠</span><span class="sxs-lookup"><span data-stu-id="00b80-103">I/O Completion Ports</span></span>

<span data-ttu-id="00b80-104">I/o 完成埠可提供有效率的執行緒模型，以處理多處理器系統上的多個非同步 i/o 要求。</span><span class="sxs-lookup"><span data-stu-id="00b80-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="00b80-105">當進程建立 i/o 完成埠時，系統會針對其唯一目的是要為這些要求提供服務的要求，建立相關聯的佇列物件。</span><span class="sxs-lookup"><span data-stu-id="00b80-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="00b80-106">處理許多並行非同步 i/o 要求的處理常式可以更快速且有效率地使用 i/o 完成埠搭配預先配置的執行緒集區，而不是在收到 i/o 要求時建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="00b80-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="00b80-107">I/o 完成埠的運作方式</span><span class="sxs-lookup"><span data-stu-id="00b80-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="00b80-108">[**CreateIoCompletionPort**](createiocompletionport.md)函式會建立 i/o 完成埠，並將一個或多個檔案控制代碼與該通訊埠產生關聯。</span><span class="sxs-lookup"><span data-stu-id="00b80-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="00b80-109">當其中一個檔案控制代碼的非同步 i/o 作業完成時，i/o 完成封包會以先進先出的方式排入佇列中， (FIFO) 順序寫入相關聯的 i/o 完成通訊埠。</span><span class="sxs-lookup"><span data-stu-id="00b80-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="00b80-110">這項機制的一個強大用途是將多個檔案控制代碼的同步處理點結合成單一物件，雖然另外還有其他有用的應用程式。</span><span class="sxs-lookup"><span data-stu-id="00b80-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="00b80-111">請注意，當封包以 FIFO 順序排入佇列時，它們可能會以不同順序排入佇列。</span><span class="sxs-lookup"><span data-stu-id="00b80-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="00b80-112">此處所用的詞彙 *檔案控制代碼* 是指代表重迭 i/o 端點（而不只是磁片上的檔案）的系統抽象概念。</span><span class="sxs-lookup"><span data-stu-id="00b80-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="00b80-113">例如，它可以是網路端點、TCP 通訊端、具名管道或郵件位置。</span><span class="sxs-lookup"><span data-stu-id="00b80-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="00b80-114">您可以使用任何支援重迭 i/o 的系統物件。</span><span class="sxs-lookup"><span data-stu-id="00b80-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="00b80-115">如需相關 i/o 函數的清單，請參閱本主題的結尾。</span><span class="sxs-lookup"><span data-stu-id="00b80-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="00b80-116">當檔案控制代碼與完成埠相關聯時，傳入的狀態欄塊將不會更新，除非封包從完成埠移除。</span><span class="sxs-lookup"><span data-stu-id="00b80-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="00b80-117">唯一的例外狀況是，如果原始作業以同步方式傳回，就會發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="00b80-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="00b80-118">執行緒 (由主執行緒或主執行緒本身建立的執行緒) 使用 [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) 函式來等候完成封包排入 i/o 完成埠的佇列，而不是直接等候非同步 i/o 完成。</span><span class="sxs-lookup"><span data-stu-id="00b80-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="00b80-119">在 i/o 完成埠上封鎖其執行的執行緒，會以後進先出的 (LIFO) 順序來釋出，而下一個完成封包則會從該執行緒的 i/o 完成埠 FIFO 佇列中提取。</span><span class="sxs-lookup"><span data-stu-id="00b80-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="00b80-120">這表示，當完成封包釋出至執行緒時，系統會釋放與該埠相關聯的最後一個 (最近) 執行緒，並將最舊 i/o 完成的完成資訊傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="00b80-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="00b80-121">雖然任何數目的執行緒都可以針對指定的 i/o 完成埠呼叫 [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) ，但當指定的執行緒第一次呼叫 **GetQueuedCompletionStatus** 時，它會變成與指定的 i/o 完成埠相關聯，直到發生下列其中一種情況為止：執行緒結束、指定不同的 i/o 完成埠，或關閉 i/o 完成埠。</span><span class="sxs-lookup"><span data-stu-id="00b80-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="00b80-122">換句話說，單一線程最多可與一個 i/o 完成埠相關聯。</span><span class="sxs-lookup"><span data-stu-id="00b80-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="00b80-123">當完成封包排入 i/o 完成埠的佇列時，系統會先檢查與該埠相關聯的執行緒數目是否正在執行。</span><span class="sxs-lookup"><span data-stu-id="00b80-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="00b80-124">如果執行的執行緒數目小於並行值 () 下一節中所討論的，其中一個等候中的執行緒 (最新的) 可處理完成封包。</span><span class="sxs-lookup"><span data-stu-id="00b80-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="00b80-125">當執行中的執行緒完成其處理時，通常會再次呼叫 [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) ，此時它會傳回下一個完成封包，或等候佇列是空的。</span><span class="sxs-lookup"><span data-stu-id="00b80-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="00b80-126">執行緒可以使用 [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) 函式，將完成的封包放入 i/o 完成埠的佇列中。</span><span class="sxs-lookup"><span data-stu-id="00b80-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="00b80-127">如此一來，除了從 i/o 系統接收 i/o 完成封包之外，還可以使用完成埠來接收來自進程其他執行緒的通訊。</span><span class="sxs-lookup"><span data-stu-id="00b80-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="00b80-128">**PostQueuedCompletionStatus** 函式可讓應用程式將其專屬的特殊用途完成封包排入 i/o 完成埠的佇列，而不需啟動非同步 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="00b80-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="00b80-129">例如，如果要通知外來事件的背景工作執行緒，這就很有用。</span><span class="sxs-lookup"><span data-stu-id="00b80-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="00b80-130">I/o 完成通訊埠控制碼，以及與該特定 i/o 完成埠相關聯的每個檔案控制代碼，稱為 *i/o 完成埠的參考*。</span><span class="sxs-lookup"><span data-stu-id="00b80-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="00b80-131">當 i/o 完成通訊埠沒有其他參考時，就會釋放它。</span><span class="sxs-lookup"><span data-stu-id="00b80-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="00b80-132">因此，所有這些控制碼都必須適當地關閉，才能釋放 i/o 完成埠及其相關聯的系統資源。</span><span class="sxs-lookup"><span data-stu-id="00b80-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="00b80-133">滿足這些條件之後，應用程式應該呼叫 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 函式來關閉 i/o 完成埠控制碼。</span><span class="sxs-lookup"><span data-stu-id="00b80-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="00b80-134">I/o 完成埠與建立它的進程相關聯，而且無法在進程之間共用。</span><span class="sxs-lookup"><span data-stu-id="00b80-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="00b80-135">不過，在相同進程中的執行緒之間可共用單一控制碼。</span><span class="sxs-lookup"><span data-stu-id="00b80-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="00b80-136">執行緒和平行存取</span><span class="sxs-lookup"><span data-stu-id="00b80-136">Threads and Concurrency</span></span>

<span data-ttu-id="00b80-137">要謹慎考慮的 i/o 完成埠最重要的屬性是並行值。</span><span class="sxs-lookup"><span data-stu-id="00b80-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="00b80-138">當使用 [**CreateIoCompletionPort**](createiocompletionport.md) 透過 *NumberOfConcurrentThreads* 參數建立時，就會指定完成埠的並行值。</span><span class="sxs-lookup"><span data-stu-id="00b80-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="00b80-139">此值會限制與完成埠相關聯之可執行檔執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="00b80-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="00b80-140">當與完成埠相關聯的可執行執行緒總數達到並行值時，系統會封鎖與該完成埠相關聯之任何後續執行緒的執行，直到可執行檔執行緒數目低於並行值為止。</span><span class="sxs-lookup"><span data-stu-id="00b80-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="00b80-141">在佇列中等候完成封包時，會發生最有效率的情況，但由於埠已達到其並行限制，因此不會滿足任何等候。</span><span class="sxs-lookup"><span data-stu-id="00b80-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="00b80-142">請考慮在 [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) 函式呼叫中，有一個和多個執行緒的並行值會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="00b80-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="00b80-143">在此情況下，如果佇列永遠有等候中的完成封包，當執行中的執行緒呼叫 **GetQueuedCompletionStatus** 時，它將不會封鎖執行，因為如先前所述，執行緒佇列為 LIFO。</span><span class="sxs-lookup"><span data-stu-id="00b80-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="00b80-144">相反地，這個執行緒會立即取得下一個排入佇列的完成封包。</span><span class="sxs-lookup"><span data-stu-id="00b80-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="00b80-145">因為執行中的執行緒會持續收取完成封包，而其他執行緒無法執行，所以不會發生任何執行緒內容切換。</span><span class="sxs-lookup"><span data-stu-id="00b80-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="00b80-146">在上述範例中，額外的執行緒看似無用且永遠不會執行，但這會假設執行中的執行緒永遠不會被其他機制進入等候狀態，而會終止或關閉其相關聯的 i/o 完成通訊埠。</span><span class="sxs-lookup"><span data-stu-id="00b80-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="00b80-147">在設計應用程式時，請考慮所有這類執行緒執行的後果。</span><span class="sxs-lookup"><span data-stu-id="00b80-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="00b80-148">針對並行值挑選的最佳整體最大值是電腦上的 Cpu 數目。</span><span class="sxs-lookup"><span data-stu-id="00b80-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="00b80-149">如果您的交易需要較長的計算，則較大的並行值會允許更多執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="00b80-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="00b80-150">每個完成封包可能需要較長的時間才能完成，但會同時處理更多的完成封包。</span><span class="sxs-lookup"><span data-stu-id="00b80-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="00b80-151">您可以搭配程式碼剖析工具來試驗並行值，以達到應用程式的最佳效果。</span><span class="sxs-lookup"><span data-stu-id="00b80-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="00b80-152">如果另一個與相同 i/o 完成埠相關聯的執行中線程因其他原因而進入等候狀態（例如 [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread)函式），則系統也可讓等候 [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)的執行緒完成封包。</span><span class="sxs-lookup"><span data-stu-id="00b80-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="00b80-153">當等候狀態中的執行緒再次開始執行時，使用中線程的數目超過並行值時，可能會有短暫的時間。</span><span class="sxs-lookup"><span data-stu-id="00b80-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="00b80-154">不過，系統會在作用中線程的數目低於並行值之前，藉由不允許任何新的使用中線程，快速減少此數目。</span><span class="sxs-lookup"><span data-stu-id="00b80-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="00b80-155">這是讓您的應用程式在其執行緒集區中建立比並行值更多執行緒的原因之一。</span><span class="sxs-lookup"><span data-stu-id="00b80-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="00b80-156">執行緒集區管理已超出本主題的範圍，但良好的經驗法則是線上程集區中最少有兩個執行緒，如同系統上的處理器。</span><span class="sxs-lookup"><span data-stu-id="00b80-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="00b80-157">如需執行緒共用的詳細資訊，請參閱 [執行緒](/windows/desktop/ProcThread/thread-pools)集區。</span><span class="sxs-lookup"><span data-stu-id="00b80-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="00b80-158">支援的 i/o 函數</span><span class="sxs-lookup"><span data-stu-id="00b80-158">Supported I/O Functions</span></span>

<span data-ttu-id="00b80-159">下列函式可用於啟動使用 i/o 完成埠完成的 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="00b80-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="00b80-160">您 [**必須將重迭結構的**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 實例和先前與 i/o 完成埠相關聯的檔案控制代碼傳遞給函式， (呼叫 [**CreateIoCompletionPort**](createiocompletionport.md)) 來啟用 i/o 完成埠機制：</span><span class="sxs-lookup"><span data-stu-id="00b80-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="00b80-161">**ConnectNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="00b80-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="00b80-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="00b80-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="00b80-163">**LockFileEx**</span><span class="sxs-lookup"><span data-stu-id="00b80-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="00b80-164">**ReadDirectoryChangesW**</span><span class="sxs-lookup"><span data-stu-id="00b80-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="00b80-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="00b80-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="00b80-166">**TransactNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="00b80-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="00b80-167">**WaitCommEvent**</span><span class="sxs-lookup"><span data-stu-id="00b80-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="00b80-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="00b80-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="00b80-169">**WSASendMsg**</span><span class="sxs-lookup"><span data-stu-id="00b80-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="00b80-170">**WSASendTo**</span><span class="sxs-lookup"><span data-stu-id="00b80-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="00b80-171">**WSASend**</span><span class="sxs-lookup"><span data-stu-id="00b80-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="00b80-172">**WSARecvFrom**</span><span class="sxs-lookup"><span data-stu-id="00b80-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="00b80-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span><span class="sxs-lookup"><span data-stu-id="00b80-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="00b80-174">**WSARecv**</span><span class="sxs-lookup"><span data-stu-id="00b80-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="00b80-175">相關主題</span><span class="sxs-lookup"><span data-stu-id="00b80-175">Related topics</span></span>

<dl> <span data-ttu-id="00b80-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="00b80-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="00b80-177">關於處理序和執行緒</span><span class="sxs-lookup"><span data-stu-id="00b80-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="00b80-178">**BindIoCompletionCallback**</span><span class="sxs-lookup"><span data-stu-id="00b80-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="00b80-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="00b80-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="00b80-180">**GetQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="00b80-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="00b80-181">**GetQueuedCompletionStatusEx**</span><span class="sxs-lookup"><span data-stu-id="00b80-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="00b80-182">**PostQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="00b80-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
