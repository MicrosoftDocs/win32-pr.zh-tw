---
description: 最佳檔案系統交易的建議。
ms.assetid: 847939ff-5322-4023-8ef7-9d845e80d65c
title: 交易式 NTFS 的效能考慮
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3a71f7e100e1ddd8524932a4a259a12092bddcb6
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103944890"
---
# <a name="performance-considerations-for-transactional-ntfs"></a><span data-ttu-id="84b29-103">交易式 NTFS 的效能考慮</span><span class="sxs-lookup"><span data-stu-id="84b29-103">Performance Considerations for Transactional NTFS</span></span>

<span data-ttu-id="84b29-104">交易式 NTFS (TxF) 已針對效能進行謹慎設計，而且在類似案例下的一般用途交易替代方案通常會優於一般用途。</span><span class="sxs-lookup"><span data-stu-id="84b29-104">Transactional NTFS (TxF) has been carefully designed for performance and will typically perform better than general-purpose transactional alternatives under similar scenarios.</span></span> <span data-ttu-id="84b29-105">不過，檔案系統交易的額外負荷比非交易作業更多，而且與非交易 i/o 相較之下，i/o 效能的降低是預期的。</span><span class="sxs-lookup"><span data-stu-id="84b29-105">However, file system transactions have more overhead than non-transacted operations, and some reduction in I/O performance compared to non-transacted I/O is to be expected.</span></span> <span data-ttu-id="84b29-106">效能關鍵的應用程式應該執行技術採用的資格週期，以評估交易檔案系統作業的效能影響。</span><span class="sxs-lookup"><span data-stu-id="84b29-106">Performance-critical applications should perform a technology adoption qualification cycle, evaluating the performance impact of transacted file system operations.</span></span>

## <a name="overview-of-txf-operations"></a><span data-ttu-id="84b29-107">TxF 作業總覽</span><span class="sxs-lookup"><span data-stu-id="84b29-107">Overview of TxF Operations</span></span>

<span data-ttu-id="84b29-108">如果發生交易中止，則 TxF 會使用 *復原* 記錄來記錄將檔案系統恢復為一致狀態（也稱為復原）所需的變更。</span><span class="sxs-lookup"><span data-stu-id="84b29-108">TxF uses *undo* logging to record the changes necessary to put the file system back into a consistent state, also referred to as a rollback, should a transaction abort occur.</span></span> <span data-ttu-id="84b29-109">這項復原記錄會產生額外的 i/o，而且是與非交易式檔案系統作業相較之下，TxF 效能負荷的來源。</span><span class="sxs-lookup"><span data-stu-id="84b29-109">This undo logging generates additional I/O and is the source of TxF performance overhead compared to non-transactional file system operations.</span></span>

<span data-ttu-id="84b29-110">TxF 運作方式的高階摘要如下所示：</span><span class="sxs-lookup"><span data-stu-id="84b29-110">A high-level summary of how TxF operates is as follows:</span></span>

-   <span data-ttu-id="84b29-111">當交易進行時，TxF 會針對檔案系統所進行的每項修改，將 *恢復* 記錄寫入記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="84b29-111">As a transaction progresses, TxF writes *undo* records into its log file for each modification it makes to the file system.</span></span> <span data-ttu-id="84b29-112">如果發生中止，則會剖析這些復原記錄，使檔案系統回到交易開始之前的狀態。</span><span class="sxs-lookup"><span data-stu-id="84b29-112">If an abort occurs, these undo records are parsed to put the file system back in the state it was before the transaction began.</span></span>
-   <span data-ttu-id="84b29-113">*中繼資料變更* 復原記錄只會描述檔案系統中繼資料的變更。</span><span class="sxs-lookup"><span data-stu-id="84b29-113">A *metadata change* undo record describes a change only to the file system's metadata.</span></span> <span data-ttu-id="84b29-114">其中一些範例包括移動、重新命名、附加和屬性變更。</span><span class="sxs-lookup"><span data-stu-id="84b29-114">Some examples of this are moves, renames, appends, and attribute changes.</span></span> <span data-ttu-id="84b29-115">針對中繼資料變更復原記錄，復原變更所需的所有資訊都是在記錄中，並儲存在記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="84b29-115">For metadata change undo records, all of the information necessary to undo the change is in the record and stored in the log file.</span></span>
-   <span data-ttu-id="84b29-116">*覆寫* 復原記錄會描述檔案部分的覆寫。</span><span class="sxs-lookup"><span data-stu-id="84b29-116">An *overwrite* undo record describes an overwrite of a portion of a file.</span></span> <span data-ttu-id="84b29-117">當檔案遭到覆寫時，檔案的原始內容會儲存在隱藏目錄的特殊復原檔案中，而覆寫復原記錄會指向此檔案。</span><span class="sxs-lookup"><span data-stu-id="84b29-117">When a file overwrite occurs, the file's original contents are stored in a special undo file in a hidden directory and the overwrite undo record points to this file.</span></span> <span data-ttu-id="84b29-118">當檔案更新最後從快取排清到磁片時，也必須清除恢復檔案的內容，因此交易檔案覆寫可能會產生最多兩個額外的隨機 i/o 作業：一個用來讀取舊的資料，另一個則寫入恢復檔案。</span><span class="sxs-lookup"><span data-stu-id="84b29-118">When file updates are eventually flushed from cache to disk, the contents of the undo file must also be flushed, so a transacted file overwrite could generate up to two extra random I/O operations: one to read the old data and one to write it to the undo file.</span></span> <span data-ttu-id="84b29-119">這些額外的 i/o 作業是 TxF 的效能成本。</span><span class="sxs-lookup"><span data-stu-id="84b29-119">These extra I/O operations are a performance cost of TxF.</span></span>
-   <span data-ttu-id="84b29-120">當認可發生時，TxF 會先清除所有復原資訊，然後清除實際的檔案變更，然後寫入和清除認可記錄。</span><span class="sxs-lookup"><span data-stu-id="84b29-120">When a commit occurs, TxF first flushes all undo information, then flushes the actual file changes, and then writes and flushes a commit record.</span></span> <span data-ttu-id="84b29-121">如果沒有要排清的復原檔案，則會將記錄檔排清為相對於非交易 i/o 的唯一額外 TxF 負擔。</span><span class="sxs-lookup"><span data-stu-id="84b29-121">If there are no undo files to flush, the only additional TxF overhead relative to non-transacted I/O is the log flushes themselves.</span></span> <span data-ttu-id="84b29-122">不過，記錄檔排清會導致有效率的大型連續寫入，因此效能成本最短。</span><span class="sxs-lookup"><span data-stu-id="84b29-122">However, log flushes result in efficient large sequential writes so the performance cost is minimal.</span></span>
-   <span data-ttu-id="84b29-123">TxF 已針對認可優化。</span><span class="sxs-lookup"><span data-stu-id="84b29-123">TxF is optimized for commit.</span></span> <span data-ttu-id="84b29-124">預期大部分的交易都將成功而不需要復原，因此交易的所有恢復記錄都應該不會使用。</span><span class="sxs-lookup"><span data-stu-id="84b29-124">It is expected that most transactions will succeed and not need to rollback, therefore all undo records for a transaction are expected to go unused.</span></span> <span data-ttu-id="84b29-125">從效能的觀點來看，TxF 認可作業很快就會復原，而且需要大量資源。</span><span class="sxs-lookup"><span data-stu-id="84b29-125">From a performance perspective, TxF commit operations are fast and rollbacks are resource-intensive.</span></span>
-   <span data-ttu-id="84b29-126">復原比認可更耗用資源。</span><span class="sxs-lookup"><span data-stu-id="84b29-126">Rollback is more resource-intensive than commit.</span></span> <span data-ttu-id="84b29-127">在復原期間，交易中所做的所有變更都必須取消完成。</span><span class="sxs-lookup"><span data-stu-id="84b29-127">During rollback, all the changes that were made in the transaction have to be un-done.</span></span> <span data-ttu-id="84b29-128">一般而言，復原持續時間可能與最初進行變更時所花費的時間大致相同。</span><span class="sxs-lookup"><span data-stu-id="84b29-128">In general, rollback duration can be approximately the same it took to originally make the changes.</span></span> <span data-ttu-id="84b29-129">例如，如果花了1秒鐘來進行所有變更，則可能需要約1秒才能復原它們。</span><span class="sxs-lookup"><span data-stu-id="84b29-129">For example, if it took 1 second to make all the changes then it could take about 1 second to undo them.</span></span> <span data-ttu-id="84b29-130">針對非常長的交易，rollback 可能會造成額外的效能影響。</span><span class="sxs-lookup"><span data-stu-id="84b29-130">For very long transactions, rollback can create additional performance impacts.</span></span> <span data-ttu-id="84b29-131">例如，如果系統必須在系統停止回應且必須執行未排程重新開機的事件中自動回復交易，系統開機時間可能會延遲。</span><span class="sxs-lookup"><span data-stu-id="84b29-131">For example, system boot time can be delayed if the system must automatically rollback a transaction in the event that the system stops responding and must perform an unscheduled restart.</span></span>

<span data-ttu-id="84b29-132">有關可從上一個清單中繪製之效能的摘要結論如下所示：</span><span class="sxs-lookup"><span data-stu-id="84b29-132">The summary conclusions about performance that can be drawn from the previous list are as follows:</span></span>

-   <span data-ttu-id="84b29-133">針對涉及檔案覆寫的交易，TxF 的效能成本可能很重要。</span><span class="sxs-lookup"><span data-stu-id="84b29-133">The performance cost of TxF for transactions involving file overwrites can be significant.</span></span>
-   <span data-ttu-id="84b29-134">僅涉及中繼資料作業之交易的 TxF 效能成本可能相對較低，但前提是使用大型交易。</span><span class="sxs-lookup"><span data-stu-id="84b29-134">The performance cost of TxF for transactions involving only metadata operations can be relatively low, provided large transactions be used.</span></span> <span data-ttu-id="84b29-135">大型交易是針對每個認可記錄有許多恢復記錄。</span><span class="sxs-lookup"><span data-stu-id="84b29-135">A large transaction is when there are many undo records for every commit record.</span></span>

## <a name="recommendations-for-best-performance"></a><span data-ttu-id="84b29-136">最佳效能建議</span><span class="sxs-lookup"><span data-stu-id="84b29-136">Recommendations For Best Performance</span></span>

<span data-ttu-id="84b29-137">針對較大型的交易進行分攤 TxF 負擔。</span><span class="sxs-lookup"><span data-stu-id="84b29-137">Amortize TxF overhead over larger transactions.</span></span> <span data-ttu-id="84b29-138">例如，如果您有 *n* 個變更集，讓每個變更都有 *m* 個步驟，而且您可以選擇將它視為 *n* 個步驟的交易（每個步驟都有 m *個步驟*），或將其全部做為具有 *m* \* *N* 步驟的單一交易，則第二個選項會更有效率。</span><span class="sxs-lookup"><span data-stu-id="84b29-138">For example, if you have *N* sets of changes to make where each change has *M* steps and you have the option to either do this as *N* transactions of *M* steps each or do it all as a single transaction with *M*\**N* steps, the latter option would be more efficient.</span></span>

<span data-ttu-id="84b29-139">請考慮對非常大型交易的開機可能造成的影響。</span><span class="sxs-lookup"><span data-stu-id="84b29-139">Consider the possible impact on boot of very large transactions.</span></span> <span data-ttu-id="84b29-140">如先前所述，復原可能會很慢，而且如果系統需要以開機時間執行自動回復，則會延遲開機時間。</span><span class="sxs-lookup"><span data-stu-id="84b29-140">As previously stated, rollback can be slow and will delay boot time if the system needs to perform automatic rollbacks as boot time.</span></span> <span data-ttu-id="84b29-141">交易愈大，延遲越久。</span><span class="sxs-lookup"><span data-stu-id="84b29-141">The larger the transaction, the longer the delay.</span></span>

<span data-ttu-id="84b29-142">將交易保存到大部分的中繼資料作業。</span><span class="sxs-lookup"><span data-stu-id="84b29-142">Keep transactions to mostly metadata operations.</span></span> <span data-ttu-id="84b29-143">這是 TxF 針對進行優化的功能，一般而言，效能與大型中繼資料交易的非交易式檔案 i/o 相同。</span><span class="sxs-lookup"><span data-stu-id="84b29-143">This is what TxF is optimized for and, in general, the performance is about the same as non-transacted file I/O for large metadata transactions.</span></span> <span data-ttu-id="84b29-144">有效率的中繼資料 TxF 函式範例包括 [**MoveFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-movefiletransacteda)、 [**SetFileAttributesTransacted**](/windows/desktop/api/WinBase/nf-winbase-setfileattributestransacteda)、 [**CopyFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-copyfiletransacteda)、 [**DeleteFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-deletefiletransacteda)、 [**CreateHardLinkTransacted**](/windows/desktop/api/WinBase/nf-winbase-createhardlinktransacteda)和附加的寫入 (呼叫 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) 函式（當檔案指標是在檔案結尾時），或是 *EOF*) 。</span><span class="sxs-lookup"><span data-stu-id="84b29-144">Examples of efficient metadata TxF functions are [**MoveFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-movefiletransacteda), [**SetFileAttributesTransacted**](/windows/desktop/api/WinBase/nf-winbase-setfileattributestransacteda), [**CopyFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-copyfiletransacteda), [**DeleteFileTransacted**](/windows/desktop/api/WinBase/nf-winbase-deletefiletransacteda), [**CreateHardLinkTransacted**](/windows/desktop/api/WinBase/nf-winbase-createhardlinktransacteda), and appended writes (calls to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function when the file pointer as at the end the file, or *EOF*).</span></span> <span data-ttu-id="84b29-145">當檔案指標不在 EOF 時，耗用大量資源的非中繼資料作業的範例就是呼叫 **WriteFile** 函式。</span><span class="sxs-lookup"><span data-stu-id="84b29-145">An example of resource-intensive non-metadata operations are calls to the **WriteFile** function when the file pointer is not at the EOF.</span></span>

## <a name="summary-of-txf-performance-expectations"></a><span data-ttu-id="84b29-146">TxF 效能預期的摘要</span><span class="sxs-lookup"><span data-stu-id="84b29-146">Summary of TxF Performance Expectations</span></span>

<span data-ttu-id="84b29-147">針對就地更新，覆寫檔案的區段會比非交易式檔案 i/o 慢許多，而檔案系統中繼資料作業的 TxF 效能 (例如，建立、移動和附加) 相當於大型交易的非交易式檔案 i/o。</span><span class="sxs-lookup"><span data-stu-id="84b29-147">For in-place updates, overwrites to a section of a file will be much slower than non-transacted file I/O, while TxF performance for file system metadata operations (for example, create, move, and append) is comparable to non-transacted file I/O for large transactions.</span></span>

 

 



