---
description: 描述檔案緩衝的應用程式控制考慮，也稱為未緩衝的檔案輸入/輸出 (i/o) 。
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: 檔案緩衝
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104194758"
---
# <a name="file-buffering"></a><span data-ttu-id="509bb-103">檔案緩衝</span><span class="sxs-lookup"><span data-stu-id="509bb-103">File Buffering</span></span>

<span data-ttu-id="509bb-104">本主題涵蓋檔案緩衝的應用程式控制的各種考慮，也稱為未緩衝的檔案輸入/輸出 (i/o) 。</span><span class="sxs-lookup"><span data-stu-id="509bb-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="509bb-105">檔案緩衝通常是由系統在幕後處理，除非另有指定，否則會被視為 Windows [作業系統內檔案](file-caching.md) 快取的一部分。</span><span class="sxs-lookup"><span data-stu-id="509bb-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="509bb-106">雖然「快取 *」和「* *緩衝* 處理」有時會交替使用，但本主題只會在說明如何與)  (未快取的資料進行互動的內容中使用「 *緩衝區* 」一詞，而在其他情況下，使用者模式應用程式的直接控制也是如此。</span><span class="sxs-lookup"><span data-stu-id="509bb-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="509bb-107">使用 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) 函式開啟或建立檔案時，不能指定檔案 **\_ 旗 \_ \_** 標來停用從檔案讀取或寫入資料的系統快取。</span><span class="sxs-lookup"><span data-stu-id="509bb-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="509bb-108">雖然這可讓您完整且直接控制資料 i/o 緩衝，但在檔案和類似的裝置中，也需要考慮資料的對齊需求。</span><span class="sxs-lookup"><span data-stu-id="509bb-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="509bb-109">這種對齊方式資訊適用于裝置上的 i/o，例如支援搜尋的檔案，以及檔案位置指標 (或 *位移*) 的概念。</span><span class="sxs-lookup"><span data-stu-id="509bb-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="509bb-110">針對未搜尋的裝置（例如具名管道或通訊裝置），關閉緩衝可能不需要任何特定的對齊方式。</span><span class="sxs-lookup"><span data-stu-id="509bb-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="509bb-111">在該情況下，可能會因一致而獲得的任何限制或效率，取決於基礎技術。</span><span class="sxs-lookup"><span data-stu-id="509bb-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="509bb-112">在簡單的範例中，應用程式會使用「檔案」 **\_ 旗標 \_ 無 \_ 緩衝** 旗標來開啟檔案以進行寫入存取，然後使用在應用程式內定義的資料緩衝區來執行 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) 函式的呼叫。</span><span class="sxs-lookup"><span data-stu-id="509bb-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="509bb-113">在這些情況下，這個本機緩衝區實際上是此作業唯一存在的檔案緩衝區。</span><span class="sxs-lookup"><span data-stu-id="509bb-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="509bb-114">由於實體磁片配置、檔案系統儲存配置以及系統層級的檔案指標位置追蹤，除非本機定義的資料緩衝區符合某些對齊準則（如下一節所述），否則此寫入作業將會失敗。</span><span class="sxs-lookup"><span data-stu-id="509bb-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="509bb-115">快取的討論不會考慮實體磁片本身的任何硬體快取，這在任何情況下都不保證會在系統的直接控制內。</span><span class="sxs-lookup"><span data-stu-id="509bb-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="509bb-116">這不會影響此主題中指定的需求。</span><span class="sxs-lookup"><span data-stu-id="509bb-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="509bb-117">如需檔案旗標 **如何 \_ \_ 無 \_ 緩衝** 與其他快取相關旗標互動的詳細資訊，請參閱 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea)。</span><span class="sxs-lookup"><span data-stu-id="509bb-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="509bb-118">對齊和檔案存取需求</span><span class="sxs-lookup"><span data-stu-id="509bb-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="509bb-119">如前所述，應用程式必須符合特定需求，才能使用檔案旗標（ **\_ \_ 沒有 \_ 緩衝**）開啟的檔案。</span><span class="sxs-lookup"><span data-stu-id="509bb-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="509bb-120">適用下列細節：</span><span class="sxs-lookup"><span data-stu-id="509bb-120">The following specifics apply:</span></span>

-   <span data-ttu-id="509bb-121">檔案存取大小（包含重 [**迭結構中的選擇性**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) 檔案位移，如果有指定）必須是磁片區磁區大小的整數倍數的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="509bb-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="509bb-122">例如，如果磁區大小為512個位元組，則應用程式可以要求512、1024、1536或2048位元組的讀取和寫入，但不能要求335、981或7171位元組。</span><span class="sxs-lookup"><span data-stu-id="509bb-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="509bb-123">讀取和寫入作業的檔案存取緩衝區位址應該是實體磁區對齊的，這表示在記憶體中的位址與磁片區的實體磁區大小的整數倍數相符。</span><span class="sxs-lookup"><span data-stu-id="509bb-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="509bb-124">視磁片而定，可能不會強制執行這項需求。</span><span class="sxs-lookup"><span data-stu-id="509bb-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="509bb-125">應用程式開發人員應該注意到市場中新的存放裝置類型，其實體媒體磁區大小為4096個位元組。</span><span class="sxs-lookup"><span data-stu-id="509bb-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="509bb-126">這些裝置的產業名稱是「Advanced Format」。</span><span class="sxs-lookup"><span data-stu-id="509bb-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="509bb-127">因為可能會有直接導入4096個位元組的相容性問題作為媒體的定址單位，所以暫時性的相容性解決方案是引進可模擬一般512位元組磁區存放裝置的裝置，但透過標準 ATA 和 SCSI 命令提供真正磁區大小的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="509bb-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="509bb-128">這種模擬的結果是，開發人員必須瞭解的兩個磁區大小：</span><span class="sxs-lookup"><span data-stu-id="509bb-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="509bb-129">邏輯磁區：用於邏輯區塊定址媒體的單位。</span><span class="sxs-lookup"><span data-stu-id="509bb-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="509bb-130">我們也可以將它視為儲存體可接受的最小寫入單位。</span><span class="sxs-lookup"><span data-stu-id="509bb-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="509bb-131">這是「模擬」。</span><span class="sxs-lookup"><span data-stu-id="509bb-131">This is the "emulation".</span></span>
-   <span data-ttu-id="509bb-132">實體磁區：裝置的讀取和寫入作業會在單一作業中完成的單位。</span><span class="sxs-lookup"><span data-stu-id="509bb-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="509bb-133">這是不可部分完成的寫入單位，以及需要對齊的非緩衝 i/o，以達到最佳效能和可靠性特性。</span><span class="sxs-lookup"><span data-stu-id="509bb-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="509bb-134">最新的 Windows Api （例如 [**IOCTL \_ 磁片 \_ 取得磁片 \_ 磁碟機 \_ 幾何**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry)和 [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea)）將會傳回邏輯磁區大小，但可透過 [**IOCTL \_ 儲存體 \_ 查詢 \_ 屬性**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property)控制項程式碼抓取實體磁區大小，並在 [**儲存體 \_ 存取 \_ 對齊 \_ 描述**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor)元結構中包含 **BytesPerPhysicalSector** 成員所含的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="509bb-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="509bb-135">如需範例，請參閱 [**儲存體 \_ 存取 \_ 對齊 \_ 描述**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor)項的範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="509bb-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="509bb-136">Microsoft 強烈建議開發人員將未緩衝的 i/o 對齊，如 **IOCTL \_ 儲存體 \_ 查詢 \_ 屬性** 控制項程式碼所報告的實體磁區大小，以協助確保其應用程式已針對此磁區大小轉換做好準備。</span><span class="sxs-lookup"><span data-stu-id="509bb-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="509bb-137">**Windows Server 2003 和 WINDOWS XP：** 無法使用 [**儲存體 \_ 存取 \_ 對齊 \_ 描述**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) 元結構。</span><span class="sxs-lookup"><span data-stu-id="509bb-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="509bb-138">它是在 Windows Vista 和 Windows Server 2008 中引進的。</span><span class="sxs-lookup"><span data-stu-id="509bb-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="509bb-139">由於讀取和寫入作業的緩衝區位址必須為磁區對齊，因此應用程式必須能夠直接控制這些緩衝區的配置方式。</span><span class="sxs-lookup"><span data-stu-id="509bb-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="509bb-140">磁區對齊緩衝區的其中一種方式是使用 [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 函數來配置緩衝區。</span><span class="sxs-lookup"><span data-stu-id="509bb-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="509bb-141">請考慮下列事項：</span><span class="sxs-lookup"><span data-stu-id="509bb-141">Consider the following:</span></span>

-   <span data-ttu-id="509bb-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 配置的記憶體會對齊系統的頁面大小的整數倍數的位址。</span><span class="sxs-lookup"><span data-stu-id="509bb-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="509bb-143">針對 Itanium 型系統，頁面大小為 x64 和 x86 或8192位元組上的4096個位元組。</span><span class="sxs-lookup"><span data-stu-id="509bb-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="509bb-144">如需詳細資訊，請參閱 [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) 函數。</span><span class="sxs-lookup"><span data-stu-id="509bb-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="509bb-145">對於直接存取存放裝置而言，磁區大小通常是512到4096位元組 (硬碟) ，而2048位元組適用于光碟。</span><span class="sxs-lookup"><span data-stu-id="509bb-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="509bb-146">頁面和磁區大小都是2的乘冪。</span><span class="sxs-lookup"><span data-stu-id="509bb-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="509bb-147">因此，在大部分情況下，頁面對齊的記憶體也會對齊磁區，因為磁區大小大於頁面大小的情況很罕見。</span><span class="sxs-lookup"><span data-stu-id="509bb-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="509bb-148">取得手動對齊的記憶體緩衝區的另一種方式，是使用來自 C Run-Time 程式庫的[ \_ 對齊 \_ malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019)函數。</span><span class="sxs-lookup"><span data-stu-id="509bb-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="509bb-149">如需如何手動控制緩衝區對齊的範例，請參閱 [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)的範例程式碼一節中的 c + + 語言程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="509bb-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
