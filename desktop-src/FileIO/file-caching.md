---
description: Windows 會快取從磁片讀取並寫入磁片的檔案資料。
ms.assetid: 0865c741-63e3-4246-ba69-801b02153e4a
title: 檔案快取
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1a14fb668af16cfb8a4e42b59b25b73ecefbb7cb
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103852132"
---
# <a name="file-caching"></a><span data-ttu-id="ba121-103">檔案快取</span><span class="sxs-lookup"><span data-stu-id="ba121-103">File Caching</span></span>

<span data-ttu-id="ba121-104">根據預設，Windows 會快取從磁碟讀取與寫入到磁碟的檔案資料。</span><span class="sxs-lookup"><span data-stu-id="ba121-104">By default, Windows caches file data that is read from disks and written to disks.</span></span> <span data-ttu-id="ba121-105">這表示讀取作業會從系統記憶體（稱為系統檔案快取）中的區域讀取檔案資料，而不是從實體磁片讀取檔案資料。</span><span class="sxs-lookup"><span data-stu-id="ba121-105">This implies that read operations read file data from an area in system memory known as the system file cache, rather than from the physical disk.</span></span> <span data-ttu-id="ba121-106">同樣地，寫入作業會將檔案資料寫入到系統檔案快取而非寫入到磁碟，而且此類型的快取稱為回寫式快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-106">Correspondingly, write operations write file data to the system file cache rather than to the disk, and this type of cache is referred to as a write-back cache.</span></span> <span data-ttu-id="ba121-107">快取是以個別檔案物件為單位來管理。</span><span class="sxs-lookup"><span data-stu-id="ba121-107">Caching is managed per file object.</span></span>

<span data-ttu-id="ba121-108">快取會在快取 *管理員* 的方向下進行，它會在 Windows 執行時持續運作。</span><span class="sxs-lookup"><span data-stu-id="ba121-108">Caching occurs under the direction of the *cache manager*, which operates continuously while Windows is running.</span></span> <span data-ttu-id="ba121-109">系統檔案快取中的檔案資料會以作業系統所決定的間隔寫入磁片，而該檔案資料先前使用的記憶體會 *釋出，* 這稱為清除快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-109">File data in the system file cache is written to the disk at intervals determined by the operating system, and the memory previously used by that file data is freed—this is referred to as *flushing* the cache.</span></span> <span data-ttu-id="ba121-110">延遲將資料寫入至檔案，並將其保存在快取中，直到快取排清為止的原則稱為「延遲寫入」，且快取管理員會在確定時間間隔觸發此原則。</span><span class="sxs-lookup"><span data-stu-id="ba121-110">The policy of delaying the writing of the data to the file and holding it in the cache until the cache is flushed is called lazy writing, and it is triggered by the cache manager at a determinate time interval.</span></span> <span data-ttu-id="ba121-111">檔案資料區塊排清的時間部分是以資料儲存在快取中的時間長度以及該資料自上次在讀取作業中存取之後的時間長度為基礎。</span><span class="sxs-lookup"><span data-stu-id="ba121-111">The time at which a block of file data is flushed is partially based on the amount of time it has been stored in the cache and the amount of time since the data was last accessed in a read operation.</span></span> <span data-ttu-id="ba121-112">這可確保頻繁讀取的檔案資料將可儘可能地維持在系統檔案快取中供存取。</span><span class="sxs-lookup"><span data-stu-id="ba121-112">This ensures that file data that is frequently read will stay accessible in the system file cache for the maximum amount of time.</span></span>

<span data-ttu-id="ba121-113">下圖說明此檔案資料快取程式。</span><span class="sxs-lookup"><span data-stu-id="ba121-113">This file data caching process is illustrated in the following figure.</span></span>

![檔案資料快取進程](images/fig3.png)

<span data-ttu-id="ba121-115">如上圖中的實心箭號所示，當快取管理員在檔案讀取作業期間第一次要求時，會將 256 KB 的資料區域讀入系統位址空間中的 256 KB 快取「位置」。</span><span class="sxs-lookup"><span data-stu-id="ba121-115">As depicted by the solid arrows in the previous figure, a 256 KB region of data is read into a 256 KB cache "slot" in system address space when it is first requested by the cache manager during a file read operation.</span></span> <span data-ttu-id="ba121-116">使用者模式處理序接著會將此位置資料複製到其自己的位址空間。</span><span class="sxs-lookup"><span data-stu-id="ba121-116">A user-mode process then copies the data in this slot to its own address space.</span></span> <span data-ttu-id="ba121-117">當處理序完成其資料存取時，它會將修改的資料寫回系統快取中的相同位置，如處理序位址空間與系統快取之間的點箭號所示。</span><span class="sxs-lookup"><span data-stu-id="ba121-117">When the process has completed its data access, it writes the altered data back to the same slot in the system cache, as shown by the dotted arrow between the process address space and the system cache.</span></span> <span data-ttu-id="ba121-118">當快取管理員判定在一段時間內不再需要資料時，它會將改變的資料寫回磁片上的檔案，如系統快取和磁片之間的點箭號所示。</span><span class="sxs-lookup"><span data-stu-id="ba121-118">When the cache manager has determined that the data will no longer be needed for a certain amount of time, it writes the altered data back to the file on the disk, as shown by the dotted arrow between the system cache and the disk.</span></span>

<span data-ttu-id="ba121-119">檔案資料快取所提供的 i/o 效能改善數量，取決於所讀取或寫入的檔案資料區塊大小。</span><span class="sxs-lookup"><span data-stu-id="ba121-119">The amount of I/O performance improvement that file data caching offers depends on the size of the file data block being read or written.</span></span> <span data-ttu-id="ba121-120">讀取和寫入大量的檔案資料時，很可能需要磁片讀取和寫入才能完成 i/o 作業。</span><span class="sxs-lookup"><span data-stu-id="ba121-120">When large blocks of file data are read and written, it is more likely that disk reads and writes will be necessary to finish the I/O operation.</span></span> <span data-ttu-id="ba121-121">I/o 效能會變得越來越大，因為這種類型的 i/o 作業也會發生。</span><span class="sxs-lookup"><span data-stu-id="ba121-121">I/O performance will be increasingly impaired as more of this kind of I/O operation occurs.</span></span>

<span data-ttu-id="ba121-122">在這些情況下，可以關閉快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-122">In these situations, caching can be turned off.</span></span> <span data-ttu-id="ba121-123">這是在開啟檔案時完成的，方法是將 **檔案 \_ 旗標 \_ 無 \_ 緩衝** 處理傳遞為 [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea)的 *dwFlagsAndAttributes* 參數值。</span><span class="sxs-lookup"><span data-stu-id="ba121-123">This is done at the time the file is opened by passing **FILE\_FLAG\_NO\_BUFFERING** as a value for the *dwFlagsAndAttributes* parameter of [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span> <span data-ttu-id="ba121-124">停用快取時，所有的讀取和寫入作業都會直接存取實體磁片。</span><span class="sxs-lookup"><span data-stu-id="ba121-124">When caching is disabled, all read and write operations directly access the physical disk.</span></span> <span data-ttu-id="ba121-125">但是，檔案中繼資料仍可能會被快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-125">However, the file metadata may still be cached.</span></span> <span data-ttu-id="ba121-126">若要將中繼資料排清到磁片，請使用 [**FlushFileBuffers**](/windows/desktop/api/FileAPI/nf-fileapi-flushfilebuffers) 函數。</span><span class="sxs-lookup"><span data-stu-id="ba121-126">To flush the metadata to disk, use the [**FlushFileBuffers**](/windows/desktop/api/FileAPI/nf-fileapi-flushfilebuffers) function.</span></span>

<span data-ttu-id="ba121-127">發生排清的頻率是在系統效能與系統可靠性之間取得平衡的重要考慮。</span><span class="sxs-lookup"><span data-stu-id="ba121-127">The frequency at which flushing occurs is an important consideration that balances system performance with system reliability.</span></span> <span data-ttu-id="ba121-128">如果系統過於頻繁地排清快取，則排清的大型寫入作業數目將會大幅降低系統效能。</span><span class="sxs-lookup"><span data-stu-id="ba121-128">If the system flushes the cache too often, the number of large write operations flushing incurs will degrade system performance significantly.</span></span> <span data-ttu-id="ba121-129">如果系統的清除頻率過高，則可能是因為系統記憶體會被快取耗盡，或是突然的系統故障 (例如，電腦的電源中斷) 將在排清之前發生。</span><span class="sxs-lookup"><span data-stu-id="ba121-129">If the system is not flushed often enough, then the likelihood is greater that either system memory will be depleted by the cache, or a sudden system failure (such as a loss of power to the computer) will happen before the flush.</span></span> <span data-ttu-id="ba121-130">在後者的實例中，快取的資料將會遺失。</span><span class="sxs-lookup"><span data-stu-id="ba121-130">In the latter instance, the cached data will be lost.</span></span>

<span data-ttu-id="ba121-131">為了確保發生適當的排清量，快取管理員會每秒產生一個處理常式，稱為「延遲寫入器」。</span><span class="sxs-lookup"><span data-stu-id="ba121-131">To ensure that the right amount of flushing occurs, the cache manager spawns a process every second called a lazy writer.</span></span> <span data-ttu-id="ba121-132">延遲寫入器進程會將最近未排清的頁面排入佇列，以寫入磁片。</span><span class="sxs-lookup"><span data-stu-id="ba121-132">The lazy writer process queues one-eighth of the pages that have not been flushed recently to be written to disk.</span></span> <span data-ttu-id="ba121-133">它會持續重新評估為了達到最佳系統效能而排清的資料量，如果需要寫入更多資料，就會將更多的資料排入佇列。</span><span class="sxs-lookup"><span data-stu-id="ba121-133">It constantly reevaluates the amount of data being flushed for optimal system performance, and if more data needs to be written it queues more data.</span></span> <span data-ttu-id="ba121-134">延遲寫入器不會清除暫存檔案，因為這是由應用程式或系統所刪除。</span><span class="sxs-lookup"><span data-stu-id="ba121-134">Lazy writers do not flush temporary files, because the assumption is that they will be deleted by the application or system.</span></span>

<span data-ttu-id="ba121-135">某些應用程式（例如病毒檢查軟體）需要將其寫入作業立即排清到磁片;Windows 透過寫入快取來提供這種功能。</span><span class="sxs-lookup"><span data-stu-id="ba121-135">Some applications, such as virus-checking software, require that their write operations be flushed to disk immediately; Windows provides this ability through write-through caching.</span></span> <span data-ttu-id="ba121-136">程式會藉由將檔案 **\_ 旗標 \_ 寫入 \_ 至** [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea)的呼叫，藉以啟用特定 i/o 作業的寫入快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-136">A process enables write-through caching for a specific I/O operation by passing the **FILE\_FLAG\_WRITE\_THROUGH** flag into its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span> <span data-ttu-id="ba121-137">啟用寫入快取之後，資料仍會寫入快取中，但是快取管理員會將資料立即寫入磁片，而不是使用延遲寫入器產生延遲。</span><span class="sxs-lookup"><span data-stu-id="ba121-137">With write-through caching enabled, data is still written into the cache, but the cache manager writes the data immediately to disk rather than incurring a delay by using the lazy writer.</span></span> <span data-ttu-id="ba121-138">進程也可以藉由呼叫 [**FlushFileBuffers**](/windows/desktop/api/FileAPI/nf-fileapi-flushfilebuffers) 函式來強制清除其開啟的檔案。</span><span class="sxs-lookup"><span data-stu-id="ba121-138">A process can also force a flush of a file it has opened by calling the [**FlushFileBuffers**](/windows/desktop/api/FileAPI/nf-fileapi-flushfilebuffers) function.</span></span>

<span data-ttu-id="ba121-139">檔案系統中繼資料一律會進行快取。</span><span class="sxs-lookup"><span data-stu-id="ba121-139">File system metadata is always cached.</span></span> <span data-ttu-id="ba121-140">因此，若要將任何中繼資料變更儲存至磁片，必須 **\_ 透過檔案旗標 \_ 寫入 \_** 來清除或開啟檔案。</span><span class="sxs-lookup"><span data-stu-id="ba121-140">Therefore, to store any metadata changes to disk, the file must either be flushed or be opened with **FILE\_FLAG\_WRITE\_THROUGH**.</span></span>

 

 



