---
description: 深入瞭解 Shell 命名空間和其資料來源物件。 此命名空間提供 Windows Shell UI 中的擴充性選項。
ms.assetid: 539c4455-e1c7-45a0-b3c3-781f2b7a1617
title: Shell 命名空間簡介
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6e1be0187094ffe7cf7b56b724c5990fe18321fa
ms.sourcegitcommit: 5d4e99f4c8f42f5f543e52cb9beb9fb13ec56c5f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/19/2021
ms.locfileid: "112404291"
---
# <a name="introduction-to-the-shell-namespace"></a><span data-ttu-id="610b3-104">Shell 命名空間簡介</span><span class="sxs-lookup"><span data-stu-id="610b3-104">Introduction to the Shell Namespace</span></span>

<span data-ttu-id="610b3-105">Shell *命名空間* 會將檔案系統和其他由 shell 管理的物件組織成單一樹狀結構階層。</span><span class="sxs-lookup"><span data-stu-id="610b3-105">The Shell *namespace* organizes the file system and other objects managed by the Shell into a single tree-structured hierarchy.</span></span> <span data-ttu-id="610b3-106">就概念而言，它是較大且較多的檔案系統版本。</span><span class="sxs-lookup"><span data-stu-id="610b3-106">Conceptually, it is a larger and more inclusive version of the file system.</span></span>

-   [<span data-ttu-id="610b3-107">簡介</span><span class="sxs-lookup"><span data-stu-id="610b3-107">Introduction</span></span>](#introduction)
-   [<span data-ttu-id="610b3-108">識別命名空間物件</span><span class="sxs-lookup"><span data-stu-id="610b3-108">Identifying Namespace Objects</span></span>](#identifying-namespace-objects)
    -   [<span data-ttu-id="610b3-109">專案識別碼</span><span class="sxs-lookup"><span data-stu-id="610b3-109">Item IDs</span></span>](#item-ids)
    -   [<span data-ttu-id="610b3-110">專案識別碼清單</span><span class="sxs-lookup"><span data-stu-id="610b3-110">Item ID Lists</span></span>](#item-id-lists)
    -   [<span data-ttu-id="610b3-111">Pidl</span><span class="sxs-lookup"><span data-stu-id="610b3-111">PIDLs</span></span>](#pidls)
    -   [<span data-ttu-id="610b3-112">配置 Pidl</span><span class="sxs-lookup"><span data-stu-id="610b3-112">Allocating PIDLs</span></span>](#allocating-pidls)

## <a name="introduction"></a><span data-ttu-id="610b3-113">簡介</span><span class="sxs-lookup"><span data-stu-id="610b3-113">Introduction</span></span>

<span data-ttu-id="610b3-114">Shell 的主要職責之一就是管理和提供對組成系統的各種物件的存取權。</span><span class="sxs-lookup"><span data-stu-id="610b3-114">One of the primary responsibilities of the Shell is managing and providing access to the wide variety of objects that make up the system.</span></span> <span data-ttu-id="610b3-115">這些物件最多與熟悉的是位於電腦磁片磁碟機上的資料夾和檔案。</span><span class="sxs-lookup"><span data-stu-id="610b3-115">The most numerous and familiar of these objects are the folders and files that reside on computer disk drives.</span></span> <span data-ttu-id="610b3-116">不過，Shell 也會管理許多非系統或 *虛擬* 物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-116">However, the Shell manages a number of nonfile system, or *virtual* objects, as well.</span></span> <span data-ttu-id="610b3-117">部分範例包括：</span><span class="sxs-lookup"><span data-stu-id="610b3-117">Some examples include:</span></span>

-   <span data-ttu-id="610b3-118">網路印表機</span><span class="sxs-lookup"><span data-stu-id="610b3-118">Network printers</span></span>
-   <span data-ttu-id="610b3-119">其他網路電腦</span><span class="sxs-lookup"><span data-stu-id="610b3-119">Other networked computers</span></span>
-   <span data-ttu-id="610b3-120">主控台應用程式</span><span class="sxs-lookup"><span data-stu-id="610b3-120">Control Panel applications</span></span>
-   <span data-ttu-id="610b3-121">資源回收筒</span><span class="sxs-lookup"><span data-stu-id="610b3-121">The Recycle Bin</span></span>

<span data-ttu-id="610b3-122">某些虛擬物件完全不牽涉到實體儲存體。</span><span class="sxs-lookup"><span data-stu-id="610b3-122">Some virtual objects do not involve physical storage at all.</span></span> <span data-ttu-id="610b3-123">例如，印表機物件包含網路印表機的連結集合。</span><span class="sxs-lookup"><span data-stu-id="610b3-123">The printer object, for instance, contains a collection of links to networked printers.</span></span> <span data-ttu-id="610b3-124">其他虛擬物件（例如資源回收筒）可能包含儲存在磁片磁碟機上的資料，但必須以不同于一般檔案的方式來處理。</span><span class="sxs-lookup"><span data-stu-id="610b3-124">Other virtual objects, such as the Recycle Bin, may contain data that is stored on a disk drive, but needs to be handled differently than normal files.</span></span> <span data-ttu-id="610b3-125">例如，虛擬物件可以用來代表儲存在資料庫中的資料。</span><span class="sxs-lookup"><span data-stu-id="610b3-125">For example, a virtual object can be used to represent data stored in a database.</span></span> <span data-ttu-id="610b3-126">就命名空間而言，資料庫中的各種專案可能會以個別物件的形式出現在 Windows 檔案總管中，即使它們全都儲存在單一磁片檔案中也一樣。</span><span class="sxs-lookup"><span data-stu-id="610b3-126">In terms of the namespace, the various items in the database could appear in the Windows Explorer as separate objects, even though they are all stored in a single disk file.</span></span>

<span data-ttu-id="610b3-127">虛擬物件甚至可能位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="610b3-127">Virtual objects may even be located on remote computers.</span></span> <span data-ttu-id="610b3-128">例如，為了促進漫遊，使用者的檔檔案可能會儲存在伺服器上。</span><span class="sxs-lookup"><span data-stu-id="610b3-128">For instance, to facilitate roaming, a user's document files might be stored on a server.</span></span> <span data-ttu-id="610b3-129">為了讓使用者從多部桌上型電腦存取他們的檔案，他們目前使用的桌上型電腦上的我的檔資料夾會指向伺服器，而不是桌上型電腦的硬碟。</span><span class="sxs-lookup"><span data-stu-id="610b3-129">To give users access to their files from multiple desktop PCs, the My Documents folder on the desktop PC they are currently using will point to the server, not the hard disk of the desktop PC.</span></span> <span data-ttu-id="610b3-130">其路徑將包含對應的網路磁碟機機或 UNC 路徑名稱。</span><span class="sxs-lookup"><span data-stu-id="610b3-130">Its path will include either a mapped network drive or a UNC path name.</span></span>

<span data-ttu-id="610b3-131">命名空間和檔案系統一樣，包含兩種基本類型的物件：資料夾和檔案。</span><span class="sxs-lookup"><span data-stu-id="610b3-131">Like the file system, the namespace includes two basic types of object: folders and files.</span></span> <span data-ttu-id="610b3-132">資料夾物件是樹狀結構的 *節點* ;它們是檔物件和其他資料夾的容器。</span><span class="sxs-lookup"><span data-stu-id="610b3-132">Folder objects are the *nodes* of the tree; they are containers for file objects and other folders.</span></span> <span data-ttu-id="610b3-133">檔案物件是樹狀結構的 *葉* ;它們是一般磁片檔案或虛擬物件，例如印表機連結。</span><span class="sxs-lookup"><span data-stu-id="610b3-133">File objects are the *leaves* of the tree; they are either normal disk files or virtual objects, such as printer links.</span></span> <span data-ttu-id="610b3-134">不屬於檔案系統的資料夾有時稱為 *虛擬資料夾*。</span><span class="sxs-lookup"><span data-stu-id="610b3-134">Folders that are not part of the file system are sometimes referred to as *virtual folders*.</span></span>

<span data-ttu-id="610b3-135">如同檔系統資料夾，虛擬資料夾的集合通常會因系統而異。</span><span class="sxs-lookup"><span data-stu-id="610b3-135">Like file system folders, the collection of virtual folders generally varies from system to system.</span></span> <span data-ttu-id="610b3-136">虛擬資料夾有三個類別：</span><span class="sxs-lookup"><span data-stu-id="610b3-136">There are three classes of virtual folders:</span></span>

-   <span data-ttu-id="610b3-137">在所有系統上都能找到的標準虛擬資料夾，例如資源回收筒。</span><span class="sxs-lookup"><span data-stu-id="610b3-137">Standard virtual folders, such as the Recycle Bin, that are found on all systems.</span></span>
-   <span data-ttu-id="610b3-138">選用的虛擬資料夾，具有標準名稱和功能，但可能不會出現在所有系統上。</span><span class="sxs-lookup"><span data-stu-id="610b3-138">Optional virtual folders that have standard names and functionality, but may not be present on all systems.</span></span>
-   <span data-ttu-id="610b3-139">使用者所安裝的非標準資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-139">Non-standard folders that are installed by the user.</span></span>

<span data-ttu-id="610b3-140">不同于檔系統資料夾，使用者無法自行建立新的虛擬資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-140">Unlike file system folders, users cannot create new virtual folders themselves.</span></span> <span data-ttu-id="610b3-141">他們只能安裝非 Microsoft 開發人員所建立的使用者。</span><span class="sxs-lookup"><span data-stu-id="610b3-141">They can only install ones created by non-Microsoft developers.</span></span> <span data-ttu-id="610b3-142">因此，虛擬資料夾的數目通常比檔系統資料夾的數目少得多。</span><span class="sxs-lookup"><span data-stu-id="610b3-142">The number of virtual folders is thus normally much fewer than the number of file system folders.</span></span> <span data-ttu-id="610b3-143">如需如何執行虛擬資料夾的討論，請參閱 [命名空間延伸](nse-works.md)。</span><span class="sxs-lookup"><span data-stu-id="610b3-143">For a discussion of how to implement virtual folders see [Namespace Extensions](nse-works.md).</span></span>

<span data-ttu-id="610b3-144">您可以在 Windows 檔案總管的瀏覽器列中，看到命名空間結構的視覺化標記法。</span><span class="sxs-lookup"><span data-stu-id="610b3-144">You can see a visual representation of how the namespace is structured in the Explorer Bar of the Windows Explorer.</span></span> <span data-ttu-id="610b3-145">例如，下列 Windows 檔案總管的螢幕擷取畫面會顯示相對簡單的命名空間。</span><span class="sxs-lookup"><span data-stu-id="610b3-145">For example, the following screen shot of Windows Explorer shows a relatively simple namespace.</span></span>

![shell 命名空間的視圖](images/prog1.png)

<span data-ttu-id="610b3-147">命名空間階層的終極根目錄是桌面。</span><span class="sxs-lookup"><span data-stu-id="610b3-147">The ultimate root of the namespace hierarchy is the desktop.</span></span> <span data-ttu-id="610b3-148">根目錄正下方會有數個虛擬資料夾，例如我的電腦和資源回收筒。</span><span class="sxs-lookup"><span data-stu-id="610b3-148">Immediately below the root are several virtual folders such as My Computer and the Recycle Bin.</span></span>

<span data-ttu-id="610b3-149">各種磁片磁碟機的檔案系統可以被視為較大的命名空間階層的子集。</span><span class="sxs-lookup"><span data-stu-id="610b3-149">The file systems of the various disk drives can be seen to be subsets of the larger namespace hierarchy.</span></span> <span data-ttu-id="610b3-150">這些檔案系統的根目錄是我的電腦資料夾的子資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-150">The roots of these file systems are subfolders of the My Computer folder.</span></span> <span data-ttu-id="610b3-151">我的電腦也包含任何對應網路磁碟機機的根。</span><span class="sxs-lookup"><span data-stu-id="610b3-151">My Computer also includes the roots of any mapped network drives.</span></span> <span data-ttu-id="610b3-152">樹狀結構中的其他節點（例如我的檔）是虛擬資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-152">Other nodes in the tree, such as My Documents, are virtual folders.</span></span>

## <a name="identifying-namespace-objects"></a><span data-ttu-id="610b3-153">識別命名空間物件</span><span class="sxs-lookup"><span data-stu-id="610b3-153">Identifying Namespace Objects</span></span>

<span data-ttu-id="610b3-154">在您可以使用命名空間物件之前，您必須先有方法可以進行識別。</span><span class="sxs-lookup"><span data-stu-id="610b3-154">Before you can use a namespace object, you must first have a way of identifying it.</span></span> <span data-ttu-id="610b3-155">檔案系統中的物件可以有 MyFile.htm 之類的名稱。</span><span class="sxs-lookup"><span data-stu-id="610b3-155">An object in the file system could have a name such as MyFile.htm.</span></span> <span data-ttu-id="610b3-156">由於系統中的其他位置可能會有其他檔案，因此可唯一識別檔案或資料夾，需要完整路徑（例如 "C： \\ MyDocs \\MyFile.htm"）。</span><span class="sxs-lookup"><span data-stu-id="610b3-156">Because there might be other files with that name elsewhere in the system, uniquely identifying a file or folder requires a fully qualified path such as "C:\\MyDocs\\MyFile.htm".</span></span> <span data-ttu-id="610b3-157">這個路徑基本上是路徑中所有資料夾的排序清單，從檔案系統根目錄（C：）以檔案 \\ 結尾。</span><span class="sxs-lookup"><span data-stu-id="610b3-157">This path is basically an ordered list of all folders in a path from the file system root, C:\\, ending with the file.</span></span>

<span data-ttu-id="610b3-158">在命名空間的內容中，路徑仍相當適合用來識別位於命名空間之檔案系統部分中的物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-158">In the context of the namespace, paths are still quite useful for identifying objects located in the file system part of the namespace.</span></span> <span data-ttu-id="610b3-159">不過，它們無法用於虛擬物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-159">However, they cannot be used for virtual objects.</span></span> <span data-ttu-id="610b3-160">相反地，Shell 會提供另一種可搭配任何命名空間物件使用的識別方法。</span><span class="sxs-lookup"><span data-stu-id="610b3-160">Instead, the Shell provides an alternative means of identification that can be used with any namespace object.</span></span>

### <a name="item-ids"></a><span data-ttu-id="610b3-161">專案識別碼</span><span class="sxs-lookup"><span data-stu-id="610b3-161">Item IDs</span></span>

<span data-ttu-id="610b3-162">在資料夾內，每個物件都有一個 *專案識別碼*，也就是檔案或資料夾名稱的功能對等專案。</span><span class="sxs-lookup"><span data-stu-id="610b3-162">Within a folder, each object has an *item ID*, which is the functional equivalent of a file or folder name.</span></span> <span data-ttu-id="610b3-163">專案識別碼實際上是 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構：</span><span class="sxs-lookup"><span data-stu-id="610b3-163">The item ID is actually a [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure:</span></span>


```
typedef struct _SHITEMID { 
    USHORT cb; 
    BYTE   abID[1]; 
} SHITEMID, * LPSHITEMID; 
```



<span data-ttu-id="610b3-164">**AbID** 成員是物件的識別碼。</span><span class="sxs-lookup"><span data-stu-id="610b3-164">The **abID** member is the object's identifier.</span></span> <span data-ttu-id="610b3-165">未定義 **abID** 的長度，而且其值取決於包含物件的資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-165">The length of **abID** is not defined, and its value is determined by the folder that contains the object.</span></span> <span data-ttu-id="610b3-166">因為資料夾不會指派 **abID** 值的標準定義，所以它們只對相關聯的資料夾物件有意義。</span><span class="sxs-lookup"><span data-stu-id="610b3-166">Because there is no standard definition for how **abID** values are assigned by folders, they are only meaningful to the associated folder object.</span></span> <span data-ttu-id="610b3-167">應用程式應該直接將它們視為權杖，以識別特定資料夾中的物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-167">Applications should simply treat them as a token that identifies an object in a particular folder.</span></span> <span data-ttu-id="610b3-168">由於 **abID** 的長度不同，因此 **cb** 成員會保存 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構的大小（以位元組為單位）。</span><span class="sxs-lookup"><span data-stu-id="610b3-168">Because the length of **abID** varies, the **cb** member holds the size of the [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, in bytes.</span></span>

<span data-ttu-id="610b3-169">因為專案識別碼對於顯示用途沒有説明，所以包含物件的資料夾通常會為它指定顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="610b3-169">Because item IDs aren't useful for display purposes, the folder that contains the object normally assigns it a display name.</span></span> <span data-ttu-id="610b3-170">這是 Windows 檔案總管在顯示資料夾內容時所使用的名稱。</span><span class="sxs-lookup"><span data-stu-id="610b3-170">This is the name that is used by Windows Explorer when it displays the contents of a folder.</span></span> <span data-ttu-id="610b3-171">如需如何處理顯示名稱的詳細資訊，請參閱 [從資料夾取得資訊](folder-info.md)。</span><span class="sxs-lookup"><span data-stu-id="610b3-171">For more information on how display names are handled, see [Getting Information From a Folder](folder-info.md).</span></span>

### <a name="item-id-lists"></a><span data-ttu-id="610b3-172">專案識別碼清單</span><span class="sxs-lookup"><span data-stu-id="610b3-172">Item ID Lists</span></span>

<span data-ttu-id="610b3-173">專案識別碼很少使用。</span><span class="sxs-lookup"><span data-stu-id="610b3-173">The item ID is rarely used by itself.</span></span> <span data-ttu-id="610b3-174">通常，它是專案識別碼清單的一部分，與檔案系統路徑的用途相同。</span><span class="sxs-lookup"><span data-stu-id="610b3-174">Normally, it is part of an item ID list, which serves the same purpose as a file system path.</span></span> <span data-ttu-id="610b3-175">但是，不是路徑所使用的字元字串，而是專案 ID 清單是 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構。</span><span class="sxs-lookup"><span data-stu-id="610b3-175">However, instead of the character string used for paths, an item ID list is an [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure.</span></span> <span data-ttu-id="610b3-176">此結構是一或多個專案 Id 的排序次序，以兩個位元組的 **Null** 結束。</span><span class="sxs-lookup"><span data-stu-id="610b3-176">This structure is an ordered sequence of one or more item IDs, terminated by a two-byte **NULL**.</span></span> <span data-ttu-id="610b3-177">專案識別碼清單中的每個專案識別碼都會對應至命名空間物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-177">Each item ID in the item ID list corresponds to a namespace object.</span></span> <span data-ttu-id="610b3-178">它們的順序定義了命名空間中的路徑，與檔案系統路徑很類似。</span><span class="sxs-lookup"><span data-stu-id="610b3-178">Their order defines a path in the namespace, much like a file system path.</span></span>

<span data-ttu-id="610b3-179">下圖顯示對應至 C： MyDocsMyFile.htm 之 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構的示意標記法 \\ \\ 。</span><span class="sxs-lookup"><span data-stu-id="610b3-179">The following illustration shows a schematic representation of the [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure that corresponds to C:\\MyDocs\\MyFile.htm.</span></span> <span data-ttu-id="610b3-180">每個專案識別碼的顯示名稱會顯示在其上方。</span><span class="sxs-lookup"><span data-stu-id="610b3-180">The display name of each item ID is shown above it.</span></span> <span data-ttu-id="610b3-181">不同的 **abID** 成員寬度是任意的;它們說明這個成員的大小可能不同的事實。</span><span class="sxs-lookup"><span data-stu-id="610b3-181">The varying widths of the **abID** members are arbitrary; they illustrate the fact that the size of this member can vary.</span></span>

![pidl 的圖解圖解](images/shell2.png)

### <a name="pidls"></a><span data-ttu-id="610b3-183">Pidl</span><span class="sxs-lookup"><span data-stu-id="610b3-183">PIDLs</span></span>

<span data-ttu-id="610b3-184">針對 Shell API，命名空間物件通常是以其 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構的指標來識別，或指向專案識別碼清單的指標， (PIDL) 。</span><span class="sxs-lookup"><span data-stu-id="610b3-184">For the Shell API, namespace objects are usually identified by a pointer to their [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure, or pointer to an item identifier list (PIDL).</span></span> <span data-ttu-id="610b3-185">為了方便起見，PIDL 一詞通常會在此檔中參考結構本身，而不是指向它的指標。</span><span class="sxs-lookup"><span data-stu-id="610b3-185">For convenience, the term PIDL will generally refer in this documentation to the structure itself rather than the pointer to it.</span></span>

<span data-ttu-id="610b3-186">上圖所示的 PIDL 稱為 *full* 或 *絕對* PIDL。</span><span class="sxs-lookup"><span data-stu-id="610b3-186">The PIDL shown in the preceding illustration is referred to as a *full*, or *absolute*, PIDL.</span></span> <span data-ttu-id="610b3-187">完整 PIDL 會從桌面開始，並包含路徑中所有中繼資料夾的專案識別碼。</span><span class="sxs-lookup"><span data-stu-id="610b3-187">A full PIDL starts from the desktop, and contains the item IDs of all intermediate folders in the path.</span></span> <span data-ttu-id="610b3-188">它的結尾是物件的專案識別碼，後面接著終止的雙位元組 **Null**。</span><span class="sxs-lookup"><span data-stu-id="610b3-188">It ends with the object's item ID followed by a terminating two-byte **NULL**.</span></span> <span data-ttu-id="610b3-189">完整的 PIDL 與完整路徑類似，並且可唯一識別 Shell 命名空間中的物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-189">A full PIDL is similar to a fully qualified path and uniquely identifies the object in the Shell namespace.</span></span>

<span data-ttu-id="610b3-190">不常使用完整 Pidl。</span><span class="sxs-lookup"><span data-stu-id="610b3-190">Full PIDLs are used infrequently.</span></span> <span data-ttu-id="610b3-191">許多函式和方法都需要 *相對 PIDL*。</span><span class="sxs-lookup"><span data-stu-id="610b3-191">Many functions and methods expect a *relative PIDL*.</span></span> <span data-ttu-id="610b3-192">相對 PIDL 的根目錄是資料夾，而不是桌面。</span><span class="sxs-lookup"><span data-stu-id="610b3-192">The root of a relative PIDL is a folder, not the desktop.</span></span> <span data-ttu-id="610b3-193">如同相對路徑，組成結構的專案識別碼系列會在命名空間中定義兩個物件之間的路徑。</span><span class="sxs-lookup"><span data-stu-id="610b3-193">As with relative paths, the series of item IDs that make up the structure define a path in the namespace between two objects.</span></span> <span data-ttu-id="610b3-194">雖然它們無法唯一識別物件，但它們通常會小於完整 PIDL，而且足以滿足許多用途。</span><span class="sxs-lookup"><span data-stu-id="610b3-194">Although they do not uniquely identify the object, they are usually smaller than a full PIDL and sufficient for many purposes.</span></span>

<span data-ttu-id="610b3-195">最常使用的相對 Pidl （ *單一層級 pidl*）是相對於物件的父資料夾。</span><span class="sxs-lookup"><span data-stu-id="610b3-195">The most commonly used relative PIDLs, *single-level PIDLs*, are relative to the object's parent folder.</span></span> <span data-ttu-id="610b3-196">它們只包含物件的專案識別碼和終止的 **Null**。</span><span class="sxs-lookup"><span data-stu-id="610b3-196">They contain only the object's item ID and a terminating **NULL**.</span></span> <span data-ttu-id="610b3-197">多層級的 Pidl 也可用於許多用途。</span><span class="sxs-lookup"><span data-stu-id="610b3-197">Multi-level PIDLs are also used for many purposes.</span></span> <span data-ttu-id="610b3-198">它們包含兩個或多個專案識別碼，通常會透過一或多個子資料夾的一連串，定義從父資料夾到物件的路徑。</span><span class="sxs-lookup"><span data-stu-id="610b3-198">They contain two or more item IDs and typically define a path from a parent folder to an object through a series of one or more subfolders.</span></span> <span data-ttu-id="610b3-199">請注意，單一層級的 PIDL 仍然可以是完整的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="610b3-199">Note that a single-level PIDL can still be a fully qualified PIDL.</span></span> <span data-ttu-id="610b3-200">尤其是桌面物件是桌面的子系，因此其完整 Pidl 只包含一個專案識別碼。</span><span class="sxs-lookup"><span data-stu-id="610b3-200">In particular, desktop objects are children of the desktop, so their fully qualified PIDLs contain only one item ID.</span></span>

<span data-ttu-id="610b3-201">如同 [取得資料夾識別碼](folder-id.md)所述，Shell API 提供了許多方法來取得物件的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="610b3-201">As discussed in [Getting a Folder's ID](folder-id.md), the Shell API provides a number of ways to retrieve an object's PIDL.</span></span> <span data-ttu-id="610b3-202">一旦有了此功能，您通常只會在呼叫其他 Shell API 函式和方法時，使用它來識別物件。</span><span class="sxs-lookup"><span data-stu-id="610b3-202">Once you have it, you commonly just use it to identify the object when you call other Shell API functions and methods.</span></span> <span data-ttu-id="610b3-203">在此內容中，PIDL 的內部內容不透明且不相關。</span><span class="sxs-lookup"><span data-stu-id="610b3-203">In this context, a PIDL's internal contents are opaque and irrelevant.</span></span> <span data-ttu-id="610b3-204">基於此討論的目的，請將 Pidl 視為代表特定命名空間物件的權杖，並將焦點放在如何將它們用於一般工作。</span><span class="sxs-lookup"><span data-stu-id="610b3-204">For the purposes of this discussion, think of PIDLs as tokens that represent particular namespace objects, and focus on how to use them for common tasks.</span></span>

### <a name="allocating-pidls"></a><span data-ttu-id="610b3-205">配置 Pidl</span><span class="sxs-lookup"><span data-stu-id="610b3-205">Allocating PIDLs</span></span>

<span data-ttu-id="610b3-206">雖然 Pidl 與路徑有一些相似之處，但使用它們需要稍微不同的方法。</span><span class="sxs-lookup"><span data-stu-id="610b3-206">Although PIDLs have some similarity to paths, using them requires a somewhat different approach.</span></span> <span data-ttu-id="610b3-207">主要差異在於如何為它們配置和解除配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="610b3-207">The primary difference is in how to allocate and deallocate memory for them.</span></span>

<span data-ttu-id="610b3-208">就像路徑所用的字串一樣，必須為 PIDL 配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="610b3-208">Like the string used for a path, memory must be allocated for a PIDL.</span></span> <span data-ttu-id="610b3-209">如果應用程式建立 PIDL，則必須為 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構配置足夠的記憶體。</span><span class="sxs-lookup"><span data-stu-id="610b3-209">If an application creates a PIDL, it must allocate sufficient memory for the [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure.</span></span> <span data-ttu-id="610b3-210">在這裡討論的大部分案例中，Shell 會建立 PIDL 並處理記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="610b3-210">For most of the cases discussed here, the Shell creates the PIDL and handles memory allocation.</span></span> <span data-ttu-id="610b3-211">無論配置 PIDL 的內容為何，應用程式通常會在不再需要時，負責將 PIDL 解除配置。</span><span class="sxs-lookup"><span data-stu-id="610b3-211">Regardless of what allocated the PIDL, the application is usually responsible for deallocating the PIDL when it is no longer needed.</span></span>

<span data-ttu-id="610b3-212">您可以使用 [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) 函式來配置 PIDL，並使用 [**CoTaskMemFree**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemfree) 函式將它解除配置。</span><span class="sxs-lookup"><span data-stu-id="610b3-212">Use the [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) function to allocate the PIDL, and the [**CoTaskMemFree**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemfree) function to deallocate it.</span></span>

 

 
