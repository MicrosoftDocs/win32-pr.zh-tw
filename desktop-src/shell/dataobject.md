---
description: 資料物件是所有 Shell 資料傳輸的核心。
ms.assetid: c63d339e-ac62-4da1-b5ce-22d45a6a3413
title: 命令介面資料物件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 69a6c411310b6c9e9f28df4de048d3b6909c44b9
ms.sourcegitcommit: 822413efb4a70dd464e5db4d9e8693ef74f8132f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/09/2021
ms.locfileid: "113581626"
---
# <a name="shell-data-object"></a><span data-ttu-id="01dfd-103">命令介面資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-103">Shell Data Object</span></span>

<span data-ttu-id="01dfd-104">資料物件是所有 Shell 資料傳輸的核心。</span><span class="sxs-lookup"><span data-stu-id="01dfd-104">The data object is central to all Shell data transfers.</span></span> <span data-ttu-id="01dfd-105">它主要是用來保存已傳送資料的容器。</span><span class="sxs-lookup"><span data-stu-id="01dfd-105">It is primarily a container to hold the transferred data.</span></span> <span data-ttu-id="01dfd-106">不過，目標也可以與資料物件進行通訊，以促進某些特製化類型的 Shell 資料傳輸，例如優化的移動。</span><span class="sxs-lookup"><span data-stu-id="01dfd-106">However, the target can also communicate with the data object to facilitate some specialized types of Shell data transfer such as optimized moves.</span></span> <span data-ttu-id="01dfd-107">本主題提供 Shell 資料物件如何運作的一般討論、來源如何建立它們，以及目標如何處理它們。</span><span class="sxs-lookup"><span data-stu-id="01dfd-107">This topic provides a general discussion of how Shell data objects work, how they are constructed by a source, and how they are handled by a target.</span></span> <span data-ttu-id="01dfd-108">如需如何使用資料物件來傳送不同類型之 Shell 資料的詳細討論，請參閱 [處理 Shell 資料傳輸案例](datascenarios.md)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-108">For a detailed discussion of how to use data objects to transfer different types of Shell data, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

-   [<span data-ttu-id="01dfd-109">資料物件的運作方式</span><span class="sxs-lookup"><span data-stu-id="01dfd-109">How Data Objects Work</span></span>](#how-data-objects-work)
    -   [<span data-ttu-id="01dfd-110">剪貼簿格式</span><span class="sxs-lookup"><span data-stu-id="01dfd-110">Clipboard Formats</span></span>](#clipboard-formats)
    -   [<span data-ttu-id="01dfd-111">FORMATETC 結構</span><span class="sxs-lookup"><span data-stu-id="01dfd-111">FORMATETC Structure</span></span>](#formatetc-structure)
    -   [<span data-ttu-id="01dfd-112">STGMEDIUM 結構</span><span class="sxs-lookup"><span data-stu-id="01dfd-112">STGMEDIUM structure</span></span>](#stgmedium-structure)
-   [<span data-ttu-id="01dfd-113">來源如何建立資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-113">How a Source Creates a Data Object</span></span>](#how-a-source-creates-a-data-object)
    -   [<span data-ttu-id="01dfd-114">如何將全域記憶體物件加入至資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-114">How to Add a Global Memory Object to a Data Object</span></span>](#how-to-add-a-global-memory-object-to-a-data-object)
    -   [<span data-ttu-id="01dfd-115">執行 IDataObject</span><span class="sxs-lookup"><span data-stu-id="01dfd-115">Implementing IDataObject</span></span>](#implementing-idataobject)
    -   [<span data-ttu-id="01dfd-116">執行 IDropSource</span><span class="sxs-lookup"><span data-stu-id="01dfd-116">Implementing IDropSource</span></span>](#implementing-idropsource)
-   [<span data-ttu-id="01dfd-117">目標如何處理資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-117">How a Target Handles a Data Object</span></span>](#how-a-target-handles-a-data-object)
    -   [<span data-ttu-id="01dfd-118">從資料物件解壓縮 Shell 資料</span><span class="sxs-lookup"><span data-stu-id="01dfd-118">Extracting Shell Data from a Data Object</span></span>](#extracting-shell-data-from-a-data-object)
    -   [<span data-ttu-id="01dfd-119">執行 IDropTarget</span><span class="sxs-lookup"><span data-stu-id="01dfd-119">Implementing IDropTarget</span></span>](#implementing-idroptarget)
-   [<span data-ttu-id="01dfd-120">使用拖放 Helper 物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-120">Using the Drag-and-Drop Helper Object</span></span>](#using-the-drag-and-drop-helper-object)
    -   [<span data-ttu-id="01dfd-121">使用 IDragSourceHelper 介面</span><span class="sxs-lookup"><span data-stu-id="01dfd-121">Using the IDragSourceHelper Interface</span></span>](#using-the-idragsourcehelper-interface)
    -   [<span data-ttu-id="01dfd-122">使用 IDropTargetHelper 介面</span><span class="sxs-lookup"><span data-stu-id="01dfd-122">Using the IDropTargetHelper Interface</span></span>](#using-the-idroptargethelper-interface)

## <a name="how-data-objects-work"></a><span data-ttu-id="01dfd-123">資料物件的運作方式</span><span class="sxs-lookup"><span data-stu-id="01dfd-123">How Data Objects Work</span></span>

<span data-ttu-id="01dfd-124">資料物件是元件物件模型 (COM) 物件，由資料來源建立，以將資料傳送至目標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-124">Data objects are Component Object Model (COM) objects, created by the data source to transfer data to a target.</span></span> <span data-ttu-id="01dfd-125">它們通常會包含一個以上的資料項目目。</span><span class="sxs-lookup"><span data-stu-id="01dfd-125">They typically carry more than one item of data.</span></span> <span data-ttu-id="01dfd-126">這種作法有兩個原因：</span><span class="sxs-lookup"><span data-stu-id="01dfd-126">There are two reasons for this practice:</span></span>

-   <span data-ttu-id="01dfd-127">雖然幾乎任何類型的資料都可以使用資料物件傳送，但來源通常不知道目標可接受的資料類型。</span><span class="sxs-lookup"><span data-stu-id="01dfd-127">While almost any type of data can be transferred with a data object, the source typically does not know what kind of data the target can accept.</span></span> <span data-ttu-id="01dfd-128">例如，資料可能是格式化文字檔的一部分。</span><span class="sxs-lookup"><span data-stu-id="01dfd-128">For instance, the data might be a portion of a formatted text document.</span></span> <span data-ttu-id="01dfd-129">雖然目標可能能夠處理複雜的格式設定資訊，但它也可能只接受 ANSI 文字。</span><span class="sxs-lookup"><span data-stu-id="01dfd-129">While the target might be able to handle complex formatting information, it might also be able to accept only ANSI text.</span></span> <span data-ttu-id="01dfd-130">基於這個理由，資料物件通常會以數種不同的格式包含相同的資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-130">For this reason, data objects often include the same data in several different formats.</span></span> <span data-ttu-id="01dfd-131">然後，目標可以使用它可以處理的格式來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-131">The target can then extract the data in a format that it can handle.</span></span>
-   <span data-ttu-id="01dfd-132">資料物件也可以包含不是來源資料版本的輔助資料項目目。</span><span class="sxs-lookup"><span data-stu-id="01dfd-132">Data objects can also contain auxiliary data items that are not versions of source data.</span></span> <span data-ttu-id="01dfd-133">這種類型的資料項目通常會提供資料傳輸作業的其他相關資訊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-133">This type of data item typically provides additional information about the data transfer operation.</span></span> <span data-ttu-id="01dfd-134">例如，Shell 會使用輔助資料項目來指出是否要複製或移動檔案。</span><span class="sxs-lookup"><span data-stu-id="01dfd-134">For instance, the Shell uses auxiliary data items to indicate whether a file is to be copied or moved.</span></span>

### <a name="clipboard-formats"></a><span data-ttu-id="01dfd-135">剪貼簿格式</span><span class="sxs-lookup"><span data-stu-id="01dfd-135">Clipboard Formats</span></span>

<span data-ttu-id="01dfd-136">資料物件中的每個資料項目目都有相關聯的格式，通常稱為「剪貼簿」 *格式*。</span><span class="sxs-lookup"><span data-stu-id="01dfd-136">Each item of data in a data object has an associated format, usually called a *clipboard format*.</span></span> <span data-ttu-id="01dfd-137">在 Winuser 中宣告的一些標準剪貼簿格式，會對應到常用的資料類型。</span><span class="sxs-lookup"><span data-stu-id="01dfd-137">There are a number of standard clipboard formats, declared in Winuser.h, that correspond to commonly used types of data.</span></span> <span data-ttu-id="01dfd-138">剪貼簿格式是整數，但通常是以其對等名稱（其格式為 CF \_ *XXX*）參考。</span><span class="sxs-lookup"><span data-stu-id="01dfd-138">Clipboard formats are integers, but they are normally referred to by their equivalent name, which has the form CF\_*XXX*.</span></span> <span data-ttu-id="01dfd-139">例如，ANSI 文字的剪貼簿格式為 CF \_ 文字。</span><span class="sxs-lookup"><span data-stu-id="01dfd-139">For instance, the clipboard format for ANSI text is CF\_TEXT.</span></span>

<span data-ttu-id="01dfd-140">應用程式可以藉由定義私用格式來擴充可用剪貼簿格式的範圍。</span><span class="sxs-lookup"><span data-stu-id="01dfd-140">Applications can extend the range of available clipboard formats by defining private formats.</span></span> <span data-ttu-id="01dfd-141">若要定義私用格式，應用程式會使用可識別格式的字串來呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-141">To define a private format, an application calls [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) with a string that identifies the format.</span></span> <span data-ttu-id="01dfd-142">函數傳回的不帶正負號整數是有效的格式值，可以像標準剪貼簿格式一樣使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-142">The unsigned integer that the function returns is a valid format value that can be used just like a standard clipboard format.</span></span> <span data-ttu-id="01dfd-143">不過，來源和目標都必須註冊格式才能使用它。</span><span class="sxs-lookup"><span data-stu-id="01dfd-143">However, both source and target must register the format in order to use it.</span></span> <span data-ttu-id="01dfd-144">有一個例外狀況（[CF \_ HDROP](clipboard.md)），用來傳輸 Shell 資料的剪貼簿格式會定義為私用格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-144">With one exception—[CF\_HDROP](clipboard.md)—the clipboard formats used to transfer Shell data are defined as private formats.</span></span> <span data-ttu-id="01dfd-145">它們必須先由來源和目標注冊，才能使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-145">They must be registered by the source and target before they can be used.</span></span> <span data-ttu-id="01dfd-146">如需可用 Shell 剪貼簿格式的描述，請參閱 Shell 剪貼簿格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-146">For a description of the available Shell clipboard formats, see Shell Clipboard Formats.</span></span>

<span data-ttu-id="01dfd-147">雖然有一些例外狀況，但資料物件通常只會針對每個支援的剪貼簿格式包含一個資料項目目。</span><span class="sxs-lookup"><span data-stu-id="01dfd-147">Although there are some exceptions, data objects normally contain only one item of data for each clipboard format they support.</span></span> <span data-ttu-id="01dfd-148">格式和資料之間的一對一相互關聯可讓格式值當做相關資料項目的識別碼使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-148">This one-to-one correlation between format and data allows the format value to be used as an identifier for the associated data item.</span></span> <span data-ttu-id="01dfd-149">事實上，在討論資料物件的內容時，特定的資料項目目通常稱為「格式」，而且是由其格式名稱所參考。</span><span class="sxs-lookup"><span data-stu-id="01dfd-149">In fact, when discussing the contents of a data object, a particular item of data is typically called a "format" and is referred to by its format name.</span></span> <span data-ttu-id="01dfd-150">例如，「解壓縮 CF \_ 文字格式 ...」這類片語通常用於討論資料物件的 ANSI 文字資料項目。</span><span class="sxs-lookup"><span data-stu-id="01dfd-150">For example, phrases such as "Extract the CF\_TEXT format..." are typically used when discussing a data object's ANSI text data item.</span></span>

<span data-ttu-id="01dfd-151">當放置目標接收到資料物件的指標時，放置目標會列舉可用的格式，以判斷哪些類型的資料可以使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-151">When the drop target receives the pointer to the data object, the drop target enumerates the available formats to determine what types of data are available.</span></span> <span data-ttu-id="01dfd-152">然後，它會要求一或多個可用的格式，並解壓縮資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-152">It then requests one or more of the available formats and extracts the data.</span></span> <span data-ttu-id="01dfd-153">目標從資料物件解壓縮 Shell 資料的特定方式會因格式而異;這會在 [目標處理資料物件的方式](#how-a-target-handles-a-data-object)中詳細討論。</span><span class="sxs-lookup"><span data-stu-id="01dfd-153">The specific way that the target extracts Shell data from a data object varies with the format; this is discussed in detail in [How a Target Handles a Data Object](#how-a-target-handles-a-data-object).</span></span>

<span data-ttu-id="01dfd-154">使用簡單的剪貼簿資料傳輸時，資料會放在全域記憶體物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-154">With simple clipboard data transfers, the data is placed in a global memory object.</span></span> <span data-ttu-id="01dfd-155">該物件的位址會放置在剪貼簿上，連同其格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-155">The address of that object is placed on the Clipboard, along with its format.</span></span> <span data-ttu-id="01dfd-156">剪貼簿格式會告訴目標它會在相關聯的位址找到哪種資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-156">The clipboard format tells the target what kind of data it will find at the associated address.</span></span> <span data-ttu-id="01dfd-157">雖然簡單的剪貼簿傳輸很容易執行：</span><span class="sxs-lookup"><span data-stu-id="01dfd-157">While simple clipboard transfers are easy to implement:</span></span>

-   <span data-ttu-id="01dfd-158">資料物件提供更有彈性的方式來傳輸資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-158">Data objects provide a much more flexible way to transfer data.</span></span>
-   <span data-ttu-id="01dfd-159">資料物件更適合傳輸大量資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-159">Data objects are better suited for transferring large amounts of data.</span></span>
-   <span data-ttu-id="01dfd-160">使用拖放作業時，必須使用資料物件來傳輸資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-160">Data objects must be used to transfer data with a drag-and-drop operation.</span></span>

<span data-ttu-id="01dfd-161">基於這些原因，所有 Shell 資料傳輸都會使用資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-161">For these reasons, all Shell data transfers use data objects.</span></span> <span data-ttu-id="01dfd-162">使用資料物件時，不會直接使用剪貼簿格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-162">With data objects, clipboard formats are not used directly.</span></span> <span data-ttu-id="01dfd-163">相反地，資料項目目會以剪貼簿格式的一般化（ [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構）來識別。</span><span class="sxs-lookup"><span data-stu-id="01dfd-163">Instead, data items are identified with a generalization of the clipboard format, a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span>

### <a name="formatetc-structure"></a><span data-ttu-id="01dfd-164">FORMATETC 結構</span><span class="sxs-lookup"><span data-stu-id="01dfd-164">FORMATETC Structure</span></span>

<span data-ttu-id="01dfd-165">[**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構是剪貼簿格式的擴充版本。</span><span class="sxs-lookup"><span data-stu-id="01dfd-165">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is an extended version of a clipboard format.</span></span> <span data-ttu-id="01dfd-166">如同用於 Shell 資料傳輸， **FORMATETC** 結構具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="01dfd-166">As used for Shell data transfers, the **FORMATETC** structure has the following characteristics:</span></span>

-   <span data-ttu-id="01dfd-167">資料項目在 **cfFormat** 成員中仍是以其剪貼簿格式來識別。</span><span class="sxs-lookup"><span data-stu-id="01dfd-167">A data item is still identified by its clipboard format, in the **cfFormat** member.</span></span>
-   <span data-ttu-id="01dfd-168">資料傳輸不限於全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-168">Data transfer is not limited to global memory objects.</span></span> <span data-ttu-id="01dfd-169">**Tymed** 成員是用來指出相關聯的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構中所包含的資料傳輸機制。</span><span class="sxs-lookup"><span data-stu-id="01dfd-169">The **tymed** member is used to indicate the data transfer mechanism contained in the associated [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="01dfd-170">它會設定為其中一個 [**TYMED \_ XXX**](/windows/win32/api/objidl/ne-objidl-tymed) 值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-170">It is set to one of the [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) values.</span></span>
-   <span data-ttu-id="01dfd-171">Shell 會使用 **lIndex** 成員及其 [CFSTR \_ FILECONTENTS](clipboard.md) 格式，讓資料物件能夠包含每個格式的一個以上資料項目。</span><span class="sxs-lookup"><span data-stu-id="01dfd-171">The Shell uses the **lIndex** member with its [CFSTR\_FILECONTENTS](clipboard.md) format to allow a data object to contain more than one data item per format.</span></span> <span data-ttu-id="01dfd-172">如需如何使用此格式的討論，請參閱 [處理 Shell 資料傳輸案例](datascenarios.md)的 *使用 CFSTR \_ FILECONTENTS 格式從檔案解壓縮資料* 一節。</span><span class="sxs-lookup"><span data-stu-id="01dfd-172">For a discussion of how to use this format, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>
-   <span data-ttu-id="01dfd-173">**DwAspect** 成員通常會設定為 >dvaspect \_ 內容。</span><span class="sxs-lookup"><span data-stu-id="01dfd-173">The **dwAspect** member is typically set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="01dfd-174">不過，Shlobj.h 中定義了三個可用於 Shell 資料傳輸的值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-174">However, there are three values defined in Shlobj.h that can be used for Shell data transfer.</span></span> 

    | <span data-ttu-id="01dfd-175">值</span><span class="sxs-lookup"><span data-stu-id="01dfd-175">Value</span></span>               | <span data-ttu-id="01dfd-176">描述</span><span class="sxs-lookup"><span data-stu-id="01dfd-176">Description</span></span>                                                                                       |
    |---------------------|---------------------------------------------------------------------------------------------------|
    | <span data-ttu-id="01dfd-177">>DVASPECT \_ 複製</span><span class="sxs-lookup"><span data-stu-id="01dfd-177">DVASPECT\_COPY</span></span>      | <span data-ttu-id="01dfd-178">用來表示格式代表資料的複本。</span><span class="sxs-lookup"><span data-stu-id="01dfd-178">Used to indicate that the format represents a copy of the data.</span></span>                                   |
    | <span data-ttu-id="01dfd-179">>DVASPECT \_ 連結</span><span class="sxs-lookup"><span data-stu-id="01dfd-179">DVASPECT\_LINK</span></span>      | <span data-ttu-id="01dfd-180">用來表示格式代表資料的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-180">Used to indicate that the format represents a shortcut to the data.</span></span>                               |
    | <span data-ttu-id="01dfd-181">>DVASPECT \_ SHORTNAME</span><span class="sxs-lookup"><span data-stu-id="01dfd-181">DVASPECT\_SHORTNAME</span></span> | <span data-ttu-id="01dfd-182">搭配 CF \_ HDROP 格式使用，可要求名稱縮短為8.3 格式的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="01dfd-182">Used with the CF\_HDROP format to request a file path with the names shortened to the 8.3 format.</span></span> |

    

     

-   <span data-ttu-id="01dfd-183">**Ptd** 成員不會用於 Shell 資料傳輸，而且通常會設定為 **Null**。</span><span class="sxs-lookup"><span data-stu-id="01dfd-183">The **ptd** member is not used for Shell data transfers and is normally set to **NULL**.</span></span>

### <a name="stgmedium-structure"></a><span data-ttu-id="01dfd-184">STGMEDIUM 結構</span><span class="sxs-lookup"><span data-stu-id="01dfd-184">STGMEDIUM structure</span></span>

<span data-ttu-id="01dfd-185">[**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構會提供所傳送資料的存取權。</span><span class="sxs-lookup"><span data-stu-id="01dfd-185">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure provides access to the data being transferred.</span></span> <span data-ttu-id="01dfd-186">Shell 資料支援三種資料傳輸機制：</span><span class="sxs-lookup"><span data-stu-id="01dfd-186">Three data transfer mechanisms are supported for Shell data:</span></span>

-   <span data-ttu-id="01dfd-187">全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-187">A global memory object.</span></span>
-   <span data-ttu-id="01dfd-188">[**IStream**](/windows/win32/api/objidl/nn-objidl-istream)介面。</span><span class="sxs-lookup"><span data-stu-id="01dfd-188">An [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span>
-   <span data-ttu-id="01dfd-189">[**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage)介面。</span><span class="sxs-lookup"><span data-stu-id="01dfd-189">An [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="01dfd-190">[**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的 **Tymed** 成員是 [**tymed \_ XXX**](/windows/win32/api/objidl/ne-objidl-tymed)值，用來識別資料傳輸機制。</span><span class="sxs-lookup"><span data-stu-id="01dfd-190">The **tymed** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure is a [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) value that identifies the data transfer mechanism.</span></span> <span data-ttu-id="01dfd-191">第二個成員是目標用來將資料解壓縮的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-191">The second member is a pointer that is used by the target to extract the data.</span></span> <span data-ttu-id="01dfd-192">根據 **tymed** 值而定，指標可以是各種類型的其中一個。</span><span class="sxs-lookup"><span data-stu-id="01dfd-192">The pointer can be one of a variety of types, depending on the **tymed** value.</span></span> <span data-ttu-id="01dfd-193">下表摘要說明用於 Shell 資料傳輸的三個 **tymed** 值，以及其對應的 **STGMEDIUM** 成員名稱。</span><span class="sxs-lookup"><span data-stu-id="01dfd-193">The three **tymed** values that are used for Shell data transfers are summarized in the following table, along with their corresponding **STGMEDIUM** member name.</span></span>



| <span data-ttu-id="01dfd-194">tymed 值</span><span class="sxs-lookup"><span data-stu-id="01dfd-194">tymed Value</span></span>     | <span data-ttu-id="01dfd-195">成員名稱</span><span class="sxs-lookup"><span data-stu-id="01dfd-195">Member name</span></span> | <span data-ttu-id="01dfd-196">說明</span><span class="sxs-lookup"><span data-stu-id="01dfd-196">Description</span></span>                                                                                                                                                                                                                                                                                                       |
|-----------------|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="01dfd-197">TYMED \_ HGLOBAL</span><span class="sxs-lookup"><span data-stu-id="01dfd-197">TYMED\_HGLOBAL</span></span>  | <span data-ttu-id="01dfd-198">**hGlobal**</span><span class="sxs-lookup"><span data-stu-id="01dfd-198">**hGlobal**</span></span> | <span data-ttu-id="01dfd-199">全域記憶體物件的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-199">A pointer to a global memory object.</span></span> <span data-ttu-id="01dfd-200">此指標類型通常用來傳輸少量的資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-200">This pointer type is typically used for transferring small amounts of data.</span></span> <span data-ttu-id="01dfd-201">例如，Shell 會使用全域記憶體物件來傳送簡短的文字字串，例如檔案名或 Url。</span><span class="sxs-lookup"><span data-stu-id="01dfd-201">For instance, the Shell uses global memory objects to transfer short text strings such as file names or URLs.</span></span>                                                                                    |
| <span data-ttu-id="01dfd-202">TYMED \_ ISTREAM</span><span class="sxs-lookup"><span data-stu-id="01dfd-202">TYMED\_ISTREAM</span></span>  | <span data-ttu-id="01dfd-203">**pstm**</span><span class="sxs-lookup"><span data-stu-id="01dfd-203">**pstm**</span></span>    | <span data-ttu-id="01dfd-204">[**IStream**](/windows/win32/api/objidl/nn-objidl-istream)介面的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-204">A pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="01dfd-205">此指標類型對於大部分的 Shell 資料傳輸而言是慣用的，因為相較于 TYMED HGLOBAL，它需要較少的記憶體 \_ 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-205">This pointer type is preferred for most Shell data transfers because it requires relatively little memory compared to TYMED\_HGLOBAL.</span></span> <span data-ttu-id="01dfd-206">此外，TYMED 的 \_ ISTREAM 資料傳輸機制不需要來源以任何特定方式儲存其資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-206">Also, the TYMED\_ISTREAM data transfer mechanism does not require the source to store its data in any particular way.</span></span> |
| <span data-ttu-id="01dfd-207">TYMED \_ ISTORAGE</span><span class="sxs-lookup"><span data-stu-id="01dfd-207">TYMED\_ISTORAGE</span></span> | <span data-ttu-id="01dfd-208">**pstg**</span><span class="sxs-lookup"><span data-stu-id="01dfd-208">**pstg**</span></span>    | <span data-ttu-id="01dfd-209">[**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage)介面的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-209">A pointer to an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="01dfd-210">目標會呼叫介面方法來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-210">The target calls the interface methods to extract the data.</span></span> <span data-ttu-id="01dfd-211">如同 TYMED \_ ISTREAM，此指標類型需要較少的記憶體。</span><span class="sxs-lookup"><span data-stu-id="01dfd-211">Like TYMED\_ISTREAM, this pointer type requires relatively little memory.</span></span> <span data-ttu-id="01dfd-212">不過，由於 TYMED \_ ISTORAGE 的彈性比 TYMED ISTREAM 還低 \_ ，因此它並不常使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-212">However, because TYMED\_ISTORAGE is less flexible than TYMED\_ISTREAM, it is not as commonly used.</span></span>                  |



 

## <a name="how-a-source-creates-a-data-object"></a><span data-ttu-id="01dfd-213">來源如何建立資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-213">How a Source Creates a Data Object</span></span>

<span data-ttu-id="01dfd-214">當使用者起始 Shell 資料傳輸時，來源會負責建立資料物件並載入資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-214">When a user initiates a Shell data transfer, the source is responsible for creating a data object and loading it with data.</span></span> <span data-ttu-id="01dfd-215">下列程式摘要說明此程式：</span><span class="sxs-lookup"><span data-stu-id="01dfd-215">The following procedure summarizes the process:</span></span>

1.  <span data-ttu-id="01dfd-216">呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) ，以針對將包含在資料物件中的每個 Shell 格式取得有效的剪貼簿格式值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-216">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for each Shell format that will be included in the data object.</span></span> <span data-ttu-id="01dfd-217">請記住， [CF \_ HDROP](clipboard.md) 已經是有效的剪貼簿格式，而且不需要註冊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-217">Remember that [CF\_HDROP](clipboard.md) is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="01dfd-218">針對要傳送的每個格式，請將相關聯的資料放入全域記憶體物件，或建立可透過 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 或 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) 介面存取該資料的物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-218">For each format to be transferred, either put the associated data into a global memory object or create an object that provides access to that data through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="01dfd-219">**IStream** 和 **IStorage** 介面是使用標準 COM 技術所建立。</span><span class="sxs-lookup"><span data-stu-id="01dfd-219">The **IStream** and **IStorage** interfaces are created using standard COM techniques.</span></span> <span data-ttu-id="01dfd-220">如需如何處理全域記憶體物件的討論，請參閱 [如何將全域記憶體物件加入至資料物件](#how-to-add-a-global-memory-object-to-a-data-object)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-220">For a discussion of how to handle global memory objects, see [How to Add a Global Memory Object to a Data Object](#how-to-add-a-global-memory-object-to-a-data-object).</span></span>
3.  <span data-ttu-id="01dfd-221">建立每個格式的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 和 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-221">Create [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures for each format.</span></span>
4.  <span data-ttu-id="01dfd-222">具現化資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-222">Instantiate a data object.</span></span>
5.  <span data-ttu-id="01dfd-223">針對每個支援的格式呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並傳入格式的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 和 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構，以將資料載入資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-223">Load the data into the data object by calling the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method for each supported format and passing in the format's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>
6.  <span data-ttu-id="01dfd-224">使用剪貼簿資料傳輸，呼叫 [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) 將資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面指標放置在剪貼簿上。</span><span class="sxs-lookup"><span data-stu-id="01dfd-224">With clipboard data transfers, call [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span> <span data-ttu-id="01dfd-225">若為拖放傳送，請呼叫 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)來起始 *拖曳迴圈*。</span><span class="sxs-lookup"><span data-stu-id="01dfd-225">For drag-and-drop transfers, initiate a *drag loop* by calling [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span> <span data-ttu-id="01dfd-226">卸載資料時，會將 **IDataObject** 指標傳遞至放置目標，並結束拖曳迴圈。</span><span class="sxs-lookup"><span data-stu-id="01dfd-226">The **IDataObject** pointer will be passed to the drop target when the data is dropped, ending the drag loop.</span></span>

<span data-ttu-id="01dfd-227">現在可以將資料物件傳輸至目標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-227">The data object is now ready to be transferred to the target.</span></span> <span data-ttu-id="01dfd-228">針對剪貼簿資料傳輸，只會保留物件，直到目標透過呼叫 [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard)來要求為止。</span><span class="sxs-lookup"><span data-stu-id="01dfd-228">For clipboard data transfers, the object is simply held until the target requests it by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="01dfd-229">若為拖放資料傳輸，資料物件會負責建立表示資料的圖示，並在使用者移動資料指標時移動資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-229">For drag-and-drop data transfers, the data object is responsible for creating an icon to represent the data and moving it as the user moves the cursor.</span></span> <span data-ttu-id="01dfd-230">當物件在拖曳迴圈中時，來源會透過其 [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) 介面接收狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-230">While the object is in the drag loop, the source receives status information through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="01dfd-231">如需進一步討論，請參閱 [執行 IDropSource](#implementing-idropsource)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-231">For further discussion, see [Implementing IDropSource](#implementing-idropsource).</span></span>

<span data-ttu-id="01dfd-232">如果目標是從剪貼簿取出資料物件，則來源不會收到任何通知。</span><span class="sxs-lookup"><span data-stu-id="01dfd-232">The source receives no notification if the data object is retrieved from the Clipboard by a target.</span></span> <span data-ttu-id="01dfd-233">當拖放作業在目標上卸載物件時，呼叫來起始拖曳迴圈的 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 函式將會傳回。</span><span class="sxs-lookup"><span data-stu-id="01dfd-233">When an object is dropped on a target by a drag-and-drop operation, the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function that was called to initiate the drag loop will return.</span></span>

### <a name="how-to-add-a-global-memory-object-to-a-data-object"></a><span data-ttu-id="01dfd-234">如何將全域記憶體物件加入至資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-234">How to Add a Global Memory Object to a Data Object</span></span>

<span data-ttu-id="01dfd-235">許多 Shell 資料格式都是全域記憶體物件的形式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-235">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="01dfd-236">使用下列程式建立包含全域記憶體物件的格式，並將它載入資料物件中：</span><span class="sxs-lookup"><span data-stu-id="01dfd-236">Use the following procedure to create a format containing a global memory object and load it into the data object:</span></span>

1.  <span data-ttu-id="01dfd-237">建立 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-237">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="01dfd-238">將 **cfFormat** 成員設定為適當的剪貼簿格式值，並將 **tymed** 成員設定為 tymed \_ HGLOBAL。</span><span class="sxs-lookup"><span data-stu-id="01dfd-238">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="01dfd-239">建立 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-239">Create an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="01dfd-240">將 **tymed** 成員設定為 tymed \_ HGLOBAL。</span><span class="sxs-lookup"><span data-stu-id="01dfd-240">Set the **tymed** member to TYMED\_HGLOBAL.</span></span>
3.  <span data-ttu-id="01dfd-241">藉由呼叫 [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) 來配置適當大小的記憶體區塊，以建立全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-241">Create a global memory object by calling [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) to allocate a suitably sized block of memory.</span></span>
4.  <span data-ttu-id="01dfd-242">指派要傳送至 [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc)所傳回之位址的資料區塊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-242">Assign the block of data to be transferred to the address returned by [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc).</span></span>
5.  <span data-ttu-id="01dfd-243">將全域記憶體物件的位址指派給 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的 **hGlobal** 成員。</span><span class="sxs-lookup"><span data-stu-id="01dfd-243">Assign the global memory object's address to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
6.  <span data-ttu-id="01dfd-244">藉由呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 並傳入在先前步驟中建立的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 和 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構，將格式載入資料物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-244">Load the format into the data object by calling [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) and passing in the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures created in the previous steps.</span></span>

<span data-ttu-id="01dfd-245">下列範例函式會建立包含 **DWORD** 值的全域記憶體物件，並將其載入至資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-245">The following sample function creates a global memory object containing a **DWORD** value and loads it into a data object.</span></span> <span data-ttu-id="01dfd-246">**Pdtobj** 參數是資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject)介面指標， **cf** 是剪貼簿格式的值，而 **dw** 則是資料值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-246">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format value, and **dw** is the data value.</span></span>


```C++
STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, 
                      NULL, 
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
    STGMEDIUM medium;

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    
    if (pdw)
    {
        *pdw = dw;       
        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);
 
        if (FAILED(hres))
            GlobalFree((HGLOBAL)pdw);
    }
    return hres;
}
```



### <a name="implementing-idataobject"></a><span data-ttu-id="01dfd-247">執行 IDataObject</span><span class="sxs-lookup"><span data-stu-id="01dfd-247">Implementing IDataObject</span></span>

<span data-ttu-id="01dfd-248">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 是資料物件的主要介面。</span><span class="sxs-lookup"><span data-stu-id="01dfd-248">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) is a data object's primary interface.</span></span> <span data-ttu-id="01dfd-249">它必須由所有資料物件實作為。</span><span class="sxs-lookup"><span data-stu-id="01dfd-249">It must be implemented by all data objects.</span></span> <span data-ttu-id="01dfd-250">來源和目標會使用它來因應各種用途，包括：</span><span class="sxs-lookup"><span data-stu-id="01dfd-250">It is used by both source and target for a variety of purposes, including:</span></span>

-   <span data-ttu-id="01dfd-251">將資料載入資料物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-251">Loading data into the data object.</span></span>
-   <span data-ttu-id="01dfd-252">從資料物件中提取資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-252">Extracting data from the data object.</span></span>
-   <span data-ttu-id="01dfd-253">判斷資料物件中的資料類型。</span><span class="sxs-lookup"><span data-stu-id="01dfd-253">Determining what types of data are in the data object.</span></span>
-   <span data-ttu-id="01dfd-254">對資料物件提供資料傳輸結果的意見反應。</span><span class="sxs-lookup"><span data-stu-id="01dfd-254">Providing feedback to the data object on outcome of the data transfer.</span></span>

<span data-ttu-id="01dfd-255">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 支援多種方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-255">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) supports a number of methods.</span></span> <span data-ttu-id="01dfd-256">本節討論如何針對 Shell 資料物件、 [SetData](#setdata-method)、 [EnumFormatEtc](#enumformatetc-method)和操作方法，執行三個最重要的[方法。](#getdata-method)</span><span class="sxs-lookup"><span data-stu-id="01dfd-256">This section discusses how to implement the three most important methods for Shell data objects, [SetData](#setdata-method), [EnumFormatEtc](#enumformatetc-method), and [GetData](#getdata-method).</span></span> <span data-ttu-id="01dfd-257">如需其他方法的討論，請參閱 **IDataObject** 參考。</span><span class="sxs-lookup"><span data-stu-id="01dfd-257">For a discussion of the other methods, see the **IDataObject** reference.</span></span>

### <a name="setdata-method"></a><span data-ttu-id="01dfd-258">SetData 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-258">SetData method</span></span>

<span data-ttu-id="01dfd-259">[**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata)方法的主要功能是讓來源將資料載入資料物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-259">The primary function of the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is to allow the source to load data into the data object.</span></span> <span data-ttu-id="01dfd-260">針對要包含的每一種格式，來源會建立 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構來識別格式，以及用來保存資料指標的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-260">For each format to be included, the source creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to identify the format and an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure to hold a pointer to the data.</span></span> <span data-ttu-id="01dfd-261">然後，來源會呼叫物件的 **IDataObject：： SetData** 方法，並以格式的 **FORMATETC** 和 **STGMEDIUM** 結構傳遞。</span><span class="sxs-lookup"><span data-stu-id="01dfd-261">The source then calls the object's **IDataObject::SetData** method and passes in the format's **FORMATETC** and **STGMEDIUM** structures.</span></span> <span data-ttu-id="01dfd-262">方法必須儲存這項資訊，讓它可以在目標呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) 來從物件中解壓縮資料時使用。</span><span class="sxs-lookup"><span data-stu-id="01dfd-262">The method must store this information so that it is available when the target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract data from the object.</span></span>

<span data-ttu-id="01dfd-263">不過，當傳輸檔案時，Shell 通常會將每個檔案的資訊傳輸到個別的 [CFSTR \_ FILECONTENTS](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-263">However, when transferring files, the Shell often puts the information for each file to be transferred into a separate [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="01dfd-264">為了區分不同的檔案，每個檔案的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構的 **lIndex** 成員都會設定為識別特定檔案的索引值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-264">To distinguish the different files, the **lIndex** member of each file's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is set to an index value that identifies the particular file.</span></span> <span data-ttu-id="01dfd-265">您的 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 實電腦必須能夠儲存 \_ 不同于其 **lIndex** 成員的多個 CFSTR FILECONTENTS 格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-265">Your [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) implementation must be capable of storing multiple CFSTR\_FILECONTENTS formats that differ only by their **lIndex** members.</span></span>

<span data-ttu-id="01dfd-266">當游標在目標視窗上時，目標可以使用 [拖放 helper 物件](#using-the-drag-and-drop-helper-object) 來指定拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-266">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="01dfd-267">拖放協助程式物件會呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) ，將私用格式載入至用於跨進程支援的資料物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-267">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="01dfd-268">為了支援拖放協助程式物件，您的 **IDataObject：： SetData** 實電腦必須能夠接受並儲存任意私用格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-268">To support the drag-and-drop helper object, your **IDataObject::SetData** implementation must be able to accept and store arbitrary private formats.</span></span>

<span data-ttu-id="01dfd-269">資料卸載之後，某些類型的 Shell 資料傳輸需要目標呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) ，以提供資料物件與 drop 作業結果的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-269">After the data has been dropped, some types of Shell data transfer require the target to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to provide the data object with information about the outcome of the drop operation.</span></span> <span data-ttu-id="01dfd-270">例如，使用優化的移動作業來移動檔案時，目標通常會刪除原始檔案，但不需要這麼做。</span><span class="sxs-lookup"><span data-stu-id="01dfd-270">For example, when moving files with an optimized move operation, the target normally deletes the original files, but it is not required to do so.</span></span> <span data-ttu-id="01dfd-271">目標會透過呼叫 **IDataObject：： SetData** 和 [CFSTR \_ LOGICALPERFORMEDDROPEFFECT](clipboard.md) 格式來通知資料物件是否已刪除檔案。</span><span class="sxs-lookup"><span data-stu-id="01dfd-271">The target informs the data object whether it deleted the files by calling **IDataObject::SetData** with a [CFSTR\_LOGICALPERFORMEDDROPEFFECT](clipboard.md) format.</span></span> <span data-ttu-id="01dfd-272">還有其他數個 [Shell 剪貼簿格式](clipboard.md) ，目標也會使用這些格式，將資訊傳遞給資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-272">There are several other [Shell Clipboard Formats](clipboard.md) that are also used by the target to pass information to the data object.</span></span> <span data-ttu-id="01dfd-273">您的 **IDataObject：： SetData** 實電腦必須能夠辨識這些格式並適當地回應。</span><span class="sxs-lookup"><span data-stu-id="01dfd-273">Your **IDataObject::SetData** implementation must be able to recognize these formats and respond appropriately.</span></span> <span data-ttu-id="01dfd-274">如需進一步討論，請參閱 [處理 Shell 資料傳輸案例](datascenarios.md)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-274">For further discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

### <a name="enumformatetc-method"></a><span data-ttu-id="01dfd-275">EnumFormatEtc 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-275">EnumFormatEtc method</span></span>

<span data-ttu-id="01dfd-276">當目標收到資料物件時，它通常會呼叫 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 來判斷物件所包含的格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-276">When the target receives a data object, it commonly calls [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) to determine what formats the object contains.</span></span> <span data-ttu-id="01dfd-277">方法會建立 OLE 列舉物件，並傳回物件之 [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-277">The method creates an OLE enumeration object and returns a pointer to the object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="01dfd-278">目標接著會使用介面來列舉可用的格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-278">The target then uses the interface to enumerate the available formats.</span></span>

<span data-ttu-id="01dfd-279">列舉物件應該一律以品質的順序來列舉可用的格式，從最佳的開始。</span><span class="sxs-lookup"><span data-stu-id="01dfd-279">An enumeration object should always enumerate the available formats in order of quality, starting with the best.</span></span> <span data-ttu-id="01dfd-280">相對品質的格式是由 drop source 所定義。</span><span class="sxs-lookup"><span data-stu-id="01dfd-280">The relative quality of formats is defined by the drop source.</span></span> <span data-ttu-id="01dfd-281">一般而言，最高品質的格式包含最豐富且最完整的資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-281">In general, the highest-quality formats contain the richest and most complete data.</span></span> <span data-ttu-id="01dfd-282">比方說，24位色彩影像通常會被視為比該影像的灰階版本更高的品質。</span><span class="sxs-lookup"><span data-stu-id="01dfd-282">For instance, a 24-bit color image would normally be considered higher quality than a gray-scale version of that image.</span></span> <span data-ttu-id="01dfd-283">依品質的順序來列舉格式的原因是，目標通常會列舉到其所支援的格式，然後使用該格式來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-283">The reason for enumerating formats in order of their quality is that targets typically enumerate until they get to a format that they support, and then they use that format to extract the data.</span></span> <span data-ttu-id="01dfd-284">若要讓此程式產生目標可支援的最佳可用格式，必須依品質的順序來列舉格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-284">For this procedure to produce the best available format that the target can support, the formats must be enumerated in order of their quality.</span></span>

<span data-ttu-id="01dfd-285">Shell 資料的列舉物件執行方式與其他資料傳輸類型的方式大致相同，但有一個值得注意的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="01dfd-285">An enumeration object for Shell data is implemented in much the same way as for other types of data transfer, with one notable exception.</span></span> <span data-ttu-id="01dfd-286">由於資料物件通常只會針對每個格式包含一個資料項目，因此通常會列舉傳遞給 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata)的每個格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-286">Because data objects typically contain only one data item per format, they normally enumerate every format that is passed to [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="01dfd-287">不過，如 [SetData 方法](#setdata-method) 一節中所述，Shell 資料物件可以包含多個 [CFSTR \_ FILECONTENTS](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-287">However, as discussed in the [SetData method](#setdata-method) section, Shell data objects can contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>

<span data-ttu-id="01dfd-288">因為 [**IDataObject：： EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) 的目的是要讓目標判斷哪些類型的資料存在，所以不需要列舉一個以上的 [CFSTR \_ FILECONTENTS](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-288">Because the purpose of [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) is to allow the target to determine what types of data are present, there is no need to enumerate more than one [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="01dfd-289">如果目標需要知道資料物件所包含的其中一種格式，則目標可以從隨附的 CFSTR FILEDESCRIPTOR 格式取得該資訊 \_ 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-289">If the target needs to know how many of these formats the data object contains, the target can retrieve that information from the accompanying CFSTR\_FILEDESCRIPTOR format.</span></span> <span data-ttu-id="01dfd-290">如需如何執行 **IDataObject：： EnumFormatEtc** 的進一步討論，請參閱方法的參考檔。</span><span class="sxs-lookup"><span data-stu-id="01dfd-290">For further discussion of how to implement **IDataObject::EnumFormatEtc**, see the method's reference documentation.</span></span>

### <a name="getdata-method"></a><span data-ttu-id="01dfd-291">的一種方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-291">GetData method</span></span>

<span data-ttu-id="01dfd-292">目標會呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) ，以解壓縮特定的資料格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-292">The target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract a particular data format.</span></span> <span data-ttu-id="01dfd-293">目標會藉由傳入適當的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構來指定格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-293">The target specifies the format by passing in the appropriate [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="01dfd-294">**IDataObject：：** STGMEDIUM 會傳回格式的 [](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-294">**IDataObject::GetData** returns the format's [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>

<span data-ttu-id="01dfd-295">目標可以將 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構的 **tymed** 成員設定為特定的 tymed \_ *XXX* 值，以指定要使用哪一種資料傳輸機制來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-295">The target can set the **tymed** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to a specific TYMED\_*XXX* value to specify which data transfer mechanism it will use to extract the data.</span></span> <span data-ttu-id="01dfd-296">不過，目標也可以進行更一般的要求，並讓資料物件決定。</span><span class="sxs-lookup"><span data-stu-id="01dfd-296">However, the target can also make a more generic request and let the data object decide.</span></span> <span data-ttu-id="01dfd-297">若要要求資料物件選取資料傳輸機制，目標會設定它所支援的所有 TYMED \_ *XXX* 值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-297">To ask the data object to select the data transfer mechanism, the target sets all the TYMED\_*XXX* values that it supports.</span></span> <span data-ttu-id="01dfd-298">[**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) STGMEDIUM 會選取其中一個資料傳輸機制，並傳回適當的 [](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-298">[**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) selects one of these data transfer mechanisms and returns the appropriate [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="01dfd-299">例如， **tymed** 通常會設定為 tymed \_ HGLOBAL \| tymed \_ ISTREAM \| tymed \_ ISTORAGE，以要求三個 Shell 資料傳輸機制的任一個。</span><span class="sxs-lookup"><span data-stu-id="01dfd-299">For instance, **tymed** is commonly set to TYMED\_HGLOBAL \| TYMED\_ISTREAM \| TYMED\_ISTORAGE to request any of the three Shell data transfer mechanisms.</span></span>

> [!Note]  
> <span data-ttu-id="01dfd-300">因為可能會有多 [個 CFSTR \_ FILECONTENTS](clipboard.md)格式，所以 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構的 **cfFormat** 和 **Tymed** 成員不足以指出應該傳回的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-300">Because there can be multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, the **cfFormat** and **tymed** members of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure are not sufficient to indicate which [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should return.</span></span> <span data-ttu-id="01dfd-301">針對 CFSTR \_ FILECONTENTS 格式， **IDataObject：：** 也必須檢查 **FORMATETC** 結構的 **lIndex** 成員，才能傳回正確的 **STGMEDIUM** 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-301">For the CFSTR\_FILECONTENTS format, **IDataObject::GetData** must also examine the **FORMATETC** structure's **lIndex** member in order to return the correct **STGMEDIUM** structure.</span></span>

 

<span data-ttu-id="01dfd-302">[CFSTR \_ INDRAGLOOP](clipboard.md)格式放置於資料物件中，以允許目標檢查拖放迴圈的狀態，同時避免物件資料的記憶體密集呈現。</span><span class="sxs-lookup"><span data-stu-id="01dfd-302">The [CFSTR\_INDRAGLOOP](clipboard.md) format is placed in data objects to allow targets to check the status of the drag-and-drop loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="01dfd-303">如果資料物件是在拖曳迴圈內，則格式的資料就是設定為非零值的 **DWORD** 值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-303">The format's data is a **DWORD** value that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="01dfd-304">如果資料已卸載，則格式的資料值會設為零。</span><span class="sxs-lookup"><span data-stu-id="01dfd-304">The format's data value is set to zero if the data has been dropped.</span></span> <span data-ttu-id="01dfd-305">如果目標要求此格式，但來源尚未載入，則 [**IDataObject：：：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) 會回應，就像來源已載入值為零的格式一樣。</span><span class="sxs-lookup"><span data-stu-id="01dfd-305">If a target requests this format and it has not been loaded by the source, [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should respond as if the source had loaded the format with a value of zero.</span></span>

<span data-ttu-id="01dfd-306">當游標在目標視窗上時，目標可以使用 [拖放 helper 物件](#using-the-drag-and-drop-helper-object) 來指定拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-306">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="01dfd-307">拖放協助程式物件會呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) ，將私用格式載入至用於跨進程支援的資料物件中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-307">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="01dfd-308">稍後會呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) 來取出它們。</span><span class="sxs-lookup"><span data-stu-id="01dfd-308">It later calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to retrieve them.</span></span> <span data-ttu-id="01dfd-309">若要支援拖放協助程式物件，您的 Shell 資料物件實作為要求時，必須能夠傳回任意私用格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-309">To support the drag-and-drop helper object, your Shell Data Object implementation must be able to return arbitrary private formats when they are requested.</span></span>

### <a name="implementing-idropsource"></a><span data-ttu-id="01dfd-310">執行 IDropSource</span><span class="sxs-lookup"><span data-stu-id="01dfd-310">Implementing IDropSource</span></span>

<span data-ttu-id="01dfd-311">來源必須建立公開 [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) 介面的物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-311">The source must create an object that exposes an [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="01dfd-312">此介面可讓來源更新表示游標目前位置的 *拖曳影像* ，並提供意見反應給系統，以瞭解如何終止拖放作業。</span><span class="sxs-lookup"><span data-stu-id="01dfd-312">This interface allows the source to update the *drag image* that indicates the current position of the cursor and to provide feedback to the system on how to terminate a drag-and-drop operation.</span></span> <span data-ttu-id="01dfd-313">**IDropSource** 有兩種方法： [**system.windows.dragdrop.givefeedback>**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) 和 [**system.windows.dragdrop.querycontinuedrag>**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-313">**IDropSource** has two methods: [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) and [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag).</span></span>

### <a name="givefeedback-method"></a><span data-ttu-id="01dfd-314">GiveFeedback 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-314">GiveFeedback method</span></span>

<span data-ttu-id="01dfd-315">在拖曳迴圈中，卸載來源負責追蹤游標位置，並顯示適當的拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-315">While in the drag loop, a drop source is responsible for keeping track of the cursor position and displaying an appropriate drag image.</span></span> <span data-ttu-id="01dfd-316">不過，在某些情況下，您可能會想要在拖曳影像超過放置目標的視窗時，變更它的外觀。</span><span class="sxs-lookup"><span data-stu-id="01dfd-316">However, in some cases you might want to change the appearance of the drag image when it is over the drop target's window.</span></span>

<span data-ttu-id="01dfd-317">當游標進入或離開目標視窗，而且在目標視窗中移動時，系統會定期呼叫目標的 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面。</span><span class="sxs-lookup"><span data-stu-id="01dfd-317">When the cursor enters or leaves the target window and while it is moving over the target window, the system periodically calls the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span> <span data-ttu-id="01dfd-318">目標會以 [**DROPEFFECT**](../com/dropeffect-constants.md) 值回應，此值會透過 [**system.windows.dragdrop.givefeedback>**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) 方法轉送至來源。</span><span class="sxs-lookup"><span data-stu-id="01dfd-318">The target responds with a [**DROPEFFECT**](../com/dropeffect-constants.md) value that is forwarded to the source through the [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) method.</span></span> <span data-ttu-id="01dfd-319">如果有的話，來源可以根據 **DROPEFFECT** 值修改資料指標的外觀。</span><span class="sxs-lookup"><span data-stu-id="01dfd-319">If appropriate, the source can modify the appearance of the cursor based on the **DROPEFFECT** value.</span></span> <span data-ttu-id="01dfd-320">如需詳細資訊，請參閱 **system.windows.dragdrop.givefeedback>** 和 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 參考。</span><span class="sxs-lookup"><span data-stu-id="01dfd-320">For further details, see the **GiveFeedback** and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

### <a name="querycontinuedrag-method"></a><span data-ttu-id="01dfd-321">QueryContinueDrag 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-321">QueryContinueDrag method</span></span>

<span data-ttu-id="01dfd-322">當資料物件在拖曳迴圈中，而滑鼠按鍵或鍵盤狀態變更時，就會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-322">This method is called if the mouse button or keyboard state changes while the data object is in the drag loop.</span></span> <span data-ttu-id="01dfd-323">它會通知來源是否已按下 ESC 鍵，並提供鍵盤輔助按鍵的目前狀態，例如 CTRL 或 SHIFT。</span><span class="sxs-lookup"><span data-stu-id="01dfd-323">It notifies the source whether the ESC key has been pressed and provides the current state of the keyboard modifier keys, such as CTRL or SHIFT.</span></span> <span data-ttu-id="01dfd-324">[**System.windows.dragdrop.querycontinuedrag>**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag)方法的傳回值會指定三個動作的其中一個：</span><span class="sxs-lookup"><span data-stu-id="01dfd-324">The [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) method's return value specifies one of three actions:</span></span>

-   <span data-ttu-id="01dfd-325">S \_ 沒問題。</span><span class="sxs-lookup"><span data-stu-id="01dfd-325">S\_OK.</span></span> <span data-ttu-id="01dfd-326">繼續拖曳作業</span><span class="sxs-lookup"><span data-stu-id="01dfd-326">Continue the drag operation</span></span>
-   <span data-ttu-id="01dfd-327">SYSTEM.WINDOWS.DRAGDROP.DROP> \_ S \_ 下降。</span><span class="sxs-lookup"><span data-stu-id="01dfd-327">DRAGDROP\_S\_DROP.</span></span> <span data-ttu-id="01dfd-328">捨棄資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-328">Drop the data.</span></span> <span data-ttu-id="01dfd-329">系統接著會呼叫目標的 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-329">The system then calls the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method.</span></span>
-   <span data-ttu-id="01dfd-330">SYSTEM.WINDOWS.DRAGDROP.DROP> \_ S \_ 取消。</span><span class="sxs-lookup"><span data-stu-id="01dfd-330">DRAGDROP\_S\_CANCEL.</span></span> <span data-ttu-id="01dfd-331">終止拖曳迴圈而不卸載資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-331">Terminate the drag loop without dropping the data.</span></span> <span data-ttu-id="01dfd-332">如果已按下 ESCAPE 鍵，通常會傳回這個值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-332">This value is normally returned if the ESCAPE key was pressed.</span></span>

<span data-ttu-id="01dfd-333">如需進一步討論，請參閱 [**system.windows.dragdrop.querycontinuedrag>**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) 和 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 參考。</span><span class="sxs-lookup"><span data-stu-id="01dfd-333">For further discussion, see the [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

## <a name="how-a-target-handles-a-data-object"></a><span data-ttu-id="01dfd-334">目標如何處理資料物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-334">How a Target Handles a Data Object</span></span>

<span data-ttu-id="01dfd-335">當目標從剪貼簿抓取資料物件，或由使用者在目標視窗上卸載資料物件時，它會接收資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-335">The target receives a data object when it either retrieves the data object from the Clipboard or has it dropped on the target window by the user.</span></span> <span data-ttu-id="01dfd-336">然後，目標可以從資料物件中提取資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-336">The target can then extract data from the data object.</span></span> <span data-ttu-id="01dfd-337">如有必要，目標也可以通知資料物件的作業結果。</span><span class="sxs-lookup"><span data-stu-id="01dfd-337">If necessary, the target can also notify the data object of the outcome of the operation.</span></span> <span data-ttu-id="01dfd-338">在 Shell 資料傳輸之前，卸載目標必須為作業準備自己：</span><span class="sxs-lookup"><span data-stu-id="01dfd-338">Prior to a Shell data transfer, a drop target must prepare itself for the operation:</span></span>

1.  <span data-ttu-id="01dfd-339">目標必須呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) ，以針對可能包含在資料物件中的所有 Shell 格式（除了 [CF \_ HDROP](clipboard.md)以外）取得有效的剪貼簿格式值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-339">The target must call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for all Shell formats, other than [CF\_HDROP](clipboard.md), that might be included in the data object.</span></span> <span data-ttu-id="01dfd-340">CF \_ HDROP 已經是有效的剪貼簿格式，且不需要註冊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-340">CF\_HDROP is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="01dfd-341">若要支援拖放作業，目標必須執行 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面並註冊目標視窗。</span><span class="sxs-lookup"><span data-stu-id="01dfd-341">To support a drag-and-drop operation, the target must implement an [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface and register a target window.</span></span> <span data-ttu-id="01dfd-342">為了註冊目標視窗，目標會呼叫 [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) ，並在視窗的控制碼和 **IDropTarget** 介面指標中傳遞。</span><span class="sxs-lookup"><span data-stu-id="01dfd-342">To register a target window, the target calls [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) and passes in the window's handle and the **IDropTarget** interface pointer.</span></span>

<span data-ttu-id="01dfd-343">針對剪貼簿傳送，目標不會收到資料物件放在剪貼簿上的任何通知。</span><span class="sxs-lookup"><span data-stu-id="01dfd-343">For clipboard transfers, the target does not receive any notification that a data object has been placed on the Clipboard.</span></span> <span data-ttu-id="01dfd-344">一般情況下，應用程式會收到物件在剪貼簿上的使用者動作，例如按一下應用程式工具列上的 [貼上] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="01dfd-344">Typically, an application is notified that an object is on the Clipboard by a user action, such as clicking the Paste button on the application's toolbar.</span></span> <span data-ttu-id="01dfd-345">目標接著會藉由呼叫 [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard)，從剪貼簿抓取資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject)指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-345">The target then retrieves the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) pointer from the Clipboard by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="01dfd-346">若為拖放資料傳輸，系統會使用目標的 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面，為目標提供資料傳輸進度的相關資訊：</span><span class="sxs-lookup"><span data-stu-id="01dfd-346">For drag-and-drop data transfers, the system uses the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to provide the target with information about the progress of the data transfer:</span></span>

-   <span data-ttu-id="01dfd-347">當游標進入目標視窗時，系統會呼叫 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-347">The system calls [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) when the cursor enters the target window.</span></span>
-   <span data-ttu-id="01dfd-348">系統會定期呼叫 [**IDropTarget：:D ragover**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) ，因為游標會在目標視窗上傳遞，以將目標設為目前的資料指標位置。</span><span class="sxs-lookup"><span data-stu-id="01dfd-348">The system periodically calls [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) as the cursor passes over the target window, to give the target the current cursor position.</span></span>
-   <span data-ttu-id="01dfd-349">當資料指標離開目標視窗時，系統會呼叫 [**IDropTarget：:D ragleave**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-349">The system calls [**IDropTarget::DragLeave**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) when the cursor leaves the target window.</span></span>
-   <span data-ttu-id="01dfd-350">當使用者在目標視窗上放置資料物件時，系統會呼叫 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-350">The system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) when the user drops the data object on the target window.</span></span>

<span data-ttu-id="01dfd-351">如需如何執行這些方法的討論，請參閱 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-351">For a discussion of how to implement these methods, see [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget).</span></span>

<span data-ttu-id="01dfd-352">卸載資料時， [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 會為目標提供資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-352">When the data is dropped, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) provides the target with a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="01dfd-353">然後，目標會使用這個介面從資料物件中取出資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-353">The target then uses this interface to extract data from the data object.</span></span>

### <a name="extracting-shell-data-from-a-data-object"></a><span data-ttu-id="01dfd-354">從資料物件解壓縮 Shell 資料</span><span class="sxs-lookup"><span data-stu-id="01dfd-354">Extracting Shell Data from a Data Object</span></span>

<span data-ttu-id="01dfd-355">從剪貼簿卸載或抓取資料物件之後，目標就可以將它所需的資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-355">Once a data object has been dropped or retrieved from the Clipboard, the target can extract the data it needs.</span></span> <span data-ttu-id="01dfd-356">提取程式中的第一個步驟通常是列舉資料物件所包含的格式：</span><span class="sxs-lookup"><span data-stu-id="01dfd-356">The first step in the extraction process is typically to enumerate the formats contained by the data object:</span></span>

-   <span data-ttu-id="01dfd-357">呼叫 [**IDataObject：： EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-357">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc).</span></span> <span data-ttu-id="01dfd-358">資料物件會建立標準的 OLE 列舉物件，並傳回其 [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-358">The data object creates a standard OLE enumeration object and returns a pointer to its [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span>
-   <span data-ttu-id="01dfd-359">您可以使用 [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) 方法來列舉資料物件所包含的格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-359">Use the [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) methods to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="01dfd-360">這項作業通常會針對物件所包含的每種格式，取得一個 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-360">This operation usually retrieves one [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure for each format that the object contains.</span></span> <span data-ttu-id="01dfd-361">不過，無論資料物件包含多少種格式，列舉物件通常只會針對 [CFSTR \_ FILECONTENTS](clipboard.md)格式傳回單一 **FORMATETC** 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-361">However, the enumeration object normally returns only a single **FORMATETC** structure for the [CFSTR\_FILECONTENTS](clipboard.md) format, regardless of how many such formats are contained by the data object.</span></span>
-   <span data-ttu-id="01dfd-362">選取一或多個要解壓縮的格式，並儲存其 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-362">Select one or more formats to be extracted, and store their [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structures.</span></span>

<span data-ttu-id="01dfd-363">若要取出特定格式，請將相關聯的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構傳遞至 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-363">To retrieve a particular format, pass the associated [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="01dfd-364">這個方法會傳回 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構，以提供資料的存取權。</span><span class="sxs-lookup"><span data-stu-id="01dfd-364">This method returns an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that provides access to the data.</span></span> <span data-ttu-id="01dfd-365">若要指定特定的資料傳輸機制，請將 **FORMATETC** 結構的 **tymed** 值設定為對應的 tymed \_ *XXX* 值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-365">To specify a particular data transfer mechanism, set the **tymed** value of the **FORMATETC** structure to the corresponding TYMED\_*XXX* value.</span></span> <span data-ttu-id="01dfd-366">若要要求資料物件選取資料傳輸機制，目標 \_ 會為目標可以處理的每個資料傳輸機制設定 TYMED *XXX* 值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-366">To ask the data object to select a data transfer mechanism, the target sets the TYMED\_*XXX* values for every data transfer mechanism that the target can handle.</span></span> <span data-ttu-id="01dfd-367">資料物件會選取其中一個資料傳輸機制，並傳回適當的 **STGMEDIUM** 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-367">The data object selects one of these data transfer mechanisms and returns the appropriate **STGMEDIUM** structure.</span></span>

<span data-ttu-id="01dfd-368">針對大部分的格式，目標都可以藉由傳遞在列舉可用格式時所收到的 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構來取得資料。</span><span class="sxs-lookup"><span data-stu-id="01dfd-368">For most formats, the target can retrieve the data by passing the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure that it received when it enumerated the available formats.</span></span> <span data-ttu-id="01dfd-369">這項規則的例外狀況是 [CFSTR \_ FILECONTENTS](clipboard.md)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-369">One exception to this rule is [CFSTR\_FILECONTENTS](clipboard.md).</span></span> <span data-ttu-id="01dfd-370">因為資料物件可以包含此格式的多個實例，所以列舉值所傳回的 **FORMATETC** 結構可能不會對應至您想要解壓縮的特定格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-370">Because a data object can contain multiple instances of this format, the **FORMATETC** structure returned by the enumerator might not correspond to the particular format you want to extract.</span></span> <span data-ttu-id="01dfd-371">除了指定 **cfFormat** 和 **tymed** 成員之外，您還必須將 **lIndex** 成員設定為檔案的索引值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-371">In addition to specifying the **cfFormat** and **tymed** members, you must also set the **lIndex** member to the file's index value.</span></span> <span data-ttu-id="01dfd-372">如需進一步討論，請參閱 *使用 CFSTR \_ FILECONTENTS 格式從*[處理 Shell 資料傳輸案例](datascenarios.md)的檔案中解壓縮資料一節。</span><span class="sxs-lookup"><span data-stu-id="01dfd-372">For further discussion, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md)</span></span>

<span data-ttu-id="01dfd-373">資料解壓縮進程取決於傳回的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構所包含的指標類型。</span><span class="sxs-lookup"><span data-stu-id="01dfd-373">The data extraction process depends on the type of pointer contained by the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="01dfd-374">如果結構包含 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 或 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) 介面的指標，請使用介面方法來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-374">If the structure contains a pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface, use the interface methods to extract the data.</span></span> <span data-ttu-id="01dfd-375">下一節將討論從全域記憶體物件中解壓縮資料的程式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-375">The process of extracting data from a global memory object is discussed in the next section.</span></span>

### <a name="extracting-a-global-memory-object-from-a-data-object"></a><span data-ttu-id="01dfd-376">從資料物件解壓縮全域記憶體物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-376">Extracting a global memory object from a data object</span></span>

<span data-ttu-id="01dfd-377">許多 Shell 資料格式都是全域記憶體物件的形式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-377">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="01dfd-378">使用下列程式，從資料物件解壓縮包含全域記憶體物件的格式，並將其資料指派給本機變數：</span><span class="sxs-lookup"><span data-stu-id="01dfd-378">Use the following procedure to extract a format containing a global memory object from a data object and assign its data to a local variable:</span></span>

1.  <span data-ttu-id="01dfd-379">建立 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-379">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="01dfd-380">將 **cfFormat** 成員設定為適當的剪貼簿格式值，並將 **tymed** 成員設定為 tymed \_ HGLOBAL。</span><span class="sxs-lookup"><span data-stu-id="01dfd-380">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="01dfd-381">建立空的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構。</span><span class="sxs-lookup"><span data-stu-id="01dfd-381">Create an empty [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
3.  <span data-ttu-id="01dfd-382">呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)，並傳入 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) 和 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) 結構的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-382">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata), and pass in pointers to the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>

    <span data-ttu-id="01dfd-383">當 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) STGMEDIUM 結構傳回時， [](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構將包含包含資料之全域記憶體物件的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-383">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure will contain a pointer to the global memory object that contains the data.</span></span>

4.  <span data-ttu-id="01dfd-384">藉由呼叫 [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock)並傳入 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的 **hGlobal** 成員，將資料指派給區域變數。</span><span class="sxs-lookup"><span data-stu-id="01dfd-384">Assign the data to a local variable by calling [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) and passing in the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
5.  <span data-ttu-id="01dfd-385">呼叫 [**GlobalUnlock**](/windows/win32/api/winbase/nf-winbase-globalunlock) 以釋放全域記憶體物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="01dfd-385">Call [**GlobalUnlock**](/windows/win32/api/winbase/nf-winbase-globalunlock) to release the lock on the global memory object.</span></span>
6.  <span data-ttu-id="01dfd-386">呼叫 [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) 以釋放全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-386">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object.</span></span>

> [!Note]  
> <span data-ttu-id="01dfd-387">您必須使用 [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) 來釋放全域記憶體物件，而不是 [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-387">You must use [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object, not [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree).</span></span>

 

<span data-ttu-id="01dfd-388">下列範例示範如何從資料物件將儲存為全域記憶體物件的 **DWORD** 值解壓縮。</span><span class="sxs-lookup"><span data-stu-id="01dfd-388">The following example shows how to extract a **DWORD** value stored as a global memory object from a data object.</span></span> <span data-ttu-id="01dfd-389">**Pdtobj** 參數是資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject)介面指標， **cf** 是用來識別所需資料的剪貼簿格式，而 **pdwOut** 則是用來傳回資料值。</span><span class="sxs-lookup"><span data-stu-id="01dfd-389">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format that identifies the desired data, and **pdwOut** is used to return the data value.</span></span>


```C++
STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut)
{    STGMEDIUM medium;
   FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, 
       TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hres))
   {
       DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);
       if (pdw)
       {
           *pdwOut = *pdw;
           GlobalUnlock(medium.hGlobal);
       }
       else
       {
           hres = E_UNEXPECTED;
       }
       ReleaseStgMedium(&medium);
   }
   return hres;
}
```



### <a name="implementing-idroptarget"></a><span data-ttu-id="01dfd-390">執行 IDropTarget</span><span class="sxs-lookup"><span data-stu-id="01dfd-390">Implementing IDropTarget</span></span>

<span data-ttu-id="01dfd-391">當游標位於目標視窗上時，系統會使用 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面來與目標通訊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-391">The system uses the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to communicate with the target while the cursor is over the target window.</span></span> <span data-ttu-id="01dfd-392">目標的回應會透過其 [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) 介面轉送至來源。</span><span class="sxs-lookup"><span data-stu-id="01dfd-392">The target's responses are forwarded to the source through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="01dfd-393">根據回應，來源可以修改代表資料的圖示。</span><span class="sxs-lookup"><span data-stu-id="01dfd-393">Depending on the response, the source can modify the icon that represents the data.</span></span> <span data-ttu-id="01dfd-394">如果放置目標需要指定資料圖示，就可以建立 [拖放](#using-the-drag-and-drop-helper-object)協助程式物件來完成此動作。</span><span class="sxs-lookup"><span data-stu-id="01dfd-394">If the drop target needs to specify the data icon, it can do so by creating a [drag-and-drop helper object](#using-the-drag-and-drop-helper-object).</span></span>

<span data-ttu-id="01dfd-395">使用傳統的拖放作業時，目標會將 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop)的 *pdwEffect* 參數設定為適當的 [**DROPEFFECT**](../com/dropeffect-constants.md)值，以通知資料物件結果。</span><span class="sxs-lookup"><span data-stu-id="01dfd-395">With conventional drag-and-drop operations, the target informs the data object of the outcome of the operation by setting the *pdwEffect* parameter of [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) to the appropriate [**DROPEFFECT**](../com/dropeffect-constants.md) value.</span></span> <span data-ttu-id="01dfd-396">使用 Shell 資料物件時，目標可能也需要呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-396">With Shell data objects, the target might also need to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="01dfd-397">如需如何針對不同的資料傳輸案例回應目標的討論，請參閱 [處理 Shell 資料傳輸案例](datascenarios.md)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-397">For a discussion of how targets should respond for different data transfer scenarios, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="01dfd-398">下列各節將簡短討論如何執行 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)、 [**IDropTarget：:D ragover**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover)和 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-398">The following sections briefly discuss how to implement the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover), and [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) methods.</span></span> <span data-ttu-id="01dfd-399">如需詳細資訊，請參閱參考檔。</span><span class="sxs-lookup"><span data-stu-id="01dfd-399">For further details, see the reference documentation.</span></span>

### <a name="dragenter-method"></a><span data-ttu-id="01dfd-400">System.windows.dragdrop.dragenter> 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-400">DragEnter method</span></span>

<span data-ttu-id="01dfd-401">當游標進入目標視窗時，系統會呼叫 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) 方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-401">The system calls the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) method when the cursor enters the target window.</span></span> <span data-ttu-id="01dfd-402">它的參數會為目標提供游標位置、鍵盤輔助按鍵的狀態（例如 CTRL 鍵），以及資料物件之 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="01dfd-402">Its parameters provide the target with the location of the cursor, the state of keyboard modifier keys such as the CTRL key, and a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="01dfd-403">目標負責使用該介面來判斷它是否可以接受資料物件所包含的任何格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-403">The target is responsible for using that interface to determine whether it can accept any of the formats contained by the data object.</span></span> <span data-ttu-id="01dfd-404">如果可以，通常會將 *pdwEffect* 的值保持不變。</span><span class="sxs-lookup"><span data-stu-id="01dfd-404">If it can, it normally leaves the value of *pdwEffect* unchanged.</span></span> <span data-ttu-id="01dfd-405">如果它無法接受資料物件中的任何資料，則會將 *pdwEffect* 參數設定為 DROPEFFECT \_ NONE。</span><span class="sxs-lookup"><span data-stu-id="01dfd-405">If it cannot accept any data from the data object, it sets the *pdwEffect* parameter to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="01dfd-406">系統會將此參數的值傳遞至資料物件的 [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) 介面，以允許它顯示適當的拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-406">The system passes the value of this parameter to the data object's [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface to allow it to display the appropriate drag image.</span></span>

<span data-ttu-id="01dfd-407">目標不應使用 [**IDataObject：：：：：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) 的方法來轉譯 Shell 資料，然後再將它卸載。</span><span class="sxs-lookup"><span data-stu-id="01dfd-407">Targets should not use the [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) method to render Shell data before it has been dropped.</span></span> <span data-ttu-id="01dfd-408">針對每一種情況，完全呈現物件的資料，可能會導致拖曳游標停止。</span><span class="sxs-lookup"><span data-stu-id="01dfd-408">Fully rendering the object's data for each such occurrence might cause the drag cursor to stall.</span></span> <span data-ttu-id="01dfd-409">為了避免這個問題，某些 Shell 物件包含 [CFSTR \_ INDRAGLOOP](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="01dfd-409">To avoid this problem, some Shell objects contain a [CFSTR\_INDRAGLOOP](clipboard.md) format.</span></span> <span data-ttu-id="01dfd-410">藉由將此格式解壓縮，目標可以檢查拖曳迴圈的狀態，同時避免物件資料的記憶體密集呈現。</span><span class="sxs-lookup"><span data-stu-id="01dfd-410">By extracting this format, targets can check the status of the drag loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="01dfd-411">如果資料物件是在拖曳迴圈內，則格式的資料值是設定為非零值的 **DWORD** 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-411">The format's data value is a **DWORD** that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="01dfd-412">如果資料已卸載，則格式的資料值會設為零。</span><span class="sxs-lookup"><span data-stu-id="01dfd-412">The format's data value is set to zero if the data has been dropped.</span></span>

<span data-ttu-id="01dfd-413">如果目標可以接受資料物件中的資料，它應該會檢查 **grfKeyState** ，以判斷是否已按下任何輔助按鍵來修改正常的卸載行為。</span><span class="sxs-lookup"><span data-stu-id="01dfd-413">If the target can accept data from the data object, it should examine **grfKeyState** to determine whether any modifier keys have been pressed to modify the normal drop behavior.</span></span> <span data-ttu-id="01dfd-414">例如，預設作業通常是移動，但按下 CTRL 鍵通常表示複製操作。</span><span class="sxs-lookup"><span data-stu-id="01dfd-414">For instance, the default operation is typically a move, but depressing the CTRL key usually indicates a copy operation.</span></span>

<span data-ttu-id="01dfd-415">當游標在目標視窗上時，目標可以使用 [拖放協助程式物件](#using-the-drag-and-drop-helper-object) 來取代資料物件的拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-415">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to replace the data object's drag image with its own.</span></span> <span data-ttu-id="01dfd-416">如果是， [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) 應該呼叫 [**IDropTargetHelper：:D Ragenter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) ，將 *system.windows.dragdrop.dragenter>* 參數中包含的資訊傳遞給拖放 helper 物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-416">If so, [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) should call [**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) to pass the information contained in the *DragEnter* parameters to the drag-and-drop helper object.</span></span>

### <a name="dragover-method"></a><span data-ttu-id="01dfd-417">System.windows.dragdrop.dragover> 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-417">DragOver method</span></span>

<span data-ttu-id="01dfd-418">當資料指標在目標視窗內移動時，系統會定期呼叫 [**IDropTarget：:D ragover**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) 方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-418">As the cursor moves within the target window, the system periodically calls the [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) method.</span></span> <span data-ttu-id="01dfd-419">其參數會為目標提供游標的位置，以及鍵盤輔助按鍵（例如 CTRL 鍵）的狀態。</span><span class="sxs-lookup"><span data-stu-id="01dfd-419">Its parameters provide the target with the location of the cursor and the state of keyboard modifier keys such as the CTRL key.</span></span> <span data-ttu-id="01dfd-420">**IDropTarget：:D ragover** 與 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)有許多相同的責任，而且這些執行通常很類似。</span><span class="sxs-lookup"><span data-stu-id="01dfd-420">**IDropTarget::DragOver** has much the same responsibilities as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), and the implementations are usually very similar.</span></span>

<span data-ttu-id="01dfd-421">如果目標是使用拖放協助程式物件， [**IDropTarget：:D ragover**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) 應該呼叫 [**IDropTargetHelper：:D ragover**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) 將 *system.windows.dragdrop.dragover>* 參數中包含的資訊轉送至拖放 helper 物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-421">If the target is using the drag-and-drop helper object, [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) should call [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) to forward the information contained in the *DragOver* parameters to the drag-and-drop helper object.</span></span>

### <a name="drop-method"></a><span data-ttu-id="01dfd-422">Drop 方法</span><span class="sxs-lookup"><span data-stu-id="01dfd-422">Drop method</span></span>

<span data-ttu-id="01dfd-423">系統會呼叫 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 方法，以通知目標使用者已卸載資料，通常是透過放開滑鼠按鍵。</span><span class="sxs-lookup"><span data-stu-id="01dfd-423">The system calls the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to notify the target that the user has dropped the data, typically by releasing the mouse button.</span></span> <span data-ttu-id="01dfd-424">**IDropTarget：:D rop** 具有與 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)相同的參數。</span><span class="sxs-lookup"><span data-stu-id="01dfd-424">**IDropTarget::Drop** has the same parameters as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span> <span data-ttu-id="01dfd-425">目標通常會從資料物件中解壓縮一或多個格式來回應。</span><span class="sxs-lookup"><span data-stu-id="01dfd-425">The target normally responds by extracting one or more formats from the data object.</span></span> <span data-ttu-id="01dfd-426">完成時，目標應該將 *pdwEffect* 參數設定為 [**DROPEFFECT**](../com/dropeffect-constants.md) 值，以指出作業的結果。</span><span class="sxs-lookup"><span data-stu-id="01dfd-426">When finished, the target should set the *pdwEffect* parameter to a [**DROPEFFECT**](../com/dropeffect-constants.md) value that indicates the outcome of the operation.</span></span> <span data-ttu-id="01dfd-427">針對某些類型的 Shell 資料傳輸，目標也必須呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 來傳遞格式，以及將作業結果的其他資訊傳遞至資料物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-427">For some types of Shell data transfer, the target must also call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to pass a format with additional information on the outcome of the operation to the data object.</span></span> <span data-ttu-id="01dfd-428">如需詳細的討論，請參閱 [處理 Shell 資料傳輸案例](datascenarios.md)。</span><span class="sxs-lookup"><span data-stu-id="01dfd-428">For a detailed discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="01dfd-429">如果目標是使用拖放協助程式物件， [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 應該呼叫 [**IDropTargetHelper：:D rop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) 將 [**IDropTargetHelper：:D ragover**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) 參數中包含的資訊轉送到拖放 helper 物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-429">If the target is using the drag-and-drop helper object, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) should call [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) to forward the information contained in the [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) parameters to the drag-and-drop helper object.</span></span>

## <a name="using-the-drag-and-drop-helper-object"></a><span data-ttu-id="01dfd-430">使用拖放 Helper 物件</span><span class="sxs-lookup"><span data-stu-id="01dfd-430">Using the Drag-and-Drop Helper Object</span></span>

<span data-ttu-id="01dfd-431"> (CLSID DragDropHelper) 的拖放協助程式物件 \_ 會由 Shell 匯出，以允許目標在目標視窗上時指定拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-431">The drag-and-drop helper object (CLSID\_DragDropHelper) is exported by the Shell to allow targets to specify the drag image while it is over the target window.</span></span> <span data-ttu-id="01dfd-432">若要使用拖放協助程式物件，請使用 CLSID DragDropHelper 的 CLSID) 呼叫 [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) 來建立 (同進程伺服器物件 \_ 。</span><span class="sxs-lookup"><span data-stu-id="01dfd-432">To use the drag-and-drop helper object, create an in-process server object by calling [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) with a class identifier (CLSID) of CLSID\_DragDropHelper.</span></span> <span data-ttu-id="01dfd-433">拖放協助程式物件會公開兩個以下列方式使用的介面：</span><span class="sxs-lookup"><span data-stu-id="01dfd-433">The drag-and-drop helper object exposes two interfaces that are used in the following way:</span></span>

-   <span data-ttu-id="01dfd-434">[**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper)介面允許放置目標指定代表資料物件的圖示。</span><span class="sxs-lookup"><span data-stu-id="01dfd-434">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface allows the drop target to specify an icon to represent the data object.</span></span>
-   <span data-ttu-id="01dfd-435">[**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper)介面可讓放置目標通知游標位置的拖放 helper 物件，以及顯示或隱藏資料圖示。</span><span class="sxs-lookup"><span data-stu-id="01dfd-435">The [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) interface allows the drop target to inform the drag-and-drop helper object of the cursor location, and to show or hide the data icon.</span></span>

### <a name="using-the-idragsourcehelper-interface"></a><span data-ttu-id="01dfd-436">使用 IDragSourceHelper 介面</span><span class="sxs-lookup"><span data-stu-id="01dfd-436">Using the IDragSourceHelper Interface</span></span>

<span data-ttu-id="01dfd-437">[**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper)介面是由拖放協助程式物件公開，可讓放置目標提供當游標位於目標視窗上方時所顯示的影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-437">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface is exposed by the drag-and-drop helper object to allow a drop target to provide the image that will be displayed while the cursor is over the target window.</span></span> <span data-ttu-id="01dfd-438">**IDragSourceHelper** 提供兩種替代方式來指定用來作為拖曳影像的點陣圖：</span><span class="sxs-lookup"><span data-stu-id="01dfd-438">**IDragSourceHelper** provides two alternative ways to specify the bitmap to be used as a drag image:</span></span>

-   <span data-ttu-id="01dfd-439">您可以 \_ 使用 [**IDragSourceHelper：： InitializeFromWindow**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow)初始化拖放協助程式物件，藉以為視窗註冊 DI GETDRAGIMAGE 視窗訊息，以放置視窗。</span><span class="sxs-lookup"><span data-stu-id="01dfd-439">Drop targets that have a window can register a DI\_GETDRAGIMAGE window message for it by initializing the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromWindow**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow).</span></span> <span data-ttu-id="01dfd-440">當目標收到 DI \_ GETDRAGIMAGE 訊息時，處理常式會將拖曳影像點陣圖資訊放在傳遞做為訊息 *lParam* 值的 [**SHDRAGIMAGE**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage)結構中。</span><span class="sxs-lookup"><span data-stu-id="01dfd-440">When the target receives a DI\_GETDRAGIMAGE message, the handler puts the drag image bitmap information in the [**SHDRAGIMAGE**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage) structure that is passed as the message's *lParam* value.</span></span>
-   <span data-ttu-id="01dfd-441">無視窗的放置目標會在使用 [**IDragSourceHelper：： InitializeFromBitmap**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap)初始化拖放協助程式物件時，指定點陣圖。</span><span class="sxs-lookup"><span data-stu-id="01dfd-441">Windowless drop targets specify a bitmap when they initialize the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromBitmap**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap).</span></span>

### <a name="using-the-idroptargethelper-interface"></a><span data-ttu-id="01dfd-442">使用 IDropTargetHelper 介面</span><span class="sxs-lookup"><span data-stu-id="01dfd-442">Using the IDropTargetHelper Interface</span></span>

<span data-ttu-id="01dfd-443">當游標進入或離開目標時，此介面可讓放置目標通知拖放 helper 物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-443">This interface allows the drop target to notify the drag-and-drop helper object when the cursor enters or leaves the target.</span></span> <span data-ttu-id="01dfd-444">當游標停留在目標視窗上時， [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) 可讓目標為拖放 helper 物件提供目標透過其 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面接收的資訊。</span><span class="sxs-lookup"><span data-stu-id="01dfd-444">While the cursor is over the target window, [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) allows the target to give the drag-and-drop helper object the information that the target receives through its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="01dfd-445">有四個 [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) 方法（[**IDropTargetHelper：:D ragenter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter)、 [**IDropTargetHelper：:D Ragleave**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave)、 [**IDropTargetHelper：:D ragover**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover)和 [**IDropTargetHelper：:D rop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)）與相同名稱的 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 方法相關聯。</span><span class="sxs-lookup"><span data-stu-id="01dfd-445">Four of the [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) methods—[**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter), [**IDropTargetHelper::DragLeave**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave), [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover), and [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)—are associated with the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) method of the same name.</span></span> <span data-ttu-id="01dfd-446">若要使用拖放協助程式物件，每個 **IDropTarget** 方法都應該呼叫對應的 **IDropTargetHelper** 方法，將資訊轉送到拖放 helper 物件。</span><span class="sxs-lookup"><span data-stu-id="01dfd-446">To use the drag-and-drop helper object, each of the **IDropTarget** methods should call the corresponding **IDropTargetHelper** method to forward the information to the drag-and-drop helper object.</span></span> <span data-ttu-id="01dfd-447">第五個 **IDropTargetHelper** 方法（ [**IDropTargetHelper：： Show**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show)）會通知拖放協助程式物件顯示或隱藏拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-447">The fifth **IDropTargetHelper** method, [**IDropTargetHelper::Show**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show), notifies the drag-and-drop helper object to show or hide the drag image.</span></span> <span data-ttu-id="01dfd-448">在較低色彩深度的影片模式中拖曳目標視窗時，會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="01dfd-448">This method is used when dragging over a target window in a low color-depth video mode.</span></span> <span data-ttu-id="01dfd-449">它可讓目標在繪製視窗時隱藏拖曳影像。</span><span class="sxs-lookup"><span data-stu-id="01dfd-449">It allows the target to hide the drag image while it is painting the window.</span></span>

 

 
