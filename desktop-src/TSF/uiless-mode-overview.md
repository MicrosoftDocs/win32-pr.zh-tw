---
title: UILess 模式總覽
description: UILess 模式總覽
ms.assetid: cc0e4936-eab1-452d-9ba1-188401918e99
keywords:
- 文字服務架構 (TSF) 、UILessMode
- TSF (文字服務架構) ，UILessMode
- 啟用 TSF 的應用程式，UILessMode
- UILessMode
- 文字服務架構 (TSF) ，候選清單 UIElement
- TSF (文字服務架構) ，候選清單 UIElement
- 啟用 TSF 的應用程式，候選清單 UIElement
- 候選清單 UIElement
- 文字服務架構 (TSF) 、UIElement 提示
- TSF (文字服務架構) ，UIElement 提示
- 啟用 TSF 的應用程式，UIElement 提示
- UIElement 提示
- 文字服務架構 (TSF) 、預先定義的 UI 元素
- TSF (文字服務架構) ，預先定義的 UI 元素
- 啟用 TSF 的應用程式，預先定義的 UI 元素
- 預先定義的 UI 元素
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b7354a88fb28fd0d6bf5f4180ac23359a2117fe7
ms.sourcegitcommit: ee06501cc29132927ade9813e0888aaa4decc487
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/28/2021
ms.locfileid: "104556276"
---
# <a name="uiless-mode-overview"></a><span data-ttu-id="169ef-119">UILess 模式總覽</span><span class="sxs-lookup"><span data-stu-id="169ef-119">UILess Mode Overview</span></span>

## <a name="how-to-create-uilessmode"></a><span data-ttu-id="169ef-120">如何建立 UILessMode</span><span class="sxs-lookup"><span data-stu-id="169ef-120">How to create UILessMode</span></span>

<span data-ttu-id="169ef-121">**使無 UI 的執行緒：** 應用程式可透過 [**ITfThreadMgrEx：： ActivateEx**](/windows/desktop/api/Msctf/nf-msctf-itfthreadmgrex-activateex) 與 ITF AE UIELEMENTENABLEDONLY，讓 UI 更少執行緒 \_ \_ 。</span><span class="sxs-lookup"><span data-stu-id="169ef-121">**Making UI-less Thread:** The application can make a UI Less Thread by [**ITfThreadMgrEx::ActivateEx**](/windows/desktop/api/Msctf/nf-msctf-itfthreadmgrex-activateex) with ITF\_AE\_UIELEMENTENABLEDONLY.</span></span> <span data-ttu-id="169ef-122">使用這個旗標啟動 ThreadMgr 時，只會線上程上啟動可控制其 UI 元素的秘訣。</span><span class="sxs-lookup"><span data-stu-id="169ef-122">When ThreadMgr is activated with this flag, only TIPs that can control its UI element are activated on the thread.</span></span> <span data-ttu-id="169ef-123">應用程式需要執行 [**ITfUIElementSink**](/windows/desktop/api/Msctf/nn-msctf-itfuielementsink) 介面，並將介面告知執行緒管理員。</span><span class="sxs-lookup"><span data-stu-id="169ef-123">The application needs to implement [**ITfUIElementSink**](/windows/desktop/api/Msctf/nn-msctf-itfuielementsink) interface and advise the interface into thread manager.</span></span> <span data-ttu-id="169ef-124">[**ITfUIElementSink：： BeginUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementsink-beginuielement) 會在提示顯示其 UI 時呼叫。</span><span class="sxs-lookup"><span data-stu-id="169ef-124">[**ITfUIElementSink::BeginUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementsink-beginuielement) is called when TIP shows its UI.</span></span> <span data-ttu-id="169ef-125">應用程式可能會在 pbShow 參數中傳回 **TRUE** ，以允許提示在應用程式不需要繪製時顯示提示的原始 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-125">The application can return **TRUE** in pbShow param to allow TIP to show TIP's original UI when the application does not want to draw.</span></span> <span data-ttu-id="169ef-126">如果應用程式不允許提示的 UI，它會在 pbShow 中傳回 **FALSE** (請參閱下圖) 。</span><span class="sxs-lookup"><span data-stu-id="169ef-126">If the application does not allow TIP's UI, it can return **FALSE** in pbShow (see diagrams below).</span></span> <span data-ttu-id="169ef-127">應用程式可以從 *pElement* 參數取得一些資訊，藉此繪製 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-127">The application can draw the UI by itself by getting some information from the *pElement* param.</span></span> <span data-ttu-id="169ef-128">它可能是候選清單、語言列專案或秘訣的自訂 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-128">It could be the candidate list, the language bar item, or the custom UI of TIP.</span></span> <span data-ttu-id="169ef-129">應用程式可以透過 QIing [**ITfUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfuielement) 介面來知道 UI 的種類。</span><span class="sxs-lookup"><span data-stu-id="169ef-129">The application can know the kind of UI by QIing [**ITfUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfuielement) interface.</span></span> <span data-ttu-id="169ef-130">當 UI 變更時，會呼叫 [**ITfUIElementSink：： UpdateUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementsink-updateuielement) 。</span><span class="sxs-lookup"><span data-stu-id="169ef-130">When the UI is changed, [**ITfUIElementSink::UpdateUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementsink-updateuielement) is called.</span></span> <span data-ttu-id="169ef-131">此應用程式可以比較 pElement->GetGUID () 的 GUID，以瞭解該元素目前是否由應用程式繪製。</span><span class="sxs-lookup"><span data-stu-id="169ef-131">The application can compare the GUID from pElement->GetGUID() to know if the element is currently drawn by the application.</span></span>

<span data-ttu-id="169ef-132">**讓 UI 更不感知提示：** 如果應用程式想要在不想要允許提示 UI 的應用程式（例如遊戲應用程式或全螢幕應用程式）下執行，則秘訣應支援較不模式的 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-132">**Making UI-less Aware TIP:** TIP should support UI less mode if it wants to run under the application that does not want to allow TIP's UI such as game application or full screen applications.</span></span> <span data-ttu-id="169ef-133">若要以 UI 較不清楚，提示必須執行 [**ITfTextInputProcessorEx**](/windows/desktop/api/Msctf/nn-msctf-itftextinputprocessorex) 介面。</span><span class="sxs-lookup"><span data-stu-id="169ef-133">To be UI less aware, TIP needs to implement [**ITfTextInputProcessorEx**](/windows/desktop/api/Msctf/nn-msctf-itftextinputprocessorex) interface.</span></span> <span data-ttu-id="169ef-134">如果未執行這個介面，則不會在 UI 較低模式的執行緒下啟用提示。</span><span class="sxs-lookup"><span data-stu-id="169ef-134">If this interface is not implemented, TIP will not be activated under the UI less mode thread.</span></span> <span data-ttu-id="169ef-135">此外，提示必須先呼叫 [**ITFUIElementMgr：： BeginUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementmgr-beginuielement) ，才能在螢幕上顯示可見的 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-135">In addition, TIP must call [**ITFUIElementMgr::BeginUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementmgr-beginuielement) before it shows a visible UI to the screen.</span></span> <span data-ttu-id="169ef-136">這個方法會呼叫 [**ITfUIElementSink**](/windows/desktop/api/Msctf/nn-msctf-itfuielementsink) 來通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="169ef-136">This method makes a call to [**ITfUIElementSink**](/windows/desktop/api/Msctf/nn-msctf-itfuielementsink) to notify the application.</span></span> <span data-ttu-id="169ef-137">應用程式會決定是否可顯示。</span><span class="sxs-lookup"><span data-stu-id="169ef-137">And the application will decide if it can be shown or not.</span></span> <span data-ttu-id="169ef-138">當提示呼叫 BeginUIElement () 時，提示必須具有對應 UI 的 [**ITfUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfuielement) 介面。</span><span class="sxs-lookup"><span data-stu-id="169ef-138">When TIP calls BeginUIElement(), TIP needs to have the [**ITfUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfuielement) interface for the corresponding UI.</span></span> <span data-ttu-id="169ef-139">應用程式會將介面 QI，以取得其他 UI 特定介面，以取得詳細資訊來繪製 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-139">The application will QI the interface to get another UI specific interface to retrieve more information to draw the UI.</span></span> <span data-ttu-id="169ef-140">System 預先定義 [**ITfCandidateListUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfcandidatelistuielement) and [**ITfReadingInformationUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfreadinginformationuielement) for TIP。</span><span class="sxs-lookup"><span data-stu-id="169ef-140">System predefines [**ITfCandidateListUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfcandidatelistuielement) and [**ITfReadingInformationUIElement**](/windows/desktop/api/Msctf/nn-msctf-itfreadinginformationuielement) for TIP.</span></span> <span data-ttu-id="169ef-141">當提示想要在 UI less 模式執行緒下顯示候選清單時，提示必須建立 **ITfCandidateListUIElement** 介面的實例，並呼叫 **ITFUIElementMgr：： BeginUIElement**。</span><span class="sxs-lookup"><span data-stu-id="169ef-141">When TIP wants to show the candidate list under UI less mode thread, TIP must create an instance of the **ITfCandidateListUIElement** interface and call **ITFUIElementMgr::BeginUIElement**.</span></span> <span data-ttu-id="169ef-142">呼叫 [**ITfTextInputProcessorEx：： ActivateEx**](/windows/desktop/api/Msctf/nf-msctf-itftextinputprocessorex-activateex) 時，秘訣已經知道執行緒的 UI 較小，因此可以消除額外的自訂 UI。</span><span class="sxs-lookup"><span data-stu-id="169ef-142">When [**ITfTextInputProcessorEx::ActivateEx**](/windows/desktop/api/Msctf/nf-msctf-itftextinputprocessorex-activateex) is called, TIP already know the thread is UI less more so it can eliminate the extra custom UI.</span></span> <span data-ttu-id="169ef-143">當然，它可以執行自己的介面，它可以從 QIed 並嘗試發出通知。</span><span class="sxs-lookup"><span data-stu-id="169ef-143">However, of course, it can implement its own interface that can be QIed from and try to make a notification.</span></span> <span data-ttu-id="169ef-144">因此秘訣和 &**ITfUIElement** 程式可以有 tip 自訂 UI 的協商。</span><span class="sxs-lookup"><span data-stu-id="169ef-144">Thus TIP and the appli **ITfUIElement** cation can have a negotiation for the TIP custom UI.</span></span>

## <a name="uielement-supporting-tip"></a><span data-ttu-id="169ef-145">UIElement 支援提示</span><span class="sxs-lookup"><span data-stu-id="169ef-145">UIElement Supporting TIP</span></span>

<span data-ttu-id="169ef-146">支援 UIElement 的秘訣必須由 GUID \_ TFCAT \_ TIPCAP \_ UIELEMENTENABLED 分類。</span><span class="sxs-lookup"><span data-stu-id="169ef-146">The TIP that supports the UIElement must be categorized by GUID\_TFCAT\_TIPCAP\_UIELEMENTENABLED.</span></span> <span data-ttu-id="169ef-147">GUID \_ TFCAT TIPCAP UIELEMENTENABLED 中的秘訣 \_ \_ 必須使用 [**ITFUIELEMENTMGR**](/windows/desktop/api/Msctf/nn-msctf-itfuielementmgr) 來顯示任何 ui，讓應用程式能夠控制 ui 的可見度。</span><span class="sxs-lookup"><span data-stu-id="169ef-147">The TIP in GUID\_TFCAT\_TIPCAP\_UIELEMENTENABLED must use [**ITfUIElementMgr**](/windows/desktop/api/Msctf/nn-msctf-itfuielementmgr) to show any UI so the application can control the visibility of the UI.</span></span>

<span data-ttu-id="169ef-148">**顯示/隱藏 UIElement 的狀態：** 顯示/隱藏 [**ITfUIElement：： Show**](/windows/desktop/api/Msctf/nf-msctf-itfuielement-show) 或 [**ITfUIElement：： IsShown**](/windows/desktop/api/Msctf/nf-msctf-itfuielement-isshown) 方法所指出的狀態是實際的可見狀態。</span><span class="sxs-lookup"><span data-stu-id="169ef-148">**Show/Hide status of UIElement:** Show/Hide status that is indicated by [**ITfUIElement::Show**](/windows/desktop/api/Msctf/nf-msctf-itfuielement-show) or [**ITfUIElement::IsShown**](/windows/desktop/api/Msctf/nf-msctf-itfuielement-isshown) method is the actual visible status.</span></span> <span data-ttu-id="169ef-149">它與 UIElement 的可用性無關。</span><span class="sxs-lookup"><span data-stu-id="169ef-149">It is not related to the availability of UIElement.</span></span> <span data-ttu-id="169ef-150">當顯示狀態存在時，UIElement 應該一律可供使用。</span><span class="sxs-lookup"><span data-stu-id="169ef-150">UIElement should be always available when the show status exists.</span></span> <span data-ttu-id="169ef-151">顯示狀態可從應用程式進行控制。</span><span class="sxs-lookup"><span data-stu-id="169ef-151">The show status is controllable from the application.</span></span> <span data-ttu-id="169ef-152">應用程式可能會突然進入 UILess 模式，並開始繪製一些 UI，方法是呼叫 **ITfUIElement：： Show** 和 **FALSE** 來隱藏所有提示 ui。</span><span class="sxs-lookup"><span data-stu-id="169ef-152">The application may suddenly move into UILess mode and start drawing some UI by itself, by calling **ITfUIElement::Show** with **FALSE** to hide all the UI of TIP.</span></span> <span data-ttu-id="169ef-153">然後提示可以採用其中一個選項。</span><span class="sxs-lookup"><span data-stu-id="169ef-153">Then TIP can take one of some options.</span></span> <span data-ttu-id="169ef-154">1) 提示可以將 UIElement 移至隱藏狀態，並開始產生 UpdateUIElement。</span><span class="sxs-lookup"><span data-stu-id="169ef-154">1) TIP can move the UIElement to the Hide status and start generating UpdateUIElement.</span></span> <span data-ttu-id="169ef-155">2) 提示可以完成 UIElement，因為 UI 元素不支援隱藏狀態和提示呼叫 EndUIElement () 完成。</span><span class="sxs-lookup"><span data-stu-id="169ef-155">2) TIP can finish UIElement since the UI element does not support Hide status and Tip calls EndUIElement() to finish it.</span></span>

## <a name="predefined-ui-elements"></a><span data-ttu-id="169ef-156">預先定義的 UI 元素</span><span class="sxs-lookup"><span data-stu-id="169ef-156">Predefined UI Elements</span></span>

<span data-ttu-id="169ef-157">**候選清單：** 候選清單是 EA 輸入的其中一個主要 UI 元素。</span><span class="sxs-lookup"><span data-stu-id="169ef-157">**The candidate list:** The candidate list is one of the major UI elements for EA input.</span></span> <span data-ttu-id="169ef-158">這個 UI 元素提供候選清單和對應的候選字串數目來進行繪製。</span><span class="sxs-lookup"><span data-stu-id="169ef-158">This UI Element provides the candidate list and corresponding number of the candidate strings for drawing.</span></span>

<span data-ttu-id="169ef-159">**閱讀資訊視窗** [閱讀資訊] 視窗常見於中文鍵盤輸入。</span><span class="sxs-lookup"><span data-stu-id="169ef-159">**The reading information window** The reading information window is common for Chinese Keyboard Input.</span></span> <span data-ttu-id="169ef-160">它具有無法以組合字元串的形式插入檔中的階段。</span><span class="sxs-lookup"><span data-stu-id="169ef-160">It has the stage that cannot be inserted into the document as the composition string.</span></span> <span data-ttu-id="169ef-161">某些中文輸入處理器會開啟一個小型閱讀資訊視窗，其中顯示閱讀、拼音或輸入資訊。</span><span class="sxs-lookup"><span data-stu-id="169ef-161">Some Chinese Input Processor opens a small reading information window that shows the reading, phonetic or typing information.</span></span>

## <a name="the-flow-chart-of-uilessmode"></a><span data-ttu-id="169ef-162">UILessMode 的流程圖</span><span class="sxs-lookup"><span data-stu-id="169ef-162">The flow chart of UILessMode</span></span>

![顯示 U I LessMode 流程圖的圖表。](images/tsf-uilessmode-ovw1.gif)

<span data-ttu-id="169ef-164">在 pbShown by ITfUIElementMgr：： BeginUIElement 中的提示收到 **TRUE** 之後 \* ，提示不需要 [](/windows/desktop/api/Msctf/nf-msctf-itfuielementmgr-beginuielement)呼叫 UIElement 的 UpdateUIElement。</span><span class="sxs-lookup"><span data-stu-id="169ef-164">After the TIP receives **TRUE** in \*pbShown by [**ITfUIElementMgr::BeginUIElement**](/windows/desktop/api/Msctf/nf-msctf-itfuielementmgr-beginuielement), the TIP does not have to call UpdateUIElement for the UIElement.</span></span> <span data-ttu-id="169ef-165">但是提示必須呼叫 EndUIElement () 因此 [**ITfUIElementMgr**](/windows/desktop/api/Msctf/nn-msctf-itfuielementmgr) 和應用程式可以追蹤 UIElement 的狀態。</span><span class="sxs-lookup"><span data-stu-id="169ef-165">But TIP needs to call EndUIElement() so the [**ITfUIElementMgr**](/windows/desktop/api/Msctf/nn-msctf-itfuielementmgr) and the application can track the status of UIElement.</span></span> <span data-ttu-id="169ef-166">提示必須在 BeginUIElement 之後呼叫 UpdateUIElement () ， () 在 pbShow 中傳回 **FALSE** \* 。</span><span class="sxs-lookup"><span data-stu-id="169ef-166">TIP must calls UpdateUIElement() after BeginUIElement() returns **FALSE** in \*pbShow.</span></span> <span data-ttu-id="169ef-167">想要繪製 UI 的應用程式不會檢查 BeginUIElement () 中的內容，它只會傳回 BeginUIElement () 的顯示狀態，並開始在 UpdateUIElement () 檢查內容。</span><span class="sxs-lookup"><span data-stu-id="169ef-167">The application that wants to draw the UI does not check the contents in BeginUIElement(), it just returns the show status at BeginUIElement() and starts checking the contents at UpdateUIElement().</span></span> <span data-ttu-id="169ef-168">例如，候選清單 UIElement 的 update 旗標有第一個 UpdateUIElement () 的所有位。</span><span class="sxs-lookup"><span data-stu-id="169ef-168">For example, the update flag of the candidate list UIElement has all bits at the first UpdateUIElement().</span></span> <span data-ttu-id="169ef-169">這表示 UIElement 的內容不需要在 BeginUIElement () 備妥。</span><span class="sxs-lookup"><span data-stu-id="169ef-169">This means that the contents of UIElement does not have to be ready at BeginUIElement().</span></span>

![此圖顯示當 T I P 呼叫 ' ITUIElementMgr：： BeginUIElement () ' 和 ' BeginUIElement of Application UIElementSink ' 時，會呼叫。](images/tsf-uilessmode-ovw2.gif)![顯示應用程式在 \* pbShow 中傳回 FALSE 的圖表。](images/tsf-uilessmode-ovw3.gif)![uilessmode 流程圖](images/tsf-uilessmode-ovw4.gif)

## <a name="the-candidate-list-uielement"></a><span data-ttu-id="169ef-173">候選清單 UIElement</span><span class="sxs-lookup"><span data-stu-id="169ef-173">The candidate list UIElement</span></span>

<span data-ttu-id="169ef-174">**關於 PageIndex：** 當 (TF \_ CLUIE STRING 設定) 時，繪製候選清單的應用程式會計算每頁的字串數目 \_ 。</span><span class="sxs-lookup"><span data-stu-id="169ef-174">**About PageIndex:** The application that draws the candidate list will calculate the number of strings per page when the contents of the list is changed (TF\_CLUIE\_STRING is set).</span></span> <span data-ttu-id="169ef-175">當候選清單適用于 UILess 模式時，不適合變更頁面索引。</span><span class="sxs-lookup"><span data-stu-id="169ef-175">It is not good to change the page index while the candidate list is available for UILess mode.</span></span> <span data-ttu-id="169ef-176">這表示，當選取範圍移至下一個頁面時，提示的候選清單應該會有分頁的行為，而不是滾動。</span><span class="sxs-lookup"><span data-stu-id="169ef-176">This means that TIP's candidate list should behave the paging rather than scrolling when the selection is moved to the next page.</span></span> <span data-ttu-id="169ef-177">如果捲軸在選取範圍移動時發生，則頁面索引會變更，而應用程式需要重新計算頁面索引。</span><span class="sxs-lookup"><span data-stu-id="169ef-177">If the scroll happens at the selection moves, the page index is changed and the application needs to recalculate the page index.</span></span> <span data-ttu-id="169ef-178">提示可能不是預期的結果。</span><span class="sxs-lookup"><span data-stu-id="169ef-178">The result may not be expected by TIP.</span></span>

<span data-ttu-id="169ef-179">**沒有選取專案：** 如果候選清單沒有選取專案， [**ITfCandidateListUIElement：： GetSelection**](/windows/desktop/api/Msctf/nf-msctf-itfcandidatelistuielement-getselection) \_ 會傳回 FALSE。</span><span class="sxs-lookup"><span data-stu-id="169ef-179">**No Selection:** [**ITfCandidateListUIElement::GetSelection**](/windows/desktop/api/Msctf/nf-msctf-itfcandidatelistuielement-getselection) returns S\_FALSE, if the candidate list does not have a selection.</span></span> <span data-ttu-id="169ef-180">第一個參數的傳回值無效。</span><span class="sxs-lookup"><span data-stu-id="169ef-180">The return value of the first param is invalid.</span></span>

 

 




