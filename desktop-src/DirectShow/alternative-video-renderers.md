---
description: 本主題說明如何撰寫適用于 DirectShow 的自訂影片轉譯器。
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: 替代影片轉譯器
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "103688316"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="e24ef-103">替代影片轉譯器</span><span class="sxs-lookup"><span data-stu-id="e24ef-103">Alternative Video Renderers</span></span>

<span data-ttu-id="e24ef-104">本主題說明如何撰寫適用于 DirectShow 的自訂影片轉譯器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="e24ef-105">建議您撰寫適用于影片混合轉譯器的外掛程式配置器， (VMR) 或 [**增強的影片**](enhanced-video-renderer-filter.md) 轉譯器 (EVR) ，而不是撰寫自訂影片轉譯器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="e24ef-106">這種方法可提供 VMR/EVR 的所有優點，包括支援 DirectX Video 加速 (DXVA) 、硬體去交錯和框架逐步執行，而且可能比自訂影片轉譯器更健全。</span><span class="sxs-lookup"><span data-stu-id="e24ef-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="e24ef-107">如需詳細資訊，請參閱下列主題：</span><span class="sxs-lookup"><span data-stu-id="e24ef-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="e24ef-108">VMR Renderless 播放模式 (自訂配置器-展示者) </span><span class="sxs-lookup"><span data-stu-id="e24ef-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="e24ef-109">如何撰寫 EVR 展示者</span><span class="sxs-lookup"><span data-stu-id="e24ef-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="e24ef-110">撰寫替代轉譯器</span><span class="sxs-lookup"><span data-stu-id="e24ef-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="e24ef-111">Microsoft DirectShow 提供以視窗為基礎的影片轉譯器;它也會在執行時間安裝中提供全螢幕轉譯器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="e24ef-112">您可以使用 DirectShow 基類來撰寫替代的影片轉譯器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="e24ef-113">為了讓替代轉譯器能夠與 DirectShow 型應用程式正確互動，轉譯器必須遵守本文中所述的指導方針。</span><span class="sxs-lookup"><span data-stu-id="e24ef-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="e24ef-114">您可以使用 [**CBaseRenderer**](cbaserenderer.md) 和 [**CBaseVideoRenderer**](cbasevideorenderer.md) 類別，在執行替代的影片轉譯時，協助您遵循這些指導方針。</span><span class="sxs-lookup"><span data-stu-id="e24ef-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="e24ef-115">由於不斷進行的 DirectShow 開發，請定期審核您的實施，以確保轉譯器與最新的 DirectShow 版本相容。</span><span class="sxs-lookup"><span data-stu-id="e24ef-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="e24ef-116">本主題討論轉譯器負責處理的許多通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="e24ef-117">DirectShow 通知的簡短檢查可能有助於設定階段。</span><span class="sxs-lookup"><span data-stu-id="e24ef-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="e24ef-118">有三種類型的通知會出現在 DirectShow 中：</span><span class="sxs-lookup"><span data-stu-id="e24ef-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="e24ef-119">*資料流程通知* 是在媒體資料流程中發生的事件，會從一個篩選準則傳遞到下一個篩選器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="e24ef-120">這些可以是開始排清、結束排清或結束資料流程通知，並藉由在下游篩選的輸入 pin 上呼叫適當的方法來傳送 (例如 [**IPin：： BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)) 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="e24ef-121">*篩選圖形通知*，這是從篩選傳送至篩選圖形管理員（例如 [**EC \_ 完成**](ec-complete.md)）的事件。</span><span class="sxs-lookup"><span data-stu-id="e24ef-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="e24ef-122">這可透過在篩選圖形管理員上呼叫 [**IMediaEventSink：： Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) 方法來完成。</span><span class="sxs-lookup"><span data-stu-id="e24ef-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="e24ef-123">*代理程式更新*，由控制應用程式從篩選圖形管理員抓取。</span><span class="sxs-lookup"><span data-stu-id="e24ef-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="e24ef-124">應用程式會在篩選圖形管理員上呼叫 [**IMediaEvent：： GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) 方法，以取得這些事件。</span><span class="sxs-lookup"><span data-stu-id="e24ef-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="e24ef-125">篩選圖形管理員通常會將它收到的事件傳遞至應用程式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="e24ef-126">本主題討論轉譯器篩選器在處理它所接收的串流通知，以及傳送適當的篩選圖形通知時的責任。</span><span class="sxs-lookup"><span data-stu-id="e24ef-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="e24ef-127">處理資料流程結束和清除通知</span><span class="sxs-lookup"><span data-stu-id="e24ef-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="e24ef-128">資料流程結束通知會從上游篩選開始 (例如來源篩選準則，) 篩選器偵測到它無法傳送任何資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="e24ef-129">它會通過圖形中的每個篩選，最後結束于轉譯器，而該轉譯器負責後續將 [**EC \_ 完成**](ec-complete.md) 通知傳送至篩選圖形管理員。</span><span class="sxs-lookup"><span data-stu-id="e24ef-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e24ef-130">轉譯器在處理這些通知時有特殊責任。</span><span class="sxs-lookup"><span data-stu-id="e24ef-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="e24ef-131">當上游篩選器呼叫它的輸入釘選 [**IPin：： EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) 方法時，轉譯器會接收資料流程結束通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="e24ef-132">轉譯器應該記下此通知，然後繼續轉譯它已收到的任何資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="e24ef-133">一旦收到所有剩餘的資料之後，轉譯器應該會將 [**EC \_ 完成**](ec-complete.md) 通知傳送至篩選圖形管理員。</span><span class="sxs-lookup"><span data-stu-id="e24ef-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e24ef-134">每次在每次到達資料流程結尾時，轉譯器都應該只傳送一次 **EC \_ 完成** 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="e24ef-135">此外，只有在執行篩選圖形時，才必須傳送 **EC \_ 完全** 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="e24ef-136">因此，當來源篩選傳送資料流程結束時，如果篩選圖形暫停，則在最後執行篩選圖形之前，不應傳送 **EC \_ 完成** 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="e24ef-137">[**IMemInputPin：： Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive)或 [**IMemInputPin：： ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple)方法在結束資料流程通知之後的任何呼叫都應遭到拒絕。</span><span class="sxs-lookup"><span data-stu-id="e24ef-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="e24ef-138">**E \_** 在此情況下，未預期的是最適當的錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="e24ef-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="e24ef-139">當篩選圖形停止時，應該清除任何快取的資料流程結束通知，而不會在下次啟動時重新傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="e24ef-140">這是因為篩選圖形管理員一律會在執行之前暫停所有篩選，以便進行適當的排清。</span><span class="sxs-lookup"><span data-stu-id="e24ef-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="e24ef-141">因此，例如，如果已暫停篩選圖形並收到資料流程結束通知，然後篩選圖形已停止，則轉譯器在後續執行時，不應傳送 [**EC \_ 完成**](ec-complete.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="e24ef-142">如果未進行任何搜尋，來源篩選器會在執行狀態之前的暫停狀態期間，自動傳送另一個結束資料流程的通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="e24ef-143">另一方面，如果在篩選圖形停止時發生搜尋，則來源篩選可能會有要傳送的資料，因此不會傳送資料流程結束通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="e24ef-144">影片轉譯器通常相依于資料流程的結束通知，而不是傳送 [**EC \_ 完成**](ec-complete.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="e24ef-145">例如，如果資料流程已完成播放 (也就是已) 傳送資料流程結束通知，然後將另一個視窗拖曳到 [影片轉譯器] 視窗上，則會產生許多的 [**WM \_ 油漆**](/windows/desktop/gdi/wm-paint) 視窗訊息。</span><span class="sxs-lookup"><span data-stu-id="e24ef-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="e24ef-146">執行影片轉譯器的一般作法是避免在收到 **WM \_ 油漆** 訊息時重新繪製目前的框架 (根據假設將會) 收到另一個要繪製的框架。</span><span class="sxs-lookup"><span data-stu-id="e24ef-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="e24ef-147">但是，當傳送資料流程結束通知時，轉譯器會處於等候狀態;它仍在執行中，但卻知道它將不會收到任何額外的資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="e24ef-148">在這些情況下，轉譯器通常會將播放區域呈現為黑色。</span><span class="sxs-lookup"><span data-stu-id="e24ef-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="e24ef-149">處理清除是轉譯器的額外複雜。</span><span class="sxs-lookup"><span data-stu-id="e24ef-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="e24ef-150">清除會透過一對稱為 [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)和 [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush)的 [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin)方法來執行。</span><span class="sxs-lookup"><span data-stu-id="e24ef-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="e24ef-151">排清程式基本上是轉譯器必須處理的其他狀態。</span><span class="sxs-lookup"><span data-stu-id="e24ef-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="e24ef-152">來源篩選器在不呼叫 **EndFlush** 的情況下呼叫 **BeginFlush** 是不合法的，所以希望狀態是簡短且離散的;不過，轉譯器必須正確處理在排清轉換期間收到的資料或通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="e24ef-153">呼叫 [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) 之後所收到的任何資料，都應該藉由傳回 **\_ FALSE** 來立即予以拒絕。</span><span class="sxs-lookup"><span data-stu-id="e24ef-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="e24ef-154">此外，在清除轉譯器時，也應該清除任何快取的資料流程結束通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="e24ef-155">轉譯器通常會在回應搜尋時進行清除。</span><span class="sxs-lookup"><span data-stu-id="e24ef-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="e24ef-156">排清可確保在傳送新的範例之前，會從篩選圖形清除舊的資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="e24ef-157"> (通常會在資料流程的兩個區段之前逐一播放，最好是透過延後的命令來處理，而不是等候一個區段完成，然後再發出 seek 命令。 ) </span><span class="sxs-lookup"><span data-stu-id="e24ef-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="e24ef-158">處理狀態變更並暫停完成</span><span class="sxs-lookup"><span data-stu-id="e24ef-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="e24ef-159">轉譯器篩選器的狀態變更時，與篩選圖形中的任何其他篩選器的行為相同，但有下列例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e24ef-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="e24ef-160">在暫停之後，轉譯器會將一些資料排入佇列，準備好在後續執行時進行轉譯。</span><span class="sxs-lookup"><span data-stu-id="e24ef-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="e24ef-161">當影片轉譯器停止時，它會保留在此已排入佇列的資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="e24ef-162">這是 DirectShow 規則的例外狀況，篩選圖停止時，篩選器不應保留任何資源。</span><span class="sxs-lookup"><span data-stu-id="e24ef-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="e24ef-163">這個例外狀況的原因是，藉由保留資源，轉譯器一律會有一個影像，以便在收到 [**WM \_ 油漆**](/windows/desktop/gdi/wm-paint) 訊息時重新繪製視窗。</span><span class="sxs-lookup"><span data-stu-id="e24ef-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="e24ef-164">它也有一個可滿足方法（例如 [**CBaseControlVideo：： GetStaticImage**](cbasecontrolvideo-getstaticimage.md)）的影像，可要求目前映射的複本。</span><span class="sxs-lookup"><span data-stu-id="e24ef-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="e24ef-165">保存資源的另一項影響是將配置器停止已取消認可，進而讓下一次狀態變更的執行速度變得更快，因為映射緩衝區已配置。</span><span class="sxs-lookup"><span data-stu-id="e24ef-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="e24ef-166">只有在執行時，影片轉譯器才會轉譯和發行範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="e24ef-167">在暫停時，篩選可能會轉譯 (例如，在視窗) 中繪製靜態海報影像時，不應該釋出它們。</span><span class="sxs-lookup"><span data-stu-id="e24ef-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="e24ef-168">音訊轉譯器不會在暫停 (的情況下進行轉譯，不過它們可以執行其他活動，例如) 的準備 wave 裝置。</span><span class="sxs-lookup"><span data-stu-id="e24ef-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="e24ef-169">您可以藉由將範例中的資料流程時間與傳遞給 [**IMediaControl：： Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) 方法的參考時間結合，來取得應轉譯樣本的時間。</span><span class="sxs-lookup"><span data-stu-id="e24ef-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="e24ef-170">轉譯器應該拒絕開始時間小於或等於結束時間的樣本。</span><span class="sxs-lookup"><span data-stu-id="e24ef-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="e24ef-171">當應用程式暫停篩選圖形時，不會從 [**IMediaControl：:P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) 方法傳回篩選圖形，直到轉譯器有資料佇列為止。</span><span class="sxs-lookup"><span data-stu-id="e24ef-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="e24ef-172">為了確保這一點，當轉譯器暫停時，如果沒有等待轉譯的資料，它應該會傳回 \_ FALSE。</span><span class="sxs-lookup"><span data-stu-id="e24ef-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="e24ef-173">如果資料已排入佇列，則可能會 **傳回 \_ [確定]**。</span><span class="sxs-lookup"><span data-stu-id="e24ef-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="e24ef-174">篩選圖形管理員會在暫停篩選圖形時檢查所有傳回值，以確保轉譯器將資料排入佇列。</span><span class="sxs-lookup"><span data-stu-id="e24ef-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="e24ef-175">如果有一或多個篩選準則未就緒，則篩選圖形管理員會藉由呼叫 [**IMediaFilter：： >getstate**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)來輪詢圖形中的篩選。</span><span class="sxs-lookup"><span data-stu-id="e24ef-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="e24ef-176">**>getstate** 方法會使用超時參數。</span><span class="sxs-lookup"><span data-stu-id="e24ef-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="e24ef-177">篩選準則 (通常是在 **>getstate** 方法過期時，仍在等候資料抵達的轉譯器) 會傳回 **VFW \_ S \_ 狀態 \_ 中繼**。</span><span class="sxs-lookup"><span data-stu-id="e24ef-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="e24ef-178">當資料抵達轉譯器之後， **>getstate** 應該會立即傳回，而且可以是 **\_ OK**。</span><span class="sxs-lookup"><span data-stu-id="e24ef-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="e24ef-179">在 [中繼] 和 [已完成] 狀態中，報告的篩選狀態將會 \_ 暫停狀態。</span><span class="sxs-lookup"><span data-stu-id="e24ef-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="e24ef-180">只有傳回值會指出篩選準則是否真的就緒。</span><span class="sxs-lookup"><span data-stu-id="e24ef-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="e24ef-181">如果轉譯器正在等候資料到達，則其來源篩選準則會傳送資料流程結束通知，然後也應完成狀態變更。</span><span class="sxs-lookup"><span data-stu-id="e24ef-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="e24ef-182">一旦所有篩選準則都有等候轉譯的資料，篩選圖形將會完成其暫停狀態變更。</span><span class="sxs-lookup"><span data-stu-id="e24ef-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="e24ef-183">處理終止</span><span class="sxs-lookup"><span data-stu-id="e24ef-183">Handling Termination</span></span>

<span data-ttu-id="e24ef-184">影片轉譯器必須正確地處理來自使用者的終止事件。</span><span class="sxs-lookup"><span data-stu-id="e24ef-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="e24ef-185">這表示會正確地隱藏視窗，並知道後續會強制顯示視窗時該怎麼辦。</span><span class="sxs-lookup"><span data-stu-id="e24ef-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="e24ef-186">此外，當轉譯器從篩選圖形中移除時，影片轉譯器必須通知篩選圖形管理員 (或更準確，) 以釋放資源。</span><span class="sxs-lookup"><span data-stu-id="e24ef-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="e24ef-187">如果使用者按下 ALT + F4) 來關閉影片視窗 (例如，則慣例是立即隱藏視窗，然後將 [**EC \_ USERABORT**](ec-userabort.md) 通知傳送至篩選圖形管理員。</span><span class="sxs-lookup"><span data-stu-id="e24ef-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e24ef-188">此通知會傳遞至應用程式，這將會停止圖表播放。</span><span class="sxs-lookup"><span data-stu-id="e24ef-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="e24ef-189">傳送 **EC \_ USERABORT** 之後，影片轉譯器應該拒絕任何其他傳遞給它的範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="e24ef-190">圖形停止的旗標應該留在轉譯器之前，直到它之後停止為止，此時應該重設，讓應用程式可以覆寫使用者動作，並視需要繼續播放圖形。</span><span class="sxs-lookup"><span data-stu-id="e24ef-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="e24ef-191">如果影片正在執行時按下 ALT + F4，則會隱藏視窗，並會拒絕所有更進一步的範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="e24ef-192">如果後續顯示視窗 (可能是透過 [**IVideoWindow：:p 顯示) \_ 可見**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible) ，則不應產生任何 [**EC 重新 \_ 繪製**](ec-repaint.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="e24ef-193">影片轉譯器也應該在影片轉譯器結束時，將 [ [**EC \_ 視窗] \_**](ec-window-destroyed.md) 終結通知傳送至篩選圖形。</span><span class="sxs-lookup"><span data-stu-id="e24ef-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="e24ef-194">事實上，最好是在使用 null 參數呼叫轉譯器的 [**IBaseFilter：： JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) 方法時進行處理， (表示轉譯器即將從篩選圖形) 中移除，而不是等到實際的影片視窗終結為止。</span><span class="sxs-lookup"><span data-stu-id="e24ef-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="e24ef-195">傳送此通知可讓篩選圖形管理員中的外掛程式散發者，將相依于視窗焦點的資源傳遞給其他篩選器，例如音訊裝置。</span><span class="sxs-lookup"><span data-stu-id="e24ef-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="e24ef-196">處理動態格式變更</span><span class="sxs-lookup"><span data-stu-id="e24ef-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="e24ef-197">在某些情況下，轉譯器的上游篩選可能會在播放影片時嘗試變更影片格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="e24ef-198">它最常是起始動態格式變更的影片解壓縮程式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="e24ef-199">嘗試動態變更格式的上游篩選器應該一律呼叫轉譯器輸入釘選上的 [**IPin：： QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) 方法。</span><span class="sxs-lookup"><span data-stu-id="e24ef-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="e24ef-200">影片轉譯器對於其應該支援的動態格式變更類型有一些一點時間。</span><span class="sxs-lookup"><span data-stu-id="e24ef-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="e24ef-201">它至少應該允許上游篩選器變更調色板。</span><span class="sxs-lookup"><span data-stu-id="e24ef-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="e24ef-202">當上游篩選變更媒體類型時，它會將媒體類型附加至以新格式傳遞的第一個範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="e24ef-203">如果轉譯器在佇列中保存範例以供轉譯，則在轉譯具有類型變更的範例之前，不應該變更格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="e24ef-204">影片轉譯器也可以從解碼器要求格式變更。</span><span class="sxs-lookup"><span data-stu-id="e24ef-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="e24ef-205">例如，它可能會要求解碼器提供具有負面 **biHeight** 的 DirectDraw 相容格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="e24ef-206">當轉譯器暫停時，它應該呼叫上游釘選上的 [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) ，以查看該解碼器可以提供的格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="e24ef-207">但是，此解碼器可能不會列舉其可接受的所有型別，因此，轉譯器應該提供某些型別，即使該解碼器沒有通告它們也一樣。</span><span class="sxs-lookup"><span data-stu-id="e24ef-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="e24ef-208">如果解碼器可以切換為要求的格式，則會從 [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept)傳回 **S \_ OK** 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="e24ef-209">然後，轉譯器會將新的媒體類型附加至上游配置器上的下一個媒體範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="e24ef-210">若要這樣做，轉譯器必須提供自訂配置器，它會執行私用方法，以將媒體類型附加至下一個範例。</span><span class="sxs-lookup"><span data-stu-id="e24ef-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="e24ef-211"> (在此私用方法中，請呼叫 [**IMediaSample：： SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) 來設定類型。 ) </span><span class="sxs-lookup"><span data-stu-id="e24ef-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="e24ef-212">轉譯器的輸入圖釘應該會在 [**IMemInputPin：： GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) 方法中傳回轉譯器的自訂配置器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="e24ef-213">覆寫 [**IMemInputPin：： NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) ，使上游篩選器不使用轉譯器的配置器時，它就會失敗。</span><span class="sxs-lookup"><span data-stu-id="e24ef-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="e24ef-214">使用某些解碼器時，若將 **biHeight** 設定為正數，則會讓解碼器將影像向下繪製。</span><span class="sxs-lookup"><span data-stu-id="e24ef-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="e24ef-215"> (此項不正確，則應視為解碼器中的 bug。 ) </span><span class="sxs-lookup"><span data-stu-id="e24ef-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="e24ef-216">每當影片轉譯器偵測到格式變更時，它應該會傳送 [**EC \_ 顯示 \_ 變更**](ec-display-changed.md) 的通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="e24ef-217">大部分的影片轉譯器會在連接期間挑選格式，以便透過 GDI 有效率地繪製格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="e24ef-218">如果使用者在不重新開機電腦的情況下變更目前的顯示模式，轉譯器可能會發現本身的影像格式不正確，而且應該傳送此通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="e24ef-219">第一個參數應該是需要重新連接的 pin。</span><span class="sxs-lookup"><span data-stu-id="e24ef-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="e24ef-220">篩選圖形管理員會排列要停止的篩選圖形，以及重新連線的 pin。</span><span class="sxs-lookup"><span data-stu-id="e24ef-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="e24ef-221">在後續的重新連接期間，轉譯器可以接受更適當的格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="e24ef-222">每當影片轉譯器偵測到資料流程中的調色板變更時，就應該將 [EC 選擇區變更] 通知傳送至篩選圖形管理員。 [**\_ \_**](ec-palette-changed.md)</span><span class="sxs-lookup"><span data-stu-id="e24ef-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e24ef-223">DirectShow 影片轉譯器會偵測調色板是否真的變更為動態格式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="e24ef-224">影片轉譯器不只會篩選出已傳送的 EC 小 **\_ 元件 \_ 變更** 通知數目，還能減少所需的調色板建立、安裝和刪除的數量。</span><span class="sxs-lookup"><span data-stu-id="e24ef-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="e24ef-225">最後，影片轉譯器也可以偵測到影片的大小已變更，在這種情況下，它應該會傳送 [**EC \_ 影片 \_ 大小 \_ 變更**](ec-video-size-changed.md) 的通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="e24ef-226">應用程式可能會使用此通知來協商複合檔案中的空間。</span><span class="sxs-lookup"><span data-stu-id="e24ef-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="e24ef-227">實際的影片尺寸可透過 [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) 控制項介面取得。</span><span class="sxs-lookup"><span data-stu-id="e24ef-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="e24ef-228">DirectShow 轉譯器會在傳送這些事件之前，偵測影片的大小是否真的變更。</span><span class="sxs-lookup"><span data-stu-id="e24ef-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="e24ef-229">處理持續性屬性</span><span class="sxs-lookup"><span data-stu-id="e24ef-229">Handling Persistent Properties</span></span>

<span data-ttu-id="e24ef-230">透過 [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) 和 [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) 介面設定的所有屬性都是在連接之間保持一致。</span><span class="sxs-lookup"><span data-stu-id="e24ef-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="e24ef-231">因此，中斷和重新連接轉譯器應該不會對視窗大小、位置或樣式顯示任何影響。</span><span class="sxs-lookup"><span data-stu-id="e24ef-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="e24ef-232">但是，如果影片尺寸在連接之間變更，轉譯器應該將來源和目的地矩形重設為其預設值。</span><span class="sxs-lookup"><span data-stu-id="e24ef-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="e24ef-233">來源和目的地位置是透過 **IBasicVideo** 介面進行設定。</span><span class="sxs-lookup"><span data-stu-id="e24ef-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="e24ef-234">[**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo)和 [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow)都提供足夠的屬性存取權，以允許應用程式以持續格式儲存和還原介面中的所有資料。</span><span class="sxs-lookup"><span data-stu-id="e24ef-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="e24ef-235">當應用程式必須在編輯會話期間儲存篩選圖形的確切設定和屬性，並于稍後還原這些應用程式時，這將會很有用。</span><span class="sxs-lookup"><span data-stu-id="e24ef-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="e24ef-236">處理 EC 重新 \_ 繪製通知</span><span class="sxs-lookup"><span data-stu-id="e24ef-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="e24ef-237">只有當轉譯器暫停或停止時，才會傳送 [**EC 重新 \_ 繪製**](ec-repaint.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="e24ef-238">此通知會向篩選圖形管理員發出轉譯器需要資料的信號。</span><span class="sxs-lookup"><span data-stu-id="e24ef-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="e24ef-239">如果篩選圖形在收到其中一個通知時停止，則會暫停篩選圖形、等候所有篩選器接收資料 (呼叫 [**>getstate**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)) ，然後再將它停止。</span><span class="sxs-lookup"><span data-stu-id="e24ef-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="e24ef-240">停止時，影片轉譯器應該會保留影像，以便可以處理後續的 [**WM \_ 繪製**](/windows/desktop/gdi/wm-paint) 訊息。</span><span class="sxs-lookup"><span data-stu-id="e24ef-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="e24ef-241">因此，如果影片轉譯器在停止或暫停時收到 [**WM \_ 油漆**](/windows/desktop/gdi/wm-paint) 訊息，而且沒有任何用來繪製其視窗的內容，則它應該會將 [**EC 重新 \_ 繪製**](ec-repaint.md) 傳送給篩選圖形管理員。</span><span class="sxs-lookup"><span data-stu-id="e24ef-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="e24ef-242">如果在暫停時收到 **EC 重新 \_ 繪製** 通知，則篩選圖形管理員會以目前的位置呼叫 [**IMediaPosition：:p 的 \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) ， (也就是搜尋目前的位置) 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="e24ef-243">這會導致來源篩選器排清篩選圖形，並讓新的資料透過篩選圖形傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="e24ef-244">轉譯器一次只能傳送這些通知的其中一個。</span><span class="sxs-lookup"><span data-stu-id="e24ef-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="e24ef-245">因此，一旦轉譯器傳送通知，就應該確保在傳遞一些範例之前，不再傳送任何資訊。</span><span class="sxs-lookup"><span data-stu-id="e24ef-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="e24ef-246">傳統的作法是使用旗標來表示可以傳送重繪，這會在系統傳送 [**EC 重新 \_ 繪製**](ec-repaint.md) 通知之後關閉。</span><span class="sxs-lookup"><span data-stu-id="e24ef-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="e24ef-247">此旗標應該在資料傳遞之後，或在輸入釘選時重設，但如果輸入 pin 上有信號結束資料流程，則應該重設。</span><span class="sxs-lookup"><span data-stu-id="e24ef-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="e24ef-248">如果轉譯器不會監視其 [**ec 重新 \_ 繪製**](ec-repaint.md) 通知，則會使用 **EC 重新 \_ 繪製** 要求將篩選圖形管理員大量 (這對處理) 而言相當耗費資源。</span><span class="sxs-lookup"><span data-stu-id="e24ef-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="e24ef-249">例如，如果轉譯器沒有要繪製的影像，而另一個視窗是在整個拖曳作業中拖曳到轉譯器的整個視窗，轉譯器會接收多個 [**WM \_ 繪製**](/windows/desktop/gdi/wm-paint) 訊息。</span><span class="sxs-lookup"><span data-stu-id="e24ef-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="e24ef-250">只有第一個會從轉譯器產生方格重新 **\_ 繪製** 事件通知至篩選圖形管理員。</span><span class="sxs-lookup"><span data-stu-id="e24ef-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="e24ef-251">轉譯器應該將其輸入的 pin 當作第一個參數傳送給 [**EC 重新 \_ 繪製**](ec-repaint.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="e24ef-252">如此一來，就會查詢附加的輸出圖釘以進行 [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)，並在支援時，先將 **EC 重新 \_ 繪製** 通知傳送至該處。</span><span class="sxs-lookup"><span data-stu-id="e24ef-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="e24ef-253">這可讓輸出圖釘在必須接觸篩選圖形之前處理重繪。</span><span class="sxs-lookup"><span data-stu-id="e24ef-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="e24ef-254">如果篩選圖形已停止，則不會執行此操作，因為已取消認可轉譯器配置器不會提供任何緩衝區。</span><span class="sxs-lookup"><span data-stu-id="e24ef-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="e24ef-255">如果輸出 pin 無法處理要求，且篩選圖形正在執行，則會忽略 [**EC 重新 \_ 繪製**](ec-repaint.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="e24ef-256">輸出 pin 必須從 [**IMediaEventSink：： Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify)傳回 **S \_ OK** ，表示它已成功處理重新繪製要求。</span><span class="sxs-lookup"><span data-stu-id="e24ef-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="e24ef-257">輸出圖釘將會在篩選圖形管理員背景工作執行緒上呼叫，以避免轉譯器直接呼叫輸出釘選，因此 >iaas 可避開任何鎖死問題。</span><span class="sxs-lookup"><span data-stu-id="e24ef-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="e24ef-258">如果篩選圖形已停止或暫停，而且輸出不會處理要求，則會完成預設處理。</span><span class="sxs-lookup"><span data-stu-id="e24ef-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="e24ef-259">在 Full-Screen 模式中處理通知</span><span class="sxs-lookup"><span data-stu-id="e24ef-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="e24ef-260">[**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow)外掛程式散發者 (PID) 在篩選圖形中管理全螢幕播放。</span><span class="sxs-lookup"><span data-stu-id="e24ef-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="e24ef-261">它會針對專家的全螢幕轉譯器交換影片轉譯器、將轉譯器的視窗延展至全螢幕，或讓轉譯器直接執行全螢幕播放。</span><span class="sxs-lookup"><span data-stu-id="e24ef-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="e24ef-262">若要在全螢幕通訊協定中互動，影片轉譯器應在每次啟用或停用它的視窗時傳送 [**EC \_ 啟動**](ec-activate.md) 通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="e24ef-263">換句話說，系統應該會針對轉譯器收到的每個 WM ACTI加值稅EAPP 訊息傳送 **EC \_ 啟動** 通知 \_ 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="e24ef-264">在全螢幕模式中使用轉譯器時，這些通知會管理切換進入和離開該全螢幕模式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="e24ef-265">視窗停用通常是在使用者按下 ALT + TAB 切換到另一個視窗時發生，而 DirectShow 全螢幕轉譯器會使用它做為提示以返回一般轉譯模式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="e24ef-266">當您在切換離開全螢幕模式時，將 [**ec \_ 啟動**](ec-activate.md) 通知傳送至篩選圖形管理員時，篩選圖形管理員會將 [**ec \_ 全螢幕 \_ 遺失**](ec-fullscreen-lost.md) 通知傳送至控制應用程式。</span><span class="sxs-lookup"><span data-stu-id="e24ef-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="e24ef-267">例如，應用程式可能會使用此通知來還原全螢幕按鈕的狀態。</span><span class="sxs-lookup"><span data-stu-id="e24ef-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="e24ef-268">由 DirectShow 在內部使用 **EC \_ 啟動** 通知，以管理從影片轉譯器提示的全螢幕切換。</span><span class="sxs-lookup"><span data-stu-id="e24ef-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="e24ef-269">通知摘要</span><span class="sxs-lookup"><span data-stu-id="e24ef-269">Summary of Notifications</span></span>

<span data-ttu-id="e24ef-270">此區段會列出轉譯器可以傳送的篩選圖形通知。</span><span class="sxs-lookup"><span data-stu-id="e24ef-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="e24ef-271">事件通知</span><span class="sxs-lookup"><span data-stu-id="e24ef-271">Event notification</span></span>                                        | <span data-ttu-id="e24ef-272">Description</span><span class="sxs-lookup"><span data-stu-id="e24ef-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="e24ef-273">**EC \_ 啟用**</span><span class="sxs-lookup"><span data-stu-id="e24ef-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="e24ef-274">由影片轉譯器針對每個所接收的 WM ACTI加值稅EAPP 訊息，以全螢幕轉譯模式傳送 \_ 。</span><span class="sxs-lookup"><span data-stu-id="e24ef-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="e24ef-275">**EC \_ 完成**</span><span class="sxs-lookup"><span data-stu-id="e24ef-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="e24ef-276">在轉譯所有資料之後，由轉譯器傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="e24ef-277">**EC \_ 顯示 \_ 已變更**</span><span class="sxs-lookup"><span data-stu-id="e24ef-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="e24ef-278">顯示格式變更時由影片轉譯器傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="e24ef-279">**\_ \_ 已變更 EC 元件**</span><span class="sxs-lookup"><span data-stu-id="e24ef-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="e24ef-280">每當影片轉譯器偵測到資料流程中的調色板變更時傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="e24ef-281">**EC 重新 \_ 繪製**</span><span class="sxs-lookup"><span data-stu-id="e24ef-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="e24ef-282">當 \_ 收到 WM 油漆訊息且沒有可顯示的資料時，由已停止或暫停的影片轉譯器傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="e24ef-283">這會導致篩選圖形管理員產生要繪製至顯示器的框架。</span><span class="sxs-lookup"><span data-stu-id="e24ef-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="e24ef-284">**EC \_ USERABORT**</span><span class="sxs-lookup"><span data-stu-id="e24ef-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="e24ef-285">由影片轉譯器傳送以表示使用者要求的關閉 (例如，關閉影片視窗) 的使用者。</span><span class="sxs-lookup"><span data-stu-id="e24ef-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="e24ef-286">**EC \_ 影片 \_ 大小 \_ 已變更**</span><span class="sxs-lookup"><span data-stu-id="e24ef-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="e24ef-287">每當偵測到原生影片大小變更時，由影片轉譯器傳送。</span><span class="sxs-lookup"><span data-stu-id="e24ef-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="e24ef-288">**EC \_ 視窗已 \_ 損毀**</span><span class="sxs-lookup"><span data-stu-id="e24ef-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="e24ef-289">在移除或終結篩選時由影片轉譯器傳送，讓相依于視窗焦點的資源可以傳遞給其他篩選器。</span><span class="sxs-lookup"><span data-stu-id="e24ef-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="e24ef-290">相關主題</span><span class="sxs-lookup"><span data-stu-id="e24ef-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e24ef-291">撰寫影片轉譯器</span><span class="sxs-lookup"><span data-stu-id="e24ef-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
