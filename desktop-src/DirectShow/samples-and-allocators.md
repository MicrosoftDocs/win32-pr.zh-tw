---
description: 範例和配置器
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: 範例和配置器
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "104557401"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="89c60-103">範例和配置器</span><span class="sxs-lookup"><span data-stu-id="89c60-103">Samples and Allocators</span></span>

<span data-ttu-id="89c60-104">當 pin 將媒體資料傳遞給另一個 pin 時，不會將直接指標傳遞至記憶體緩衝區。</span><span class="sxs-lookup"><span data-stu-id="89c60-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="89c60-105">相反地，它會將指標傳遞至管理記憶體的 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="89c60-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="89c60-106">這個物件稱為 *媒體範例*，會公開 [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) 介面。</span><span class="sxs-lookup"><span data-stu-id="89c60-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="89c60-107">接收的 pin 會藉由呼叫 **IMediaSample** 方法（例如 [**IMediaSample：： GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer)、 [**IMediaSample：： GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)和 [**IMediaSample：： GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength)）來存取記憶體緩衝區。</span><span class="sxs-lookup"><span data-stu-id="89c60-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="89c60-108">範例一律會從輸出釘選到輸入 pin，以下游傳送。</span><span class="sxs-lookup"><span data-stu-id="89c60-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="89c60-109">在推送模型中，輸出 pin 會在輸入 pin 上呼叫 [**IMemInputPin：： Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) 來傳遞範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="89c60-110">輸入 pin 將會同步處理資料 (也就是完全在 **Receive** 方法) 內，或是在工作者執行緒上以非同步方式處理。</span><span class="sxs-lookup"><span data-stu-id="89c60-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="89c60-111">如果需要等候資源，就可以在 **Receive** 方法內封鎖輸入 pin。</span><span class="sxs-lookup"><span data-stu-id="89c60-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="89c60-112">另一個 COM 物件稱為配置 *器，負責* 建立和管理媒體範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="89c60-113">配置器會公開 [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) 介面。</span><span class="sxs-lookup"><span data-stu-id="89c60-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="89c60-114">每當篩選準則需要具有空緩衝區的媒體範例時，它會呼叫 [**IMemAllocator：： GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) 方法，以傳回範例的指標。</span><span class="sxs-lookup"><span data-stu-id="89c60-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="89c60-115">每個 pin 連接都會共用一個配置器。</span><span class="sxs-lookup"><span data-stu-id="89c60-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="89c60-116">當兩個 pin 連線時，它們會決定要提供配置器的篩選器。</span><span class="sxs-lookup"><span data-stu-id="89c60-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="89c60-117">釘選也會在配置器上設定屬性，例如緩衝區數目和每個緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="89c60-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="89c60-118"> (需詳細資訊，請參閱 [篩選連接](how-filters-connect.md) 和 [協商配置器](negotiating-allocators.md)。 ) </span><span class="sxs-lookup"><span data-stu-id="89c60-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="89c60-119">下圖顯示配置器、媒體範例和篩選器之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="89c60-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![媒體範例和配置器](images/mediasamples.png)

<span data-ttu-id="89c60-121">**媒體範例參考計數**</span><span class="sxs-lookup"><span data-stu-id="89c60-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="89c60-122">配置器會建立有限的範例集區。</span><span class="sxs-lookup"><span data-stu-id="89c60-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="89c60-123">在任何時候，有些範例可能會在使用中，而其他範例則適用于 **GetBuffer** 呼叫。</span><span class="sxs-lookup"><span data-stu-id="89c60-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="89c60-124">配置器會使用參考計數來追蹤範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="89c60-125">**GetBuffer** 方法會傳回參考計數為1的範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="89c60-126">如果參考計數變成零，此範例會回到配置器的集區，以便在下一個 **GetBuffer** 呼叫中使用。</span><span class="sxs-lookup"><span data-stu-id="89c60-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="89c60-127">只要參考計數維持在零的上方，就無法使用 **GetBuffer** 的範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="89c60-128">如果正在使用屬於配置器的每個範例， **GetBuffer** 方法會封鎖，直到範例變成可用為止。</span><span class="sxs-lookup"><span data-stu-id="89c60-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="89c60-129">例如，假設輸入 pin 會收到範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="89c60-130">如果它是以同步方式處理範例，則在 **Receive** 方法內，它不會遞增參考計數。</span><span class="sxs-lookup"><span data-stu-id="89c60-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="89c60-131">在 **接收** 傳回之後，輸出圖釘會釋出範例，參考計數會變成零，而範例則會返回配置器的集區。</span><span class="sxs-lookup"><span data-stu-id="89c60-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="89c60-132">另一方面，如果輸入 pin 在背景工作執行緒上處理此範例，則會在離開 **Receive** 方法之前遞增參考計數。</span><span class="sxs-lookup"><span data-stu-id="89c60-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="89c60-133">參考計數現在是2。</span><span class="sxs-lookup"><span data-stu-id="89c60-133">The reference count is now 2.</span></span> <span data-ttu-id="89c60-134">當輸出針腳釋出範例時，計數會變成 1;此範例尚未返回集區。</span><span class="sxs-lookup"><span data-stu-id="89c60-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="89c60-135">使用範例完成背景工作執行緒之後，它會呼叫 **Release** 來釋放範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="89c60-136">現在，此範例會回到集區。</span><span class="sxs-lookup"><span data-stu-id="89c60-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="89c60-137">當 pin 收到範例時，它可以將資料複製到另一個範例，也可以修改原始範例，並將該範例傳遞給下一個篩選準則。</span><span class="sxs-lookup"><span data-stu-id="89c60-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="89c60-138">範例可能會移動整個圖形的長度，每個篩選器會依序呼叫 **AddRef** 和 **放開** 。</span><span class="sxs-lookup"><span data-stu-id="89c60-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="89c60-139">因此，在呼叫 **Receive** 之後，輸出 pin 絕對不能重複使用範例，因為下游篩選可能會使用此範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="89c60-140">輸出 pin 必須一律呼叫 **GetBuffer** 以取得新的範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="89c60-141">這項機制可減少記憶體配置的數量，因為篩選器會重複使用相同的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="89c60-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="89c60-142">它也會防止篩選不小心寫入尚未處理的資料，因為配置器會維護可用範例的清單。</span><span class="sxs-lookup"><span data-stu-id="89c60-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="89c60-143">篩選可以針對輸入和輸出使用不同的配置器。</span><span class="sxs-lookup"><span data-stu-id="89c60-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="89c60-144">如果展開輸入資料 (例如，將其解壓縮) ，它可能會這麼做。</span><span class="sxs-lookup"><span data-stu-id="89c60-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="89c60-145">如果輸出不大於輸入，篩選器可能會就地處理資料，而不會將它複製到新的範例。</span><span class="sxs-lookup"><span data-stu-id="89c60-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="89c60-146">在此情況下，兩個或多個 pin 連線可以共用一個配置器。</span><span class="sxs-lookup"><span data-stu-id="89c60-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="89c60-147">**認可和 Decommitting 配置器**</span><span class="sxs-lookup"><span data-stu-id="89c60-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="89c60-148">當篩選器第一次建立配置器時，配置器尚未保留任何記憶體緩衝區。</span><span class="sxs-lookup"><span data-stu-id="89c60-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="89c60-149">此時，對 **GetBuffer** 方法的任何呼叫都將會失敗。</span><span class="sxs-lookup"><span data-stu-id="89c60-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="89c60-150">串流處理開始時，輸出圖釘會呼叫 [**IMemAllocator：： Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit)，它會認可配置器，使其配置記憶體。</span><span class="sxs-lookup"><span data-stu-id="89c60-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="89c60-151">Pin 現在可呼叫 **GetBuffer**。</span><span class="sxs-lookup"><span data-stu-id="89c60-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="89c60-152">當串流停止時，pin 會呼叫 [**IMemAllocator：:D ecommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit)，以解除配置器。</span><span class="sxs-lookup"><span data-stu-id="89c60-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="89c60-153">對 **GetBuffer** 的所有後續呼叫都會失敗，直到重新認可配置器為止。</span><span class="sxs-lookup"><span data-stu-id="89c60-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="89c60-154">此外，如果對 **GetBuffer** 的任何呼叫目前封鎖等候範例，則會立即傳回失敗碼。</span><span class="sxs-lookup"><span data-stu-id="89c60-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="89c60-155">**取消認可** 方法不一定會釋出記憶體，視執行而定。</span><span class="sxs-lookup"><span data-stu-id="89c60-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="89c60-156">例如， [**CMemAllocator**](cmemallocator.md) 類別會等待其「函式」方法釋放記憶體。</span><span class="sxs-lookup"><span data-stu-id="89c60-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="89c60-157">相關主題</span><span class="sxs-lookup"><span data-stu-id="89c60-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="89c60-158">篩選圖形中的資料流程</span><span class="sxs-lookup"><span data-stu-id="89c60-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
