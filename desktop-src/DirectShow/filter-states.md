---
description: 篩選狀態
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: 篩選狀態
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "106972315"
---
# <a name="filter-states"></a><span data-ttu-id="e7dd5-103">篩選狀態</span><span class="sxs-lookup"><span data-stu-id="e7dd5-103">Filter States</span></span>

<span data-ttu-id="e7dd5-104">篩選器有三種可能的狀態：已停止、已暫停且正在執行。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="e7dd5-105">暫停狀態的目的是在圖形中提示資料，讓 run 命令立即回應。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="e7dd5-106">篩選圖形管理員會控制所有狀態轉換。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="e7dd5-107">當應用程式呼叫 [**IMediaControl：： Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run)、 [**IMediaControl：:P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)或 [**IMediaControl：： Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop)時，篩選圖形管理員會在所有篩選準則上呼叫對應的 [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) 方法。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="e7dd5-108">[已停止] 和 [執行] 之間的轉換一律會通過暫停狀態，因此，如果應用程式呼叫在停止的圖形上執行，則篩選圖形管理員會在 **執行** 它之前先暫停圖形。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="e7dd5-109">在大部分的篩選準則下，執行中和暫停狀態都相同。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="e7dd5-110">請考慮下列篩選圖形：</span><span class="sxs-lookup"><span data-stu-id="e7dd5-110">Consider the following filter graph:</span></span>

<span data-ttu-id="e7dd5-111">來源 > 轉換 > 轉譯器</span><span class="sxs-lookup"><span data-stu-id="e7dd5-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="e7dd5-112">現在假設來源篩選準則不是即時的捕獲來源。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="e7dd5-113">當來源篩選暫停時，它會建立一個執行緒，以產生新的資料並儘快將其寫入媒體範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="e7dd5-114">執行緒會在轉換篩選的輸入釘上呼叫 [**IMemInputPin：： Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ，藉以「推送」這些樣本。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="e7dd5-115">轉換篩選器會接收來源篩選準則的執行緒上的範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="e7dd5-116">它可能會使用背景工作執行緒將範例傳遞給轉譯器，但通常會在相同的執行緒上傳遞這些範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="e7dd5-117">當轉譯器暫停時，它會等候接收範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="e7dd5-118">收到一個之後，它會無限期地封鎖並保存該範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="e7dd5-119">如果是影片轉譯器，它會將範例顯示為海報影像，並視需要重新繪製影像。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="e7dd5-120">此時，資料流程已完全 cued 且可供轉譯。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="e7dd5-121">如果圖形維持暫停，範例會在第一個範例後方的圖形中「堆積」，直到每個篩選準則在 [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) 或 [**IMemAllocator：： GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)中封鎖為止。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="e7dd5-122">但是，不會遺失任何資料。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-122">No data is lost, though.</span></span> <span data-ttu-id="e7dd5-123">解除封鎖來源執行緒之後，它就會從它封鎖的點繼續進行。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="e7dd5-124">來源篩選和轉換篩選會忽略從暫停轉換成執行中的轉換，它們只是盡可能快速地處理資料。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="e7dd5-125">但是，當轉譯器執行時，它會啟動轉譯範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="e7dd5-126">首先，它會轉譯它暫停時所持有的範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="e7dd5-127">然後，每次收到新的範例時，它會計算樣本的呈現時間。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="e7dd5-128"> (需詳細資訊，請參閱 [DirectShow 中的時間和時鐘](time-and-clocks-in-directshow.md)。 ) 轉譯器會保存每個範例直到呈現時間，此時會轉譯範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="e7dd5-129">當它等候呈現時間時，它會在 [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) 方法中封鎖，或在具有佇列的背景工作執行緒上接收新的範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="e7dd5-130">從轉譯器進行上游篩選不牽涉到排程。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="e7dd5-131">即時來源（例如「捕獲裝置」）是此一般架構的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="e7dd5-132">使用即時來源時，不適合事先提示所有資料。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="e7dd5-133">應用程式可能會暫停圖形，然後在執行之前等候很長的時間。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="e7dd5-134">圖形不應該呈現「過時」範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="e7dd5-135">因此，在執行時，即時來源不會在暫停的情況下產生樣本。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="e7dd5-136">若要對篩選圖形管理員發出此事實的通知，來源篩選的 [**IMediaFilter：： >getstate**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) 方法會傳回 VFW \_ s 無法 \_ \_ 提示。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="e7dd5-137">這個傳回碼表示篩選已經切換到暫停的狀態，即使轉譯器並未接收任何資料。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="e7dd5-138">當篩選準則停止時，它會拒絕其他傳遞給它的範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="e7dd5-139">來源篩選器會關閉串流執行緒，而其他篩選器會關閉任何可能已建立的背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="e7dd5-140">Pin 取消認可其配置器。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="e7dd5-141">狀態轉換</span><span class="sxs-lookup"><span data-stu-id="e7dd5-141">State Transitions</span></span>

<span data-ttu-id="e7dd5-142">篩選圖形管理員會以上游循序執行所有狀態轉換，從轉譯器開始，再回到來源篩選。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="e7dd5-143">這是為了避免卸載樣本，以及防止圖形死結的必要順序。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="e7dd5-144">最重要的狀態轉換介於暫停和停止之間：</span><span class="sxs-lookup"><span data-stu-id="e7dd5-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="e7dd5-145">停止暫停：當每個篩選準則暫停時，就可以開始從下一個篩選器接收樣本。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="e7dd5-146">來源篩選是最後一個要暫停的。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-146">The source filter is the last to pause.</span></span> <span data-ttu-id="e7dd5-147">它會建立串流執行緒，並開始傳遞範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="e7dd5-148">由於所有下游篩選都已暫停，因此沒有任何篩選器會拒絕任何範例。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="e7dd5-149">篩選圖形管理員不會完成轉換，直到圖形中的每個轉譯器收到範例 (但有例外的即時來源，如先前的) 所述。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="e7dd5-150">暫停至已停止：當篩選準則停止時，它會釋出它所保留的任何範例，以解除封鎖任何在 [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)中等候的上游篩選。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="e7dd5-151">如果篩選準則正在等候 [**receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) 方法內的資源，它會停止等待並從 **接收** 傳回，這會解除封鎖呼叫的篩選。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="e7dd5-152">因此，當篩選圖形管理員停止下一個上游篩選器時，不會在 **GetBuffer** 或 **Receive** 中封鎖該篩選，而且可以回應停止命令。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="e7dd5-153">上游篩選器可能會在取得停止命令之前提供一些額外的範例，但下游篩選器只會拒絕它們，因為它已停止。</span><span class="sxs-lookup"><span data-stu-id="e7dd5-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e7dd5-154">相關主題</span><span class="sxs-lookup"><span data-stu-id="e7dd5-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e7dd5-155">篩選圖形中的資料流程</span><span class="sxs-lookup"><span data-stu-id="e7dd5-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



