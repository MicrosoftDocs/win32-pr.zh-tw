---
description: 串流和應用程式執行緒
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: 串流和應用程式執行緒
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 432e613ff0322377c042e796d84ef7affdda99c2
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104514157"
---
# <a name="the-streaming-and-application-threads"></a><span data-ttu-id="77645-103">串流和應用程式執行緒</span><span class="sxs-lookup"><span data-stu-id="77645-103">The Streaming and Application Threads</span></span>

<span data-ttu-id="77645-104">任何 DirectShow 應用程式都包含至少兩個重要的執行緒：應用程式執行緒，以及一或多個串流執行緒。</span><span class="sxs-lookup"><span data-stu-id="77645-104">Any DirectShow application contains at least two important threads: the application thread, and one or more streaming threads.</span></span> <span data-ttu-id="77645-105">範例會在串流處理執行緒上傳遞，並在應用程式執行緒上發生狀態變更。</span><span class="sxs-lookup"><span data-stu-id="77645-105">Samples are delivered on the streaming threads, and state changes happen on the application thread.</span></span> <span data-ttu-id="77645-106">主要串流執行緒是由來源或剖析器篩選器所建立。</span><span class="sxs-lookup"><span data-stu-id="77645-106">The main streaming thread is created by a source or parser filter.</span></span> <span data-ttu-id="77645-107">其他篩選器可能會建立傳遞範例的背景工作執行緒，而這些執行緒也會被視為串流執行緒。</span><span class="sxs-lookup"><span data-stu-id="77645-107">Other filters might create worker threads that deliver samples, and these are considered streaming threads as well.</span></span>

<span data-ttu-id="77645-108">某些方法會在應用程式執行緒上呼叫，而其他方法則是在串流執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="77645-108">Some methods are called on the application thread, while others are called on a streaming thread.</span></span> <span data-ttu-id="77645-109">例如：</span><span class="sxs-lookup"><span data-stu-id="77645-109">For example:</span></span>

-   <span data-ttu-id="77645-110">串流執行緒 (s) ： [**IMemInputPin：： Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive)、 [**IMemInputPin：： ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple)、 [**IPin：： EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream)、 [**IMemAllocator：： GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer)。</span><span class="sxs-lookup"><span data-stu-id="77645-110">Streaming thread(s): [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span>
-   <span data-ttu-id="77645-111">應用程式執行緒： [**IMediaFilter：:P ause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause)、 [**IMediaFilter：： Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run)、 [**IMediaFilter：： Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop)、 [**IMediaSeeking：： SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions)、 [**IPin：： BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)、 [**IPin：： EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush)。</span><span class="sxs-lookup"><span data-stu-id="77645-111">Application thread: [**IMediaFilter::Pause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter::Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter::Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking::SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span>
-   <span data-ttu-id="77645-112">可能是： [**IPin：： NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment)。</span><span class="sxs-lookup"><span data-stu-id="77645-112">Either: [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span></span>

<span data-ttu-id="77645-113">擁有個別的串流執行緒可讓資料在應用程式執行緒等候使用者輸入時流經圖形。</span><span class="sxs-lookup"><span data-stu-id="77645-113">Having a separate streaming thread allows data to flow through the graph while the application thread waits for user input.</span></span> <span data-ttu-id="77645-114">不過，多個執行緒的風險是，當篩選暫停應用程式執行緒上的 (時，可能會建立資源) 、在串流方法內使用它們，並在停止 (應用程式執行緒) 時終結它們。</span><span class="sxs-lookup"><span data-stu-id="77645-114">The danger of multiple threads, however, is that a filter may create resources when it pauses (on the application thread), use them inside a streaming method, and destroy them when it stops (also on the application thread).</span></span> <span data-ttu-id="77645-115">如果您不小心，串流執行緒可能會在終結之後嘗試使用這些資源。</span><span class="sxs-lookup"><span data-stu-id="77645-115">If you are not careful, the streaming thread might try to use the resources after they are destroyed.</span></span> <span data-ttu-id="77645-116">解決方法是使用重要區段來保護資源，並同步處理具有狀態變更的串流方法。</span><span class="sxs-lookup"><span data-stu-id="77645-116">The solution is to protect resources using critical sections, and synchronize streaming methods with state changes.</span></span>

<span data-ttu-id="77645-117">篩選準則需要一個重要區段來保護篩選狀態。</span><span class="sxs-lookup"><span data-stu-id="77645-117">A filter needs one critical section to protect the filter state.</span></span> <span data-ttu-id="77645-118">[**CBaseFilter**](cbasefilter.md)類別具有這個重要區段的成員變數， [**CBaseFilter：： m \_ pLock**](cbasefilter-m-plock.md)。</span><span class="sxs-lookup"><span data-stu-id="77645-118">The [**CBaseFilter**](cbasefilter.md) class has a member variable for this critical section, [**CBaseFilter::m\_pLock**](cbasefilter-m-plock.md).</span></span> <span data-ttu-id="77645-119">此重要區段稱為篩選鎖定。</span><span class="sxs-lookup"><span data-stu-id="77645-119">This critical section is called the filter lock.</span></span> <span data-ttu-id="77645-120">此外，每個輸入 pin 都需要重要的區段，以保護串流執行緒所使用的資源。</span><span class="sxs-lookup"><span data-stu-id="77645-120">Also, each input pin needs a critical section to protect resources used by the streaming thread.</span></span> <span data-ttu-id="77645-121">這些重要區段稱為串流鎖定;您必須在衍生的 pin 類別中宣告它們。</span><span class="sxs-lookup"><span data-stu-id="77645-121">These critical sections are called streaming locks; you must declare them in your derived pin class.</span></span> <span data-ttu-id="77645-122">最簡單的方法是使用 [**CCritSec**](ccritsec.md) 類別，此類別會包裝 Windows **重要 \_ 區段** 物件，並可使用 [**CAutoLock**](cautolock.md) 類別來鎖定。</span><span class="sxs-lookup"><span data-stu-id="77645-122">It is easiest to use the [**CCritSec**](ccritsec.md) class, which wraps a Windows **CRITICAL\_SECTION** object and can be locked using the [**CAutoLock**](cautolock.md) class.</span></span> <span data-ttu-id="77645-123">**CCritSec** 類別也會提供一些實用的調試函數。</span><span class="sxs-lookup"><span data-stu-id="77645-123">The **CCritSec** class also provides some useful debugging functions.</span></span> <span data-ttu-id="77645-124">如需詳細資訊，請參閱 [重要區段的調試](critical-section-debugging-functions.md)程式。</span><span class="sxs-lookup"><span data-stu-id="77645-124">For more information, see [Critical Section Debugging Functions](critical-section-debugging-functions.md).</span></span>

<span data-ttu-id="77645-125">當篩選準則停止或清除時，它必須與串流執行緒同步處理應用程式執行緒。</span><span class="sxs-lookup"><span data-stu-id="77645-125">When a filter stops or flushes, it must synchronize the application thread with the streaming thread.</span></span> <span data-ttu-id="77645-126">為了避免死結，它必須先解除封鎖串流執行緒，這可能是因為下列幾個原因所造成：</span><span class="sxs-lookup"><span data-stu-id="77645-126">To avoid deadlocking, it must first unblock the streaming thread, which might be blocked for several reasons:</span></span>

-   <span data-ttu-id="77645-127">它正在等候取得 [**IMemAllocator：： GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) 方法內的範例，因為配置器的所有範例都在使用中。</span><span class="sxs-lookup"><span data-stu-id="77645-127">It is waiting to get a sample inside the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, because all of the allocator's samples are in use.</span></span>
-   <span data-ttu-id="77645-128">正在等候另一個篩選器從串流方法傳回，例如 **Receive**。</span><span class="sxs-lookup"><span data-stu-id="77645-128">It is waiting for another filter to return from a streaming method, such as **Receive**.</span></span>
-   <span data-ttu-id="77645-129">它正在等候其中一個串流方法，讓某些資源變成可用。</span><span class="sxs-lookup"><span data-stu-id="77645-129">It is waiting inside one of its own streaming methods, for some resource to become available.</span></span>
-   <span data-ttu-id="77645-130">它是等候下一個範例呈現時間的轉譯器篩選器</span><span class="sxs-lookup"><span data-stu-id="77645-130">It is a renderer filter waiting for the presentation time of the next sample</span></span>
-   <span data-ttu-id="77645-131">它是在暫停時，于 **接收** 方法內等候的轉譯器篩選準則。</span><span class="sxs-lookup"><span data-stu-id="77645-131">It is a renderer filter waiting inside the **Receive** method while paused.</span></span>

<span data-ttu-id="77645-132">因此，當篩選準則停止或排清時，必須執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="77645-132">Therefore, when the filter stops or flushes, it must do the following:</span></span>

-   <span data-ttu-id="77645-133">釋放任何因任何原因而保留的範例。</span><span class="sxs-lookup"><span data-stu-id="77645-133">Release any sample it is holding for any reason.</span></span> <span data-ttu-id="77645-134">這樣做會解除封鎖 **GetBuffer** 方法。</span><span class="sxs-lookup"><span data-stu-id="77645-134">Doing so unblocks the **GetBuffer** method.</span></span>
-   <span data-ttu-id="77645-135">儘快從任何串流方法返回。</span><span class="sxs-lookup"><span data-stu-id="77645-135">Return from any streaming method as quickly as possible.</span></span> <span data-ttu-id="77645-136">如果串流方法正在等候資源，它必須立即停止等候。</span><span class="sxs-lookup"><span data-stu-id="77645-136">If a streaming method is waiting for a resource, it must stop waiting immediately.</span></span>
-   <span data-ttu-id="77645-137">開始拒絕 **接收** 中的範例，讓串流執行緒不會存取其他資源。</span><span class="sxs-lookup"><span data-stu-id="77645-137">Start rejecting samples in **Receive**, so that the streaming thread does not access any more resources.</span></span> <span data-ttu-id="77645-138"> ([**CBaseInputPin**](cbaseinputpin.md) 類別會自動處理這種情況。 ) </span><span class="sxs-lookup"><span data-stu-id="77645-138">(The [**CBaseInputPin**](cbaseinputpin.md) class handles this automatically.)</span></span>
-   <span data-ttu-id="77645-139">**Stop** 方法必須取消認可所有篩選準則的配置器。</span><span class="sxs-lookup"><span data-stu-id="77645-139">The **Stop** method must decommit all of the filter's allocators.</span></span> <span data-ttu-id="77645-140"> (**CBaseInputPin** 類別會自動處理這種情況。 ) </span><span class="sxs-lookup"><span data-stu-id="77645-140">(The **CBaseInputPin** class handles this automatically.)</span></span>

<span data-ttu-id="77645-141">清除和停止兩者都會在應用程式執行緒上發生。</span><span class="sxs-lookup"><span data-stu-id="77645-141">Flushing and stopping both happen on the application thread.</span></span> <span data-ttu-id="77645-142">篩選準則會停止，以回應 [**IMediaControl：： Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) 方法。</span><span class="sxs-lookup"><span data-stu-id="77645-142">A filter stops in response to the [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) method.</span></span> <span data-ttu-id="77645-143">篩選圖形管理員會以上游順序發出 stop 命令，從轉譯器開始，然後回溯至來源篩選器。</span><span class="sxs-lookup"><span data-stu-id="77645-143">The Filter Graph Manager issues the stop command in upstream order, starting from the renderers and working backward to the source filters.</span></span> <span data-ttu-id="77645-144">Stop 命令會完全在篩選器的 **CBaseFilter：： stop** 方法內執行。</span><span class="sxs-lookup"><span data-stu-id="77645-144">The stop command happens completely inside the filter's **CBaseFilter::Stop** method.</span></span> <span data-ttu-id="77645-145">當方法傳回時，篩選準則應該會處於已停止狀態。</span><span class="sxs-lookup"><span data-stu-id="77645-145">When the method returns, the filter should be in a stopped state.</span></span>

<span data-ttu-id="77645-146">通常會因為搜尋命令而發生排清。</span><span class="sxs-lookup"><span data-stu-id="77645-146">Flushing typically occurs because of a seek command.</span></span> <span data-ttu-id="77645-147">Flush 命令會從來源或剖析器篩選開始，然後傳輸下游。</span><span class="sxs-lookup"><span data-stu-id="77645-147">A flush command starts from the source or parser filter, and travels downstream.</span></span> <span data-ttu-id="77645-148">清除會以兩個階段進行： [**IPin：： BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) 方法會通知篩選器捨棄所有暫止和傳入的資料; [**IPin：： EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) 方法表示篩選準則會再次接受資料。</span><span class="sxs-lookup"><span data-stu-id="77645-148">Flushing happens in two stages: The [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) method informs a filter to discard all pending and incoming data; the [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) method signals the filter to accept data again.</span></span> <span data-ttu-id="77645-149">排清需要兩個階段，因為 **BeginFlush** 呼叫是在應用程式執行緒上，在這段期間，串流執行緒會繼續傳遞資料。</span><span class="sxs-lookup"><span data-stu-id="77645-149">Flushing requires two stages because the **BeginFlush** call is on the application thread, during which the streaming thread continues to deliver data.</span></span> <span data-ttu-id="77645-150">因此，某些範例可能會在 **BeginFlush** 呼叫之後抵達。</span><span class="sxs-lookup"><span data-stu-id="77645-150">Therefore, some samples may arrive after the **BeginFlush** call.</span></span> <span data-ttu-id="77645-151">篩選應捨棄這些。</span><span class="sxs-lookup"><span data-stu-id="77645-151">The filter should discard these.</span></span> <span data-ttu-id="77645-152">在 **EndFlush** 呼叫之後抵達的任何範例保證都是新的，而且應該傳遞。</span><span class="sxs-lookup"><span data-stu-id="77645-152">Any samples that arrive after the **EndFlush** call are guaranteed to be new, and should be delivered.</span></span>

<span data-ttu-id="77645-153">接下來的章節包含程式碼範例，示範如何以避免鎖死和競爭條件的方式來執行最重要的篩選方法，例如 **暫停**、 **接收** 等等。</span><span class="sxs-lookup"><span data-stu-id="77645-153">The sections that follow contain code samples showing how to implement the most important filter methods, such as **Pause**, **Receive**, and so forth, in ways that avoid deadlocks and race conditions.</span></span> <span data-ttu-id="77645-154">不過，每個篩選準則都有不同的需求，因此您必須將這些範例調整成特定的篩選準則。</span><span class="sxs-lookup"><span data-stu-id="77645-154">Every filter has different requirements, however, so you will need to adapt these examples to your particular filter.</span></span>

> [!Note]  
> <span data-ttu-id="77645-155">[**CTransformFilter**](ctransformfilter.md)和 [**CTransInPlaceFilter**](ctransinplacefilter.md)基類會處理本文中所述的許多問題。</span><span class="sxs-lookup"><span data-stu-id="77645-155">The [**CTransformFilter**](ctransformfilter.md) and [**CTransInPlaceFilter**](ctransinplacefilter.md) base classes handle many of the issues described in this article.</span></span> <span data-ttu-id="77645-156">如果您要撰寫轉換篩選，而且您的篩選不會等候串流方法內的事件，或在 **接收** 之外保留樣本，則這些基類應該就已足夠。</span><span class="sxs-lookup"><span data-stu-id="77645-156">If you are writing a transform filter, and your filter does not wait on events inside a streaming method, or hold onto samples outside of **Receive**, then these base classes should be sufficient.</span></span>

 

 

 



