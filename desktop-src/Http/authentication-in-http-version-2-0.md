---
title: '驗證 (HTTP 伺服器 API) '
description: 從2.0 版開始，HTTP 伺服器 API 會執行應用程式的伺服器端驗證。
ms.assetid: e8e41e8e-1b10-4747-b18e-763e0752ade4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 16d523df90861c83a45f67811edad243ceee5165
ms.sourcegitcommit: 8fa6614b715bddf14648cce36d2df22e5232801a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2020
ms.locfileid: "104383642"
---
# <a name="authentication-http-server-api"></a><span data-ttu-id="64272-103">驗證 (HTTP 伺服器 API) </span><span class="sxs-lookup"><span data-stu-id="64272-103">Authentication (HTTP Server API)</span></span>

<span data-ttu-id="64272-104">某些伺服器應用程式需要用戶端驗證才能存取資源和服務 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="64272-104">Some server applications require client authentication to access resources and service HTTP requests.</span></span> <span data-ttu-id="64272-105">從2.0 版開始，HTTP 伺服器 API 會執行應用程式的伺服器端驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-105">Starting with version 2.0, the HTTP Server API performs server side authentication for the application.</span></span> <span data-ttu-id="64272-106">在 HTTP 伺服器 API 版本1.0 中，伺服器應用程式必須執行自己的驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-106">In the HTTP Server API version 1.0, the server application had to implement its own authentication.</span></span> <span data-ttu-id="64272-107">HTTP 伺服器 API 執行驗證的一些優點包括：</span><span class="sxs-lookup"><span data-stu-id="64272-107">Some advantages of authentication performed by the HTTP Server API include:</span></span>

-   <span data-ttu-id="64272-108">應用程式可在低許可權下執行，進而降低安全性風險。</span><span class="sxs-lookup"><span data-stu-id="64272-108">Applications can run under low privileges, thus reducing security risks.</span></span>
-   <span data-ttu-id="64272-109">驗證會以核心模式執行，因此會在驗證期間減少從使用者模式到核心模式的轉換。</span><span class="sxs-lookup"><span data-stu-id="64272-109">Authentication is performed in kernel mode, thus reducing transitions from user mode to kernel mode during authentication.</span></span>
-   <span data-ttu-id="64272-110">在核心模式中執行的驗證可讓伺服器應用程式在不同的使用者帳戶上執行。</span><span class="sxs-lookup"><span data-stu-id="64272-110">Authentication performed in kernel mode allows server applications to run on different user accounts.</span></span> <span data-ttu-id="64272-111">在1.0 版中，電腦上的所有應用程式都必須在相同的使用者帳戶下執行，以在服務主體名稱 (SPN) 進行驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-111">In version 1.0, all applications on the machine must run under the same user account to authenticate on the Service Principle Name (SPN).</span></span>
-   <span data-ttu-id="64272-112">如果在交握過程中回收工作者進程，就不會重設 NTLM 驗證交握。</span><span class="sxs-lookup"><span data-stu-id="64272-112">The NTLM authentication handshake is not reset if a worker process is recycled while the handshake is in process.</span></span>

<span data-ttu-id="64272-113">為了充分利用2.0 版驗證，應用程式會啟用 HTTP 伺服器 API 套用至應用程式已註冊之 Url 的驗證配置。</span><span class="sxs-lookup"><span data-stu-id="64272-113">To take advantage of the version 2.0 authentication, the application enables the authentication schemes that the HTTP Server API applies to the URLs for which the application has registered.</span></span> <span data-ttu-id="64272-114">可以在伺服器會話或 URL 群組上啟用驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-114">Authentication can be enabled on the server session or URL group.</span></span> <span data-ttu-id="64272-115">如果未在 URL 群組上設定，則 URL 群組會繼承伺服器會話所啟用的驗證配置。</span><span class="sxs-lookup"><span data-stu-id="64272-115">The URL group inherits the authentication schemes enabled by the server session if none are set on the URL group.</span></span> <span data-ttu-id="64272-116">HTTP 伺服器 API 支援下列配置：</span><span class="sxs-lookup"><span data-stu-id="64272-116">The HTTP Server API supports the following schemes:</span></span>

-   <span data-ttu-id="64272-117">交涉</span><span class="sxs-lookup"><span data-stu-id="64272-117">Negotiate</span></span>
-   <span data-ttu-id="64272-118">NTLM</span><span class="sxs-lookup"><span data-stu-id="64272-118">NTLM</span></span>
-   <span data-ttu-id="64272-119">Digest</span><span class="sxs-lookup"><span data-stu-id="64272-119">Digest</span></span>
-   <span data-ttu-id="64272-120">基本</span><span class="sxs-lookup"><span data-stu-id="64272-120">Basic</span></span>

<span data-ttu-id="64272-121">伺服器應用程式也可以執行 HTTP 伺服器 API 不支援的驗證配置。</span><span class="sxs-lookup"><span data-stu-id="64272-121">The server application can also implement authentication schemes not supported by the HTTP Server API.</span></span> <span data-ttu-id="64272-122">HTTP 伺服器 API 會將要求傳送至應用程式，以取得不支援的驗證配置，或應用程式尚未啟用的配置。</span><span class="sxs-lookup"><span data-stu-id="64272-122">The HTTP Server API sends requests to the application for authentication schemes that are not supported, or for schemes that have not been enabled by the application.</span></span>

### <a name="enabling-authentication"></a><span data-ttu-id="64272-123">啟用驗證</span><span class="sxs-lookup"><span data-stu-id="64272-123">Enabling Authentication</span></span>

<span data-ttu-id="64272-124">伺服器應用程式會使用 [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty) 或 [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty) 函數，在伺服器會話或 URL 群組上啟用及設定驗證，如下所示：</span><span class="sxs-lookup"><span data-stu-id="64272-124">The server application enables and configures authentication on the server session or URL group with the [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty) or [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty) functions as follows:</span></span>

1.  <span data-ttu-id="64272-125">應用程式會在 [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty)或 [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty)的 *Property* 參數中指定 **HttpServerAuthenticationProperty** ，以啟用驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-125">The application enables authentication by specifying **HttpServerAuthenticationProperty** in the *Property* parameter of [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty) or [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty).</span></span>
2.  <span data-ttu-id="64272-126">應用程式會在 [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty)或 [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty)的 *PPropertyInformation* 參數中，指定 [**HTTP \_ 伺服器 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_server_authentication_info)結構中的設定參數。</span><span class="sxs-lookup"><span data-stu-id="64272-126">The application specifies the configuration parameters in the [**HTTP\_SERVER\_AUTHENTICATION\_INFO**](/windows/desktop/api/Http/ns-http-http_server_authentication_info) structure in the *pPropertyInformation* parameter of [**HttpSetServerSessionProperty**](/windows/desktop/api/Http/nf-http-httpsetserversessionproperty) or [**HttpSetUrlGroupProperty**](/windows/desktop/api/Http/nf-http-httpseturlgroupproperty).</span></span> <span data-ttu-id="64272-127">應用程式會指定啟用的驗證配置、是否停用 NTLM 認證快取，並在 **HTTP \_ 伺服器 \_ 驗證 \_ 資訊** 結構中提供基本和摘要參數。</span><span class="sxs-lookup"><span data-stu-id="64272-127">The application specifies the authentication schemes enabled, whether NTLM credential caching is disabled, and supplies the Basic and Digest parameters in the **HTTP\_SERVER\_AUTHENTICATION\_INFO** structure.</span></span>

### <a name="authentication-procedure"></a><span data-ttu-id="64272-128">驗證程式</span><span class="sxs-lookup"><span data-stu-id="64272-128">Authentication Procedure</span></span>

<span data-ttu-id="64272-129">若要起始 HTTP 伺服器驗證，應用程式會在第一個要求抵達要求佇列之前啟用驗證屬性。</span><span class="sxs-lookup"><span data-stu-id="64272-129">To initiate HTTP Server authentication, the application enables the authentication property before the first request arrives on the request queue.</span></span> <span data-ttu-id="64272-130">下列步驟是驗證要求的一般處理流程。</span><span class="sxs-lookup"><span data-stu-id="64272-130">The following steps are the common processing flow for authenticating a request.</span></span>

1.  <span data-ttu-id="64272-131">應用程式會啟用驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-131">The application enables authentication.</span></span> <span data-ttu-id="64272-132">請參閱前面的「啟用驗證」一節。</span><span class="sxs-lookup"><span data-stu-id="64272-132">See the preceding "Enabling Authentication" section.</span></span>
    > [!Note]  
    > <span data-ttu-id="64272-133">用戶端傳送未經驗證的要求。</span><span class="sxs-lookup"><span data-stu-id="64272-133">The client sends an unauthenticated request.</span></span> <span data-ttu-id="64272-134">HTTP 伺服器 API 會將要求傳遞至伺服器應用程式，並讓它產生最初的401挑戰。</span><span class="sxs-lookup"><span data-stu-id="64272-134">The HTTP Server API passes the request to the server application and allows it to generate the initial 401 challenge.</span></span> <span data-ttu-id="64272-135">HTTP 伺服器 API 包含內嵌于 [**HTTP \_ 要求**](/previous-versions/windows/desktop/legacy/aa364545(v=vs.85))結構的 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info)結構。</span><span class="sxs-lookup"><span data-stu-id="64272-135">The HTTP Server API includes the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure embedded with the [**HTTP\_REQUEST**](/previous-versions/windows/desktop/legacy/aa364545(v=vs.85)) structure.</span></span> <span data-ttu-id="64272-136">**AuthStatus** 成員指出 **HttpAuthStatusNotAuthenticated**</span><span class="sxs-lookup"><span data-stu-id="64272-136">The **AuthStatus** member indicates **HttpAuthStatusNotAuthenticated**</span></span>

     

2.  <span data-ttu-id="64272-137">應用程式會檢查 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info)結構的 **AuthStatus** 成員，以判斷要求是否經過驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-137">The application examines the **AuthStatus** member of the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure to determine if the request has been authenticated.</span></span> <span data-ttu-id="64272-138">如果要求尚未經過驗證，應用程式可以將要求以匿名方式服務，或傳送最初的401驗證挑戰。</span><span class="sxs-lookup"><span data-stu-id="64272-138">If the request has not been authenticated, the application can service the request as anonymous or send an initial 401 authentication challenge.</span></span>
3.  <span data-ttu-id="64272-139">如果應用程式將要求以匿名方式服務，則它會處理要求，並將最終回應傳送給用戶端應用程式，就像驗證未涉及一樣。</span><span class="sxs-lookup"><span data-stu-id="64272-139">If the application services the request as anonymous, it handles the request and sends the final response to the client application, just as if the authentication was not involved.</span></span>
4.  <span data-ttu-id="64272-140">如果應用程式需要驗證，它會傳送一或多個 WWW-Authenticate 標頭給用戶端的可用配置，以傳送初始401挑戰。</span><span class="sxs-lookup"><span data-stu-id="64272-140">If instead the application requires authentication, it sends the initial 401 challenge with one or more WWW-Authenticate headers indicating the available schemes to the client.</span></span> <span data-ttu-id="64272-141">當回應中傳送一個以上的驗證標頭時，應用程式應該使用 [**HTTP \_ MULTIPLE \_ 已知 \_ 標頭**](/windows/desktop/api/Http/ns-http-http_multiple_known_headers) 結構來建立必要的標頭集合。</span><span class="sxs-lookup"><span data-stu-id="64272-141">The application should use the [**HTTP\_MULTIPLE\_KNOWN\_HEADERS**](/windows/desktop/api/Http/ns-http-http_multiple_known_headers) structure to build the required set of headers when more than one authentication header is sent in the response.</span></span>
    > [!Note]
    >
    > <span data-ttu-id="64272-142">用戶端會使用從伺服器應用程式所指定的一組可用配置的授權標頭，重新傳送要求給初始401回應中所指定的架構。</span><span class="sxs-lookup"><span data-stu-id="64272-142">The client resends the request with the authorization header for a scheme selected from the set of available schemes indicated by the server application in initial 401 response.</span></span>
    >
    > <span data-ttu-id="64272-143">HTTP 伺服器 API 會檢查授權要求授權標頭，以判斷是否已啟用此配置。</span><span class="sxs-lookup"><span data-stu-id="64272-143">The HTTP Server API examines the authorization request authorization header to determine if the scheme is enabled.</span></span> <span data-ttu-id="64272-144">如果是，則 HTTP 伺服器 API 會執行驗證，並處理所有過渡要求/401-回應交換，直到驗證交握完成為止。</span><span class="sxs-lookup"><span data-stu-id="64272-144">If it is, then the HTTP Server API performs authentication and handles all interim request/401-response exchanges, until the authentication handshake is finalized.</span></span>
    >
    > <span data-ttu-id="64272-145">當 HTTP 伺服器 API 完成驗證嘗試時，它會將要求傳送至應用程式，並在要求所傳回的 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info) 結構中嘗試驗證的結果。</span><span class="sxs-lookup"><span data-stu-id="64272-145">When The HTTP Server API completes the authentication attempt, it sends the request to the application with the results of the authentication attempt in the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure that is returned with the request.</span></span> <span data-ttu-id="64272-146">如果驗證嘗試因下列其中一個原因而失敗，HTTP 伺服器 API 不會將要求傳遞至應用程式：</span><span class="sxs-lookup"><span data-stu-id="64272-146">If the authentication attempt fails for one of the following reasons, the HTTP Server API does not pass the request to the application:</span></span>
    >
    > -   <span data-ttu-id="64272-147">如果驗證交握因為內部 HTTP 伺服器 API 錯誤（例如記憶體配置失敗）而失敗，則 HTTP 伺服器 API 會產生 503 (服務無法使用) 回應，並傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="64272-147">If the authentication handshake fails due to an internal HTTP Server API error such as a memory allocation failure, the HTTP Server API generates a 503 (service unavailable) response and sends back to client.</span></span>
    > -   <span data-ttu-id="64272-148">如果有格式不正確的授權標頭，例如沒有配置名稱的標頭，或遇到格式不正確的用戶端認證 Base64 編碼，則 HTTP 伺服器 API 會產生 400 (錯誤的) 要求，並傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="64272-148">If a malformed authorization header such as a header without a scheme name, or malformed Base64 encoding of client credentials encountered, the HTTP Server API generates a 400 (bad request) response and sends back to client.</span></span>

     

5.  <span data-ttu-id="64272-149">伺服器應用程式會檢查 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info)結構的 **AuthStatus** 成員，以判斷驗證是否成功。</span><span class="sxs-lookup"><span data-stu-id="64272-149">The server application examines the **AuthStatus** member of the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure to determine if authentication was successful.</span></span> <span data-ttu-id="64272-150">當驗證失敗時，HTTP 伺服器 API 會在 **HTTP \_ 要求 \_ 驗證 \_ 資訊** 結構的 **SecStatus** 成員中包含從 [AcceptSecurityCoNtext](/previous-versions/windows/embedded/ms937012(v=msdn.10))傳回的錯誤。</span><span class="sxs-lookup"><span data-stu-id="64272-150">When authentication fails, the HTTP Server API includes the error returned from [AcceptSecurityContext](/previous-versions/windows/embedded/ms937012(v=msdn.10)) in the **SecStatus** member of the **HTTP\_REQUEST\_AUTH\_INFO** structure.</span></span> <span data-ttu-id="64272-151">如果驗證嘗試因為認證不正確而失敗，應用程式可能會產生另一個具有所需 WWW-Authenticate 標頭的401挑戰，或可能決定以匿名方式提供要求的服務。</span><span class="sxs-lookup"><span data-stu-id="64272-151">If the authentication attempt fails due to bad credentials, the application can generate another 401 challenge with the desired WWW-Authenticate header, or may decided to service the request as anonymous.</span></span>
6.  <span data-ttu-id="64272-152">如果驗證成功，應用程式會使用 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info) 結構中提供的權杖來模擬用戶端及存取資源。</span><span class="sxs-lookup"><span data-stu-id="64272-152">If authentication was successful, the application uses the token provided in the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure to impersonate the client and to access resources.</span></span> <span data-ttu-id="64272-153">只要要求識別碼有效，這通常會在應用程式完成要求的回應之前，傳回給應用程式的存取權杖控制碼有效。</span><span class="sxs-lookup"><span data-stu-id="64272-153">The access token handle returned to the application is valid as long as the request ID is valid, which is typically until the application completes the response to the request.</span></span> <span data-ttu-id="64272-154">不過，權杖可能會在這段期間過期，而應用程式可能需要將另一個401挑戰傳送給用戶端。</span><span class="sxs-lookup"><span data-stu-id="64272-154">The token may, however, expire during this period and the application may need to send another 401 challenge to the client.</span></span>
7.  <span data-ttu-id="64272-155">應用程式會傳送最終的200正常回應，而且必須關閉存取權杖的控制碼。</span><span class="sxs-lookup"><span data-stu-id="64272-155">The application sends the final 200 OK response, and it must close the handle to the access token.</span></span>
    > [!Note]  
    > <span data-ttu-id="64272-156">HTTP 伺服器 API 會將相互驗證資料附加至最終的 200 OK 回應（如果在驗證交握期間產生的話）。</span><span class="sxs-lookup"><span data-stu-id="64272-156">The HTTP Server API appends the mutual authentication data to the final 200 OK response, if one was generated during the authentication handshake.</span></span>

     

### <a name="ntlm-null-sessions"></a><span data-ttu-id="64272-157">NTLM Null 會話</span><span class="sxs-lookup"><span data-stu-id="64272-157">NTLM NULL Sessions</span></span>

<span data-ttu-id="64272-158">請注意，在最終安全性內容中指出的 NTLM Null 會話不會被視為已驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-158">Note that an NTLM NULL session indicated in the final security context, is not treated as authenticated.</span></span> <span data-ttu-id="64272-159">在此情況下，會將要求傳送至應用程式，並在 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info) 結構中出現 HttpAuthStatusFailure 錯誤，而應用程式可能會傳送另一個401挑戰。</span><span class="sxs-lookup"><span data-stu-id="64272-159">In this case, the request is sent to the application with an HttpAuthStatusFailure error in the [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure and the application can send another 401 challenge.</span></span>

### <a name="preemptive-authentication"></a><span data-ttu-id="64272-160">搶先驗證</span><span class="sxs-lookup"><span data-stu-id="64272-160">Preemptive Authentication</span></span>

<span data-ttu-id="64272-161">根據 HTTP 通訊協定，在用戶端建立資源的驗證之後，它可以事先將對應的授權標頭與後續的資源連續要求一起傳送，而不需要等待伺服器的401挑戰。</span><span class="sxs-lookup"><span data-stu-id="64272-161">According to the HTTP protocol, after the client has established authentication for a resource, it can preemptively send the corresponding authorization header with subsequent consecutive requests for the resource without waiting for a 401 challenge from the server.</span></span> <span data-ttu-id="64272-162">如果應用程式仍啟用授權標頭中所指出的配置，而且 HTTP 伺服器 API 支援此配置，則 HTTP 伺服器會嘗試驗證，而不會將要求傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="64272-162">If the scheme indicated in the Authorization header is still enabled by the application and supported by the HTTP Server API, the HTTP Server attempts authentication without sending the request to the application.</span></span> <span data-ttu-id="64272-163">當應用程式收到這類型的驗證要求時，可以選擇捨棄要求並重新產生初始401挑戰，或將要求服務為已驗證的要求。</span><span class="sxs-lookup"><span data-stu-id="64272-163">When this type of authenticated request is received by the application, it can choose to discard the request and regenerate the initial 401 challenge or service the request as authenticated.</span></span>

### <a name="mutual-authentication"></a><span data-ttu-id="64272-164">相互驗證</span><span class="sxs-lookup"><span data-stu-id="64272-164">Mutual Authentication</span></span>

<span data-ttu-id="64272-165">在交握期間使用協商配置時，會產生相互驗證資料，並將其解析為 Kerberos，並要求用戶端進行相互驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-165">Mutual authentication data is generated when the negotiate scheme is used during handshake and it is resolved to Kerberos, and client has asked for mutual authentication.</span></span> <span data-ttu-id="64272-166">HTTP 伺服器 API 會在伺服器應用程式傳送的最終200正常回應中自動插入相互驗證資料。</span><span class="sxs-lookup"><span data-stu-id="64272-166">The mutual authentication data is automatically inserted by HTTP Server API in the final 200 OK response sent by the server application.</span></span> <span data-ttu-id="64272-167">根據預設，HTTP 伺服器 API 不會將相互驗證資料傳遞到伺服器應用程式，因為它會自動處理它的傳送。</span><span class="sxs-lookup"><span data-stu-id="64272-167">By default HTTP Server API does not pass the Mutual authentication data to the server application, since it automatically handles the sending of it.</span></span> <span data-ttu-id="64272-168">但是，如果伺服器應用程式在設定的 [**HTTP \_ 伺服器 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_server_authentication_info)結構中啟用了 ReceiveMutualAuth 旗標，則會將相互驗證資料傳遞給以已驗證的 [**HTTP \_ 要求**](/previous-versions/windows/desktop/legacy/aa364545(v=vs.85))內嵌的 [**HTTP \_ 要求 \_ 驗證 \_ 資訊**](/windows/desktop/api/Http/ns-http-http_request_auth_info)結構中的應用程式。</span><span class="sxs-lookup"><span data-stu-id="64272-168">However, if server application enables the ReceiveMutualAuth flag in the [**HTTP\_SERVER\_AUTHENTICATION\_INFO**](/windows/desktop/api/Http/ns-http-http_server_authentication_info) structure in configuration, the mutual authentication data is passed to the application in [**HTTP\_REQUEST\_AUTH\_INFO**](/windows/desktop/api/Http/ns-http-http_request_auth_info) structure embedded with the authenticated [**HTTP\_REQUEST**](/previous-versions/windows/desktop/legacy/aa364545(v=vs.85)).</span></span> <span data-ttu-id="64272-169">在此情況下，應用程式應該傳送具有最終200正常回應的相互驗證資料。</span><span class="sxs-lookup"><span data-stu-id="64272-169">In this case application should send the mutual authentication data with the final 200 OK response.</span></span> <span data-ttu-id="64272-170">在單一電腦提供多個網站的情況下，電腦上的所有網站都會使用網域中本機電腦帳戶的認證來進行相互驗證。</span><span class="sxs-lookup"><span data-stu-id="64272-170">In the case where multiple sites are served by a single computer, all sites on the computer use the credentials for the Local Machine Account in the domain for mutual authentication.</span></span>

 

 
