---
title: HTTP 伺服器 API 總覽
description: 本主題會識別使用 HTTP 伺服器 API 的一般作業順序。
ms.assetid: 1245fd98-8370-4f1b-8c86-de9be5e678bd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5c99af3e4914c5496c2adea10b3ac658f75f3018
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/19/2020
ms.locfileid: "106991102"
---
# <a name="http-server-api-overview"></a><span data-ttu-id="1ae63-103">HTTP 伺服器 API 總覽</span><span class="sxs-lookup"><span data-stu-id="1ae63-103">HTTP Server API Overview</span></span>

<span data-ttu-id="1ae63-104">下列清單會識別使用 HTTP 伺服器 API 的一般作業順序：</span><span class="sxs-lookup"><span data-stu-id="1ae63-104">The following list identifies a typical sequence of operations that use the HTTP Server API:</span></span>

-   <span data-ttu-id="1ae63-105">使用 [**HttpInitialize**](/windows/desktop/api/Http/nf-http-httpinitialize) 函數來初始化 HTTP 伺服器 API。</span><span class="sxs-lookup"><span data-stu-id="1ae63-105">Initialize the HTTP Server API by using the [**HttpInitialize**](/windows/desktop/api/Http/nf-http-httpinitialize) function.</span></span>
-   <span data-ttu-id="1ae63-106">使用 [**HttpCreateHttpHandle**](/windows/desktop/api/Http/nf-http-httpcreatehttphandle) 函數建立要求佇列。</span><span class="sxs-lookup"><span data-stu-id="1ae63-106">Create a request queue by using the [**HttpCreateHttpHandle**](/windows/desktop/api/Http/nf-http-httpcreatehttphandle) function.</span></span>
-   <span data-ttu-id="1ae63-107">使用 [**HttpAddUrl**](/windows/desktop/api/Http/nf-http-httpaddurl) 函數註冊一或多個 url。</span><span class="sxs-lookup"><span data-stu-id="1ae63-107">Register one or more URLs by using the [**HttpAddUrl**](/windows/desktop/api/Http/nf-http-httpaddurl) function.</span></span>
-   <span data-ttu-id="1ae63-108">使用 [**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) 函式來接收導向至已註冊之 url 的連入要求，並使用 [**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse) 函數傳送這些要求的 HTTP 回應。</span><span class="sxs-lookup"><span data-stu-id="1ae63-108">Receive incoming requests directed to registered URLs by using the [**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) function, and send HTTP responses for these requests by using the [**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse) function.</span></span>
-   <span data-ttu-id="1ae63-109"> (選擇性) 傳送回應時，請使用 [**HttpSendResponseEntityBody**](/windows/desktop/api/Http/nf-http-httpsendresponseentitybody) 函數傳送額外的實體主體。</span><span class="sxs-lookup"><span data-stu-id="1ae63-109">(Optional) When sending a response, send an additional entity body by using the [**HttpSendResponseEntityBody**](/windows/desktop/api/Http/nf-http-httpsendresponseentitybody) function.</span></span>
-   <span data-ttu-id="1ae63-110">使用 [**HttpRemoveUrl**](/windows/desktop/api/Http/nf-http-httpremoveurl)、 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 和 [**HttpTerminate**](/windows/desktop/api/Http/nf-http-httpterminate) 函數來執行清除作業。</span><span class="sxs-lookup"><span data-stu-id="1ae63-110">Perform clean-up operations by using the [**HttpRemoveUrl**](/windows/desktop/api/Http/nf-http-httpremoveurl), [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) and [**HttpTerminate**](/windows/desktop/api/Http/nf-http-httpterminate) functions.</span></span>

<span data-ttu-id="1ae63-111">在使用 Url 的作業中，請注意，它是已處理的 URL，其包含在應使用之 [**HTTP \_ 要求 \_ V1**](/windows/desktop/api/Http/ns-http-http_request_v1)結構的 **CookedUrl** 成員中。</span><span class="sxs-lookup"><span data-stu-id="1ae63-111">In operations that use URLs, note that it is the processed URL contained in the **CookedUrl** member of the [**HTTP\_REQUEST\_V1**](/windows/desktop/api/Http/ns-http-http_request_v1) structure that should be used.</span></span> <span data-ttu-id="1ae63-112">請勿在 **pRawUrl** 成員中使用未處理的 URL，這僅適用于追蹤和統計用途。</span><span class="sxs-lookup"><span data-stu-id="1ae63-112">Do not the unprocessed URL in the **pRawUrl** member, which is solely for tracking and statistical purposes.</span></span>

<span data-ttu-id="1ae63-113">每個應用程式都會建立自己的要求佇列。</span><span class="sxs-lookup"><span data-stu-id="1ae63-113">Each application creates its own request queue.</span></span> <span data-ttu-id="1ae63-114">應用程式從 [**HttpCreateHttpHandle**](/windows/desktop/api/Http/nf-http-httpcreatehttphandle)取得其要求佇列控制碼。</span><span class="sxs-lookup"><span data-stu-id="1ae63-114">An application obtains its request queue handle from [**HttpCreateHttpHandle**](/windows/desktop/api/Http/nf-http-httpcreatehttphandle).</span></span> <span data-ttu-id="1ae63-115">它會將此控制碼傳遞至 [**HttpAddUrl**](/windows/desktop/api/Http/nf-http-httpaddurl) 函式，以將 URL 新增至要求佇列。</span><span class="sxs-lookup"><span data-stu-id="1ae63-115">It passes this handle to the [**HttpAddUrl**](/windows/desktop/api/Http/nf-http-httpaddurl) function to add a URL to the request queue.</span></span> <span data-ttu-id="1ae63-116">應用程式會接收傳入要求的通知，然後藉由呼叫 [**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) 函式與要求佇列控制碼，從要求佇列中抓取該要求。</span><span class="sxs-lookup"><span data-stu-id="1ae63-116">The application receives notification of an incoming request, and retrieves it from the request queue by calling the [**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) function with the request queue handle.</span></span> <span data-ttu-id="1ae63-117">您可以使用此函式來接收要求標頭或標頭和實體主體。</span><span class="sxs-lookup"><span data-stu-id="1ae63-117">You can use this function to receive either the request headers or both the headers and entity body.</span></span> <span data-ttu-id="1ae63-118">[**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) 也會針對要求控制碼唯一的接收要求，傳回 (RequestId) 的要求識別碼。</span><span class="sxs-lookup"><span data-stu-id="1ae63-118">[**HttpReceiveHttpRequest**](/windows/desktop/api/Http/nf-http-httpreceivehttprequest) also returns a request identifier (RequestId) for the received request that is unique to the request handle.</span></span>

> [!Note]  
> <span data-ttu-id="1ae63-119">應用程式必須負責檢查所有相關的要求標頭，包括使用中的內容協調標頭，並根據標頭內容適當地使要求失敗。</span><span class="sxs-lookup"><span data-stu-id="1ae63-119">It is the application's responsibility to examine all relevant request headers, including content-negotiation headers if they are being used, and fail requests as appropriate based on header content.</span></span> <span data-ttu-id="1ae63-120">HTTP 伺服器 API 可確保只會正確地終止每個標頭行，且不會包含不合法的字元。</span><span class="sxs-lookup"><span data-stu-id="1ae63-120">The HTTP Server API ensures only that each header line is properly terminated, and does not contain illegal characters.</span></span>

 

<span data-ttu-id="1ae63-121">使用 [**HttpReceiveRequestEntityBody**](/windows/desktop/api/Http/nf-http-httpreceiverequestentitybody) 函式搭配要求佇列控制碼，以抓取要求的實體主體的後續部分（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="1ae63-121">Use the [**HttpReceiveRequestEntityBody**](/windows/desktop/api/Http/nf-http-httpreceiverequestentitybody) function with the request queue handle to retrieve subsequent portions of a request's entity body, if any.</span></span>

> [!Note]  
> <span data-ttu-id="1ae63-122">HTTP 伺服器 API 會在接收端解碼區塊的訊息，但不會在傳送端執行區塊編碼。</span><span class="sxs-lookup"><span data-stu-id="1ae63-122">The HTTP Server API decodes chunked messages on the receive side, but does not perform chunked encoding on the send side.</span></span> <span data-ttu-id="1ae63-123">如果傳送端需要區塊化，應用程式必須加以執行。</span><span class="sxs-lookup"><span data-stu-id="1ae63-123">If chunking is required on the send side, the application must implement it.</span></span> <span data-ttu-id="1ae63-124">如需區塊編碼的詳細資訊，請參閱 [RFC 2616](https://www.ietf.org/rfc/rfc2616.txt)。</span><span class="sxs-lookup"><span data-stu-id="1ae63-124">For more information about chunked encoding, see [RFC 2616](https://www.ietf.org/rfc/rfc2616.txt).</span></span>

 

<span data-ttu-id="1ae63-125">使用 [**HttpReceiveClientCertificate**](/windows/desktop/api/Http/nf-http-httpreceiveclientcertificate) 函式搭配提供 url 的應用程式，方法是使用 ( "**HTTPs**" ) 的安全配置，以選擇性地取出用戶端的憑證資訊。</span><span class="sxs-lookup"><span data-stu-id="1ae63-125">Use the [**HttpReceiveClientCertificate**](/windows/desktop/api/Http/nf-http-httpreceiveclientcertificate) function with applications that serve URLs by using a secure scheme ("**https**") to optionally retrieve the client's certificate information.</span></span>

<span data-ttu-id="1ae63-126">[**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse)函式會傳送回應。</span><span class="sxs-lookup"><span data-stu-id="1ae63-126">Responses are sent with the [**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse) function.</span></span> <span data-ttu-id="1ae63-127">此函式會使用來自對應要求的 RequestId 來傳送回應。</span><span class="sxs-lookup"><span data-stu-id="1ae63-127">This function uses the RequestId from the corresponding request to send the response.</span></span> <span data-ttu-id="1ae63-128">藉由呼叫 HttpSendResponseEntityBody 函式，並從原始接收的要求呼叫[](/windows/desktop/api/Http/nf-http-httpsendresponseentitybody)函式，就可以在數次 API 呼叫中傳送回應。</span><span class="sxs-lookup"><span data-stu-id="1ae63-128">A response can be sent in several API calls over time by calling the [**HttpSendResponseEntityBody**](/windows/desktop/api/Http/nf-http-httpsendresponseentitybody) function with the RequestId from the originally received request.</span></span>

> [!Note]  
> <span data-ttu-id="1ae63-129">根據預設， [**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse) 會使用 "MICROSOFT-HTTPapi.dll/1.0" 作為 "Server：" 標頭。</span><span class="sxs-lookup"><span data-stu-id="1ae63-129">By default, [**HttpSendHttpResponse**](/windows/desktop/api/Http/nf-http-httpsendhttpresponse) uses "Microsoft-HTTPAPI/1.0" as the "Server:" header.</span></span> <span data-ttu-id="1ae63-130">如果應用程式在回應中指定伺服器標頭，該值會被放在伺服器標頭的第一個部分，後面接著一個空格，然後是 "Microsoft-HTTPAPI.DLL/1.0"。</span><span class="sxs-lookup"><span data-stu-id="1ae63-130">If an application specifies a server header in a response, that value is placed as the first part of the server header, followed by a space and then "Microsoft-HTTPAPI/1.0".</span></span>

 

<span data-ttu-id="1ae63-131">一般而言，HTTP 伺服器 API 會隱藏連接管理的詳細資料，以及從應用程式建立和卸載的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="1ae63-131">In general, the HTTP Server API hides details of connection management and their establishment and teardown from applications.</span></span> <span data-ttu-id="1ae63-132">不過，應用程式可以藉由呼叫 [**HttpWaitForDisconnect**](/windows/desktop/api/Http/nf-http-httpwaitfordisconnect)，選擇性地偵測連接的終止。</span><span class="sxs-lookup"><span data-stu-id="1ae63-132">However, an application can optionally detect termination of a connection by calling [**HttpWaitForDisconnect**](/windows/desktop/api/Http/nf-http-httpwaitfordisconnect).</span></span>

<span data-ttu-id="1ae63-133">應用程式必須使用下列步驟來清除：</span><span class="sxs-lookup"><span data-stu-id="1ae63-133">Applications must clean-up by using the following steps:</span></span>

-   <span data-ttu-id="1ae63-134">當應用程式未接聽或回應 URL 時，會使用 [**HttpRemoveURL**](/windows/desktop/api/Http/nf-http-httpremoveurl) 函數來移除 url。</span><span class="sxs-lookup"><span data-stu-id="1ae63-134">When the application is not listening or responding to a URL, the URL is removed by using the [**HttpRemoveURL**](/windows/desktop/api/Http/nf-http-httpremoveurl) function.</span></span>
-   <span data-ttu-id="1ae63-135">當應用程式使用完要求佇列時，請使用 [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) 函數關閉要求佇列控制碼。</span><span class="sxs-lookup"><span data-stu-id="1ae63-135">When the application is finished using the request queue, close the request queue handle by using the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>
-   <span data-ttu-id="1ae63-136">當應用程式使用 HTTP 伺服器 API 完成時，請呼叫 [**HttpTerminate**](/windows/desktop/api/Http/nf-http-httpterminate) 函數。</span><span class="sxs-lookup"><span data-stu-id="1ae63-136">When the application is finished using the HTTP Server API, call the [**HttpTerminate**](/windows/desktop/api/Http/nf-http-httpterminate) function.</span></span>

 

 