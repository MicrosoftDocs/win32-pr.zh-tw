---
title: DirectX Graphic Infrastructure (DXGI) 最佳作法
description: 本文討論主要的移植問題。
ms.assetid: 2df92ffe-1bfc-d682-2770-20cf0c831c9b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f576368674d05af74e3161d4251301ebc066a489
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104376228"
---
# <a name="directx-graphics-infrastructure-dxgi-best-practices"></a><span data-ttu-id="2bdd3-103">DirectX Graphic Infrastructure (DXGI) ：最佳作法</span><span class="sxs-lookup"><span data-stu-id="2bdd3-103">DirectX Graphics Infrastructure (DXGI): Best Practices</span></span>

<span data-ttu-id="2bdd3-104">Microsoft DirectX Graphics Infrastructure (DXGI) 是新的子系統，其在封裝部分 Direct3D 10、10.1、11 和 11.1 所需低層級工作的 Windows Vista 中引進，</span><span class="sxs-lookup"><span data-stu-id="2bdd3-104">Microsoft DirectX Graphics Infrastructure (DXGI) is a new subsystem that was introduced with Windows Vista that encapsulates some of the low-level tasks that are needed by Direct3D 10, 10.1, 11, and 11.1.</span></span> <span data-ttu-id="2bdd3-105">從 Direct3D 9 程式設計師的觀點來看，DXGI 包含了大部分的程式碼，可供列舉、交換鏈建立，以及之前封裝至 Direct3D 9 Api 的簡報。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-105">From the perspective of a Direct3D 9 programmer, DXGI encompasses most of the code for enumeration, swap-chain creation, and presentation that previously was packed into the Direct3D 9 APIs.</span></span> <span data-ttu-id="2bdd3-106">當您將應用程式移植至 DXGI 和 Direct3D 2.x 和 Direct3D 11. x 時，您需要考慮一些考慮，以確保進程能順利執行。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-106">When you port an app to DXGI and Direct3D 10.x and Direct3D 11.x, you need to take some considerations into account to ensure that the process runs smoothly.</span></span>

<span data-ttu-id="2bdd3-107">本文討論主要的移植問題。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-107">This article discusses key porting issues.</span></span>

-   [<span data-ttu-id="2bdd3-108">全螢幕問題</span><span class="sxs-lookup"><span data-stu-id="2bdd3-108">Full-Screen Issues</span></span>](#full-screen-issues)
-   [<span data-ttu-id="2bdd3-109">多個監視器</span><span class="sxs-lookup"><span data-stu-id="2bdd3-109">Multiple Monitors</span></span>](#multiple-monitors)
-   [<span data-ttu-id="2bdd3-110">視窗樣式和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-110">Window Styles and DXGI</span></span>](#window-styles-and-dxgi)
-   [<span data-ttu-id="2bdd3-111">多執行緒和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-111">Multithreading and DXGI</span></span>](#multithreading-and-dxgi)
-   [<span data-ttu-id="2bdd3-112">Gamma 和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-112">Gamma and DXGI</span></span>](#gamma-and-dxgi)
-   [<span data-ttu-id="2bdd3-113">DXGI 1。1</span><span class="sxs-lookup"><span data-stu-id="2bdd3-113">DXGI 1.1</span></span>](#dxgi-11)
-   [<span data-ttu-id="2bdd3-114">DXGI 1。2</span><span class="sxs-lookup"><span data-stu-id="2bdd3-114">DXGI 1.2</span></span>](#dxgi-12)

## <a name="full-screen-issues"></a><span data-ttu-id="2bdd3-115">Full-Screen 問題</span><span class="sxs-lookup"><span data-stu-id="2bdd3-115">Full-Screen Issues</span></span>

<span data-ttu-id="2bdd3-116">從 Direct3D 9 移植至 DXGI 以及 Direct3D 2.x 或 Direct3D 11. x，與從視窗間移至全螢幕模式的相關問題通常可能會造成開發人員的麻煩。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-116">In porting from Direct3D 9 to DXGI and to Direct3D 10.x or Direct3D 11.x, issues associated with moving from windowing to full-screen mode often may cause headaches for developers.</span></span> <span data-ttu-id="2bdd3-117">主要的問題是因為 Direct3D 9 應用程式與 DXGI 應用程式不同，所以需要更多實際操作的方法來追蹤視窗樣式和視窗狀態。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-117">The main problems arise because Direct3D 9 applications, unlike DXGI applications, require a more hands-on approach to tracking window styles and window states.</span></span> <span data-ttu-id="2bdd3-118">當模式變更程式碼移植到在 DXGI 上執行時，通常會造成非預期的行為。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-118">When the mode-changing code is ported to run on DXGI, it often causes unexpected behavior.</span></span>

<span data-ttu-id="2bdd3-119">通常，Direct3D 9 應用程式會藉由設定前端緩衝區的解析度、強制裝置進入全螢幕獨佔模式，然後將背景緩衝區解析度設定為相符，來處理轉換成全螢幕模式。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-119">Often, Direct3D 9 applications handled the transition into full-screen mode by setting the resolution of the front buffer, forcing the device into full-screen exclusive mode, and then setting the back buffer resolutions to match.</span></span> <span data-ttu-id="2bdd3-120">不同的路徑用於視窗大小的變更，因為每當應用程式收到 WM 大小的訊息時，都必須從視窗進程進行管理 \_ 。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-120">A separate path was used for changes to window size because they had to be managed from the window process whenever the application received a WM\_SIZE message.</span></span>

<span data-ttu-id="2bdd3-121">DXGI 藉由結合這兩種案例來嘗試簡化此方法。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-121">DXGI attempts to simplify this approach by combining the two cases.</span></span> <span data-ttu-id="2bdd3-122">例如，當視窗框線以視窗模式拖曳時，應用程式會收到 WM 大小的 \_ 訊息。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-122">For example, when the window border is dragged in windowed mode, the application receives a WM\_SIZE message.</span></span> <span data-ttu-id="2bdd3-123">DXGI 會攔截這則訊息，並自動調整前端緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-123">DXGI intercepts this message and automatically resizes the front buffer.</span></span> <span data-ttu-id="2bdd3-124">應用程式所需執行的工作，就是呼叫 [**IDXGISwapChain：： ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) ，將背景緩衝區大小調整成以 WM 大小的參數傳遞的大小 \_ 。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-124">All that the application needs to do is call [**IDXGISwapChain::ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) to resize the back buffer to the size that was passed as parameters in WM\_SIZE.</span></span> <span data-ttu-id="2bdd3-125">同樣地，當應用程式需要在全螢幕和視窗模式之間切換時，應用程式可以直接呼叫 [**IDXGISwapChain：： SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate)。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-125">Similarly, when the application needs to switch between full-screen and windowed mode, the application can simply call [**IDXGISwapChain::SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span></span> <span data-ttu-id="2bdd3-126">DXGI 會調整前端緩衝區大小以符合新選取的全螢幕模式，並將 WM 大小的 \_ 訊息傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-126">DXGI resizes the front buffer to match the newly selected full-screen mode, and it sends a WM\_SIZE message to the application.</span></span> <span data-ttu-id="2bdd3-127">應用程式會再次呼叫 **ResizeBuffers**，就像是拖曳視窗框線一樣。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-127">The application again calls **ResizeBuffers**, just as it would if the window border was dragged.</span></span>

<span data-ttu-id="2bdd3-128">上述說明的方法會遵循非常特殊的路徑。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-128">The methodology of the preceding explanation follows a very particular path.</span></span> <span data-ttu-id="2bdd3-129">DXGI 預設會將全螢幕解析度設定為桌面解析度。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-129">DXGI set the full-screen resolution to the desktop resolution by default.</span></span> <span data-ttu-id="2bdd3-130">不過，許多應用程式會切換至慣用的全螢幕解析度。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-130">Many applications, however, switch to a preferred full-screen resolution.</span></span> <span data-ttu-id="2bdd3-131">在這種情況下，DXGI 提供 [**IDXGISwapChain：： ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget)。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-131">In such a case, DXGI provides [**IDXGISwapChain::ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget).</span></span> <span data-ttu-id="2bdd3-132">這應該在呼叫 [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate)之前呼叫。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-132">This should be called before calling [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate).</span></span> <span data-ttu-id="2bdd3-133">雖然這些方法可以依相反順序呼叫 (**SetFullscreenState** ，接著 **ResizeTarget**) ，這樣做會導致額外的 WM \_ 大小訊息傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-133">Although these methods can be called in the opposite order (**SetFullscreenState** first, followed by **ResizeTarget**), doing so causes an extra WM\_SIZE message to be sent to the application.</span></span> <span data-ttu-id="2bdd3-134"> (這麼做也會導致閃爍，因為 DXGI 可能會強制執行兩個模式的變更 ) 。呼叫 **SetFullscreenState** 之後，建議您再次呼叫 **ResizeTarget** ，並將 [**dxgi \_ 模式 \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85))的 **RefreshRate** 成員設為零。這在 DXGI 中不是作業指令，但可以避免重新整理頻率的問題，接下來將會討論。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-134">(Doing so can also cause flickering, since DXGI could be forced to perform two mode changes.) After calling **SetFullscreenState**, it is advisable to call **ResizeTarget** again with the **RefreshRate** member of [**DXGI\_MODE\_DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) zeroed out. This amounts to a no-operation instruction in DXGI, but it can avoid issues with the refresh rate, which are discussed next.</span></span>

<span data-ttu-id="2bdd3-135">處於全螢幕模式時，會停用桌面視窗管理員 (DWM) 。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-135">When in full-screen mode, the Desktop Window Manager (DWM) is disabled.</span></span> <span data-ttu-id="2bdd3-136">DXGI 可以執行翻轉來呈現背景緩衝區內容，而不是執行 array.blit，這會在視窗模式中執行。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-136">DXGI can perform a flip to present the back buffer contents instead of doing a blit, which it would do in windowed mode.</span></span> <span data-ttu-id="2bdd3-137">但是，如果不符合特定的需求，此效能增益可能會復原。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-137">This performance gain can be undone, however, if certain requirements are not met.</span></span> <span data-ttu-id="2bdd3-138">為了確保 DXGI 會進行翻轉而非 array.blit，前端緩衝區和背景緩衝區的大小必須相同。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-138">To ensure that DXGI does a flip instead of a blit, the front buffer and back buffer must be sized identically.</span></span> <span data-ttu-id="2bdd3-139">如果應用程式正確處理其 WM \_ 大小的訊息，這應該不會造成問題。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-139">If the application correctly handles its WM\_SIZE messages, this should not be a problem.</span></span> <span data-ttu-id="2bdd3-140">此外，格式必須相同。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-140">Also, the formats must be identical.</span></span>

<span data-ttu-id="2bdd3-141">大部分應用程式的問題都是重新整理頻率。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-141">The problem for most applications is the refresh rate.</span></span> <span data-ttu-id="2bdd3-142">在 [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) 的呼叫中指定的重新整理速率必須是由交換鏈所使用的 [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) 物件所列舉的更新速率。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-142">The refresh rate that is specified in the call to [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) must be a refresh rate that is enumerated by the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object that the swap chain is using.</span></span> <span data-ttu-id="2bdd3-143">如果應用程式零出傳遞至 **ResizeTarget** 的 [**Dxgi \_ 模式 \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) **RefreshRate** 成員，則 DXGI 可以自動計算此值。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-143">DXGI can automatically calculate this value if the application zeroes out the **RefreshRate** member of [**DXGI\_MODE\_DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) that is passed into **ResizeTarget**.</span></span> <span data-ttu-id="2bdd3-144">請務必不要假設一定會支援特定的重新整理頻率，並且只是將值硬式編碼。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-144">It is important not to assume that certain refresh rates will always be supported and to simply hard-code a value.</span></span> <span data-ttu-id="2bdd3-145">開發人員通常會選擇 60 Hz 作為重新整理頻率，而不知道來自監視器的列舉重新整理率大約是監視器的 60000/1001 Hz。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-145">Often, developers choose 60 Hz as the refresh rate, not knowing that the enumerated refresh rate from the monitor is approximately 60,000 / 1,001 Hz from the monitor.</span></span> <span data-ttu-id="2bdd3-146">如果重新整理率不符合預期的重新整理速率60，則會強制執行 DXGI 以全螢幕模式執行 array.blit，而不是翻轉。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-146">If the refresh rate does not match the expected refresh rate of 60, DXGI is forced to perform a blit in full-screen mode instead of a flip.</span></span>

<span data-ttu-id="2bdd3-147">開發人員經常面臨的最後一個問題，就是如何在全螢幕模式下變更全螢幕解析度。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-147">The last issue that developers often face is how to change full-screen resolutions while remaining in full-screen mode.</span></span> <span data-ttu-id="2bdd3-148">呼叫 [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) 和 [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate) 有時會成功，但全螢幕解析度仍會保持桌面解析度。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-148">Calling [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) and [**SetFullscreenState**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate) sometimes succeeds, but the full-screen resolution remains the desktop resolution.</span></span> <span data-ttu-id="2bdd3-149">此外，開發人員也可以建立全螢幕的交換鏈，並提供特定的解決方式，只是要找出所有傳入的數位都是電腦解析度的預設值。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-149">Also, developers may create a full-screen swap chain and give a specific resolution, only to find that DXGI defaults to the desktop resolution regardless of the numbers passed in.</span></span> <span data-ttu-id="2bdd3-150">除非另有指示，否則 DXGI 預設為全螢幕交換鏈的桌面解析度。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-150">Unless otherwise instructed, DXGI defaults to the desktop resolution for full-screen swap chains.</span></span> <span data-ttu-id="2bdd3-151">建立全螢幕交換鏈時，必須將 [**dxgi \_ 交換 \_ 鏈 \_ DESC**](/windows/desktop/api/dxgi/ns-dxgi-dxgi_swap_chain_desc)結構的 **旗標** 成員設為 [**dxgi \_ 交換 \_ 鏈 \_ 旗標 \_ 允許 \_ 模式 \_ 切換**](/windows/desktop/api/dxgi/ne-dxgi-dxgi_swap_chain_flag)，以覆寫 DXGI 的預設行為。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-151">When creating a full-screen swap chain, the **Flags** member of the [**DXGI\_SWAP\_CHAIN\_DESC**](/windows/desktop/api/dxgi/ns-dxgi-dxgi_swap_chain_desc) structure must be set to [**DXGI\_SWAP\_CHAIN\_FLAG\_ALLOW\_MODE\_SWITCH**](/windows/desktop/api/dxgi/ne-dxgi-dxgi_swap_chain_flag) to override DXGI's default behavior.</span></span> <span data-ttu-id="2bdd3-152">此旗標也可以傳遞至 **ResizeTarget** ，以動態方式啟用或停用此功能。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-152">This flag also can be passed to **ResizeTarget** to enable or disable this functionality dynamically.</span></span>

## <a name="multiple-monitors"></a><span data-ttu-id="2bdd3-153">多個監視器</span><span class="sxs-lookup"><span data-stu-id="2bdd3-153">Multiple Monitors</span></span>

<span data-ttu-id="2bdd3-154">搭配多個監視器使用 DXGI 時，有兩個要遵循的規則。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-154">When using DXGI with multiple monitors, there are two rules to follow.</span></span>

<span data-ttu-id="2bdd3-155">第一個規則適用于在多個監視器上建立兩個或多個全螢幕交換鏈。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-155">The first rule applies to the creation of two or more full-screen swap chains on multiple monitors.</span></span> <span data-ttu-id="2bdd3-156">建立這類交換鏈時，最好將所有交換鏈建立為視窗視窗，然後將它們設定為全螢幕。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-156">When creating such swap chains, it is best to create all swap chains as windowed, and then to set them to full-screen.</span></span> <span data-ttu-id="2bdd3-157">如果交換鏈是在全螢幕模式中建立，則建立第二個交換鏈會導致模式變更傳送至第一個交換鏈，這可能會導致全螢幕模式終止。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-157">If swap chains are created in full-screen mode, the creation of a second swap chain causes a mode change to be sent to the first swap chain, which could cause termination of full-screen mode.</span></span>

<span data-ttu-id="2bdd3-158">第二個規則會套用到輸出。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-158">The second rule applies to outputs.</span></span> <span data-ttu-id="2bdd3-159">關注建立交換鏈時使用的輸出。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-159">Be watchful of outputs used when creating swap chains.</span></span> <span data-ttu-id="2bdd3-160">使用 DXGI 時， [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) 物件可控制交換鏈在全螢幕時所使用的監視。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-160">With DXGI, the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object controls which monitor the swap chain uses when becoming full-screen.</span></span> <span data-ttu-id="2bdd3-161">與 DXGI 不同的是，Direct3D 9 沒有輸出的概念。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-161">Unlike DXGI, Direct3D 9 had no concept of outputs.</span></span>

## <a name="window-styles-and-dxgi"></a><span data-ttu-id="2bdd3-162">視窗樣式和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-162">Window Styles and DXGI</span></span>

<span data-ttu-id="2bdd3-163">在全螢幕和視窗模式之間切換時，Direct3D 9 應用程式必須執行許多工作。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-163">Direct3D 9 applications had a lot of work to do when switching between full-screen and windowed modes.</span></span> <span data-ttu-id="2bdd3-164">大部分的工作都牽涉到變更視窗樣式，以新增和移除框線、加入捲軸等等。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-164">Much of this work involved changing window styles to add and remove borders, to add scrollbars, and so on.</span></span> <span data-ttu-id="2bdd3-165">當應用程式移植至 DXGI 和 Direct3D 2.x 或 Direct3D 11. x 時，此程式碼通常會保留在原處。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-165">When applications are ported to DXGI and Direct3D 10.x or Direct3D 11.x, this code often is left in place.</span></span> <span data-ttu-id="2bdd3-166">視所做的變更而定，切換模式可能會導致非預期的行為。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-166">Depending on the changes being made, switching between modes can cause unexpected behavior.</span></span> <span data-ttu-id="2bdd3-167">例如，當切換至視窗模式時，應用程式可能不會再有視窗框架或視窗框線，儘管有專門設定這些樣式的程式碼。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-167">For example, when switching to windowed mode, the application might no longer have a window frame or window border despite having code that specifically sets these styles.</span></span> <span data-ttu-id="2bdd3-168">發生這種情況是因為 DXGI 現在會處理其本身的大部分變更。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-168">This occurs because DXGI now handles much of this style changing on its own.</span></span> <span data-ttu-id="2bdd3-169">手動設定視窗樣式可能會干擾 DXGI，而這可能會造成非預期的行為。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-169">Manual setting of window styles can interfere with DXGI, and this can cause unexpected behavior.</span></span>

<span data-ttu-id="2bdd3-170">建議的行為是盡可能少的工作，並讓 DXGI 處理與視窗的大部分互動。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-170">The recommended behavior is to do as little work as possible, and to let DXGI handle most of the interaction with the windows.</span></span> <span data-ttu-id="2bdd3-171">但是，如果應用程式需要處理自己的視窗化行為，則可以使用 [**IDXGIFactory：： MakeWindowAssociation**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-makewindowassociation) 來指示 DXGI 停用部分自動視窗處理。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-171">However, if the application needs to handle its own windowing behavior, [**IDXGIFactory::MakeWindowAssociation**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-makewindowassociation) can be used to tell DXGI to disable some of its automatic window handling.</span></span>

## <a name="multithreading-and-dxgi"></a><span data-ttu-id="2bdd3-172">多執行緒和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-172">Multithreading and DXGI</span></span>

<span data-ttu-id="2bdd3-173">在多執行緒應用程式中使用 DXGI以確保不會發生死結，要特別注意。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-173">Special care must be taken when using DXGI in a multithreaded application to ensure that deadlocks do not occur.</span></span> <span data-ttu-id="2bdd3-174">因為 DXGI 與視窗間的緊密互動，所以會偶爾將視窗訊息傳送至相關聯的應用程式視窗。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-174">Because of DXGI's close interaction with windowing, it occasionally sends window messages to the associated application window.</span></span> <span data-ttu-id="2bdd3-175">DXGI 需要進行視窗間的變更才能繼續，因此它會使用 [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage)，也就是同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-175">DXGI needs the windowing changes to occur before it can continue, so it will use [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), which is a synchronous call.</span></span> <span data-ttu-id="2bdd3-176">應用程式必須在 **SendMessage** 傳回之前處理視窗訊息。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-176">The application must process the window message before **SendMessage** returns.</span></span>

<span data-ttu-id="2bdd3-177">在具有 DXGI 呼叫的應用程式中，以及在相同執行緒 (或單一執行緒應用程式) 的應用程式中，幾乎需要完成一些工作。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-177">In an application where DXGI calls and the message pump are on the same thread (or a single-threaded application), little needs to be done.</span></span> <span data-ttu-id="2bdd3-178">當 DXGI 呼叫與訊息提取位於相同執行緒上時， [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) 會呼叫視窗的 [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85))。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-178">When the DXGI call is on the same thread as the message pump, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) calls the window's [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)).</span></span> <span data-ttu-id="2bdd3-179">這會略過訊息泵，並允許在呼叫 **SendMessage** 之後繼續執行。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-179">This bypasses the message pump, and allows execution to continue after the call to **SendMessage**.</span></span> <span data-ttu-id="2bdd3-180">請記住， [**IDXGISwapChain**](/windows/desktop/api/dxgi/nn-dxgi-idxgiswapchain) 呼叫（例如 [**IDXGISwapChain：:P**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present)重新傳送）也會被視為 DXGI 呼叫;DXGI 可能會延遲 [**ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) 或 [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) 中的工作，直到呼叫 **存在** 為止。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-180">Remember that [**IDXGISwapChain**](/windows/desktop/api/dxgi/nn-dxgi-idxgiswapchain) calls, such as [**IDXGISwapChain::Present**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present), are also considered DXGI calls; DXGI may defer work from [**ResizeBuffers**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) or [**ResizeTarget**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) until **Present** is called.</span></span>

<span data-ttu-id="2bdd3-181">如果 DXGI 呼叫和訊息提取位於不同的執行緒上，則必須小心，以避免發生鎖死。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-181">If the DXGI call and message pump are on different threads, care must be taken to avoid deadlocks.</span></span> <span data-ttu-id="2bdd3-182">當訊息泵和 SendMessage 位於不同的執行緒上時， [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) 會將訊息新增至視窗的訊息佇列，並等候視窗處理該訊息。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-182">When the message pump and SendMessage are on different threads, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) adds a message to the window's message queue, and waits for the window to process that message.</span></span> <span data-ttu-id="2bdd3-183">如果視窗程式忙碌或不是由訊息抽取呼叫，訊息可能永遠不會被處理，而 DXGI 將會無限期等候。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-183">If the window procedure is busy or is not called by the message pump, the message may never get processed and DXGI will wait indefinitely.</span></span>

<span data-ttu-id="2bdd3-184">例如，如果應用程式在某個執行緒上具有訊息提取，並在另一個執行緒上轉譯，則可能會想要變更模式。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-184">For example, if an application that has its message pump on one thread and its rendering on another, it may want to change modes.</span></span> <span data-ttu-id="2bdd3-185">訊息泵執行緒會告知轉譯執行緒變更模式，並等候直到模式變更完成為止。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-185">The message pump thread tells the rendering thread to change modes, and waits until the mode change is complete.</span></span> <span data-ttu-id="2bdd3-186">不過，轉譯執行緒會呼叫 DXGI 函式，然後再呼叫 [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage)，以封鎖直到訊息提取處理訊息為止。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-186">However, the rendering thread calls DXGI functions, which in turn call [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), which blocks until the message pump processes the message.</span></span> <span data-ttu-id="2bdd3-187">發生鎖死的原因是兩個執行緒現在已被封鎖，而且正在等候彼此。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-187">A deadlock occurs because both threads now are blocked, and are waiting on each other.</span></span> <span data-ttu-id="2bdd3-188">若要避免這種情況，絕對不會封鎖訊息提取。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-188">To avoid this, never block the message pump.</span></span> <span data-ttu-id="2bdd3-189">如果無法避免區塊，則所有的 DXGI 互動都應該在與訊息提取相同的執行緒上進行。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-189">If a block is unavoidable, then all DXGI interaction should occur on the same thread as the message pump.</span></span>

## <a name="gamma-and-dxgi"></a><span data-ttu-id="2bdd3-190">Gamma 和 DXGI</span><span class="sxs-lookup"><span data-stu-id="2bdd3-190">Gamma and DXGI</span></span>

<span data-ttu-id="2bdd3-191">雖然在 Direct3D 10. x 或 Direct3D 11. x 中最好使用 SRGB 紋理來處理 gamma，否則，如果開發人員想要使用不同的 gamma 值而不是2.2，或使用不支援 SRGB 的轉譯目標格式，則 gamma 會變得很有用。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-191">Although gamma may be best handled in Direct3D 10.x or Direct3D 11.x by using SRGB textures, the gamma ramp still can be useful to developers who want a different gamma value than 2.2 or who are using a render target format that does not support SRGB.</span></span> <span data-ttu-id="2bdd3-192">當您透過 DXGI 設定 gamma 曲線時，請注意兩個問題。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-192">Be aware of two issues when setting the gamma ramp through DXGI.</span></span> <span data-ttu-id="2bdd3-193">第一個問題是，傳遞至 [**IDXGIOutput：： SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) 的遞增值是 float 值，而不是 **文字** 值。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-193">The first issue is that the ramp values passed into [**IDXGIOutput::SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) are float values, not **WORD** values.</span></span> <span data-ttu-id="2bdd3-194">此外，請確定從 Direct3D 9 移植的程式碼在將這些值傳遞至 **SetGammaControl** 之前，不會嘗試轉換成 **文字** 值。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-194">Also, ensure that code ported from Direct3D 9 does not try to convert to **WORD** values before passing these to **SetGammaControl**.</span></span>

<span data-ttu-id="2bdd3-195">第二個問題是，在變更為全螢幕模式之後， [**SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) 可能不會運作，相依于所使用的 [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) 物件。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-195">The second issue is that, after changing to full-screen mode, [**SetGammaControl**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) may not appear to work, dependent on the [**IDXGIOutput**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) object being used.</span></span> <span data-ttu-id="2bdd3-196">當變更為全螢幕模式時，DXGI 會建立新的輸出物件，並針對輸出上的所有後續作業使用物件。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-196">When changing to full-screen mode, DXGI creates a new output object, and uses the object for all subsequent operations on the output.</span></span> <span data-ttu-id="2bdd3-197">如果在全螢幕模式切換之前所列舉的輸出上呼叫 **SetGammaControl** ，則不會將呼叫導向至 DXGI 目前使用的輸出。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-197">If calling **SetGammaControl** on an output that is enumerated before a full-screen mode switch, the call is not directed toward the output that DXGI is using currently.</span></span> <span data-ttu-id="2bdd3-198">若要避免這個問題，請呼叫 [**IDXGISwapChain：： GetContainingOutput**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-getcontainingoutput) 來取得目前的輸出，然後呼叫此輸出的 **SetGammaControl** 來取得正確的行為。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-198">To avoid this, call [**IDXGISwapChain::GetContainingOutput**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-getcontainingoutput) to get the current output, and then call **SetGammaControl** off this output to get the correct behavior.</span></span>

<span data-ttu-id="2bdd3-199">如需使用 gamma 更正的詳細資訊，請參閱 [使用 gamma 修正](/windows/desktop/direct3ddxgi/using-gamma-correction)。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-199">For info about using gamma correction, see [Using gamma correction](/windows/desktop/direct3ddxgi/using-gamma-correction).</span></span>

## <a name="dxgi-11"></a><span data-ttu-id="2bdd3-200">DXGI 1。1</span><span class="sxs-lookup"><span data-stu-id="2bdd3-200">DXGI 1.1</span></span>

<span data-ttu-id="2bdd3-201">Windows 7 中包含的 Direct3D 11 執行時間，並安裝到 Windows Vista (請參閱 [KB971644](https://support.microsoft.com/kb/971644)) 包含1.1 版的 DXGI。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-201">The Direct3D 11 runtime included in Windows 7 and installed onto Windows Vista (see [KB971644](https://support.microsoft.com/kb/971644)) includes version 1.1 of DXGI.</span></span> <span data-ttu-id="2bdd3-202">這項更新會新增許多新格式的定義 (特別是 BGRA、10位 X2 偏差和 Direct3D 11 的 BC6H 和 BC7 材質壓縮) ，以及新版本的 DXGI factory 和介面卡介面 ([**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1)、 [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1)、 [**IDXGIAdapter1**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter1)) 以列舉遠端桌面連線。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-202">This update adds definitions for a number of new formats (particularly BGRA, 10-bit X2 bias, and Direct3D 11's BC6H and BC7 texture compression), as well as a new version of the DXGI factory and adapter interfaces ([**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1), [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1), [**IDXGIAdapter1**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter1)) for enumerating remote desktop connections.</span></span>

<span data-ttu-id="2bdd3-203">使用 Direct3D 11 時，執行時間預設會在使用 Null [**IDXGIAdapter**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter)指標呼叫 [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice)或 [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain)時，使用 DXGI 1.1。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-203">When you use Direct3D 11, the runtime will use DXGI 1.1 by default when calling [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) or [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) with a NULL [**IDXGIAdapter**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter) pointer.</span></span> <span data-ttu-id="2bdd3-204">不支援在相同的進程中混合使用 DXGI 1.0 和 DXGI 1.1。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-204">Mixing use of DXGI 1.0 and DXGI 1.1 in the same process is not supported.</span></span> <span data-ttu-id="2bdd3-205">也不支援在相同的進程中混合來自不同 factory 的 DXGI 物件實例。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-205">Mixing DXGI object instances from different factories in the same process also is not supported.</span></span> <span data-ttu-id="2bdd3-206">因此，當您使用 DirectX 11 時，任何明確使用的 DXGI 介面都會使用「DXGI.DLL」中 [**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1)進入點所建立的 [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1) ，以確保應用程式一律使用 DXGI 1.1。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-206">Therefore, when you use DirectX 11, any explicit use of the DXGI interfaces uses a [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1) created by the [**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1) entry-point in “DXGI.DLL” to ensure the application is always using DXGI 1.1.</span></span>

## <a name="dxgi-12"></a><span data-ttu-id="2bdd3-207">DXGI 1。2</span><span class="sxs-lookup"><span data-stu-id="2bdd3-207">DXGI 1.2</span></span>

<span data-ttu-id="2bdd3-208">Windows 8 中包含的 Direct3D 11.1 執行時間也包含了 DXGI 的1.2 版。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-208">The Direct3D 11.1 runtime that is included in Windows 8 also includes version 1.2 of DXGI.</span></span>

<span data-ttu-id="2bdd3-209">DXGI 1.2 會啟用下列功能：</span><span class="sxs-lookup"><span data-stu-id="2bdd3-209">DXGI 1.2 enables these features:</span></span>

-   <span data-ttu-id="2bdd3-210">身歷聲轉譯</span><span class="sxs-lookup"><span data-stu-id="2bdd3-210">stereo rendering</span></span>
-   <span data-ttu-id="2bdd3-211">每圖元16個位元組格式</span><span class="sxs-lookup"><span data-stu-id="2bdd3-211">16 bit-per-pixel formats</span></span>

    -   <span data-ttu-id="2bdd3-212">\_ \_ \_ 現在完全支援 dxgi 格式 B5G6R5 UNORM 和 dxgi \_ 格式 \_ \_ 的 B5G5R5A1 UNORM</span><span class="sxs-lookup"><span data-stu-id="2bdd3-212">DXGI\_FORMAT\_B5G6R5\_UNORM and DXGI\_FORMAT\_B5G5R5A1\_UNORM are now fully supported</span></span>
    -   <span data-ttu-id="2bdd3-213">已新增新的 DXGI \_ 格式 \_ B5G5R5A1 \_ UNORM 格式</span><span class="sxs-lookup"><span data-stu-id="2bdd3-213">a new DXGI\_FORMAT\_B5G5R5A1\_UNORM format was added</span></span>

-   <span data-ttu-id="2bdd3-214">影片格式</span><span class="sxs-lookup"><span data-stu-id="2bdd3-214">video formats</span></span>
-   <span data-ttu-id="2bdd3-215">新的 DXGI 介面</span><span class="sxs-lookup"><span data-stu-id="2bdd3-215">new DXGI interfaces</span></span>

<span data-ttu-id="2bdd3-216">如需有關 DXGI 1.2 功能的詳細資訊，請參閱 [dxgi 1.2 增強](/windows/desktop/direct3ddxgi/dxgi-1-2-improvements)功能。</span><span class="sxs-lookup"><span data-stu-id="2bdd3-216">For more info about DXGI 1.2 features, see [DXGI 1.2 Improvements](/windows/desktop/direct3ddxgi/dxgi-1-2-improvements).</span></span>

 

 