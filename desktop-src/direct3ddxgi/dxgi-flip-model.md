---
description: Windows 8 在 DXGI 1.2 中新增對 flip 展示模型及其相關聯的目前統計資料的支援。
ms.assetid: E132DAF5-80B7-4C52-A760-3779CC140CE7
title: DXGI 翻轉模型
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 49ee82febd13a3b57a06d93fd01eb8d230d6b78a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/06/2021
ms.locfileid: "103846404"
---
# <a name="dxgi-flip-model"></a><span data-ttu-id="f1235-103">DXGI 翻轉模型</span><span class="sxs-lookup"><span data-stu-id="f1235-103">DXGI flip model</span></span>

<span data-ttu-id="f1235-104">Windows 8 在 DXGI 1.2 中新增對 flip 展示模型及其相關聯的目前統計資料的支援。</span><span class="sxs-lookup"><span data-stu-id="f1235-104">Windows 8 adds support for flip presentation model and its associated present statistics in DXGI 1.2.</span></span> <span data-ttu-id="f1235-105">Windows 8 的 DXGI 翻轉表示模型類似于 Windows 7 的 [DIRECT3D 9EX 翻轉模式展示](../direct3darticles/direct3d-9ex-improvements.md)。</span><span class="sxs-lookup"><span data-stu-id="f1235-105">Windows 8’s DXGI flip presentation model is similar to Windows 7’s [Direct3D 9EX Flip Mode Presentation](../direct3darticles/direct3d-9ex-improvements.md).</span></span> <span data-ttu-id="f1235-106">以影片或畫面播放速率為基礎的展示應用程式（例如遊戲）可以利用翻轉簡報模型來獲益。</span><span class="sxs-lookup"><span data-stu-id="f1235-106">Video or frame rate-based presentation apps such as games can benefit most by using flip presentation model.</span></span> <span data-ttu-id="f1235-107">使用 DXGI 反轉展示模型的應用程式可降低系統資源的載入並提升效能。</span><span class="sxs-lookup"><span data-stu-id="f1235-107">Apps that use DXGI flip presentation model reduce the system resource load and increase performance.</span></span> <span data-ttu-id="f1235-108">應用程式也可以透過提供即時意見反應和修正機制，使用目前的統計資料增強功能搭配翻轉展示模型，更有效地控制簡報率。</span><span class="sxs-lookup"><span data-stu-id="f1235-108">Apps can also use present statistics enhancements with flip presentation model to better control the rate of presentation by providing real-time feedback and correction mechanisms.</span></span>

-   [<span data-ttu-id="f1235-109">比較 DXGI 翻轉模型和 BitBlt 模型</span><span class="sxs-lookup"><span data-stu-id="f1235-109">Comparing the DXGI flip model and the BitBlt model</span></span>](#comparing-the-dxgi-flip-model-and-the-bitblt-model)
-   [<span data-ttu-id="f1235-110">如何使用 DXGI 翻轉模型</span><span class="sxs-lookup"><span data-stu-id="f1235-110">How to use DXGI flip model</span></span>](#how-to-use-dxgi-flip-model)
-   [<span data-ttu-id="f1235-111">DXGI 翻轉模型應用程式的框架同步處理</span><span class="sxs-lookup"><span data-stu-id="f1235-111">Frame synchronization of DXGI flip model apps</span></span>](#frame-synchronization-of-dxgi-flip-model-apps)
-   [<span data-ttu-id="f1235-112">避免、偵測和從問題中復原</span><span class="sxs-lookup"><span data-stu-id="f1235-112">Avoiding, detecting, and recovering from glitches</span></span>](#avoiding-detecting-and-recovering-from-glitches)
-   [<span data-ttu-id="f1235-113">相關主題</span><span class="sxs-lookup"><span data-stu-id="f1235-113">Related topics</span></span>](#related-topics)

## <a name="comparing-the-dxgi-flip-model-and-the-bitblt-model"></a><span data-ttu-id="f1235-114">比較 DXGI 翻轉模型和 BitBlt 模型</span><span class="sxs-lookup"><span data-stu-id="f1235-114">Comparing the DXGI flip model and the BitBlt model</span></span>

<span data-ttu-id="f1235-115">執行時間會使用位區塊傳輸 (bitblt) 並翻轉簡報模型，以在顯示監視器上顯示圖形內容。</span><span class="sxs-lookup"><span data-stu-id="f1235-115">The runtime uses the bit-block transfer (bitblt) and flip presentation models to present graphics content on display monitors.</span></span> <span data-ttu-id="f1235-116">Bitblt 和翻轉展示模型之間的最大差異，在於背景緩衝區內容如何取得 Windows 8 DWM 以進行組合。</span><span class="sxs-lookup"><span data-stu-id="f1235-116">The biggest difference between bitblt and flip presentation models is how back-buffer contents get to the Windows 8 DWM for composition.</span></span> <span data-ttu-id="f1235-117">在 bitblt 模型中，會在每次呼叫 IDXGISwapChain1 時，將背景緩衝區的內容複寫到重新導向介面 [**：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)。</span><span class="sxs-lookup"><span data-stu-id="f1235-117">In the bitblt model, contents of the back buffer are copied into the redirection surface on each call to [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1).</span></span> <span data-ttu-id="f1235-118">在反轉模型中，所有背景緩衝區都會與桌面視窗管理員 (DWM) 共用。</span><span class="sxs-lookup"><span data-stu-id="f1235-118">In the flip model, all back buffers are shared with the Desktop Window Manager (DWM).</span></span> <span data-ttu-id="f1235-119">因此，DWM 可以直接從這些背景緩衝區中撰寫，而不需要任何額外的複製作業。</span><span class="sxs-lookup"><span data-stu-id="f1235-119">Therefore, the DWM can compose straight from those back buffers without any additional copy operations.</span></span> <span data-ttu-id="f1235-120">一般而言，翻轉模型較有效率。</span><span class="sxs-lookup"><span data-stu-id="f1235-120">In general, the flip model is more efficient.</span></span> <span data-ttu-id="f1235-121">翻轉模型也提供更多功能，例如增強的目前統計資料。</span><span class="sxs-lookup"><span data-stu-id="f1235-121">The flip model also provides more features, such as enhanced present statistics.</span></span>

<span data-ttu-id="f1235-122">如果您有使用 Windows 圖形裝置介面 (GDI) 直接寫入 [**HWND**](../winprog/windows-data-types.md) 的舊版元件，請使用 bitblt 模型。</span><span class="sxs-lookup"><span data-stu-id="f1235-122">If you have legacy components that use Windows Graphics Device Interface (GDI) to write to an [**HWND**](../winprog/windows-data-types.md) directly, use the bitblt model.</span></span>

<span data-ttu-id="f1235-123">當應用程式處於視窗模式時，DXGI 翻轉模型的效能改進相當重要。</span><span class="sxs-lookup"><span data-stu-id="f1235-123">Performance improvements of DXGI flip model are significant when the app is in windowed mode.</span></span> <span data-ttu-id="f1235-124">此表格中的順序和圖例比較記憶體頻寬的使用方式，以及選擇翻轉模型與 bitblt 模型的視窗化應用程式的系統讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="f1235-124">The sequence in this table and the illustration compare memory bandwidth usages and system reads and writes of windowed apps that choose flip model versus the bitblt model.</span></span>



| <span data-ttu-id="f1235-125">步驟</span><span class="sxs-lookup"><span data-stu-id="f1235-125">Step</span></span> | <span data-ttu-id="f1235-126">BitBlt 模型存在於 DWM</span><span class="sxs-lookup"><span data-stu-id="f1235-126">BitBlt model present to DWM</span></span>                                                                               | <span data-ttu-id="f1235-127">對 DWM 呈現的 DXGI 反轉模型</span><span class="sxs-lookup"><span data-stu-id="f1235-127">DXGI flip model present to DWM</span></span>                                   |
|------|-----------------------------------------------------------------------------------------------------------|------------------------------------------------------------------|
| <span data-ttu-id="f1235-128">1.</span><span class="sxs-lookup"><span data-stu-id="f1235-128">1.</span></span>   | <span data-ttu-id="f1235-129">應用程式會更新其框架 (寫入) </span><span class="sxs-lookup"><span data-stu-id="f1235-129">The app updates its frame (Write)</span></span><br/>                                                              | <span data-ttu-id="f1235-130">應用程式會更新其框架 (寫入) </span><span class="sxs-lookup"><span data-stu-id="f1235-130">The app updates its frame (Write)</span></span><br/>                     |
| <span data-ttu-id="f1235-131">2.</span><span class="sxs-lookup"><span data-stu-id="f1235-131">2.</span></span>   | <span data-ttu-id="f1235-132">Direct3D runtime 會將介面內容複寫到 DWM 重新導向介面 (讀取、寫入) </span><span class="sxs-lookup"><span data-stu-id="f1235-132">Direct3D runtime copies surface contents to a DWM redirection surface (Read, Write)</span></span><br/>            | <span data-ttu-id="f1235-133">Direct3D runtime 將應用程式介面傳遞至 DWM</span><span class="sxs-lookup"><span data-stu-id="f1235-133">Direct3D runtime passes the app surface to DWM</span></span><br/>        |
| <span data-ttu-id="f1235-134">3.</span><span class="sxs-lookup"><span data-stu-id="f1235-134">3.</span></span>   | <span data-ttu-id="f1235-135">共用的表面複製完成之後，DWM 會將應用程式介面轉譯至螢幕 (讀取、寫入) </span><span class="sxs-lookup"><span data-stu-id="f1235-135">After the shared surface copy completes, DWM renders the app surface onto screen (Read, Write)</span></span><br/> | <span data-ttu-id="f1235-136">DWM 會將應用程式介面轉譯至螢幕 (讀取、寫入) </span><span class="sxs-lookup"><span data-stu-id="f1235-136">DWM renders the app surface onto screen (Read, Write)</span></span><br/> |



 

![比較 blt 模型和翻轉模型的圖例](images/blt-flip-mode-present.png)

<span data-ttu-id="f1235-138">Flip 模型藉由針對 DWM 的視窗化框架組合，減少 Direct3D runtime 的讀取和寫入次數，以減少系統記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="f1235-138">Flip model reduces system memory usage by reducing the number of reads and writes by the Direct3D runtime for the windowed frame composition by DWM.</span></span>

## <a name="how-to-use-dxgi-flip-model"></a><span data-ttu-id="f1235-139">如何使用 DXGI 翻轉模型</span><span class="sxs-lookup"><span data-stu-id="f1235-139">How to use DXGI flip model</span></span>

<span data-ttu-id="f1235-140">以 Windows 8 為目標的 Direct3D 11.1 應用程式會藉由建立具有 [**dxgi \_ 交換 \_ 效果 \_ \_**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect)的交換鏈，以反轉在 [**dxgi \_ 交換 \_ 鏈 \_ DESC1**](/windows/desktop/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1)結構的 **SwapEffect** 成員中設定的連續列舉值，來使用 flip 模型。</span><span class="sxs-lookup"><span data-stu-id="f1235-140">Direct3D 11.1 apps that target Windows 8 use flip model by creating the swap chain with the [**DXGI\_SWAP\_EFFECT\_FLIP\_SEQUENTIAL**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect) enumeration value set in the **SwapEffect** member of the [**DXGI\_SWAP\_CHAIN\_DESC1**](/windows/desktop/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1) structure.</span></span> <span data-ttu-id="f1235-141">當您將 **SwapEffect** 設定為 [ **dxgi \_ 交換 \_ 效果] \_ 反向 \_** 時，也請將 [ **dxgi \_ 交換 \_ 鏈 \_ DESC1** ] 的這些成員設定為指定的值：</span><span class="sxs-lookup"><span data-stu-id="f1235-141">When you set **SwapEffect** to **DXGI\_SWAP\_EFFECT\_FLIP\_SEQUENTIAL**, also set these members of **DXGI\_SWAP\_CHAIN\_DESC1** to the indicated values:</span></span>

-   <span data-ttu-id="f1235-142">**BufferCount** 至介於2到16之間的值，以避免因為等待 DWM 釋出先前的展示緩衝區而導致效能下降。</span><span class="sxs-lookup"><span data-stu-id="f1235-142">**BufferCount** to a value between 2 and 16 to prevent a performance penalty as a result of waiting on DWM to release the previous presentation buffer.</span></span>
-   <span data-ttu-id="f1235-143">將格式 **設定** 為 DXGI \_ 格式 \_ R16G16B16A16 \_ FLOAT、DXGI \_ format \_ B8G8R8A8 \_ UNORM 或 dxgi \_ format \_ R8G8B8A8 \_ UNORM</span><span class="sxs-lookup"><span data-stu-id="f1235-143">**Format** to DXGI\_FORMAT\_R16G16B16A16\_FLOAT, DXGI\_FORMAT\_B8G8R8A8\_UNORM, or DXGI\_FORMAT\_R8G8B8A8\_UNORM</span></span>
-   <span data-ttu-id="f1235-144">**SampleDesc** 成員所指定之 [**dxgi 範例 \_ \_ desc**](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_sample_desc)結構的 **計數\*\*\*\*成員，** 因為不支援多個範例消除鋸齒 (MSAA) **\_ \_**</span><span class="sxs-lookup"><span data-stu-id="f1235-144">**Count** member of the [**DXGI\_SAMPLE\_DESC**](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_sample_desc) structure that the **SampleDesc** member specifies to one and the **Quality** member of **DXGI\_SAMPLE\_DESC** to zero because multiple sample antialiasing (MSAA) is not supported</span></span>

<span data-ttu-id="f1235-145">如果您在 Windows 7 或更早版本的作業系統上使用 [**DXGI \_ 交換 \_ 效果 \_ 反轉 \_**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect) ，則裝置建立會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1235-145">If you use [**DXGI\_SWAP\_EFFECT\_FLIP\_SEQUENTIAL**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect) on Windows 7 or earlier operating system, device creation fails.</span></span> <span data-ttu-id="f1235-146">當您使用翻轉模型時，您可以在視窗模式中使用全螢幕的顯示統計資料。</span><span class="sxs-lookup"><span data-stu-id="f1235-146">When you use flip model, you can use full-screen present statistics in windowed mode.</span></span> <span data-ttu-id="f1235-147">全螢幕的行為不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="f1235-147">Full-screen behavior is not affected.</span></span> <span data-ttu-id="f1235-148">如果您將 **Null** 傳遞給視窗型交換鏈的 [**IDXGIFactory2：： CreateSwapChainForHwnd**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgifactory2-createswapchainforhwnd)的 *PFullscreenDesc* 參數，並將 **SwapEffect** 設定為 **DXGI \_ 交換效果的 \_ \_ \_ 順序**，則執行時間會建立一個額外的背景緩衝區，並將任何控制碼都轉換成在呈現時成為前端緩衝區的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f1235-148">If you pass **NULL** to the *pFullscreenDesc* parameter of [**IDXGIFactory2::CreateSwapChainForHwnd**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgifactory2-createswapchainforhwnd) for a windowed swap chain and set **SwapEffect** to **DXGI\_SWAP\_EFFECT\_FLIP\_SEQUENTIAL**, the runtime creates one extra back buffer and rotates whichever handle belongs to the buffer that becomes the front buffer at presentation time.</span></span>

<span data-ttu-id="f1235-149">當您使用 flip 模型時，請考慮下列秘訣：</span><span class="sxs-lookup"><span data-stu-id="f1235-149">When you use flip model, consider these tips:</span></span>

-   <span data-ttu-id="f1235-150">每個 [**HWND**](../winprog/windows-data-types.md)使用一個翻轉模型交換鏈。</span><span class="sxs-lookup"><span data-stu-id="f1235-150">Use one flip model swap chain per [**HWND**](../winprog/windows-data-types.md).</span></span> <span data-ttu-id="f1235-151">請勿將多個翻轉模型交換鏈的目標設為相同的 **HWND**。</span><span class="sxs-lookup"><span data-stu-id="f1235-151">Do not target multiple flip model swap chains to the same **HWND**.</span></span>
-   <span data-ttu-id="f1235-152">請勿搭配 GDI 的 [**ScrollWindow**](/windows/win32/api/winuser/nf-winuser-scrollwindow) 或 [**ScrollWindowEx**](/windows/win32/api/winuser/nf-winuser-scrollwindowex) 函式使用翻轉模型交換鏈。</span><span class="sxs-lookup"><span data-stu-id="f1235-152">Do not use flip model swap chain with GDI's [**ScrollWindow**](/windows/win32/api/winuser/nf-winuser-scrollwindow) or [**ScrollWindowEx**](/windows/win32/api/winuser/nf-winuser-scrollwindowex) function.</span></span> <span data-ttu-id="f1235-153">某些 Direct3D 應用程式會在使用者滾動事件發生後，使用 GDI 的 **ScrollWindow** 和 **ScrollWindowEx** 函數來更新視窗內容。</span><span class="sxs-lookup"><span data-stu-id="f1235-153">Some Direct3D apps use GDI's **ScrollWindow** and **ScrollWindowEx** functions to update window contents after a user scroll event occurs.</span></span> <span data-ttu-id="f1235-154">**ScrollWindow** 和 **ScrollWindowEx** 會在使用者滾動視窗時，在螢幕上執行視窗內容的 bitblts。</span><span class="sxs-lookup"><span data-stu-id="f1235-154">**ScrollWindow** and **ScrollWindowEx** perform bitblts of window contents on screen as the user scrolls a window.</span></span> <span data-ttu-id="f1235-155">這些函式也需要 GDI 和 Direct3D 內容的 bitblt 模型更新。</span><span class="sxs-lookup"><span data-stu-id="f1235-155">These functions also require bitblt model updates for GDI and Direct3D content.</span></span> <span data-ttu-id="f1235-156">當應用程式處於視窗模式時，使用任一功能的應用程式不一定會在螢幕上顯示可見的視窗內容滾動。</span><span class="sxs-lookup"><span data-stu-id="f1235-156">Apps that use either function will not necessarily display visible window contents scrolling on screen when the app is in windowed mode.</span></span> <span data-ttu-id="f1235-157">我們建議您不要使用 GDI 的 **ScrollWindow** 和 **ScrollWindowEx** 函式，而是改為在螢幕上重新繪製 gdi 和 Direct3D 內容以回應滾動。</span><span class="sxs-lookup"><span data-stu-id="f1235-157">We recommend that you not use GDI's **ScrollWindow** and **ScrollWindowEx** functions, and instead redraw GDI and Direct3D contents on screen in response to scrolling.</span></span>
-   <span data-ttu-id="f1235-158">在不是其他 Api （包括 DXGI bitblt 展示模型、其他版本的 Direct3D 或 GDI）的 [**HWND**](../winprog/windows-data-types.md) 中使用翻轉模型。</span><span class="sxs-lookup"><span data-stu-id="f1235-158">Use flip model in an [**HWND**](../winprog/windows-data-types.md) that is not also targeted by other APIs, including DXGI bitblt presentation model, other versions of Direct3D, or GDI.</span></span> <span data-ttu-id="f1235-159">因為 bitblt 模型會維護一個額外的介面複本，所以您可以透過 Direct3D 和 GDI 的分次更新，將 GDI 和其他 Direct3D 內容新增至相同的 **HWND** 。</span><span class="sxs-lookup"><span data-stu-id="f1235-159">Because bitblt model maintains an additional copy of the surface, you can add GDI and other Direct3D contents to the same **HWND** through piecemeal updates from Direct3D and GDI.</span></span> <span data-ttu-id="f1235-160">當您使用翻轉模型時，只會看到執行時間傳遞給 DWM 之翻轉模型交換鏈中的 Direct3D 內容。</span><span class="sxs-lookup"><span data-stu-id="f1235-160">When you use the flip model, only Direct3D content in flip model swap chains that the runtime passes to DWM are visible.</span></span> <span data-ttu-id="f1235-161">執行時間會忽略所有其他 bitblt 模型 Direct3D 或 GDI 內容更新。</span><span class="sxs-lookup"><span data-stu-id="f1235-161">The runtime ignores all other bitblt model Direct3D or GDI content updates.</span></span>

## <a name="frame-synchronization-of-dxgi-flip-model-apps"></a><span data-ttu-id="f1235-162">DXGI 翻轉模型應用程式的框架同步處理</span><span class="sxs-lookup"><span data-stu-id="f1235-162">Frame synchronization of DXGI flip model apps</span></span>

<span data-ttu-id="f1235-163">目前的統計資料是媒體應用程式用來同步處理影片和音訊串流以及從影片播放問題復原的畫面格時間資訊。</span><span class="sxs-lookup"><span data-stu-id="f1235-163">Present statistics are frame-timing information that media apps use to synchronize video and audio streams and recover from video playback glitches.</span></span> <span data-ttu-id="f1235-164">應用程式可以使用目前統計資料中的畫面格時間資訊，來調整其影片畫面的呈現率，以提供更流暢的簡報。</span><span class="sxs-lookup"><span data-stu-id="f1235-164">Apps can use the frame-timing information in present statistics to adjust the presentation rate of their video frames for smoother presentation.</span></span> <span data-ttu-id="f1235-165">若要取得目前的統計資料資訊，請呼叫 [**IDXGISwapChain：： GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics) 方法以取得 [**DXGI \_ 框架 \_ 統計資料**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics) 結構。</span><span class="sxs-lookup"><span data-stu-id="f1235-165">To obtain present statistics information, call the [**IDXGISwapChain::GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics) method to obtain the [**DXGI\_FRAME\_STATISTICS**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics) structure.</span></span> <span data-ttu-id="f1235-166">**DXGI \_畫面格 \_ 統計資料** 報含 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) 呼叫的相關統計資料。</span><span class="sxs-lookup"><span data-stu-id="f1235-166">**DXGI\_FRAME\_STATISTICS** contains statistics about [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) calls.</span></span> <span data-ttu-id="f1235-167">翻轉模型交換鏈會以視窗模式和全螢幕模式提供目前的統計資料資訊。</span><span class="sxs-lookup"><span data-stu-id="f1235-167">A flip model swap chain provides present statistics information in both windowed and full-screen modes.</span></span> <span data-ttu-id="f1235-168">若為視窗模式中的 bitblt 模型交換鏈，所有的 **DXGI \_ 框架 \_ 統計資料** 值都是零。</span><span class="sxs-lookup"><span data-stu-id="f1235-168">For bitblt model swap chains in windowed mode, all **DXGI\_FRAME\_STATISTICS** values are zeroes.</span></span>

<span data-ttu-id="f1235-169">若為 flip 模型目前的統計資料， [**IDXGISwapChain：： GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics) 會在這些情況下傳回非 **\_ 交集的錯誤 \_ 框架 \_ 統計資料 \_** ：</span><span class="sxs-lookup"><span data-stu-id="f1235-169">For flip model present statistics, [**IDXGISwapChain::GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics) returns **DXGI\_ERROR\_FRAME\_STATISTICS\_DISJOINT** in these situations:</span></span>

-   <span data-ttu-id="f1235-170">第一次呼叫 [**GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics)，表示序列的開頭</span><span class="sxs-lookup"><span data-stu-id="f1235-170">First call to [**GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics), which indicates the beginning of a sequence</span></span>
-   <span data-ttu-id="f1235-171">模式變更：以視窗模式切換至全螢幕或全螢幕到全螢幕轉換</span><span class="sxs-lookup"><span data-stu-id="f1235-171">Mode change: either windowed mode to or from full screen or full screen to full screen transitions</span></span>

<span data-ttu-id="f1235-172">[**DXGI \_ 框架 \_ 統計資料**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics)的 **PresentRefreshCount**、 **SyncRefreshCount** 和 **SyncQPCTime** 成員中的值具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="f1235-172">The values in **PresentRefreshCount**, **SyncRefreshCount**, and **SyncQPCTime** members of [**DXGI\_FRAME\_STATISTICS**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics) have the following characteristics:</span></span>

-   <span data-ttu-id="f1235-173">當應用程式在每個 vsync 上呈現時， **PresentRefreshCount** 等於 **SyncRefreshCount** 。</span><span class="sxs-lookup"><span data-stu-id="f1235-173">**PresentRefreshCount** is equal to **SyncRefreshCount** when the app presents on every vsync.</span></span>
-   <span data-ttu-id="f1235-174">當提交目前的時間時，會在 vsync 間隔取得 **SyncRefreshCount** ， **SyncQPCTime** 大約是與 vsync 間隔相關聯的時間。</span><span class="sxs-lookup"><span data-stu-id="f1235-174">**SyncRefreshCount** is obtained on the vsync interval when the present was submitted, **SyncQPCTime** is approximately the time associated with the vsync interval.</span></span>

<span data-ttu-id="f1235-175">[**IDXGISwapChain：： GetLastPresentCount**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getlastpresentcount)方法會傳回最後一個最新的計數，也就是與交換鏈相關聯之顯示裝置所進行的最後一個成功 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)呼叫的目前識別碼。</span><span class="sxs-lookup"><span data-stu-id="f1235-175">The [**IDXGISwapChain::GetLastPresentCount**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getlastpresentcount) method returns the last present count, that is, the present ID of the last successful [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) call made by a display device that is associated with the swap chain.</span></span> <span data-ttu-id="f1235-176">此存在識別碼是 [**DXGI \_ 框架 \_ 統計資料**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics)結構的 **PresentCount** 成員的值。</span><span class="sxs-lookup"><span data-stu-id="f1235-176">This present ID is the value of the **PresentCount** member of the [**DXGI\_FRAME\_STATISTICS**](/windows/desktop/api/DXGI/ns-dxgi-dxgi_frame_statistics) structure.</span></span> <span data-ttu-id="f1235-177">針對 bitblt 模型交換鏈，在視窗模式中，所有的 **DXGI \_ 框架 \_ 統計資料** 值都是零。</span><span class="sxs-lookup"><span data-stu-id="f1235-177">For bitblt model swap chains, while in windowed mode, all **DXGI\_FRAME\_STATISTICS** values are zeroes.</span></span>

## <a name="avoiding-detecting-and-recovering-from-glitches"></a><span data-ttu-id="f1235-178">避免、偵測和從問題中復原</span><span class="sxs-lookup"><span data-stu-id="f1235-178">Avoiding, detecting, and recovering from glitches</span></span>

<span data-ttu-id="f1235-179">執行這些步驟，以避免、偵測和復原框架簡報中的問題：</span><span class="sxs-lookup"><span data-stu-id="f1235-179">Perform these steps to avoid, detect, and recover from glitches in frame presentation:</span></span>

1.  <span data-ttu-id="f1235-180">佇列 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) (呼叫，也就是呼叫 **IDXGISwapChain1：:P resent1** 多次，這會導致它們在佇列) 中收集。</span><span class="sxs-lookup"><span data-stu-id="f1235-180">Queue [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) calls (that is, call **IDXGISwapChain1::Present1** multiple times, which causes them to collect in a queue).</span></span>
2.  <span data-ttu-id="f1235-181">建立目前的佇列結構來儲存所有成功提交的 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)的目前識別碼 (由 [**IDXGISwapChain：： GetLastPresentCount**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getlastpresentcount) 傳回) 以及相關聯的計算/預期 **PresentRefreshCount** 值。</span><span class="sxs-lookup"><span data-stu-id="f1235-181">Create a present-queue structure to store all successfully submitted [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)'s present ID (returned by [**IDXGISwapChain::GetLastPresentCount**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getlastpresentcount)) and associated, calculated/expected **PresentRefreshCount** values.</span></span>
3.  <span data-ttu-id="f1235-182">若要偵測出問題：</span><span class="sxs-lookup"><span data-stu-id="f1235-182">To detect a glitch:</span></span>

    -   <span data-ttu-id="f1235-183">呼叫 [**IDXGISwapChain：： GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics)。</span><span class="sxs-lookup"><span data-stu-id="f1235-183">Call [**IDXGISwapChain::GetFrameStatistics**](/windows/desktop/api/DXGI/nf-dxgi-idxgiswapchain-getframestatistics).</span></span>
    -   <span data-ttu-id="f1235-184">針對此框架，請取得 (**PresentCount**) 和 vsync 計數的目前識別碼，其中作業系統會將最後一個影像呈現給監視器 (**PresentRefreshCount**) 。</span><span class="sxs-lookup"><span data-stu-id="f1235-184">For this frame, get the present ID (**PresentCount**) and vsync count where the operating system presented the last image to the monitor (**PresentRefreshCount**).</span></span>
    -   <span data-ttu-id="f1235-185">取得與目前識別碼相關聯的預期 **PresentRefreshCount** ，以及您先前儲存在目前佇列結構中的識別碼。</span><span class="sxs-lookup"><span data-stu-id="f1235-185">Retrieve the expected **PresentRefreshCount** that is associated with the present ID and that you previously stored in the present-queue structure.</span></span>
    -   <span data-ttu-id="f1235-186">如果實際的 **PresentRefreshCount** 晚于預期的 **PresentRefreshCount**，就會發生問題。</span><span class="sxs-lookup"><span data-stu-id="f1235-186">If the actual **PresentRefreshCount** is later than the expected **PresentRefreshCount**, a glitch has occurred.</span></span>

4.  <span data-ttu-id="f1235-187">若要從問題中復原：</span><span class="sxs-lookup"><span data-stu-id="f1235-187">To recover from the glitch:</span></span>

    -   <span data-ttu-id="f1235-188">計算要跳到從問題中復原的畫面格數。</span><span class="sxs-lookup"><span data-stu-id="f1235-188">Calculate the number of frames to skip to recover from the glitch.</span></span> <span data-ttu-id="f1235-189">例如，如果步驟3顯示 () **PresentRefreshCount** 的預期 vsync 計數 (**PresentCount**) 為5，而目前識別碼的實際 vsync 計數是8，則要從問題中略過的畫面格數目是3個畫面格。</span><span class="sxs-lookup"><span data-stu-id="f1235-189">For example, if step 3 reveals that the expected vsync count (**PresentRefreshCount**) for a present ID (**PresentCount**) is 5 and the actual vsync count for the present ID is 8, the number of frames to skip to recover from the glitch is 3 frames.</span></span>
    -   <span data-ttu-id="f1235-190">將0傳遞給 IDXGISwapChain1 的呼叫次數 *SyncInterval* 參數 [**：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) ，以捨棄並略過此數目的畫面格。</span><span class="sxs-lookup"><span data-stu-id="f1235-190">Pass 0 to the *SyncInterval* parameter in this number of calls to [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) to discard and skip this number of frames.</span></span>

        > [!Note]  
        > <span data-ttu-id="f1235-191">如果問題是由大量的框架所組成，請呼叫 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) ，並將 *旗標* 參數設定為 [**DXGI \_ 存在 \_ 重新開機**](dxgi-present.md) ，以捨棄並略過所有未完成佇列的呈現。</span><span class="sxs-lookup"><span data-stu-id="f1235-191">If the glitch consists of a large number of frames, call [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) with the *Flags* parameter set to [**DXGI\_PRESENT\_RESTART**](dxgi-present.md) to discard and skip all outstanding queued presents.</span></span>

         

<span data-ttu-id="f1235-192">以下是從畫面格簡報中復原問題的範例案例：</span><span class="sxs-lookup"><span data-stu-id="f1235-192">Here is an example scenario of recovering from glitches in frame presentation:</span></span>

![在畫面格簡報中從問題中復原的範例案例圖例](images/frame-sync-glitch-recover.png)

<span data-ttu-id="f1235-194">在範例案例中，您預期畫面格 A 在 vsync 計數為1時進入螢幕。</span><span class="sxs-lookup"><span data-stu-id="f1235-194">In the example scenario, you expect frame A to go on screen on a vsync count of 1.</span></span> <span data-ttu-id="f1235-195">但是您實際上會偵測到畫面上顯示為4的 vsync 計數。</span><span class="sxs-lookup"><span data-stu-id="f1235-195">But you actually detect the vsync count that frame A appears on screen as 4.</span></span> <span data-ttu-id="f1235-196">因此，您可以判斷發生問題。</span><span class="sxs-lookup"><span data-stu-id="f1235-196">Therefore, you determine that a glitch occurred.</span></span> <span data-ttu-id="f1235-197">然後，您可以捨棄3個框架，也就是您可以將0傳遞給 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)的3個呼叫中的 *SyncInterval* 參數。</span><span class="sxs-lookup"><span data-stu-id="f1235-197">You can then discard 3 frames, that is, you can pass 0 to the *SyncInterval* parameter in 3 calls to [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1).</span></span> <span data-ttu-id="f1235-198">在上述範例案例中，若要從問題中復原，您需要總共8個 **IDXGISwapChain1：:P resent1** 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="f1235-198">In the preceding example scenario, to recover from the glitch, you need a total of 8 **IDXGISwapChain1::Present1** calls.</span></span> <span data-ttu-id="f1235-199">然後，會根據您預期的 vsync 計數來顯示第9個框架。</span><span class="sxs-lookup"><span data-stu-id="f1235-199">The 9th frame is then visible as per the vsync count that you expect.</span></span>

<span data-ttu-id="f1235-200">以下是簡報事件的時間表。</span><span class="sxs-lookup"><span data-stu-id="f1235-200">Here's a time line of presentation events.</span></span> <span data-ttu-id="f1235-201">每個垂直線都代表一個 vsync。</span><span class="sxs-lookup"><span data-stu-id="f1235-201">Each vertical line represents a vsync.</span></span> <span data-ttu-id="f1235-202">水準方向是時間，會增加到右邊。</span><span class="sxs-lookup"><span data-stu-id="f1235-202">The horizontal direction is time, which increases to the right.</span></span> <span data-ttu-id="f1235-203">您可以使用此圖來想像問題可能發生的情況。</span><span class="sxs-lookup"><span data-stu-id="f1235-203">You can use the figure to imagine how glitches can occur.</span></span>

![展示 eventsl 的時間行圖例](images/present-timeline.png)

<span data-ttu-id="f1235-205">下圖說明此順序：</span><span class="sxs-lookup"><span data-stu-id="f1235-205">The figure illustrates this sequence:</span></span>

1.  <span data-ttu-id="f1235-206">應用程式會在 vsync 上喚醒、轉譯藍色、呼叫 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)，然後回到睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="f1235-206">The app wakes up on vsync, renders blue, calls [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1), and then goes back to sleep.</span></span>
2.  <span data-ttu-id="f1235-207">圖形處理單元 (GPU) 從閒置喚醒、執行轉譯為藍色，然後返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="f1235-207">The graphics processing unit (GPU) wakes up from idle, performs the render to blue, and then goes back to sleep.</span></span>
3.  <span data-ttu-id="f1235-208">DWM 會在下一個 vsync 中喚醒，並在其背景緩衝區中組成藍色，呼叫 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)，然後回到睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="f1235-208">The DWM wakes up at the next vsync, composes blue into its back buffer, calls [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1), and then goes back to sleep.</span></span>
4.  <span data-ttu-id="f1235-209">應用程式會喚醒、呈現綠色、呼叫 [**IDXGISwapChain1：:P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)，然後回到睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="f1235-209">The app wakes up, renders green, calls [**IDXGISwapChain1::Present1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1), and then goes back to sleep.</span></span>
    > [!Note]  
    > <span data-ttu-id="f1235-210">當 GPU 執行藍色的組合時，應用程式會同時執行。</span><span class="sxs-lookup"><span data-stu-id="f1235-210">The app concurrently executes while the GPU performs the compose of blue.</span></span>

     

5.  <span data-ttu-id="f1235-211">接下來，GPU 會為應用程式呈現綠色。</span><span class="sxs-lookup"><span data-stu-id="f1235-211">Next, the GPU renders green for the app.</span></span>
6.  <span data-ttu-id="f1235-212">最後，數位到類比轉換器 (DAC) 在下一個 vsync 上顯示監視器上的 DWM 組合結果。</span><span class="sxs-lookup"><span data-stu-id="f1235-212">Finally, the digital to analog converter (DAC) shows results of the DWM composition on the monitor on the next vsync.</span></span>

<span data-ttu-id="f1235-213">從時間表中，您可以想像出現統計資料的延遲，以及可能發生問題的方式。</span><span class="sxs-lookup"><span data-stu-id="f1235-213">From the time line, you can imagine the latency of present statistics and how glitches can occur.</span></span> <span data-ttu-id="f1235-214">例如，若要顯示幕幕上出現的綠色色彩的 DWM 問題，請想像 [擴展綠色/紅色] 方塊，讓綠色/紅色方塊的右邊符合紫色/紅色方塊的右邊。</span><span class="sxs-lookup"><span data-stu-id="f1235-214">For example, to show a DWM glitch for the green color appearing on screen, imagine widening the green/red box so that the right side of the green/red box matches up to the right side of the purple/red box.</span></span> <span data-ttu-id="f1235-215">在此案例中，DAC 會顯示兩個藍色框架，然後顯示綠色框架。</span><span class="sxs-lookup"><span data-stu-id="f1235-215">In this scenario, the DAC shows two frames of blue and then the green frame.</span></span> <span data-ttu-id="f1235-216">您可以看到這種問題發生于讀取目前的統計資料。</span><span class="sxs-lookup"><span data-stu-id="f1235-216">You can see that this glitch occurred from reading present statistics.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f1235-217">相關主題</span><span class="sxs-lookup"><span data-stu-id="f1235-217">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f1235-218">使用翻轉模型、中途矩形和捲動區域增強簡報</span><span class="sxs-lookup"><span data-stu-id="f1235-218">Enhancing presentation with the flip model, dirty rectangles, and scrolled areas</span></span>](dxgi-1-2-presentation-improvements.md)
</dt> </dl>

 

 
