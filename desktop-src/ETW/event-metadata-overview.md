---
description: 這是 Microsoft 所提供之四種追蹤技術的每一項所預期的事件端對端旅程： TraceLogging、資訊清單型、WPP 和 MOF 的總覽。
ms.assetid: 6102593C-C6D5-4BDB-A0EF-067AF91DE00B
title: 事件中繼資料總覽
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0c16853ef2639fd560f5b5da30447556119ec877
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104468768"
---
# <a name="event-metadata-overview"></a><span data-ttu-id="2ee3e-103">事件中繼資料總覽</span><span class="sxs-lookup"><span data-stu-id="2ee3e-103">Event Metadata Overview</span></span>

<span data-ttu-id="2ee3e-104">這是 Microsoft 所提供之四種追蹤技術的每一項所預期的事件端對端旅程： [TraceLogging](../tracelogging/trace-logging-about.md)、 [資訊清單型](writing-manifest-based-events.md)、 [WPP](windows-software-trace-preprocessor.md)和 [MOF](tracing-events.md)的總覽。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-104">This is an overview of what to expect for the end-to-end journey of an event for each of the four tracing technologies furnished by Microsoft: [TraceLogging](../tracelogging/trace-logging-about.md), [Manifest-based](writing-manifest-based-events.md), [WPP](windows-software-trace-preprocessor.md), and [MOF](tracing-events.md).</span></span> <span data-ttu-id="2ee3e-105">它會針對個別事件的裝載和描述其結構的相關中繼資料，進行相關的問題，讓您稍後可以將事件解碼成合理的資料片段。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-105">It approaches the problem with respect to both an individual event's payload and the accompanying metadata that describes its structure, making it possible to later decode the event into sensible pieces of data.</span></span> <span data-ttu-id="2ee3e-106">在選擇適合專案的追蹤技術時，請務必瞭解事件每個部分的旅程。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-106">Understanding the journey of each piece of an event is important when choosing which tracing technology is appropriate for a project.</span></span> <span data-ttu-id="2ee3e-107">沒有適用于追蹤的一體適用方案。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-107">There is no one-size-fits-all solution to tracing.</span></span>

## <a name="event-payloads"></a><span data-ttu-id="2ee3e-108">事件承載</span><span class="sxs-lookup"><span data-stu-id="2ee3e-108">Event Payloads</span></span>

<span data-ttu-id="2ee3e-109">針對任何 Microsoft 提供的追蹤技術，當呼叫 [**EventWrite**](/windows/desktop/api/Evntprov/nf-evntprov-eventwrite)的寫入命令 (for TraceLoggingWrite for TraceLogging) 的資訊清單型或 [](/windows/win32/api/traceloggingprovider/nf-traceloggingprovider-traceloggingwrite)時，在執行時間為事件提供的資料會折迭成稱為事件承載的連續二進位 blob。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-109">For any of the Microsoft-provided tracing technologies, when calling the Write command (for instance [**EventWrite**](/windows/desktop/api/Evntprov/nf-evntprov-eventwrite) for manifest-based or [**TraceLoggingWrite**](/windows/win32/api/traceloggingprovider/nf-traceloggingprovider-traceloggingwrite) for TraceLogging), the data provided for the event at runtime is folded into a contiguous binary blob called the event payload.</span></span> <span data-ttu-id="2ee3e-110">這與事件架構或事件中繼資料不同 (如下所述) ，其中描述此二進位 blob 的版面配置以用於解碼工具。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-110">This is separate from the event schema or event metadata (discussed below), which describes the layout of this binary blob for decoding tools.</span></span> <span data-ttu-id="2ee3e-111">事件承載的產生方式會根據所使用的追蹤技術，以及最終事件是否為傳統 ([**TraceEvent**](/windows/win32/api/evntrace/nf-evntrace-traceevent) 樣式) 或新式 (**EventWrite** 樣式) 而有所不同。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-111">How exactly the generation of the event payload happens varies depending on the tracing technology used and ultimately whether the event is classic ([**TraceEvent**](/windows/win32/api/evntrace/nf-evntrace-traceevent) style) or modern (**EventWrite** style).</span></span>

<span data-ttu-id="2ee3e-112">若為傳統事件， [**事件 \_ 追蹤 \_ 標頭**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header) 中的旗標會傳遞至 [**TraceEvent**](/windows/win32/api/evntrace/nf-evntrace-traceevent) ，以判斷發生的情況：</span><span class="sxs-lookup"><span data-stu-id="2ee3e-112">For classic events, the flag in [**EVENT\_TRACE\_HEADER**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header) is passed into [**TraceEvent**](/windows/win32/api/evntrace/nf-evntrace-traceevent) which determines how this occurs:</span></span>

<span data-ttu-id="2ee3e-113">\- 如果指定了 **WNODE \_ 旗標 \_ 使用 \_ Mof \_ PTR** ，則 [**mof \_ 欄位**](/windows/win32/api/evntrace/ns-evntrace-mof_field) 的陣列會在記憶體中的 [**事件 \_ 追蹤 \_ 標頭**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header) 之後。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-113">\- If **WNODE\_FLAG\_USE\_MOF\_PTR** is specified, an array of [**MOF\_FIELDS**](/windows/win32/api/evntrace/ns-evntrace-mof_field) follows the [**EVENT\_TRACE\_HEADER**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header) in memory.</span></span> <span data-ttu-id="2ee3e-114">ETW 執行時間會串連這些欄位中所指定的事件資料，以形成事件裝載。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-114">The ETW runtime will concatenate the event data as specified in these fields to form the event payload.</span></span>

<span data-ttu-id="2ee3e-115">\- 如果未指定 **WNODE 旗標， \_ \_ \_ \_** 則在 [**事件 \_ 追蹤 \_ 標頭**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header)之後，使用者會直接在記憶體中建立事件承載。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-115">\- If **WNODE\_FLAG\_USE\_MOF\_PTR** is not specified, the event payload is constructed by the user directly in memory following the [**EVENT\_TRACE\_HEADER**](/windows/win32/api/evntrace/ns-evntrace-event_trace_header).</span></span>

<span data-ttu-id="2ee3e-116">MOF 和 WPP 都是傳統提供者。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-116">Both MOF and WPP are classic providers.</span></span> <span data-ttu-id="2ee3e-117">不過，WPP 的執行會為您處理這一切。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-117">However, the WPP implementation takes care of all of this for you.</span></span>

<span data-ttu-id="2ee3e-118">針對非傳統事件，會將一些 [**事件 \_ 資料 \_ 描述**](/windows/desktop/api/Evntprov/ns-evntprov-event_data_descriptor) 項傳遞至 [**EventWrite**](/windows/desktop/api/Evntprov/nf-evntprov-eventwrite)。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-118">For non-classic events, a number of [**EVENT\_DATA\_DESCRIPTORS**](/windows/desktop/api/Evntprov/ns-evntprov-event_data_descriptor) are passed into [**EventWrite**](/windows/desktop/api/Evntprov/nf-evntprov-eventwrite).</span></span> <span data-ttu-id="2ee3e-119">ETW 執行時間會串連這些描述項中所指定的事件資料，以形成事件裝載。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-119">The ETW runtime will concatenate the event data as specified in these descriptors to form the event payload.</span></span>

<span data-ttu-id="2ee3e-120">以資訊清單為基礎的 TraceLogging 技術通常是新式提供者。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-120">Both Manifest-based and TraceLogging technologies are generally modern providers.</span></span> <span data-ttu-id="2ee3e-121">使用以資訊清單為基礎的，如果您讓 mc.exe 為您產生 (um 或公里切換) 的記錄程式碼，則會為您處理承載產生。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-121">With manifest-based, if you let mc.exe generate logging code for you (um or km switch), payload generation is taken care of for you.</span></span> <span data-ttu-id="2ee3e-122">承載的產生一律由 TraceLogging 負責處理。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-122">Payload generation is always taken care of by TraceLogging.</span></span>

<span data-ttu-id="2ee3e-123">最後的結果是會在執行時間產生事件的承載。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-123">The end result is that a payload for an event is generated at runtime.</span></span> <span data-ttu-id="2ee3e-124">所有裝載基本上都很類似，因為它們是資料的二進位 blob，不論使用的是哪一種追蹤技術，以及該追蹤技術支援哪些欄位類型。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-124">All payloads are fundamentally similar in that they are binary blobs of data containing only the field data for that particular event, regardless of the tracing technology used and which field types are supported by that tracing technology.</span></span> <span data-ttu-id="2ee3e-125">如果沒有事件中繼資料，事件裝載就沒有意義，而且 unintelligable。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-125">Without the event metadata, the event payload is meaningless and unintelligable.</span></span>

<span data-ttu-id="2ee3e-126">接著，ETW 執行時間的職責是將此事件 blob 從提供者傳遞給取用者，然後將其重新關聯至其中繼資料，並變成 decodable。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-126">The ETW runtime's duty is then to carry this event blob from the provider to the consumer, where it is re-associated with its metadata and becomes decodable.</span></span> <span data-ttu-id="2ee3e-127">ETW 執行時間會加入一些額外的中繼資料，指出承載的情況（例如時間戳記、執行緒識別碼和事件的關鍵字）。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-127">The ETW runtime will add a bit of extra metadata indicating the circumstances of the payload -- for instance things like the timestamp, thread ID, and keywords of the event.</span></span> <span data-ttu-id="2ee3e-128">這項資訊與事件透過執行時間路由的方式有關，也適用于在解碼時瞭解事件的身分識別和內容。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-128">This information is relevant to how the event was routed through the runtime, and it is also useful for understanding the identity and context of the event at decoding time.</span></span> <span data-ttu-id="2ee3e-129">它最後會顯示為取用者的 [**事件 \_ 追蹤**](/windows/win32/api/evntrace/ns-evntrace-event_trace) 或 [**事件 \_ 記錄**](/windows/win32/api/evntcons/ns-evntcons-event_record) 的一部分。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-129">It is eventually surfaced as part of the [**EVENT\_TRACE**](/windows/win32/api/evntrace/ns-evntrace-event_trace) or [**EVENT\_RECORD**](/windows/win32/api/evntcons/ns-evntcons-event_record) for the consumer</span></span>

## <a name="event-metadata"></a><span data-ttu-id="2ee3e-130">事件中繼資料</span><span class="sxs-lookup"><span data-stu-id="2ee3e-130">Event Metadata</span></span>

<span data-ttu-id="2ee3e-131">事件中繼資料的旅程會根據所使用的追蹤技術而有所不同，而且是比較每項技術時最大的考慮之一。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-131">The journey for event metadata is different depending on which tracing technology is used, and it is one of the largest considerations when comparing each technology.</span></span>

### <a name="mof"></a><span data-ttu-id="2ee3e-132">MOF</span><span class="sxs-lookup"><span data-stu-id="2ee3e-132">MOF</span></span>

<span data-ttu-id="2ee3e-133">事件中繼資料是以 mof 檔案中特殊 MOF 架構的形式，由事件建立者手動撰寫的。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-133">Event metadata is authored by hand by the creator of the event in the form of a special MOF schema in a .mof file.</span></span> <span data-ttu-id="2ee3e-134">撰寫的架構必須符合記錄的承載，才能讓取用者正確地將事件解碼。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-134">The schema authored must match the payload that is logged in order for the event to be correctly decoded by consumers.</span></span> <span data-ttu-id="2ee3e-135">事件解碼器需要使用 [mofcomp.exe](../wmisdk/mofcomp.md)在系統上註冊 mof 檔案。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-135">Event decoders require that the .mof file is registered on the system using [mofcomp.exe](../wmisdk/mofcomp.md).</span></span> <span data-ttu-id="2ee3e-136">如需發佈 MOF 架構的詳細資訊，請參閱 [發佈您的傳統提供者的事件架構](publishing-your-event-schema-for-a-classic-provider.md)。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-136">For more information on publishing MOF schemas, see [Publishing Your Event Schema for a Classic Provider](publishing-your-event-schema-for-a-classic-provider.md).</span></span>

### <a name="wpp"></a><span data-ttu-id="2ee3e-137">Wpp</span><span class="sxs-lookup"><span data-stu-id="2ee3e-137">WPP</span></span>

<span data-ttu-id="2ee3e-138">事件中繼資料會在建立程式期間 tracewpp.exe 自動產生，並儲存在您二進位的 .pdb 中。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-138">Event metadata is automatically generated and stored in your binary's .pdb by tracewpp.exe during the build process.</span></span> <span data-ttu-id="2ee3e-139">您稍後可以使用 tmf 檔案的格式，透過 tracepdb.exe 將此中繼資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-139">This metadata can later be extracted in the form of a standalone .tmf file by way of tracepdb.exe.</span></span> <span data-ttu-id="2ee3e-140">事件解碼器通常需要 .pdb 或 tmf 檔案。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-140">Event decoders typically require either the .pdb or the .tmf file.</span></span> <span data-ttu-id="2ee3e-141">如需 tracepdb.exe 的詳細資訊，請參閱 [Tracepdb 總覽](/windows-hardware/drivers/devtest/tracepdb-overview)，如需 tracewpp.exe 的詳細資訊，請參閱 [TraceWPP task](/windows-hardware/drivers/devtest/tracewpp-task)。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-141">For more information on tracepdb.exe, see [Tracepdb Overview](/windows-hardware/drivers/devtest/tracepdb-overview), and for more information on tracewpp.exe, see [TraceWPP task](/windows-hardware/drivers/devtest/tracewpp-task).</span></span>

### <a name="manifest-based"></a><span data-ttu-id="2ee3e-142">以資訊清單為基礎</span><span class="sxs-lookup"><span data-stu-id="2ee3e-142">Manifest-based</span></span>

<span data-ttu-id="2ee3e-143">事件定義是在 man 檔中撰寫的。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-143">Event definitions are authored in a .man file.</span></span> <span data-ttu-id="2ee3e-144">事件資訊清單會透過資訊清單編譯器 ([mc.exe](../wes/message-compiler--mc-exe-.md)) ，產生來源編譯所需的標頭，以及數個 bin 二進位資源檔。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-144">Event manifests are run through the manifest compiler ([mc.exe](../wes/message-compiler--mc-exe-.md)), generating the headers needed for source compilation as well as several .bin binary resource files.</span></span> <span data-ttu-id="2ee3e-145">然後，您必須將這些資源檔編譯成二進位檔，並將產生的二進位檔編譯成系統，以將來自該資訊清單型提供者的事件解碼。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-145">These resource files must then be compiled as resources into a binary and the resulting binary placed on the system that intends to decode events from that manifest-based provider.</span></span> <span data-ttu-id="2ee3e-146">此外，資訊清單必須在系統上安裝 [wevtutil.exe](../wes/windows-event-log-tools.md) 最重要的是，已安裝事件資訊清單中提供者 XML 元素上的 **resourceFileName** 和 **messageFileName** 屬性必須正確地識別放置資源檔之二進位檔的完整絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-146">Additionally, the manifest must be installed on the system using [wevtutil.exe](../wes/windows-event-log-tools.md) Most importantly, the **resourceFileName** and **messageFileName** attributes on the provider XML element in the installed event manifest must correctly identify the full absolute path to the binary in which the resource files were placed.</span></span> <span data-ttu-id="2ee3e-147">請注意，您可以使用 wevtutil.exe 參數/rf 和/mf.，在資訊清單安裝時覆寫這些路徑。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-147">Note that these paths may be overwritten at manifest install time by using the wevtutil.exe switches /rf and /mf.</span></span> <span data-ttu-id="2ee3e-148">未正確且完全執行這些步驟的系統將無法解碼來自此提供者的事件。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-148">A system that has not correctly and fully performed these steps will be unable to decode events from this provider.</span></span> <span data-ttu-id="2ee3e-149">因此，事件的解碼器需要已安裝的資訊清單，並將具有相關聯資源的二進位檔安裝在資源和訊息檔案路徑所指定的位置。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-149">Event decoders thus require an installed manifest, and the binary with the associated resources installed in the location specified by resource and message file paths.</span></span> <span data-ttu-id="2ee3e-150">如需發行以資訊清單為基礎之架構的詳細資訊，請參閱 [發佈事件架構以取得以資訊清單為基礎的提供者](publishing-your-event-schema-for-a-manifest-base-provider.md)。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-150">For more information on publishing manifest-based schemas, see [Publishing Your Event Schema for a Manifest-based Provider](publishing-your-event-schema-for-a-manifest-base-provider.md).</span></span>

### <a name="tracelogging"></a><span data-ttu-id="2ee3e-151">TraceLogging</span><span class="sxs-lookup"><span data-stu-id="2ee3e-151">TraceLogging</span></span>

<span data-ttu-id="2ee3e-152">所有 TraceLogging 事件都是自我描述的。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-152">All TraceLogging events are self-describing.</span></span> <span data-ttu-id="2ee3e-153">解碼事件所需的事件中繼資料會自動產生，並以精簡的二進位格式連同承載一起傳送。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-153">The event metadata necessary to decode the event is automatically generated and transmitted along with the payload in a compact binary format.</span></span> <span data-ttu-id="2ee3e-154">事件解碼器只需要 TraceLogging 事件並瞭解 TraceLogging 元資料格式。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-154">Event decoders need only the TraceLogging event and an understanding of the TraceLogging metadata format.</span></span>

## <a name="configuring-tdh-for-decoding"></a><span data-ttu-id="2ee3e-155">設定解碼的 TDH</span><span class="sxs-lookup"><span data-stu-id="2ee3e-155">Configuring TDH for Decoding</span></span>

<span data-ttu-id="2ee3e-156">其中有許多解碼工具。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-156">There are many decoding tools out there.</span></span> <span data-ttu-id="2ee3e-157">不過，建議您盡可能使用 TDH，因為它會使用統一的 API 來解碼所有追蹤技術。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-157">However, it is recommended that you use TDH where possible, as it decodes all tracing technologies with a unified API.</span></span> <span data-ttu-id="2ee3e-158">根據您對解碼感興趣的追蹤類型而定，TDH 可能需要明確設定。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-158">Depending on the type of tracing you are interested in decoding, TDH may require explicit configuration.</span></span>

### <a name="mof"></a><span data-ttu-id="2ee3e-159">MOF</span><span class="sxs-lookup"><span data-stu-id="2ee3e-159">MOF</span></span>

<span data-ttu-id="2ee3e-160">TDH 利用在系統上使用 mofcomp.exe 註冊的 MOF 解碼資料。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-160">TDH utilizes MOF decoding data registered on the system using mofcomp.exe.</span></span> <span data-ttu-id="2ee3e-161">如需詳細資訊，請參閱 [發行傳統提供者的事件架構](publishing-your-event-schema-for-a-classic-provider.md)。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-161">For more information, see [Publishing Your Event Schema for a Classic Provider](publishing-your-event-schema-for-a-classic-provider.md).</span></span>

### <a name="wpp"></a><span data-ttu-id="2ee3e-162">Wpp</span><span class="sxs-lookup"><span data-stu-id="2ee3e-162">WPP</span></span>

<span data-ttu-id="2ee3e-163">TDH 必須指向 .pdb 檔案或相關聯的 tmf，以找出您嘗試解碼的 WPP 提供者。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-163">TDH must be pointed towards either the .pdb file or the associated .tmf for the WPP provider you are trying to decode.</span></span> <span data-ttu-id="2ee3e-164">您可以藉由呼叫 [**TdhSetDecodingParameter**](/windows/desktop/api/Tdh/nf-tdh-tdhsetdecodingparameter)來執行此作業。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-164">This can be performed by calling [**TdhSetDecodingParameter**](/windows/desktop/api/Tdh/nf-tdh-tdhsetdecodingparameter).</span></span> <span data-ttu-id="2ee3e-165">否則，解碼引擎會回到環境變數追蹤 \_ 格式 \_ 搜尋 \_ 路徑。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-165">Otherwise, the decoding engine will fall back on the environment variable TRACE\_FORMAT\_SEARCH\_PATH.</span></span>

### <a name="manifest-based"></a><span data-ttu-id="2ee3e-166">以資訊清單為基礎</span><span class="sxs-lookup"><span data-stu-id="2ee3e-166">Manifest-based</span></span>

<span data-ttu-id="2ee3e-167">TDH 會利用使用 wevtutil.exe 在系統上註冊的所有以資訊清單為基礎的提供者。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-167">TDH utilizes all manifest-based providers registered on the system using wevtutil.exe.</span></span>

### <a name="tracelogging"></a><span data-ttu-id="2ee3e-168">TraceLogging</span><span class="sxs-lookup"><span data-stu-id="2ee3e-168">TraceLogging</span></span>

<span data-ttu-id="2ee3e-169">最新版本的 TDH 會自動偵測 TraceLogging 事件並將其解碼，而無需額外的步驟。</span><span class="sxs-lookup"><span data-stu-id="2ee3e-169">The newest versions of TDH automatically detect and decode TraceLogging events with no additional steps.</span></span>

 

 
