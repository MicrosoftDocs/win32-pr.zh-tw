---
description: 建立 Dll 為開發人員帶來一些挑戰。
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Dynamic-Link 程式庫的最佳作法
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "106975283"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="a12ac-103">Dynamic-Link 程式庫的最佳作法</span><span class="sxs-lookup"><span data-stu-id="a12ac-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="a12ac-104">\* \* 更新日期： \* \*</span><span class="sxs-lookup"><span data-stu-id="a12ac-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="a12ac-105">2006 5 月17日</span><span class="sxs-lookup"><span data-stu-id="a12ac-105">May 17, 2006</span></span>

<span data-ttu-id="a12ac-106">**重要 API**</span><span class="sxs-lookup"><span data-stu-id="a12ac-106">**Important APIs**</span></span>

-   [<span data-ttu-id="a12ac-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="a12ac-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="a12ac-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="a12ac-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="a12ac-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="a12ac-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="a12ac-110">建立 Dll 為開發人員帶來一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="a12ac-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="a12ac-111">Dll 沒有系統強制的版本控制。</span><span class="sxs-lookup"><span data-stu-id="a12ac-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="a12ac-112">當系統上有多個版本的 DLL 時，容易被覆寫，且缺少版本控制架構會建立相依性和 API 衝突。</span><span class="sxs-lookup"><span data-stu-id="a12ac-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="a12ac-113">開發環境中的複雜性、載入器的執行和 DLL 相依性已建立脆弱數的載入順序和應用程式行為。</span><span class="sxs-lookup"><span data-stu-id="a12ac-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="a12ac-114">最後，許多應用程式都依賴 Dll 並且具有複雜的相依性集合，讓應用程式能夠正常運作。</span><span class="sxs-lookup"><span data-stu-id="a12ac-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="a12ac-115">本檔提供 DLL 開發人員協助建立更健全、可攜且可擴充之 Dll 的指導方針。</span><span class="sxs-lookup"><span data-stu-id="a12ac-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="a12ac-116">[**DllMain**](dllmain.md)內的不當同步處理可能會導致應用程式鎖死，或存取未初始化 DLL 中的資料或程式碼。</span><span class="sxs-lookup"><span data-stu-id="a12ac-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="a12ac-117">從 **DllMain** 內呼叫特定函式會造成這類問題。</span><span class="sxs-lookup"><span data-stu-id="a12ac-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![載入程式庫時會發生什麼事](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="a12ac-119">一般最佳作法</span><span class="sxs-lookup"><span data-stu-id="a12ac-119">General Best Practices</span></span>

<span data-ttu-id="a12ac-120">當持有載入器鎖定時，會呼叫 [**DllMain**](dllmain.md) 。</span><span class="sxs-lookup"><span data-stu-id="a12ac-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="a12ac-121">因此，可在 **DllMain** 內呼叫的函式上強加了重大限制。</span><span class="sxs-lookup"><span data-stu-id="a12ac-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="a12ac-122">因此， **DllMain** 的設計目的是要使用 Microsoft® WINDOWS® API 的一小部分來執行最少的初始化工作。</span><span class="sxs-lookup"><span data-stu-id="a12ac-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="a12ac-123">您無法在 **DllMain** 中呼叫任何直接或間接嘗試取得載入器鎖定的函式。</span><span class="sxs-lookup"><span data-stu-id="a12ac-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="a12ac-124">否則，您將會引入應用程式鎖死或損毀的可能性。</span><span class="sxs-lookup"><span data-stu-id="a12ac-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="a12ac-125">**DllMain** 執行中的錯誤可能會危害整個進程及其所有線程。</span><span class="sxs-lookup"><span data-stu-id="a12ac-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="a12ac-126">理想的 [**DllMain**](dllmain.md) 會是空的存根。</span><span class="sxs-lookup"><span data-stu-id="a12ac-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="a12ac-127">不過，由於許多應用程式的複雜性，這通常太過嚴格。</span><span class="sxs-lookup"><span data-stu-id="a12ac-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="a12ac-128">好用的 **DllMain** 經驗法則是盡可能將最多的初始化延後。</span><span class="sxs-lookup"><span data-stu-id="a12ac-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="a12ac-129">延遲初始化可提高應用程式的可靠性，因為在保留載入器鎖定時，不會執行此初始化。</span><span class="sxs-lookup"><span data-stu-id="a12ac-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="a12ac-130">此外，延遲初始化還可讓您安全地使用更多 Windows API。</span><span class="sxs-lookup"><span data-stu-id="a12ac-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="a12ac-131">某些初始化工作無法延後。</span><span class="sxs-lookup"><span data-stu-id="a12ac-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="a12ac-132">例如，如果檔案的格式不正確或包含垃圾，則相依于設定檔的 DLL 應該無法載入。</span><span class="sxs-lookup"><span data-stu-id="a12ac-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="a12ac-133">對於這種初始化類型，DLL 應該嘗試執行動作並快速失敗，而不是藉由完成其他工作來浪費資源。</span><span class="sxs-lookup"><span data-stu-id="a12ac-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="a12ac-134">您永遠不應該從 [**DllMain**](dllmain.md)內執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="a12ac-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="a12ac-135"> (直接或間接) 呼叫 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) 。</span><span class="sxs-lookup"><span data-stu-id="a12ac-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="a12ac-136">這可能會造成鎖死或損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="a12ac-137"> (直接或間接) 呼叫 [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea)、 [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)或 [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) 。</span><span class="sxs-lookup"><span data-stu-id="a12ac-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="a12ac-138">這可能會造成鎖死或損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="a12ac-139">與其他執行緒同步處理。</span><span class="sxs-lookup"><span data-stu-id="a12ac-139">Synchronize with other threads.</span></span> <span data-ttu-id="a12ac-140">這可能會造成鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="a12ac-141">取得由等候取得載入器鎖定的程式碼所擁有的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="a12ac-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="a12ac-142">這可能會造成鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="a12ac-143">使用 [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex)初始化 COM 執行緒。</span><span class="sxs-lookup"><span data-stu-id="a12ac-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="a12ac-144">在某些情況下，此函式可以呼叫 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)。</span><span class="sxs-lookup"><span data-stu-id="a12ac-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="a12ac-145">呼叫登錄功能。</span><span class="sxs-lookup"><span data-stu-id="a12ac-145">Call the registry functions.</span></span> <span data-ttu-id="a12ac-146">這些函式會在 Advapi32.dll 中實作為。</span><span class="sxs-lookup"><span data-stu-id="a12ac-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="a12ac-147">如果 Advapi32.dll 未在您的 DLL 之前初始化，則 DLL 可以存取未初始化的記憶體，並使進程損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="a12ac-148">呼叫 [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)。</span><span class="sxs-lookup"><span data-stu-id="a12ac-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="a12ac-149">建立進程可以載入另一個 DLL。</span><span class="sxs-lookup"><span data-stu-id="a12ac-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="a12ac-150">呼叫 [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread)。</span><span class="sxs-lookup"><span data-stu-id="a12ac-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="a12ac-151">在 DLL 卸離期間結束執行緒可能會再次取得載入器鎖定，導致鎖死或損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="a12ac-152">呼叫 [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread)。</span><span class="sxs-lookup"><span data-stu-id="a12ac-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="a12ac-153">如果您沒有與其他執行緒進行同步處理，則建立執行緒可能會運作，但這是有風險的。</span><span class="sxs-lookup"><span data-stu-id="a12ac-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="a12ac-154">建立具名管道或其他命名物件 (Windows 2000 僅) 。</span><span class="sxs-lookup"><span data-stu-id="a12ac-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="a12ac-155">在 Windows 2000 中，命名物件是由終端機服務 DLL 提供。</span><span class="sxs-lookup"><span data-stu-id="a12ac-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="a12ac-156">如果這個 DLL 未初始化，則對 DLL 的呼叫可能會導致處理常式損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="a12ac-157">使用 Run-Time (CRT) 的記憶體管理函數。</span><span class="sxs-lookup"><span data-stu-id="a12ac-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="a12ac-158">如果 CRT DLL 未初始化，這些函式的呼叫可能會導致處理常式損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="a12ac-159">User32.dll 或 Gdi32.dll 中呼叫函數。</span><span class="sxs-lookup"><span data-stu-id="a12ac-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="a12ac-160">某些函式會載入另一個可能不會初始化的 DLL。</span><span class="sxs-lookup"><span data-stu-id="a12ac-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="a12ac-161">使用 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a12ac-161">Use managed code.</span></span>

<span data-ttu-id="a12ac-162">下列工作可以安全地在 **DllMain** 內執行：</span><span class="sxs-lookup"><span data-stu-id="a12ac-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="a12ac-163">在編譯時期初始化靜態資料結構和成員。</span><span class="sxs-lookup"><span data-stu-id="a12ac-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="a12ac-164">建立並初始化同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="a12ac-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="a12ac-165">配置記憶體並初始化動態資料結構， (避免上列函式。 ) </span><span class="sxs-lookup"><span data-stu-id="a12ac-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="a12ac-166"> (TLS) 設定執行緒區域儲存區。</span><span class="sxs-lookup"><span data-stu-id="a12ac-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="a12ac-167">開啟、讀取和寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="a12ac-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="a12ac-168">在 Kernel32.dll (中呼叫函式，但) 上列函數除外。</span><span class="sxs-lookup"><span data-stu-id="a12ac-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="a12ac-169">將全域指標設定為 Null，並將動態成員的初始化設為 off。</span><span class="sxs-lookup"><span data-stu-id="a12ac-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="a12ac-170">在 Microsoft Windows Vista™中，您可以使用一次性的初始化函式，以確保程式碼區塊只會在多執行緒環境中執行一次。</span><span class="sxs-lookup"><span data-stu-id="a12ac-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="a12ac-171">鎖定順序反轉造成的鎖死</span><span class="sxs-lookup"><span data-stu-id="a12ac-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="a12ac-172">當您使用多個同步處理物件（例如鎖定）來執行程式碼時，請務必遵守鎖定順序。</span><span class="sxs-lookup"><span data-stu-id="a12ac-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="a12ac-173">當需要一次取得多個鎖定時，您必須定義稱為鎖定階層或鎖定順序的明確優先順序。</span><span class="sxs-lookup"><span data-stu-id="a12ac-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="a12ac-174">例如，如果在程式碼中的某個位置之前取得鎖定 A，並且在程式碼中的其他位置取得鎖定 B，則鎖定順序為 A、B、C，而此順序應該在整個程式碼中遵循。</span><span class="sxs-lookup"><span data-stu-id="a12ac-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="a12ac-175">當未遵循鎖定順序時，就會發生鎖定順序反轉，例如，如果在鎖定 A 之前取得鎖定 B，鎖定順序反轉可能會導致難以進行偵錯工具的鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="a12ac-176">為了避免這類問題，所有線程都必須以相同的順序取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="a12ac-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="a12ac-177">請務必注意，載入器會呼叫已取得載入器鎖定的 [**DllMain**](dllmain.md) ，因此載入器鎖定在鎖定階層中應該具有最高的優先順序。</span><span class="sxs-lookup"><span data-stu-id="a12ac-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="a12ac-178">另請注意，程式碼只需要取得適當的同步處理所需的鎖定;不需要取得階層中定義的每個單一鎖定。</span><span class="sxs-lookup"><span data-stu-id="a12ac-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="a12ac-179">例如，如果程式碼區段只需要鎖定 A 和 C 以進行適當的同步處理，則程式碼在取得鎖定 C 之前，應該會取得鎖定 A;程式碼也不需要取得鎖定 B。此外，DLL 程式碼無法明確取得載入器鎖定。</span><span class="sxs-lookup"><span data-stu-id="a12ac-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="a12ac-180">如果程式碼必須呼叫可間接取得載入器鎖定的 API （例如 [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) ），而且程式碼也必須取得私用鎖定，則程式碼應該在取得鎖定 P 之前呼叫 **GetModuleFileName** ，藉此確保遵守載入順序。</span><span class="sxs-lookup"><span data-stu-id="a12ac-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="a12ac-181">[圖 2] 是說明鎖定順序反轉的範例。</span><span class="sxs-lookup"><span data-stu-id="a12ac-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="a12ac-182">假設有一個 DLL 的主執行緒包含 [**DllMain**](dllmain.md)。</span><span class="sxs-lookup"><span data-stu-id="a12ac-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="a12ac-183">程式庫載入器會取得載入器鎖定 L，然後呼叫 **DllMain**。</span><span class="sxs-lookup"><span data-stu-id="a12ac-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="a12ac-184">主執行緒會建立同步處理物件 A、B 和 G 以序列化其資料結構的存取，然後嘗試取得 lock G。已成功取得鎖定 G G 的背景工作執行緒會呼叫函數，例如嘗試取得載入器鎖定 L 的 GetModuleHandle。因此，背景工作執行緒會在 L 上遭到封鎖，而主執行緒會在 G 上遭到封鎖，因而產生鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![鎖定順序反轉造成的鎖死](images/fig2.png)

<span data-ttu-id="a12ac-186">為了避免鎖定順序反轉所造成的鎖死，所有線程都應該隨時嘗試取得所定義載入順序中的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="a12ac-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="a12ac-187">同步處理的最佳作法</span><span class="sxs-lookup"><span data-stu-id="a12ac-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="a12ac-188">請考慮建立背景工作執行緒作為其初始化一部分的 DLL。</span><span class="sxs-lookup"><span data-stu-id="a12ac-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="a12ac-189">清除 DLL 時，必須與所有工作者執行緒同步處理，以確保資料結構處於一致的狀態，然後終止背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="a12ac-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="a12ac-190">目前，沒有直接解決在多執行緒環境中完全同步處理和關閉 Dll 問題的方式。</span><span class="sxs-lookup"><span data-stu-id="a12ac-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="a12ac-191">本節說明在 DLL 關閉期間，執行緒同步處理的最新最佳作法。</span><span class="sxs-lookup"><span data-stu-id="a12ac-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="a12ac-192">進程結束期間在 [**DllMain**](dllmain.md) 中的執行緒同步處理</span><span class="sxs-lookup"><span data-stu-id="a12ac-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="a12ac-193">在進程結束時呼叫 [**DllMain**](dllmain.md) 時，會強制清除所有進程的執行緒，而且可能會有位址空間不一致的情況。</span><span class="sxs-lookup"><span data-stu-id="a12ac-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="a12ac-194">在此情況下，不需要同步處理。</span><span class="sxs-lookup"><span data-stu-id="a12ac-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="a12ac-195">換句話說，理想的 DLL 進程卸 \_ \_ 離處理常式是空的。</span><span class="sxs-lookup"><span data-stu-id="a12ac-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="a12ac-196">Windows Vista 可確保核心資料結構 (環境變數、目前的目錄、進程堆積等) 處於一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="a12ac-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="a12ac-197">不過，其他資料結構可能已損毀，因此清理記憶體並不安全。</span><span class="sxs-lookup"><span data-stu-id="a12ac-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="a12ac-198">需要儲存的持續性狀態必須排清到永久儲存區。</span><span class="sxs-lookup"><span data-stu-id="a12ac-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="a12ac-199">DLL **中 dll** 執行緒卸離 dll 執行緒的執行緒同步處理 \_ \_</span><span class="sxs-lookup"><span data-stu-id="a12ac-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="a12ac-200">卸載 DLL 時，不會擲回位址空間。</span><span class="sxs-lookup"><span data-stu-id="a12ac-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="a12ac-201">因此，DLL 預期會執行正常關機。</span><span class="sxs-lookup"><span data-stu-id="a12ac-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="a12ac-202">這包括執行緒同步處理、開啟控制碼、持續狀態和已配置的資源。</span><span class="sxs-lookup"><span data-stu-id="a12ac-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="a12ac-203">執行緒同步處理很棘手，因為在 [**DllMain**](dllmain.md) 中等候執行緒結束可能會造成鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="a12ac-204">例如，DLL A 會保存載入器鎖定。</span><span class="sxs-lookup"><span data-stu-id="a12ac-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="a12ac-205">它會通知執行緒 T 結束，並等候執行緒結束。</span><span class="sxs-lookup"><span data-stu-id="a12ac-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="a12ac-206">執行緒 T 結束時，載入器會嘗試取得載入器鎖定，以呼叫 dll A 的 **DllMain** 與 dll \_ 執行緒卸 \_ 離。</span><span class="sxs-lookup"><span data-stu-id="a12ac-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="a12ac-207">這會造成鎖死。</span><span class="sxs-lookup"><span data-stu-id="a12ac-207">This causes a deadlock.</span></span> <span data-ttu-id="a12ac-208">若要將鎖死的風險降至最低：</span><span class="sxs-lookup"><span data-stu-id="a12ac-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="a12ac-209">DLL A 會 \_ \_ 在其 [**DLLMAIN**](dllmain.md) 中取得 dll 執行緒的卸離訊息，並設定執行緒 T 的事件，以通知它結束。</span><span class="sxs-lookup"><span data-stu-id="a12ac-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="a12ac-210">執行緒 T 完成其目前的工作，將本身帶入一致的狀態，發出 DLL A 的信號，並無限期等候。</span><span class="sxs-lookup"><span data-stu-id="a12ac-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="a12ac-211">請注意，一致性檢查常式應遵循與 [**DllMain**](dllmain.md) 相同的限制，以避免死結。</span><span class="sxs-lookup"><span data-stu-id="a12ac-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="a12ac-212">DLL A 終止 T，知道它處於一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="a12ac-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="a12ac-213">如果 DLL 在所有線程都已建立之後，但在開始執行之前卸載，執行緒可能會損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="a12ac-214">如果 DLL **在其初始化** 過程中建立了執行緒，則某些執行緒可能不會完成初始化，而且其 DLL \_ 執行緒 \_ 附加訊息仍在等候傳遞至 DLL。</span><span class="sxs-lookup"><span data-stu-id="a12ac-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="a12ac-215">在此情況下，如果卸載 DLL，它就會開始終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="a12ac-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="a12ac-216">不過，某些執行緒可能會在載入器鎖定之後封鎖。</span><span class="sxs-lookup"><span data-stu-id="a12ac-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="a12ac-217">\_ \_ Dll 執行緒附加訊息會在 dll 未對應時處理，導致進程損毀。</span><span class="sxs-lookup"><span data-stu-id="a12ac-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="a12ac-218">建議</span><span class="sxs-lookup"><span data-stu-id="a12ac-218">Recommendations</span></span>

<span data-ttu-id="a12ac-219">以下是建議的指導方針：</span><span class="sxs-lookup"><span data-stu-id="a12ac-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="a12ac-220">使用應用程式驗證器來攔截 [**DllMain**](dllmain.md)中最常見的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a12ac-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="a12ac-221">如果在 [**DllMain**](dllmain.md)內使用私用鎖定，請定義鎖定階層，並以一致的方式使用。</span><span class="sxs-lookup"><span data-stu-id="a12ac-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="a12ac-222">載入器鎖定必須位於此階層的底部。</span><span class="sxs-lookup"><span data-stu-id="a12ac-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="a12ac-223">確認沒有任何呼叫相依于另一個可能尚未完全載入的 DLL。</span><span class="sxs-lookup"><span data-stu-id="a12ac-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="a12ac-224">在編譯時期以靜態方式執行簡單的初始化，而不是在 [**DllMain**](dllmain.md)中執行。</span><span class="sxs-lookup"><span data-stu-id="a12ac-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="a12ac-225">延遲 [**DllMain**](dllmain.md) 中可等候到稍後的任何呼叫。</span><span class="sxs-lookup"><span data-stu-id="a12ac-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="a12ac-226">延遲可等候到稍後的初始化工作。</span><span class="sxs-lookup"><span data-stu-id="a12ac-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="a12ac-227">某些錯誤狀況必須及早偵測，如此應用程式才能正常地處理錯誤。</span><span class="sxs-lookup"><span data-stu-id="a12ac-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="a12ac-228">不過，這種早期偵測與可能產生的穩定性會有取捨。</span><span class="sxs-lookup"><span data-stu-id="a12ac-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="a12ac-229">延遲初始化通常是最好的做法。</span><span class="sxs-lookup"><span data-stu-id="a12ac-229">Deferring initialization is often best.</span></span>

 

 
