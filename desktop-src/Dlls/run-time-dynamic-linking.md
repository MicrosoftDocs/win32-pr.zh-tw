---
description: 當應用程式呼叫 LoadLibrary 或 LoadLibraryEx 函式時，系統會嘗試找出 DLL (如需詳細資訊，請參閱 Dynamic-Link 程式庫搜尋順序) 。
ms.assetid: 81e237a9-3c32-46a5-88d3-c978f43dad54
title: Run-Time 動態連結
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9e215ac83ecdc0615b8030e2e215857c67fe6e5
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106997500"
---
# <a name="run-time-dynamic-linking"></a><span data-ttu-id="d9b73-103">Run-Time 動態連結</span><span class="sxs-lookup"><span data-stu-id="d9b73-103">Run-Time Dynamic Linking</span></span>

<span data-ttu-id="d9b73-104">當應用程式呼叫 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) 函式時，系統會嘗試找出 DLL (如需詳細資訊，請參閱 [動態連結程式庫搜尋順序](dynamic-link-library-search-order.md)) 。</span><span class="sxs-lookup"><span data-stu-id="d9b73-104">When the application calls the [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) functions, the system attempts to locate the DLL (for details, see [Dynamic-Link Library Search Order](dynamic-link-library-search-order.md)).</span></span> <span data-ttu-id="d9b73-105">如果搜尋成功，系統會將 DLL 模組對應到進程的虛擬位址空間，並遞增參考計數。</span><span class="sxs-lookup"><span data-stu-id="d9b73-105">If the search succeeds, the system maps the DLL module into the virtual address space of the process and increments the reference count.</span></span> <span data-ttu-id="d9b73-106">如果呼叫 **LoadLibrary** 或 **LOADLIBRARYEX** 指定的 DLL 的程式碼已經對應到呼叫進程的虛擬位址空間，則函式只會傳回 dll 的控制碼，並遞增 dll 參考計數。</span><span class="sxs-lookup"><span data-stu-id="d9b73-106">If the call to **LoadLibrary** or **LoadLibraryEx** specifies a DLL whose code is already mapped into the virtual address space of the calling process, the function simply returns a handle to the DLL and increments the DLL reference count.</span></span> <span data-ttu-id="d9b73-107">請注意，兩個具有相同基底檔案名和副檔名但在不同目錄中找到的 Dll，不會被視為相同的 DLL。</span><span class="sxs-lookup"><span data-stu-id="d9b73-107">Note that two DLLs that have the same base file name and extension but are found in different directories are not considered to be the same DLL.</span></span>

<span data-ttu-id="d9b73-108">系統會在呼叫 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)的執行緒內容中呼叫進入點函數。</span><span class="sxs-lookup"><span data-stu-id="d9b73-108">The system calls the entry-point function in the context of the thread that called [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span> <span data-ttu-id="d9b73-109">如果 DLL 已經透過呼叫 **LoadLibrary** 或 **LoadLibraryEx** ，但沒有對應的 [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary) 函式呼叫，就不會呼叫進入點函數。</span><span class="sxs-lookup"><span data-stu-id="d9b73-109">The entry-point function is not called if the DLL was already loaded by the process through a call to **LoadLibrary** or **LoadLibraryEx** with no corresponding call to the [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary) function.</span></span>

<span data-ttu-id="d9b73-110">如果系統找不到 DLL 或進入點函數傳回 FALSE，則 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LOADLIBRARYEX**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) 會傳回 Null。</span><span class="sxs-lookup"><span data-stu-id="d9b73-110">If the system cannot find the DLL or if the entry-point function returns FALSE, [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) returns NULL.</span></span> <span data-ttu-id="d9b73-111">如果 **LoadLibrary** 或 **LoadLibraryEx** 成功，它會將控制碼傳回至 DLL 模組。</span><span class="sxs-lookup"><span data-stu-id="d9b73-111">If **LoadLibrary** or **LoadLibraryEx** succeeds, it returns a handle to the DLL module.</span></span> <span data-ttu-id="d9b73-112">此程式可以使用此控制碼來識別對 [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)、 [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary)或 [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread) 函數的呼叫中的 DLL。</span><span class="sxs-lookup"><span data-stu-id="d9b73-112">The process can use this handle to identify the DLL in a call to the [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress), [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary), or [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread) function.</span></span>

<span data-ttu-id="d9b73-113">[**GetModuleHandle**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)函數會傳回在 [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)、 [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary)或 [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread)中使用的控制碼。</span><span class="sxs-lookup"><span data-stu-id="d9b73-113">The [**GetModuleHandle**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea) function returns a handle used in [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress), [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary), or [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="d9b73-114">只有當 DLL 模組已經透過載入時間連結或先前對 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)的呼叫，對應到進程的位址空間時， **GetModuleHandle** 函數才會成功。</span><span class="sxs-lookup"><span data-stu-id="d9b73-114">The **GetModuleHandle** function succeeds only if the DLL module is already mapped into the address space of the process by load-time linking or by a previous call to [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span> <span data-ttu-id="d9b73-115">不同于 **LoadLibrary** 或 **LoadLibraryEx**， **GetModuleHandle** 不會遞增模組參考計數。</span><span class="sxs-lookup"><span data-stu-id="d9b73-115">Unlike **LoadLibrary** or **LoadLibraryEx**, **GetModuleHandle** does not increment the module reference count.</span></span> <span data-ttu-id="d9b73-116">[**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea)函式會抓取與 **GetModuleHandle**、 **LoadLibrary** 或 **LoadLibraryEx** 所傳回之控制碼相關聯之模組的完整路徑。</span><span class="sxs-lookup"><span data-stu-id="d9b73-116">The [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) function retrieves the full path of the module associated with a handle returned by **GetModuleHandle**, **LoadLibrary**, or **LoadLibraryEx**.</span></span>

<span data-ttu-id="d9b73-117">此程式可以使用 [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) 來取得 dll 中匯出函式的位址，方法是使用 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)、 [**GetModuleHandle**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)所傳回的 dll 模組控制碼。</span><span class="sxs-lookup"><span data-stu-id="d9b73-117">The process can use [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) to get the address of an exported function in the DLL using a DLL module handle returned by [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa), [**GetModuleHandle**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea).</span></span>

<span data-ttu-id="d9b73-118">當不再需要 DLL 模組時，此處理程式可以呼叫 [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary) 或 [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread)。</span><span class="sxs-lookup"><span data-stu-id="d9b73-118">When the DLL module is no longer needed, the process can call [**FreeLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary) or [**FreeLibraryAndExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="d9b73-119">如果參考計數為零，則這些函式會遞減模組參考計數，並取消對應進程的虛擬位址空間中的 DLL 程式碼。</span><span class="sxs-lookup"><span data-stu-id="d9b73-119">These functions decrement the module reference count and unmap the DLL code from the virtual address space of the process if the reference count is zero.</span></span>

<span data-ttu-id="d9b73-120">執行時間動態連結可讓進程繼續執行，即使 DLL 無法使用也是一樣。</span><span class="sxs-lookup"><span data-stu-id="d9b73-120">Run-time dynamic linking enables the process to continue running even if a DLL is not available.</span></span> <span data-ttu-id="d9b73-121">然後，程式可以使用替代方法來完成其目標。</span><span class="sxs-lookup"><span data-stu-id="d9b73-121">The process can then use an alternate method to accomplish its objective.</span></span> <span data-ttu-id="d9b73-122">例如，如果處理常式找不到一個 DLL，它可以嘗試使用另一個 DLL，也可以通知使用者發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="d9b73-122">For example, if a process is unable to locate one DLL, it can try to use another, or it can notify the user of an error.</span></span> <span data-ttu-id="d9b73-123">如果使用者可以提供遺失 DLL 的完整路徑，此程式可以使用這項資訊載入 DLL，即使它不在一般搜尋路徑中也一樣。</span><span class="sxs-lookup"><span data-stu-id="d9b73-123">If the user can provide the full path of the missing DLL, the process can use this information to load the DLL even though it is not in the normal search path.</span></span> <span data-ttu-id="d9b73-124">這種情況與載入時間連結相反，因為系統會在找不到 DLL 時，直接終止進程。</span><span class="sxs-lookup"><span data-stu-id="d9b73-124">This situation contrasts with load-time linking, in which the system simply terminates the process if it cannot find the DLL.</span></span>

<span data-ttu-id="d9b73-125">如果 DLL 使用 [**DllMain**](dllmain.md) 函式為進程的每個執行緒執行初始化，則執行時間動態連結可能會造成問題，因為呼叫 [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 或 [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) 之前已存在的執行緒不會呼叫進入點。</span><span class="sxs-lookup"><span data-stu-id="d9b73-125">Run-time dynamic linking can cause problems if the DLL uses the [**DllMain**](dllmain.md) function to perform initialization for each thread of a process, because the entry-point is not called for threads that existed before [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) is called.</span></span> <span data-ttu-id="d9b73-126">如需示範如何處理此問題的範例，請參閱 [使用 Dynamic-Link 程式庫中的執行緒區域儲存區](using-thread-local-storage-in-a-dynamic-link-library.md)。</span><span class="sxs-lookup"><span data-stu-id="d9b73-126">For an example showing how to deal with this problem, see [Using Thread Local Storage in a Dynamic-Link Library](using-thread-local-storage-in-a-dynamic-link-library.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="d9b73-127">相關主題</span><span class="sxs-lookup"><span data-stu-id="d9b73-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d9b73-128">使用執行時間動態連結</span><span class="sxs-lookup"><span data-stu-id="d9b73-128">Using Run-time Dynamic Linking</span></span>](using-run-time-dynamic-linking.md)
</dt> </dl>

 

 
