---
description: 您的應用程式可以使用 Uniscribe API 函式來支援印刷樣式以及國際文字的顯示和編輯。 Uniscribe 使用段落作為文字顯示的單位，而 Uniscribe 功能則必須用於整個段落。
ms.assetid: e1adc567-0445-4deb-8634-25653f82127c
title: 使用 Uniscribe 顯示文字
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: baeb9a2be4d00efaa2681097ddefe3a6de4c576b
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104320240"
---
# <a name="displaying-text-with-uniscribe"></a><span data-ttu-id="811f9-104">使用 Uniscribe 顯示文字</span><span class="sxs-lookup"><span data-stu-id="811f9-104">Displaying Text with Uniscribe</span></span>

<span data-ttu-id="811f9-105">您的應用程式可以使用 Uniscribe API 函式來支援印刷樣式以及國際文字的顯示和編輯。</span><span class="sxs-lookup"><span data-stu-id="811f9-105">Your applications can use Uniscribe API functions to support typography and the display and editing of international text.</span></span> <span data-ttu-id="811f9-106">Uniscribe 使用段落作為文字顯示的單位，而 Uniscribe 功能則必須用於整個段落。</span><span class="sxs-lookup"><span data-stu-id="811f9-106">Uniscribe uses the paragraph as the unit for text display, and the Uniscribe functionality must be used for the entire paragraph.</span></span>

<span data-ttu-id="811f9-107">使用 Uniscribe 來顯示文字時，應用程式必須經過格式化 ( 「版面配置」 ) 進程，通常是使用 Uniscribe。</span><span class="sxs-lookup"><span data-stu-id="811f9-107">When using Uniscribe for display of text, an application must go through a formatting ("layout") process, typically using Uniscribe.</span></span> <span data-ttu-id="811f9-108">應用程式會將文欄位落分割為具有相同樣式的字元字串，稱為「執行」。</span><span class="sxs-lookup"><span data-stu-id="811f9-108">The application divides a text paragraph into strings of characters with the same style, called "runs".</span></span> <span data-ttu-id="811f9-109">樣式取決於特定的執行，但通常會包含字型、大小和色彩這類屬性。</span><span class="sxs-lookup"><span data-stu-id="811f9-109">The style is determined by the particular implementation, but typically includes such attributes as font, size, and color.</span></span> <span data-ttu-id="811f9-110">在定義回合中，應用程式也可以套用其他資訊，例如為了搭配使用詞法工具而維護的語言和地區設定資料。</span><span class="sxs-lookup"><span data-stu-id="811f9-110">In defining runs, the application can also apply other information, such as language and locale data maintained for use with lexical tools.</span></span> <span data-ttu-id="811f9-111">例如，應用程式可能會被視為個別的執行以法文轉譯的英文文字。</span><span class="sxs-lookup"><span data-stu-id="811f9-111">For example, an application might treat as a separate run a passage in a primarily English text that is rendered in French.</span></span>

<span data-ttu-id="811f9-112">一旦決定所有段落的回合之後，應用程式就會將每個段落分割成具有相同腳本和方向 ( 「專案」 ) 的字串。</span><span class="sxs-lookup"><span data-stu-id="811f9-112">Once it has determined the runs for all paragraphs, the application divides each paragraph into strings that have the same script and direction ("items").</span></span> <span data-ttu-id="811f9-113">應用程式會套用專案資訊，以產生在腳本和方向中是唯一的執行，並且完全落在單一專案內 ( 「範圍」 ) 。</span><span class="sxs-lookup"><span data-stu-id="811f9-113">The application applies the item information to produce runs that are unique in script and direction and fall entirely within a single item ("ranges").</span></span>

<span data-ttu-id="811f9-114">雖然範圍應包含一或多個連續的腳本定義不可分割字元群組（稱為「叢集」），但專案的明細也有點任意。</span><span class="sxs-lookup"><span data-stu-id="811f9-114">The breakdown of an item into ranges is somewhat arbitrary, although a range should consist of one or more consecutive script-defined, indivisible character groupings, called "clusters."</span></span> <span data-ttu-id="811f9-115">若是歐洲語言，叢集通常會對應 [至單一代碼](uniscribe-glossary.md)頁字元或 Unicode 程式碼點，並由單一字元組成。</span><span class="sxs-lookup"><span data-stu-id="811f9-115">For European languages, a cluster typically corresponds to a single code page character or Unicode code point, and consists of a single [glyph](uniscribe-glossary.md).</span></span> <span data-ttu-id="811f9-116">不過，在泰文之類的語言中，叢集是一組字元，並且對應至多個連續的字元或程式碼點。</span><span class="sxs-lookup"><span data-stu-id="811f9-116">However, in languages such as Thai, a cluster is a grouping of glyphs and corresponds to multiple consecutive characters or code points.</span></span> <span data-ttu-id="811f9-117">例如，泰文叢集可能包含輔音、母音和音調標記。</span><span class="sxs-lookup"><span data-stu-id="811f9-117">For example, a Thai cluster might contain a consonant, a vowel, and a tone mark.</span></span> <span data-ttu-id="811f9-118">因此，它不會中斷叢集，應用程式通常應該使用它所能使用的最長範圍，或使用自己的詞法資訊，在不在叢集中間的位置之間中斷。</span><span class="sxs-lookup"><span data-stu-id="811f9-118">So that it does not break clusters, the application typically should either use the longest ranges it can or use its own lexical information to break between ranges in places that are not in the middle of a cluster.</span></span>

<span data-ttu-id="811f9-119">當它識別出每個範圍中的叢集時，應用程式必須決定每個叢集的大小。</span><span class="sxs-lookup"><span data-stu-id="811f9-119">When it has identified the clusters in each range, the application must determine the size of each cluster.</span></span> <span data-ttu-id="811f9-120">它會使用 Uniscribe 來加總群集，以決定每個範圍的大小。</span><span class="sxs-lookup"><span data-stu-id="811f9-120">It uses Uniscribe to sum the clusters to determine the size of each range.</span></span> <span data-ttu-id="811f9-121">然後，應用程式會加總範圍的大小，直到行溢位為止，也就是到達邊界。</span><span class="sxs-lookup"><span data-stu-id="811f9-121">Then the application sums the sizes of the ranges until they overflow a line, that is, reach the margin.</span></span> <span data-ttu-id="811f9-122">溢位的範圍會在目前的行和下一行之間分割。</span><span class="sxs-lookup"><span data-stu-id="811f9-122">The range that overflows the line is divided between the current line and the next line.</span></span> <span data-ttu-id="811f9-123">應用程式會針對每一行，從視覺位置建立對應到每個範圍的邏輯位置。</span><span class="sxs-lookup"><span data-stu-id="811f9-123">For each line, the application builds a map from visual position to logical position for each range.</span></span> <span data-ttu-id="811f9-124">然後，應用程式會將每個範圍的程式碼指向字元，以供之後定位和轉譯。</span><span class="sxs-lookup"><span data-stu-id="811f9-124">Then the application shapes the code points for each range into glyphs, which it can subsequently position and render.</span></span>

<span data-ttu-id="811f9-125">應用程式只會執行一次文字版面配置。</span><span class="sxs-lookup"><span data-stu-id="811f9-125">An application does text layout only one time.</span></span> <span data-ttu-id="811f9-126">之後，它會儲存字元和位置以供顯示之用，或在每次顯示文字時產生它們，而且會有速度與記憶體的取捨。</span><span class="sxs-lookup"><span data-stu-id="811f9-126">Afterwards, it either saves the glyphs and positions for display purposes or it generates them each time it displays the text, with the tradeoff being speed versus memory.</span></span> <span data-ttu-id="811f9-127">一般的應用程式會實作為配置程式一次，然後在每次顯示文字時產生圖像和位置。</span><span class="sxs-lookup"><span data-stu-id="811f9-127">A typical application implements the layout process once, then generates the glyphs and positions each time it displays the text.</span></span>

<span data-ttu-id="811f9-128">使用 [複雜字集](uniscribe-glossary.md) 的應用程式對於版面配置和顯示的簡單方法有下列問題。</span><span class="sxs-lookup"><span data-stu-id="811f9-128">An application that uses [complex scripts](uniscribe-glossary.md) has the following problems with a simple approach to layout and display.</span></span>

-   <span data-ttu-id="811f9-129">複雜字集字元的寬度取決於其內容。</span><span class="sxs-lookup"><span data-stu-id="811f9-129">The width of a complex script character depends on its context.</span></span> <span data-ttu-id="811f9-130">不可能將寬度儲存在簡單資料表中。</span><span class="sxs-lookup"><span data-stu-id="811f9-130">It is not possible to save the widths in simple tables.</span></span>
-   <span data-ttu-id="811f9-131">在泰文等腳本中的單字之間中斷需要字典支援。</span><span class="sxs-lookup"><span data-stu-id="811f9-131">Breaking between words in scripts such as Thai requires dictionary support.</span></span> <span data-ttu-id="811f9-132">例如，在泰文單字之間不會使用任何分隔字元。</span><span class="sxs-lookup"><span data-stu-id="811f9-132">For example, no separator character is used between Thai words.</span></span>
-   <span data-ttu-id="811f9-133">阿拉伯文、希伯來文、波斯文、烏爾型別的和其他 [雙向文字](uniscribe-glossary.md) 語言都需要重新排列才能顯示。</span><span class="sxs-lookup"><span data-stu-id="811f9-133">Arabic, Hebrew, Persian, Urdu, and other [bidirectional text](uniscribe-glossary.md) languages require reordering before display.</span></span>
-   <span data-ttu-id="811f9-134">通常需要某種形式的字型關聯，才能輕鬆地使用複雜的腳本。</span><span class="sxs-lookup"><span data-stu-id="811f9-134">Some form of font association is often required to easily use complex scripts.</span></span>

<span data-ttu-id="811f9-135">Uniscribe 使用段落作為顯示單元，可協助應用程式適當地處理這些複雜的腳本問題。</span><span class="sxs-lookup"><span data-stu-id="811f9-135">The fact that Uniscribe uses the paragraph as the display unit helps the application deal adequately with these complex script issues.</span></span>

> [!Note]  
> <span data-ttu-id="811f9-136">Uniscribe 必須用於整個段落，即使段落的區段不是複雜的腳本。</span><span class="sxs-lookup"><span data-stu-id="811f9-136">Uniscribe must be used for an entire paragraph, even if sections of the paragraph are not complex scripts.</span></span>

 

<span data-ttu-id="811f9-137">如下表所示，Uniscribe 1.6 版或更高版本支援數個可利用 OpenType 標記的函式。</span><span class="sxs-lookup"><span data-stu-id="811f9-137">As shown in the following table, Uniscribe version 1.6 or greater supports several functions that take advantage of OpenType tags.</span></span> <span data-ttu-id="811f9-138">它們可以替代對應的一般 Uniscribe 函式。</span><span class="sxs-lookup"><span data-stu-id="811f9-138">They can be substituted for the corresponding regular Uniscribe functions.</span></span> <span data-ttu-id="811f9-139">一般來說，您的應用程式應該會完全與一個集合中的函式搭配運作，而且不應該嘗試「混合和比對」函數。</span><span class="sxs-lookup"><span data-stu-id="811f9-139">Generally your applications should work entirely with functions from one set or the other and should not attempt to "mix and match" functions.</span></span>



| <span data-ttu-id="811f9-140">一般 Uniscribe 函式</span><span class="sxs-lookup"><span data-stu-id="811f9-140">Regular Uniscribe function</span></span>             | <span data-ttu-id="811f9-141">相等的 OpenType 函數</span><span class="sxs-lookup"><span data-stu-id="811f9-141">Equivalent OpenType function</span></span>                           |
|----------------------------------------|--------------------------------------------------------|
| [<span data-ttu-id="811f9-142">**ScriptItemize**</span><span class="sxs-lookup"><span data-stu-id="811f9-142">**ScriptItemize**</span></span>](/windows/desktop/api/Usp10/nf-usp10-scriptitemize) | [<span data-ttu-id="811f9-143">**ScriptItemizeOpenType**</span><span class="sxs-lookup"><span data-stu-id="811f9-143">**ScriptItemizeOpenType**</span></span>](/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype) |
| [<span data-ttu-id="811f9-144">**ScriptShape**</span><span class="sxs-lookup"><span data-stu-id="811f9-144">**ScriptShape**</span></span>](/windows/desktop/api/Usp10/nf-usp10-scriptshape)     | [<span data-ttu-id="811f9-145">**ScriptShapeOpenType**</span><span class="sxs-lookup"><span data-stu-id="811f9-145">**ScriptShapeOpenType**</span></span>](/windows/desktop/api/Usp10/nf-usp10-scriptshapeopentype)     |
| [<span data-ttu-id="811f9-146">**ScriptPlace**</span><span class="sxs-lookup"><span data-stu-id="811f9-146">**ScriptPlace**</span></span>](/windows/desktop/api/Usp10/nf-usp10-scriptplace)     | [<span data-ttu-id="811f9-147">**ScriptPlaceOpenType**</span><span class="sxs-lookup"><span data-stu-id="811f9-147">**ScriptPlaceOpenType**</span></span>](/windows/desktop/api/Usp10/nf-usp10-scriptplaceopentype)     |



 

## <a name="lay-out-text-using-uniscribe"></a><span data-ttu-id="811f9-148">使用 Uniscribe 配置文字</span><span class="sxs-lookup"><span data-stu-id="811f9-148">Lay Out Text Using Uniscribe</span></span>

<span data-ttu-id="811f9-149">您的應用程式可以使用下列步驟，透過 Uniscribe 配置文欄位落。</span><span class="sxs-lookup"><span data-stu-id="811f9-149">Your application can use the following steps to lay out out a text paragraph with Uniscribe.</span></span> <span data-ttu-id="811f9-150">此程式假設應用程式已將段落劃分為執行。</span><span class="sxs-lookup"><span data-stu-id="811f9-150">This procedure assumes that the application has already divided the paragraph into runs.</span></span>

1.  <span data-ttu-id="811f9-151">只有在啟動或收到 [**WM \_ SETTINGCHANGE**](../winmsg/wm-settingchange.md)訊息時，才呼叫 [**ScriptRecordDigitSubstitution**](/windows/desktop/api/Usp10/nf-usp10-scriptrecorddigitsubstitution) 。</span><span class="sxs-lookup"><span data-stu-id="811f9-151">Call [**ScriptRecordDigitSubstitution**](/windows/desktop/api/Usp10/nf-usp10-scriptrecorddigitsubstitution) only when starting or when receiving a [**WM\_SETTINGCHANGE**](../winmsg/wm-settingchange.md) message.</span></span>
2.  <span data-ttu-id="811f9-152"> (選擇性的) 呼叫 [**ScriptIsComplex**](/windows/desktop/api/Usp10/nf-usp10-scriptiscomplex) ，以判斷段落是否需要複雜的處理。</span><span class="sxs-lookup"><span data-stu-id="811f9-152">(Optional) Call [**ScriptIsComplex**](/windows/desktop/api/Usp10/nf-usp10-scriptiscomplex) to determine if the paragraph requires complex processing.</span></span>
3.  <span data-ttu-id="811f9-153"> (選擇性) 如果使用 Uniscribe 來處理雙向文字及/或數位替代，請呼叫 [**ScriptApplyDigitSubstitution**](/windows/desktop/api/Usp10/nf-usp10-scriptapplydigitsubstitution) 來準備 [**腳本 \_ 控制項**](/windows/win32/api/usp10/ns-usp10-script_control) ，並以 [**腳本 \_ 狀態**](/windows/win32/api/usp10/ns-usp10-script_state) 結構作為 [**ScriptItemize**](/windows/desktop/api/Usp10/nf-usp10-scriptitemize)的輸入。</span><span class="sxs-lookup"><span data-stu-id="811f9-153">(Optional) If using Uniscribe to handle bidirectional text and/or digit substitution, call [**ScriptApplyDigitSubstitution**](/windows/desktop/api/Usp10/nf-usp10-scriptapplydigitsubstitution) to prepare the [**SCRIPT\_CONTROL**](/windows/win32/api/usp10/ns-usp10-script_control) and [**SCRIPT\_STATE**](/windows/win32/api/usp10/ns-usp10-script_state) structures as inputs to [**ScriptItemize**](/windows/desktop/api/Usp10/nf-usp10-scriptitemize).</span></span> <span data-ttu-id="811f9-154">如果略過此步驟，但仍需要數位替換，請將 Unicode U + 0030 的國家/地區數位替換成 U + 0039 (歐洲數位) 。</span><span class="sxs-lookup"><span data-stu-id="811f9-154">If skipping this step, but still requiring digit substitution, substitute national digits for Unicode U+0030 through U+0039 (European digits).</span></span> <span data-ttu-id="811f9-155">如需數位替換的詳細資訊，請參閱 [數位圖形](digit-shapes.md)。</span><span class="sxs-lookup"><span data-stu-id="811f9-155">For information about digit substitution, see [Digit Shapes](digit-shapes.md).</span></span>
4.  <span data-ttu-id="811f9-156">呼叫 [**ScriptItemize**](/windows/desktop/api/Usp10/nf-usp10-scriptitemize) 將段落分割成專案。</span><span class="sxs-lookup"><span data-stu-id="811f9-156">Call [**ScriptItemize**](/windows/desktop/api/Usp10/nf-usp10-scriptitemize) to divide the paragraph into items.</span></span> <span data-ttu-id="811f9-157">如果未使用 Uniscribe 進行數位替換，且雙向順序是已知的，例如，由於用來輸入字元的鍵盤配置，請呼叫 **ScriptItemize**。</span><span class="sxs-lookup"><span data-stu-id="811f9-157">If not using Uniscribe for digit substitution and the bidirectional order is known, for example, because of the keyboard layout used to enter the character, call **ScriptItemize**.</span></span> <span data-ttu-id="811f9-158">在呼叫中，提供 [**腳本 \_ 控制項**](/windows/win32/api/usp10/ns-usp10-script_control) 和 [**腳本 \_ 狀態**](/windows/win32/api/usp10/ns-usp10-script_state) 結構的 null 指標。</span><span class="sxs-lookup"><span data-stu-id="811f9-158">In the call, provide null pointers for the [**SCRIPT\_CONTROL**](/windows/win32/api/usp10/ns-usp10-script_control) and [**SCRIPT\_STATE**](/windows/win32/api/usp10/ns-usp10-script_state) structures.</span></span> <span data-ttu-id="811f9-159">這項技術只會透過使用成形引擎來產生專案，而且可以使用引擎資訊將專案重新排序。</span><span class="sxs-lookup"><span data-stu-id="811f9-159">This technique generates items by use of the shaping engine only, and the items can be reordered using the engine information.</span></span>
    > [!Note]  
    > <span data-ttu-id="811f9-160">一般來說，只使用由左至右腳本且沒有任何數位替代的應用程式，應該傳遞 [**腳本 \_ 控制項**](/windows/win32/api/usp10/ns-usp10-script_control) 和 [**腳本 \_ 狀態**](/windows/win32/api/usp10/ns-usp10-script_state) 結構的 null 指標。</span><span class="sxs-lookup"><span data-stu-id="811f9-160">Typically, applications that work only with left-to-right scripts and without any digit substitution should pass null pointers for the [**SCRIPT\_CONTROL**](/windows/win32/api/usp10/ns-usp10-script_control) and [**SCRIPT\_STATE**](/windows/win32/api/usp10/ns-usp10-script_state) structures.</span></span>

     

5.  <span data-ttu-id="811f9-161">將專案資訊與執行資訊合併，以產生範圍。</span><span class="sxs-lookup"><span data-stu-id="811f9-161">Merge the item information with the run information to produce ranges.</span></span>
6.  <span data-ttu-id="811f9-162">呼叫 [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) 來識別叢集並產生字元。</span><span class="sxs-lookup"><span data-stu-id="811f9-162">Call [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) to identify clusters and generate glyphs.</span></span>
7.  <span data-ttu-id="811f9-163">如果 [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) 傳回 \_ 不在字型中的程式碼 USP E \_ 腳本 \_ \_ \_ \_ ，或有輸出包含遺漏圖像的輸出，請選取不同字型中的字元。</span><span class="sxs-lookup"><span data-stu-id="811f9-163">If [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) returns the code USP\_E\_SCRIPT\_NOT\_IN\_FONT or S\_OK with the output containing missing glyphs, select characters from a different font.</span></span> <span data-ttu-id="811f9-164">請將傳遞給 **ScriptShape** 的 [**腳本 \_ 分析**](/windows/win32/api/usp10/ns-usp10-script_analysis)結構的 **eScript** 成員設定為未定義的腳本，以替代另一個字型或停用成形 \_ 。</span><span class="sxs-lookup"><span data-stu-id="811f9-164">Either substitute another font or disable shaping by setting the **eScript** member of the [**SCRIPT\_ANALYSIS**](/windows/win32/api/usp10/ns-usp10-script_analysis) structure passed to **ScriptShape** to SCRIPT\_UNDEFINED.</span></span> <span data-ttu-id="811f9-165">如需詳細資訊，請參閱 [使用字型](using-font-fallback.md)回復。</span><span class="sxs-lookup"><span data-stu-id="811f9-165">For more information, see [Using Font Fallback](using-font-fallback.md).</span></span>
8.  <span data-ttu-id="811f9-166">呼叫 [**ScriptPlace**](/windows/desktop/api/Usp10/nf-usp10-scriptplace) 以產生每個後續範圍中圖像的 [前進寬度](uniscribe-glossary.md) 和 x 和 y 位置。</span><span class="sxs-lookup"><span data-stu-id="811f9-166">Call [**ScriptPlace**](/windows/desktop/api/Usp10/nf-usp10-scriptplace) to generate [advance widths](uniscribe-glossary.md) and x and y positions for the glyphs in each successive range.</span></span> <span data-ttu-id="811f9-167">這是文字大小變成考慮的第一個步驟。</span><span class="sxs-lookup"><span data-stu-id="811f9-167">This is the first step for which text size becomes a consideration.</span></span>
9.  <span data-ttu-id="811f9-168">將範圍大小加總，直到行溢位為止。</span><span class="sxs-lookup"><span data-stu-id="811f9-168">Sum the range sizes until the line overflows.</span></span>
10. <span data-ttu-id="811f9-169">使用邏輯屬性中的 **fSoftBreak** 和 **fWhiteSpace** 成員，來中斷單字界限的範圍。</span><span class="sxs-lookup"><span data-stu-id="811f9-169">Break the range on a word boundary by using the **fSoftBreak** and **fWhiteSpace** members in the logical attributes.</span></span> <span data-ttu-id="811f9-170">若要在執行時中斷單一字元叢集，請使用呼叫 [**ScriptBreak**](/windows/desktop/api/Usp10/nf-usp10-scriptbreak)傳回的資訊。</span><span class="sxs-lookup"><span data-stu-id="811f9-170">To break a single character cluster off the run, use the information returned by calling [**ScriptBreak**](/windows/desktop/api/Usp10/nf-usp10-scriptbreak).</span></span>
    > [!Note]  
    > <span data-ttu-id="811f9-171">決定範圍的第一個程式碼點是否應為斷字點，因為前一個範圍中的最後一個字元需要它。</span><span class="sxs-lookup"><span data-stu-id="811f9-171">Decide if the first code point of a range should be a word break point because the last character of the previous range requires it.</span></span> <span data-ttu-id="811f9-172">例如，如果一個範圍以逗號結束，請將下一個範圍中的第一個字元視為單字分隔點。</span><span class="sxs-lookup"><span data-stu-id="811f9-172">For example, if one range ends in a comma, consider the first character of the next range to be a word break point.</span></span>

     

11. <span data-ttu-id="811f9-173">針對段落中的每一行，重複步驟6到10。</span><span class="sxs-lookup"><span data-stu-id="811f9-173">Repeat steps 6 through 10 for each line in the paragraph.</span></span> <span data-ttu-id="811f9-174">但是，如果中斷最後一次執行的程式程式碼，請呼叫 [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) ，將執行的其餘部分重新調整為下一行的第一次執行。</span><span class="sxs-lookup"><span data-stu-id="811f9-174">However, if breaking the last run on the line, call [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) to reshape the remaining part of the run as the first run on the next line.</span></span>

## <a name="display-text-using-uniscribe"></a><span data-ttu-id="811f9-175">使用 Uniscribe 顯示文字</span><span class="sxs-lookup"><span data-stu-id="811f9-175">Display Text Using Uniscribe</span></span>

<span data-ttu-id="811f9-176">您的應用程式可以使用下列步驟來顯示文欄位落。</span><span class="sxs-lookup"><span data-stu-id="811f9-176">Your application can use the following steps to display a text paragraph.</span></span> <span data-ttu-id="811f9-177">此程式假設應用程式已配置文字，而且尚未從配置進程儲存字元和位置。</span><span class="sxs-lookup"><span data-stu-id="811f9-177">This procedure assumes that the application has already laid out the text and has not saved the glyphs and positions from the layout process.</span></span> <span data-ttu-id="811f9-178">如果速度是個問題，應用程式可以從配置程式儲存字元和位置，並在顯示程式的步驟2開始。</span><span class="sxs-lookup"><span data-stu-id="811f9-178">If speed is a concern, the application can save the glyphs and positions from the layout procedure and start at step 2 in the display procedure.</span></span>

> [!Note]  
> <span data-ttu-id="811f9-179">如果文字不包含由右至左的腳本提供任何字元、不包含雙向控制字元，而且使用由左至右的基底內嵌層級，則應用程式可以省略步驟2。</span><span class="sxs-lookup"><span data-stu-id="811f9-179">The application can omit step 2 if the text contains no characters from right-to-left scripts, contains no bidirectional control characters, and uses a left-to-right base embedding level.</span></span>

 

1.  <span data-ttu-id="811f9-180">針對每個執行，執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="811f9-180">For each run, do the following:</span></span>
    1.  <span data-ttu-id="811f9-181">如果樣式自上一次執行之後已變更，請釋放並重新取得裝置內容的控制碼。</span><span class="sxs-lookup"><span data-stu-id="811f9-181">If the style has changed since the last run, update the handle to the device context by releasing and getting it again.</span></span>
    2.  <span data-ttu-id="811f9-182">呼叫 [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) 以產生執行的字元。</span><span class="sxs-lookup"><span data-stu-id="811f9-182">Call [**ScriptShape**](/windows/desktop/api/Usp10/nf-usp10-scriptshape) to generate glyphs for the run.</span></span>
    3.  <span data-ttu-id="811f9-183">呼叫 [**ScriptPlace**](/windows/desktop/api/Usp10/nf-usp10-scriptplace) 以產生每個字元的前進寬度和 x、y 位移。</span><span class="sxs-lookup"><span data-stu-id="811f9-183">Call [**ScriptPlace**](/windows/desktop/api/Usp10/nf-usp10-scriptplace) to generate an advance width and an x,y offset for each glyph.</span></span>
2.  <span data-ttu-id="811f9-184">執行下列動作，以在行中建立執行的正確視覺效果順序：</span><span class="sxs-lookup"><span data-stu-id="811f9-184">Do the following to establish the correct visual order for the runs in the line:</span></span>
    1.  <span data-ttu-id="811f9-185">將雙向內嵌 [層級](uniscribe-glossary.md)的陣列（每個範圍一個）解壓縮。</span><span class="sxs-lookup"><span data-stu-id="811f9-185">Extract an array of bidirectional [embedding levels](uniscribe-glossary.md), one per range.</span></span> <span data-ttu-id="811f9-186">內嵌層級是由 (腳本 \_ 專案) si 提供。 (腳本 \_ 分析) 。</span><span class="sxs-lookup"><span data-stu-id="811f9-186">The embedding level is given by (SCRIPT\_ITEM) si.(SCRIPT\_ANALYSIS) a.</span></span> <span data-ttu-id="811f9-187"> (腳本 \_ 狀態) s. uBidiLevel。</span><span class="sxs-lookup"><span data-stu-id="811f9-187">(SCRIPT\_STATE) s.uBidiLevel.</span></span>
    2.  <span data-ttu-id="811f9-188">將此陣列傳遞至 [**ScriptLayout**](/windows/desktop/api/Usp10/nf-usp10-scriptlayout) ，以產生邏輯位置的視覺位置對應。</span><span class="sxs-lookup"><span data-stu-id="811f9-188">Pass this array to [**ScriptLayout**](/windows/desktop/api/Usp10/nf-usp10-scriptlayout) to generate a map of visual positions to logical positions.</span></span>
3.  <span data-ttu-id="811f9-189"> (選擇性的) 來證明文字，請呼叫 [**ScriptJustify**](/windows/desktop/api/Usp10/nf-usp10-scriptjustify) 或使用文字的特定知識。</span><span class="sxs-lookup"><span data-stu-id="811f9-189">(Optional) To justify the text, either call [**ScriptJustify**](/windows/desktop/api/Usp10/nf-usp10-scriptjustify) or use specialized knowledge of the text.</span></span>
4.  <span data-ttu-id="811f9-190">使用視覺效果對邏輯地圖以視覺化順序顯示執行。</span><span class="sxs-lookup"><span data-stu-id="811f9-190">Use the visual-to-logical map to display the runs in visual order.</span></span> <span data-ttu-id="811f9-191">從該行的左邊端開始，呼叫 [**ScriptTextOut**](/windows/desktop/api/Usp10/nf-usp10-scripttextout) ，以顯示對應中第一個專案所指定的執行。</span><span class="sxs-lookup"><span data-stu-id="811f9-191">Starting at the left end of the line, call [**ScriptTextOut**](/windows/desktop/api/Usp10/nf-usp10-scripttextout) to display the run given by the first entry in the map.</span></span> <span data-ttu-id="811f9-192">針對對應中的每個後續專案，呼叫 **ScriptTextOut** ，以顯示先前顯示之執行右邊的指定回合。</span><span class="sxs-lookup"><span data-stu-id="811f9-192">For each subsequent entry in the map, call **ScriptTextOut** to display the indicated run to the right of the previously displayed run.</span></span>

    <span data-ttu-id="811f9-193">如果省略步驟2，請從該行的左邊開始，然後呼叫 [**ScriptTextOut**](/windows/desktop/api/Usp10/nf-usp10-scripttextout) 來顯示第一個邏輯執行，然後在上一次執行的右側顯示每個邏輯執行。</span><span class="sxs-lookup"><span data-stu-id="811f9-193">If omitting step 2, start at the left end of the line and call [**ScriptTextOut**](/windows/desktop/api/Usp10/nf-usp10-scripttextout) to display the first logical run, and then to display each logical run to the right of the previous run.</span></span>

5.  <span data-ttu-id="811f9-194">針對段落中的所有行重複上述步驟。</span><span class="sxs-lookup"><span data-stu-id="811f9-194">Repeat the steps above for all lines in the paragraph.</span></span>

## <a name="related-topics"></a><span data-ttu-id="811f9-195">相關主題</span><span class="sxs-lookup"><span data-stu-id="811f9-195">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="811f9-196">使用 Uniscribe</span><span class="sxs-lookup"><span data-stu-id="811f9-196">Using Uniscribe</span></span>](using-uniscribe.md)
</dt> </dl>

 

 
