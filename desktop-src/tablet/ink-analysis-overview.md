---
description: InkAnalysis Api 為 Tablet PC 開發人員提供功能強大的工具，以程式設計方式檢查筆墨輸入。 API 會將筆墨分類為有意義的類別，例如單字、線條、段落和繪圖。
ms.assetid: d9521a8c-f61a-40ea-8603-e8afbba75a4e
title: 筆墨分析總覽
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8e383d16c01cd9475d4c54587b4b5fb4c09791a0
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104511032"
---
# <a name="ink-analysis-overview"></a><span data-ttu-id="a5c58-104">筆墨分析總覽</span><span class="sxs-lookup"><span data-stu-id="a5c58-104">Ink Analysis Overview</span></span>

<span data-ttu-id="a5c58-105">InkAnalysis Api 為 Tablet PC 開發人員提供功能強大的工具，以程式設計方式檢查筆墨輸入。</span><span class="sxs-lookup"><span data-stu-id="a5c58-105">The InkAnalysis APIs provide Tablet PC developers with powerful tools to programmatically examine ink input.</span></span> <span data-ttu-id="a5c58-106">API 會將筆墨分類為有意義的類別，例如單字、線條、段落和繪圖。</span><span class="sxs-lookup"><span data-stu-id="a5c58-106">The API classifies ink into meaningful categories such as words, lines, paragraphs, and drawings.</span></span>

<span data-ttu-id="a5c58-107">您可以使用各種不同的方式來使用每個分類，包括改善手寫的辨識結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-107">You can use each classification in a variety of ways, including improving recognition results for handwriting.</span></span>

## <a name="ink-analysis-basics"></a><span data-ttu-id="a5c58-108">筆墨分析基本概念</span><span class="sxs-lookup"><span data-stu-id="a5c58-108">Ink Analysis Basics</span></span>

<span data-ttu-id="a5c58-109">本節介紹 Tablet PC 平臺筆墨分析技術，並說明其使用時機和方式。</span><span class="sxs-lookup"><span data-stu-id="a5c58-109">This section introduces the Tablet PC Platform ink analysis technology and explains when and how to use it.</span></span>

<span data-ttu-id="a5c58-110">InkAnalysis Api 能有效地結合兩個不同但免費的技術：手寫辨識和版面配置分類。</span><span class="sxs-lookup"><span data-stu-id="a5c58-110">The InkAnalysis APIs effectively combine two distinct but complimentary technologies: handwriting recognition and layout classification.</span></span> <span data-ttu-id="a5c58-111">結合這兩種技術，可提供比單獨取得的結果更大的結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-111">Combining these two technologies gives definitively greater results than the parts taken alone.</span></span>

<span data-ttu-id="a5c58-112">手寫辨識是手寫數位筆跡的計算分析，會以指定的語言傳回以字元為基礎的轉譯。</span><span class="sxs-lookup"><span data-stu-id="a5c58-112">Handwriting recognition is the computational analysis of handwritten digital ink to return character-based interpretation in a given language.</span></span> <span data-ttu-id="a5c58-113">也就是說，手寫辨識是電腦「讀取」人員手寫的方式。</span><span class="sxs-lookup"><span data-stu-id="a5c58-113">That is, handwriting recognition is how the computer "reads" a person's handwriting.</span></span>

<span data-ttu-id="a5c58-114">筆墨分析可進一步細分為筆跡分類和版面配置分析。</span><span class="sxs-lookup"><span data-stu-id="a5c58-114">Ink Analysis can be further broken down into ink classification and layout analysis.</span></span> <span data-ttu-id="a5c58-115">筆墨分類是以語義有意義的單位（例如段落、線條、單字和繪圖）計算的筆跡。</span><span class="sxs-lookup"><span data-stu-id="a5c58-115">Ink classification is the computational division of ink into semantically meaningful units such as paragraphs, lines, words, and drawings.</span></span> <span data-ttu-id="a5c58-116">版面配置分析是筆跡輸入的計算檢查，用來判斷筆跡在筆跡表面上的位置，以及筆劃與其他空間之間的關聯性，甚至是語義。</span><span class="sxs-lookup"><span data-stu-id="a5c58-116">Layout analysis is the computational examination of ink input to determine the position of the ink on the inking surface and how the strokes relate to each other spatially and even semantically.</span></span> <span data-ttu-id="a5c58-117">例如，版面配置分析可告知您特定的筆墨部分是批註或呼叫。</span><span class="sxs-lookup"><span data-stu-id="a5c58-117">For example, layout analysis can tell you that a particular piece of ink is an annotation or a call out.</span></span>

### <a name="recognition"></a><span data-ttu-id="a5c58-118">辨識</span><span class="sxs-lookup"><span data-stu-id="a5c58-118">Recognition</span></span>

<span data-ttu-id="a5c58-119">在 InkAnalysis API 中使用筆墨分析進行辨識組合的其中一個範例，可協助開發人員改善辨識結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-119">One example of how the combination of recognition with ink analysis in the InkAnalysis API helps the developer is the improvement in recognition results.</span></span> <span data-ttu-id="a5c58-120">Tablet PC 手寫辨識引擎主要是設計來辨識一條水平線的筆跡。</span><span class="sxs-lookup"><span data-stu-id="a5c58-120">The Tablet PC handwriting recognition engines have been primarily designed to recognize a single horizontal line of ink.</span></span> <span data-ttu-id="a5c58-121">不過，人們通常會在拍攝筆記時撰寫多行程式碼，而這些線條不保證會與頁面相對水準。</span><span class="sxs-lookup"><span data-stu-id="a5c58-121">However, people tend to write multiple lines when taking notes, and those lines are not guaranteed to be horizontal in relation to the page.</span></span> <span data-ttu-id="a5c58-122">使用 InkAnalysis API 時，筆墨分析器會將筆墨前置處理，然後再傳送至辨識器。</span><span class="sxs-lookup"><span data-stu-id="a5c58-122">With the InkAnalysis API, ink is preprocessed by the ink analyzer before being sent to the recognizer.</span></span> <span data-ttu-id="a5c58-123">分析過的筆墨會在辨識之前轉換為水準，以改善辨識結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-123">The analyzed ink is transformed to horizontal before being recognized, improving the recognition results.</span></span>

<span data-ttu-id="a5c58-124">其他辨識的優點是藉由在將筆墨傳送至辨識器之前，讓筆墨分析器更正不正確的筆觸順序資訊來衍生。</span><span class="sxs-lookup"><span data-stu-id="a5c58-124">Other benefits to recognition are derived by having the ink analyzer correct incorrect stroke order information before sending the ink to the recognizer.</span></span> <span data-ttu-id="a5c58-125">此外，辨識結果現在以選擇性的方式提供。</span><span class="sxs-lookup"><span data-stu-id="a5c58-125">Further, recognition results are now available in a selective manner.</span></span> <span data-ttu-id="a5c58-126">也就是說，開發人員可以在單一呼叫中，快速地取得單一單字、線條或段落的辨識結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-126">That is, the developer can quickly retrieve the recognition results for a single word, line, or paragraph in one call.</span></span>

### <a name="ink-classification"></a><span data-ttu-id="a5c58-127">筆墨分類</span><span class="sxs-lookup"><span data-stu-id="a5c58-127">Ink Classification</span></span>

<span data-ttu-id="a5c58-128">當然，在許多情況下，您可能會將筆墨資料保持不變，而不是立即轉換成文字。</span><span class="sxs-lookup"><span data-stu-id="a5c58-128">There are, of course, a variety of scenarios in which you may to keep the ink data intact, rather than converting it immediately to text.</span></span> <span data-ttu-id="a5c58-129">筆墨分析也會在這裡提供優點。</span><span class="sxs-lookup"><span data-stu-id="a5c58-129">Ink analysis provides benefits here as well.</span></span> <span data-ttu-id="a5c58-130">具體來說，InkAnalysis Api 可讓您根據手寫筆劃是否為書寫或繪圖來加以分割。</span><span class="sxs-lookup"><span data-stu-id="a5c58-130">Specifically, the InkAnalysis APIs provide the ability to split ink strokes according to whether they are writing or drawings.</span></span> <span data-ttu-id="a5c58-131">分類為書寫的筆墨筆觸是組成單字或字元的筆墨筆劃。</span><span class="sxs-lookup"><span data-stu-id="a5c58-131">Ink strokes that are classified as writing are those that make up a word or characters.</span></span> <span data-ttu-id="a5c58-132">所有其他筆劃都是繪圖。</span><span class="sxs-lookup"><span data-stu-id="a5c58-132">All other strokes are drawings.</span></span> <span data-ttu-id="a5c58-133">這可為您提供新的方式來存取筆墨資料，並啟用新的使用者案例。</span><span class="sxs-lookup"><span data-stu-id="a5c58-133">This provides you with a new way to access ink data, enabling new user scenarios.</span></span> <span data-ttu-id="a5c58-134">例如，您可以根據使用者所按下的筆劃類型，執行選取專案，使其不同;如果使用者按下書寫筆劃，則應用程式會選取組成單字的整組筆劃，如果使用者按下繪圖搧風，應用程式只會選取該筆觸。</span><span class="sxs-lookup"><span data-stu-id="a5c58-134">For instance, you may implement selection so that it is different based on which type of stroke the user taps on; if a user taps a writing stroke, the application selects the entire set of strokes that compose the word, if the user taps a drawing stoke, the application selects only that stroke.</span></span>

### <a name="layout-analysis"></a><span data-ttu-id="a5c58-135">版面配置分析</span><span class="sxs-lookup"><span data-stu-id="a5c58-135">Layout Analysis</span></span>

<span data-ttu-id="a5c58-136">在撰寫和繪製元件時，有用的版面配置分析實際上遠超越筆墨的相對簡單明細。</span><span class="sxs-lookup"><span data-stu-id="a5c58-136">Useful layout analysis actually goes far beyond the relatively simple breakdown of ink into writing and drawing components.</span></span>

<span data-ttu-id="a5c58-137">筆墨分析也包含書寫和繪製筆劃的更豐富明細。</span><span class="sxs-lookup"><span data-stu-id="a5c58-137">Ink analysis also includes a richer breakdown of the writing and drawing strokes.</span></span> <span data-ttu-id="a5c58-138">作為一個非常簡單的範例，請拍攝筆墨的 blob，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="a5c58-138">As a very simple example, take a blob of ink as shown in the following illustration.</span></span>

![兩條簡單的手寫](images/12e7a221-59c1-4d69-b7aa-67f2caebe375.jpg)

<span data-ttu-id="a5c58-140">在平臺分析這些筆觸之後，它會傳回這些筆觸的樹狀標記法，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="a5c58-140">After the platform has analyzed these strokes, it returns a tree representation of these strokes as shown in the following illustration.</span></span> <span data-ttu-id="a5c58-141">在這個簡單的案例中，樹狀結構只包含段落、行和單字資訊，但是這個樹狀結構的豐富程度會隨著筆墨檔的複雜度而增加。</span><span class="sxs-lookup"><span data-stu-id="a5c58-141">For this simple case, the tree contains only paragraph, line, and word information, but the richness of this tree increases as the complexity of the ink document increases.</span></span>

![根、段落、行和單字的樹狀結構表示](images/be5a7635-0abc-45ad-bcb5-98fddee5e148.jpg)

<span data-ttu-id="a5c58-143">由於這項資訊現在會分成可管理的單位，因此您現在可以建立功能更強大的功能。</span><span class="sxs-lookup"><span data-stu-id="a5c58-143">Because this information is now separated into manageable units, you can now create more powerful features.</span></span> <span data-ttu-id="a5c58-144">例如，應用程式可以擴充功能，讓使用者在其中按一下以選取文字，然後按兩次以選取整個行，然後按三次來選取整段文字的功能。</span><span class="sxs-lookup"><span data-stu-id="a5c58-144">As an example, the application can extend the feature in which the user taps to select a word into a feature in which the user taps once to select the word, taps twice to select the entire line, and taps three times to select the entire paragraph.</span></span> <span data-ttu-id="a5c58-145">藉由利用分析作業所傳回的樹狀結構，應用程式可以將分區域關聯回樹狀結構中的筆劃。</span><span class="sxs-lookup"><span data-stu-id="a5c58-145">By leveraging the tree structure returned by the analysis operation, the application can relate the tapped area back to a stroke in the tree.</span></span> <span data-ttu-id="a5c58-146">應用程式找到筆觸之後，就可以向上查看樹狀結構，以判斷要選取的相鄰筆觸的方式和。</span><span class="sxs-lookup"><span data-stu-id="a5c58-146">After the application finds a stroke, it can walk up the tree to determine how and which neighboring strokes to select.</span></span>

<span data-ttu-id="a5c58-147">選取整行是筆墨分析優點的簡單範例，但是當其中一個會考慮筆墨分析器可以偵測的不同階層結構類型時，可能會很有説明：</span><span class="sxs-lookup"><span data-stu-id="a5c58-147">Selecting an entire line is a simplistic example of the benefits of ink analysis, but the possibilities become great when one considers the different types of hierarchical structures the ink analyzer is capable of detecting:</span></span>

-   <span data-ttu-id="a5c58-148">已排序和未排序的清單</span><span class="sxs-lookup"><span data-stu-id="a5c58-148">Ordered and unordered lists</span></span>
-   <span data-ttu-id="a5c58-149">圖形</span><span class="sxs-lookup"><span data-stu-id="a5c58-149">Shapes</span></span>
-   <span data-ttu-id="a5c58-150">Annotative 以文字內嵌撰寫的批註</span><span class="sxs-lookup"><span data-stu-id="a5c58-150">Annotative comments written inline with the text</span></span>

<span data-ttu-id="a5c58-151">功能的類型會因應用程式而異，而且會根據需求和可用的筆墨分析和辨識引擎。</span><span class="sxs-lookup"><span data-stu-id="a5c58-151">The types of features vary from application to application and are based on requirements and the available ink analysis and recognition engines.</span></span>

### <a name="key-ink-analysis-features"></a><span data-ttu-id="a5c58-152">重要筆墨分析功能</span><span class="sxs-lookup"><span data-stu-id="a5c58-152">Key Ink Analysis Features</span></span>

<span data-ttu-id="a5c58-153">InkAnalysis API 的主要功能包括下列功能：</span><span class="sxs-lookup"><span data-stu-id="a5c58-153">The key capabilities of the InkAnalysis API include the following features:</span></span>

-   <span data-ttu-id="a5c58-154">累加式分析</span><span class="sxs-lookup"><span data-stu-id="a5c58-154">Incremental Analysis</span></span>
-   <span data-ttu-id="a5c58-155">持續性</span><span class="sxs-lookup"><span data-stu-id="a5c58-155">Persistence</span></span>
-   <span data-ttu-id="a5c58-156">資料 Proxy</span><span class="sxs-lookup"><span data-stu-id="a5c58-156">Data Proxy</span></span>
-   <span data-ttu-id="a5c58-157">和解</span><span class="sxs-lookup"><span data-stu-id="a5c58-157">Reconciliation</span></span>
-   <span data-ttu-id="a5c58-158">擴充性</span><span class="sxs-lookup"><span data-stu-id="a5c58-158">Extensibility</span></span>

### <a name="incremental-analysis"></a><span data-ttu-id="a5c58-159">累加式分析</span><span class="sxs-lookup"><span data-stu-id="a5c58-159">Incremental Analysis</span></span>

<span data-ttu-id="a5c58-160">當終端使用者使用筆墨時，通常會將其視為手寫。</span><span class="sxs-lookup"><span data-stu-id="a5c58-160">When end users work with ink, they usually treat it like handwriting.</span></span> <span data-ttu-id="a5c58-161">筆墨會持續受編輯作業的影響，例如新增筆墨、刪除現有筆墨，以及修改筆墨屬性，全都是以編輯手寫的相同方式完成。</span><span class="sxs-lookup"><span data-stu-id="a5c58-161">The ink is continually subject to editing operations such as the addition of new ink, deletion of existing ink, and the modification of ink properties, all done in the same way that handwriting is continually edited.</span></span> <span data-ttu-id="a5c58-162">這些編輯作業會影響分析結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-162">These editing operations affect the analysis results.</span></span> <span data-ttu-id="a5c58-163">進行編輯時，通常會在特定時間點將其隔離到檔的區段。</span><span class="sxs-lookup"><span data-stu-id="a5c58-163">When edits occur, they can usually be isolated to sections of the document at specific points in time.</span></span> <span data-ttu-id="a5c58-164">例如，假設使用者寫入五行筆跡。</span><span class="sxs-lookup"><span data-stu-id="a5c58-164">For example, assume a user writes five lines of ink.</span></span> <span data-ttu-id="a5c58-165">應用程式分析筆墨的標準方式是等候使用者完成全部五行筆墨的書寫（例如段落），然後以同步或非同步方式分析結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-165">The standard way that applications analyze ink is to wait until the user has finished writing all five lines of ink—a paragraph, for instance—and then analyze the results, either synchronously or asynchronously.</span></span>

<span data-ttu-id="a5c58-166">您可以將分析時所分析的區域隔離，然後只 reanalyzing 已變更的部分結果，藉此優化分析這五行所花費的整體時間。</span><span class="sxs-lookup"><span data-stu-id="a5c58-166">You can optimize the overall time spent analyzing these five lines by isolating the areas that are analyzed as they are being written, and then reanalyzing only the parts of the results that have changed.</span></span> <span data-ttu-id="a5c58-167">分析第一行之後，除非使用者修改了第一行，否則永遠不會再次辨識。</span><span class="sxs-lookup"><span data-stu-id="a5c58-167">After the first line is analyzed, it will never be recognized again unless it is modified by the end user.</span></span> <span data-ttu-id="a5c58-168">第二行的辨識會被視為獨立的辨識作業。</span><span class="sxs-lookup"><span data-stu-id="a5c58-168">Recognition of the second line is treated as an independent recognition operation.</span></span>

<span data-ttu-id="a5c58-169">這種漸進式方法適用于辨識作業的行層級，但它需要針對筆墨分析作業以較高層級的方式運作。</span><span class="sxs-lookup"><span data-stu-id="a5c58-169">This incremental approach works well at the line level for the recognition operations, but it needs to work at a higher level for the ink analysis operation.</span></span> <span data-ttu-id="a5c58-170">由於筆墨分析器可以針對這五行筆墨偵測不同的較高層級分類 (例如，它可能是清單) 中的標準段落或五個專案，而筆墨分析器的累加方法是必須分析這些較高的結構。</span><span class="sxs-lookup"><span data-stu-id="a5c58-170">Because the ink analyzer can detect different higher level classifications for these five lines of ink (for example, it could be a standard paragraph or five items in a list), the incremental approach for the ink analyzer is that it has to analyze these higher structures.</span></span> <span data-ttu-id="a5c58-171">也就是說，在筆跡分析器將筆墨的第一行分類為線條之後，它會在分類第二行時再次檢查它是否仍然是線條。</span><span class="sxs-lookup"><span data-stu-id="a5c58-171">That is to say, after the ink analyzer classifies the first line of ink as a line, it double-checks that it is still a line when it classifies the second line.</span></span> <span data-ttu-id="a5c58-172">不過，「筆跡分析器」會將這次的雙重檢查隔離到段落，並在分析第二個段落時忽略第一個段落，將第二個段落視為獨立的筆墨分析器作業。</span><span class="sxs-lookup"><span data-stu-id="a5c58-172">However, the ink analyzer isolates this double-checking to the paragraph and ignores the first paragraph when analyzing a second paragraph, treating the second paragraph as an independent ink analyzer operation.</span></span> <span data-ttu-id="a5c58-173">當應用程式中已有大量筆墨時，此累加的分析方法可大幅節省處理時間。</span><span class="sxs-lookup"><span data-stu-id="a5c58-173">This incremental approach to analysis dramatically saves processing time when large amounts of ink already exist in the application.</span></span>

### <a name="persistence"></a><span data-ttu-id="a5c58-174">持續性</span><span class="sxs-lookup"><span data-stu-id="a5c58-174">Persistence</span></span>

<span data-ttu-id="a5c58-175">累加式分析可在指定的會話或 [**InkAnalyzer**](inkanalyzer.md) 物件的實例內順利運作。</span><span class="sxs-lookup"><span data-stu-id="a5c58-175">Incremental analysis works well within a given session or instance of an [**InkAnalyzer**](inkanalyzer.md) object.</span></span> <span data-ttu-id="a5c58-176">不過，當筆墨保存到磁片之後，第一代 Tablet PC 平臺 Api 無法執行累加式分析。</span><span class="sxs-lookup"><span data-stu-id="a5c58-176">However, the first generation Tablet PC Platform APIs cannot perform incremental analysis after the ink is persisted to disk.</span></span> <span data-ttu-id="a5c58-177">InkAnalysis API 可讓您將筆墨儲存至磁片，以及保存形式的分析結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-177">The InkAnalysis API enables saving ink to disk along with a persisted form of the analysis results.</span></span> <span data-ttu-id="a5c58-178">當筆墨載入時可以載入分析結果，而且可以插入 **InkAnalyzer** 的新實例。</span><span class="sxs-lookup"><span data-stu-id="a5c58-178">The analysis results can be loaded when the ink is loaded and can be injected into a new instance of an **InkAnalyzer**.</span></span> <span data-ttu-id="a5c58-179">然後， **InkAnalyzer** 物件的新實例會具有與先前相同的結果狀態，而且現在可接受任何修改做為現有狀態的累加變更，而不是再次分析所有專案。</span><span class="sxs-lookup"><span data-stu-id="a5c58-179">A new instance of the **InkAnalyzer** object then has the same results state it previously had and can now accept any modifications as incremental changes to the existing state, rather than analyzing everything again.</span></span>

### <a name="data-proxy"></a><span data-ttu-id="a5c58-180">資料 Proxy</span><span class="sxs-lookup"><span data-stu-id="a5c58-180">Data Proxy</span></span>

<span data-ttu-id="a5c58-181">許多應用程式在其應用程式中已經有某種類型的現有檔結構;例如，圖形或資料庫。</span><span class="sxs-lookup"><span data-stu-id="a5c58-181">Many applications already have some sort of existing document structure in their applications; for instance, a graph or a database.</span></span> <span data-ttu-id="a5c58-182">[**InkAnalyzer**](inkanalyzer.md)也會在 [**CoNtextNode**](icontextnode.md)物件的樹狀結構中，以結構化形式呈現結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-182">The [**InkAnalyzer**](inkanalyzer.md) also presents results in a structured form, in a tree of [**ContextNode**](icontextnode.md) objects.</span></span> <span data-ttu-id="a5c58-183">**InkAnalyzer** 結構和應用程式的現有結構需要雙向交互操作：結果會從 **InkAnalyzer** 提取至應用程式，並將狀態從應用程式推送到 **InkAnalyzer**。</span><span class="sxs-lookup"><span data-stu-id="a5c58-183">The **InkAnalyzer** structure and the application's existing structure need to interoperate in two directions: results are pulled from the **InkAnalyzer** into the application and state is pushed from the application into the **InkAnalyzer**.</span></span>

<span data-ttu-id="a5c58-184">如果您只需要將 [**InkAnalyzer**](inkanalyzer.md) 中的結果提取到應用程式的結構中，就會相當簡單。</span><span class="sxs-lookup"><span data-stu-id="a5c58-184">If pulling the results from the [**InkAnalyzer**](inkanalyzer.md) into the application's structure were all that was needed, it would be relatively simple.</span></span> <span data-ttu-id="a5c58-185">應用程式會逐一查看結果樹狀結構，並將 (整合) 所需的所有結果全都併入其現有的資料結構中。</span><span class="sxs-lookup"><span data-stu-id="a5c58-185">Applications would iterate through the results tree and copy (integrate) all pieces of the results they need into their existing data structure.</span></span> <span data-ttu-id="a5c58-186">不過，因為許多水準應用程式都需要增量分析和持續性磁片，所以問題會變成雙向。</span><span class="sxs-lookup"><span data-stu-id="a5c58-186">However, because many horizontal applications require incremental analysis and persistence to disk, the problem becomes two-directional.</span></span> <span data-ttu-id="a5c58-187">狀態 (過去的結果) 需要從應用程式的結構提取並推送至 **InkAnalyzer**。</span><span class="sxs-lookup"><span data-stu-id="a5c58-187">State (past results) needs to be pulled from the application's structure and pushed into the **InkAnalyzer**.</span></span>

<span data-ttu-id="a5c58-188">為了滿足這項需求， [**InkAnalyzer**](inkanalyzer.md) 包含一系列事件，可在分析作業期間于適當時間引發，以允許應用程式將資料的要求 proxy 回其現有的結構。</span><span class="sxs-lookup"><span data-stu-id="a5c58-188">To meet this requirement, the [**InkAnalyzer**](inkanalyzer.md) contains a series of events that it raises at the appropriate time during an analysis operation to allow applications to proxy the request for data back to their existing structures.</span></span> <span data-ttu-id="a5c58-189">這些事件只會針對累加作業所需的那些 [**CoNtextNode**](icontextnode.md) 物件引發。</span><span class="sxs-lookup"><span data-stu-id="a5c58-189">These events are raised only for those [**ContextNode**](icontextnode.md) objects required by the incremental operation.</span></span>

### <a name="reconciliation"></a><span data-ttu-id="a5c58-190">和解</span><span class="sxs-lookup"><span data-stu-id="a5c58-190">Reconciliation</span></span>

<span data-ttu-id="a5c58-191">大部分的應用程式會想要在背景中分析筆墨，以保持最小的使用者介面中斷。</span><span class="sxs-lookup"><span data-stu-id="a5c58-191">Most applications will want to analyze the ink in the background to keep user interface interruptions to a minimum.</span></span> <span data-ttu-id="a5c58-192">在背景中分析筆墨會造成問題，不過，如果使用者變更筆墨 (或正在分析的相鄰筆墨) 。</span><span class="sxs-lookup"><span data-stu-id="a5c58-192">Analyzing ink in the background causes problems, however, if the user changes the ink (or neighboring ink) that is being analyzed.</span></span> <span data-ttu-id="a5c58-193">例如，如果使用者在背景作業期間刪除筆墨，則產生的結構會在背景作業開始時反映檔的狀態，而不是在完成時反映檔的狀態。</span><span class="sxs-lookup"><span data-stu-id="a5c58-193">For example, if the user deletes the ink during the background operation, the resulting structure would reflect the state of the document when the background operation started, rather than when it was completed.</span></span>

<span data-ttu-id="a5c58-194">為了協助應用程式， [**InkAnalyzer**](inkanalyzer.md) 會協調分析作業的開頭和結尾之間的檔狀態差異。</span><span class="sxs-lookup"><span data-stu-id="a5c58-194">To assist applications, the [**InkAnalyzer**](inkanalyzer.md) reconciles the differences in document state between the beginning and end of the analysis operation.</span></span> <span data-ttu-id="a5c58-195">當分析在背景中執行時，使用者或應用程式所做的變更一律會覆寫在背景中計算的結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-195">Changes made by the user or application while the analysis is running in the background always override the results calculated in the background.</span></span> <span data-ttu-id="a5c58-196">在對帳之後，只會報告結果結構中不會與檔變更衝突的部分，並將衝突的筆觸標記為未來的分析。</span><span class="sxs-lookup"><span data-stu-id="a5c58-196">After reconciliation, only the parts of the results structure that do not conflict with document changes are reported, and the conflicting strokes are tagged for future analysis.</span></span> <span data-ttu-id="a5c58-197">下次執行背景分析作業時，會根據新的狀態重新計算結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-197">The next time the background analysis operation is run, the results are recalculated based on the new state.</span></span>

<span data-ttu-id="a5c58-198">下圖顯示此程式。</span><span class="sxs-lookup"><span data-stu-id="a5c58-198">The following diagram shows this process.</span></span> <span data-ttu-id="a5c58-199">從上到下，圖表中的時間是以線性方式表示。</span><span class="sxs-lookup"><span data-stu-id="a5c58-199">Time is expressed linearly from top to bottom in the diagram.</span></span>

![分析作業期間協調檔狀態變更的進程](images/6323e0b5-b6b3-4adc-8c73-da3fad5b4bc2.jpg)

1.  <span data-ttu-id="a5c58-201">在時間 1 (t1) 時，應用程式會從使用者收集筆跡，包括任何類型的筆墨修改，例如新增、移除或修改。</span><span class="sxs-lookup"><span data-stu-id="a5c58-201">At time 1 (t1), the application is collecting ink from the end-user, including any kind of ink modification, such as adding, removing, or modifying.</span></span>
2.  <span data-ttu-id="a5c58-202">在 t2，應用程式會叫用背景分析作業。</span><span class="sxs-lookup"><span data-stu-id="a5c58-202">At t2, the application invokes the background analysis operation.</span></span> <span data-ttu-id="a5c58-203">[**InkAnalyzer**](inkanalyzer.md)會決定哪些筆墨沒有結果，以及要重複檢查哪些筆墨。</span><span class="sxs-lookup"><span data-stu-id="a5c58-203">The [**InkAnalyzer**](inkanalyzer.md) determines what ink does not have results and what ink needs to be double-checked.</span></span> <span data-ttu-id="a5c58-204">它會複製所需的筆墨資料，讓背景執行緒可以獨立執行。</span><span class="sxs-lookup"><span data-stu-id="a5c58-204">It copies the needed ink data to allow the background thread to execute independently.</span></span>
3.  <span data-ttu-id="a5c58-205">在 t3 上， [**InkAnalyzer**](inkanalyzer.md) 會將使用者介面執行緒執行傳回給應用程式。</span><span class="sxs-lookup"><span data-stu-id="a5c58-205">At t3, the [**InkAnalyzer**](inkanalyzer.md) returns the user interface thread execution to the application.</span></span> <span data-ttu-id="a5c58-206">**InkAnalyzer** 會建立第二個執行緒、背景分析執行緒，而筆墨分析和辨識引擎會分析複製的筆墨資料。</span><span class="sxs-lookup"><span data-stu-id="a5c58-206">The **InkAnalyzer** creates a second thread, the background analysis thread, and the ink analysis and recognition engines analyze the copied ink data.</span></span>
4.  <span data-ttu-id="a5c58-207">在第二個背景執行緒上進行分析作業時，使用者會繼續在 t4 和 t5 上編輯檔、新增和移除筆劃資料。</span><span class="sxs-lookup"><span data-stu-id="a5c58-207">While the analysis operation is occurring on the second background thread, the end user continues to edit the document, adding and removing stroke data, at t4 and t5.</span></span> <span data-ttu-id="a5c58-208">這些編輯可能會與在背景中處理的工作發生衝突。</span><span class="sxs-lookup"><span data-stu-id="a5c58-208">These edits can conflict with the work that is being process in the background.</span></span>
5.  <span data-ttu-id="a5c58-209">在 t6，背景執行緒已完成分析作業，並已準備好結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-209">At t6, the background thread has finished the analysis operation, and results are ready.</span></span> <span data-ttu-id="a5c58-210">在 [**InkAnalyzer**](inkanalyzer.md) 將結果傳達給應用程式之前，它會執行對帳演算法，以判斷在計算分析作業時所進行的使用者編輯 (t4 和 t5) 與結果產生衝突。</span><span class="sxs-lookup"><span data-stu-id="a5c58-210">Before the [**InkAnalyzer**](inkanalyzer.md) communicates the results to the application, it runs a reconciliation algorithm to determine if the user edits made while the analysis operation was being calculated (t4 and t5) conflict with the results.</span></span> <span data-ttu-id="a5c58-211">如果偵測到任何衝突，則會將衝突的筆劃標示為重新分析，這會在下次應用程式叫用背景分析作業時發生。</span><span class="sxs-lookup"><span data-stu-id="a5c58-211">If any collisions are detected, the colliding strokes are flagged for re-analysis, which occurs the next time the application invokes the background analysis operation.</span></span>
6.  <span data-ttu-id="a5c58-212">最後，在 t7 時，如果偵測到所有衝突， [**InkAnalyzer**](inkanalyzer.md) 會向應用程式呈現結果。</span><span class="sxs-lookup"><span data-stu-id="a5c58-212">Finally, at t7, with all the collisions detected, the [**InkAnalyzer**](inkanalyzer.md) presents the results to the application.</span></span>

### <a name="extensibility"></a><span data-ttu-id="a5c58-213">擴充性</span><span class="sxs-lookup"><span data-stu-id="a5c58-213">Extensibility</span></span>

<span data-ttu-id="a5c58-214">InkAnalysis Api 可讓應用程式使用新的分析引擎類型，以防止應用程式必須重寫 InkAnalysis API 的所有優點，包括對帳、資料 proxy、持續性和累加式分析。</span><span class="sxs-lookup"><span data-stu-id="a5c58-214">The InkAnalysis APIs allow new types of analysis engines to be used by applications, in such a way as to prevent the application from having to rewrite all of the benefits of the InkAnalysis API, including reconciliation, data proxy, persistence, and incremental analysis.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a5c58-215">相關主題</span><span class="sxs-lookup"><span data-stu-id="a5c58-215">Related topics</span></span>

<dl> <dt>

<span data-ttu-id="a5c58-216">[Microsoft Ink](/previous-versions/dotnet/netframework-3.5/ms581553(v=vs.90))</span><span class="sxs-lookup"><span data-stu-id="a5c58-216">[Microsoft.Ink](/previous-versions/dotnet/netframework-3.5/ms581553(v=vs.90))</span></span>
</dt> <dt>

[<span data-ttu-id="a5c58-217">筆跡分析參考</span><span class="sxs-lookup"><span data-stu-id="a5c58-217">Ink Analysis Reference</span></span>](ink-analysis-reference.md)
</dt> </dl>

 

 
