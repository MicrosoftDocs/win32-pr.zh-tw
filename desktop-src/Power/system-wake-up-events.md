---
description: 您的應用程式可以使用排程的計時器或裝置事件，將處於睡眠狀態的電腦還原到工作狀態。
ms.assetid: b7326b09-0829-4e76-80d0-e4ecdf7f556e
title: 系統喚醒事件
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f13332305ef023d932f2912f7299aa12cd402733
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "106977906"
---
# <a name="system-wake-up-events"></a><span data-ttu-id="e9b12-103">系統喚醒事件</span><span class="sxs-lookup"><span data-stu-id="e9b12-103">System Wake-up Events</span></span>

<span data-ttu-id="e9b12-104">下列資訊適用于從 [睡眠 (S3) 和休眠 (S4) ](/windows-hardware/drivers/kernel/system-sleeping-states)喚醒。</span><span class="sxs-lookup"><span data-stu-id="e9b12-104">The following information applies to wakes from [sleep (S3) and hibernate (S4)](/windows-hardware/drivers/kernel/system-sleeping-states).</span></span> <span data-ttu-id="e9b12-105">若要從新式待命喚醒 (S0 低功率閒置) ，請參閱 [從閒置轉換為使用中的轉換](/windows-hardware/design/device-experiences/transition-from-idle-to-active)。</span><span class="sxs-lookup"><span data-stu-id="e9b12-105">For wakes from Modern Standby (S0 Low Power Idle), please refer to [transitions from idle to active](/windows-hardware/design/device-experiences/transition-from-idle-to-active).</span></span>

<span data-ttu-id="e9b12-106">您的應用程式可以使用排程的計時器或裝置事件，將處於睡眠狀態的電腦還原到工作狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-106">Your application can restore a computer that is in a sleep state to the working state by using a scheduled timer or a device event.</span></span> <span data-ttu-id="e9b12-107">這就是所謂的 *喚醒事件*。</span><span class="sxs-lookup"><span data-stu-id="e9b12-107">This is known as a *wake-up event*.</span></span> <span data-ttu-id="e9b12-108">使用 [可等候計時器物件](/windows/desktop/Sync/waitable-timer-objects) 來指定系統應該喚醒的時間。</span><span class="sxs-lookup"><span data-stu-id="e9b12-108">Use a [waitable timer object](/windows/desktop/Sync/waitable-timer-objects) to specify the time at which the system should wake.</span></span> <span data-ttu-id="e9b12-109">若要建立物件，請使用 [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) 函數。</span><span class="sxs-lookup"><span data-stu-id="e9b12-109">To create the object, use the [**CreateWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) function.</span></span> <span data-ttu-id="e9b12-110">若要設定計時器，請使用 [**SetWaitableTimer**](/windows/desktop/api/synchapi/nf-synchapi-setwaitabletimer) 函數。</span><span class="sxs-lookup"><span data-stu-id="e9b12-110">To set the timer, use the [**SetWaitableTimer**](/windows/desktop/api/synchapi/nf-synchapi-setwaitabletimer) function.</span></span> <span data-ttu-id="e9b12-111">*PDueTime* 參數會指定何時將計時器發出信號。</span><span class="sxs-lookup"><span data-stu-id="e9b12-111">The *pDueTime* parameter specifies when the timer will be signaled.</span></span> <span data-ttu-id="e9b12-112">若要指定系統應該在計時器收到信號時喚醒，請將 *fResume* 參數設定為 **TRUE**。</span><span class="sxs-lookup"><span data-stu-id="e9b12-112">To specify that the system should wake when the timer is signaled, set the *fResume* parameter to **TRUE**.</span></span>

<span data-ttu-id="e9b12-113">當系統自動喚醒時，因為 (電源交換器或使用者活動) 以外的事件，系統會自動將自動閒置計時器設定為至少2分鐘。</span><span class="sxs-lookup"><span data-stu-id="e9b12-113">When the system wakes automatically because of an event (other than power switch or user activity), the system automatically sets an unattended idle timer to at least 2 minutes.</span></span> <span data-ttu-id="e9b12-114">此計時器讓應用程式有足夠的時間呼叫 [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) 函式，以指出它們正在忙碌中。</span><span class="sxs-lookup"><span data-stu-id="e9b12-114">This timer gives applications sufficient time to call the [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) function to indicate that they are busy.</span></span> <span data-ttu-id="e9b12-115">這段時間可讓系統在不再需要電腦之後，快速返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-115">This time enables the system to return to the sleep state quickly after the computer is no longer required.</span></span> <span data-ttu-id="e9b12-116">下列準則會判斷系統是否返回睡眠狀態：</span><span class="sxs-lookup"><span data-stu-id="e9b12-116">The following criteria determine whether the system returns to the sleep state:</span></span>

-   <span data-ttu-id="e9b12-117">如果系統自動喚醒 (也就是沒有任何使用者活動存在) ，它會在自動閒置計時器過期時立即關閉，假設沒有任何應用程式已呼叫 [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) 來表示系統是必要的。</span><span class="sxs-lookup"><span data-stu-id="e9b12-117">If the system wakes automatically (that is, no user activity is present), it shuts down as soon as the unattended idle timer expires, assuming that no applications have called [**SetThreadExecutionState**](/windows/desktop/api/Winbase/nf-winbase-setthreadexecutionstate) to indicate that the system is required.</span></span>
-   <span data-ttu-id="e9b12-118">以裝置為基礎的喚醒預設會觸發自動閒置計時器，除非設備磁碟機表示使用者存在。</span><span class="sxs-lookup"><span data-stu-id="e9b12-118">Device-based wakes trigger the unattended idle timer by default unless the device driver indicates user presence.</span></span> <span data-ttu-id="e9b12-119">如果驅動程式指出使用者狀態，則會使用系統閒置計時器。</span><span class="sxs-lookup"><span data-stu-id="e9b12-119">If the driver indicates user presence, then the system idle timer is used.</span></span>
-   <span data-ttu-id="e9b12-120">如果系統自動喚醒，但使用者在處理事件時提供新的輸入，系統就不會根據自動閒置計時器自動返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-120">If the system wakes automatically, but the user provides new input while the event is handled, the system does not automatically return to sleep based on the unattended idle timer.</span></span> <span data-ttu-id="e9b12-121">相反地，系統會根據系統閒置計時器返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-121">Instead, the system returns to sleep based on the system idle timer.</span></span>
-   <span data-ttu-id="e9b12-122">如果系統因為使用者活動而喚醒，系統不會根據自動閒置計時器自動返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-122">If the system wakes due to user activity, the system does not automatically return to sleep based on the unattended idle timer.</span></span> <span data-ttu-id="e9b12-123">相反地，系統會根據系統閒置計時器返回睡眠狀態。</span><span class="sxs-lookup"><span data-stu-id="e9b12-123">Instead the system returns to sleep based on the system idle timer.</span></span>

<span data-ttu-id="e9b12-124">當系統自動喚醒時，會將 [PBT \_ APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) 事件廣播至所有應用程式。</span><span class="sxs-lookup"><span data-stu-id="e9b12-124">When the system wakes automatically, it broadcasts the [PBT\_APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) event to all applications.</span></span> <span data-ttu-id="e9b12-125">由於使用者不存在，大部分的應用程式都不應該執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="e9b12-125">Because the user is not present, most applications should do nothing.</span></span> <span data-ttu-id="e9b12-126">事件處理應用程式（例如傳真伺服器）應該處理其事件。</span><span class="sxs-lookup"><span data-stu-id="e9b12-126">Event-handling applications, such as fax servers, should handle their events.</span></span> <span data-ttu-id="e9b12-127">若要判斷系統是否處於此狀態，請呼叫 [**IsSystemResumeAutomatic**](/windows/desktop/api/Winbase/nf-winbase-issystemresumeautomatic) 函數。</span><span class="sxs-lookup"><span data-stu-id="e9b12-127">To determine whether the system is in this state, call the [**IsSystemResumeAutomatic**](/windows/desktop/api/Winbase/nf-winbase-issystemresumeautomatic) function.</span></span> <span data-ttu-id="e9b12-128">當系統自動喚醒時，不會自動開啟顯示器。</span><span class="sxs-lookup"><span data-stu-id="e9b12-128">When the system wakes automatically, the display is not automatically turned on.</span></span>

<span data-ttu-id="e9b12-129">如果系統因為使用者活動而喚醒，系統會先廣播 [PBT \_ APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) 事件，後面接著 [PBT \_ APMRESUMESUSPEND](pbt-apmresumesuspend.md) 事件。</span><span class="sxs-lookup"><span data-stu-id="e9b12-129">If the system wakes due to user activity, the system will first broadcast the [PBT\_APMRESUMEAUTOMATIC](pbt-apmresumeautomatic.md) event followed by a [PBT\_APMRESUMESUSPEND](pbt-apmresumesuspend.md) event.</span></span> <span data-ttu-id="e9b12-130">此外，系統也會開啟顯示器。</span><span class="sxs-lookup"><span data-stu-id="e9b12-130">In addition, the system will turn on the display.</span></span> <span data-ttu-id="e9b12-131">您的應用程式應該在系統進入睡眠狀態時重新開啟已關閉的檔案，並為使用者輸入做好準備。</span><span class="sxs-lookup"><span data-stu-id="e9b12-131">Your application should reopen files that it closed when the system entered sleep and prepare for user input.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e9b12-132">相關主題</span><span class="sxs-lookup"><span data-stu-id="e9b12-132">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e9b12-133">關於電源管理</span><span class="sxs-lookup"><span data-stu-id="e9b12-133">About Power Management</span></span>](about-power-management.md)
</dt> <dt>

[<span data-ttu-id="e9b12-134">系統睡眠準則</span><span class="sxs-lookup"><span data-stu-id="e9b12-134">System Sleep Criteria</span></span>](system-sleep-criteria.md)
</dt> </dl>

 

 
